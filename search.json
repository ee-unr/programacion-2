[
  {
    "objectID": "informacion/programa.html",
    "href": "informacion/programa.html",
    "title": "Programa",
    "section": "",
    "text": "Los profesionales en Estad√≠stica y Ciencia de Datos necesitan contar con habilidades avanzadas de programaci√≥n, que les permitan abordar problemas complejos y desarrollar soluciones eficientes y robustas.\nLa asignatura Programaci√≥n 2 introduce a los estudiantes a conceptos y pr√°cticas avanzadas de la programaci√≥n, incorporando herramientas y paradigmas que resultan fundamentales para el desarrollo profesional en Estad√≠stica y Ciencia de Datos.\nLa asignatura profundiza en enfoques como la programaci√≥n funcional y la programaci√≥n orientada a objetos, promoviendo el desarrollo de soluciones estructuradas, reutilizables, robustas y escalables. Adem√°s, se abordan conceptos fundamentales de estructuras de datos y algoritmos, relevantes para el dise√±o y an√°lisis de programas eficientes, as√≠ como para la comprensi√≥n de la complejidad computacional. Se focaliza en el lenguaje Python, ampliamente utilizado en la industria y la academia por su versatilidad, su ecosistema de librer√≠as y su capacidad para integrarse con diversas tecnolog√≠as.\nDictada en el segundo cuatrimestre del primer a√±o, Programaci√≥n 2 completa los contenidos del √°rea de Fundamentos Computacionales en el Ciclo de Formaci√≥n T√©cnica en Estad√≠stica y Ciencia de Datos, iniciada en el primer cuatrimestre con Programaci√≥n 1. De este modo, consolida las competencias inform√°ticas de los estudiantes y los prepara para afrontar asignaturas m√°s avanzadas y desaf√≠os profesionales que requieren un dominio s√≥lido de la programaci√≥n. Asimismo, fomenta buenas pr√°cticas de desarrollo de c√≥digo, el uso eficiente de los recursos computacionales y el pensamiento cr√≠tico en la resoluci√≥n de problemas.",
    "crumbs": [
      "Informaci√≥n",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/programa.html#fundamentaci√≥n",
    "href": "informacion/programa.html#fundamentaci√≥n",
    "title": "Programa",
    "section": "",
    "text": "Los profesionales en Estad√≠stica y Ciencia de Datos necesitan contar con habilidades avanzadas de programaci√≥n, que les permitan abordar problemas complejos y desarrollar soluciones eficientes y robustas.\nLa asignatura Programaci√≥n 2 introduce a los estudiantes a conceptos y pr√°cticas avanzadas de la programaci√≥n, incorporando herramientas y paradigmas que resultan fundamentales para el desarrollo profesional en Estad√≠stica y Ciencia de Datos.\nLa asignatura profundiza en enfoques como la programaci√≥n funcional y la programaci√≥n orientada a objetos, promoviendo el desarrollo de soluciones estructuradas, reutilizables, robustas y escalables. Adem√°s, se abordan conceptos fundamentales de estructuras de datos y algoritmos, relevantes para el dise√±o y an√°lisis de programas eficientes, as√≠ como para la comprensi√≥n de la complejidad computacional. Se focaliza en el lenguaje Python, ampliamente utilizado en la industria y la academia por su versatilidad, su ecosistema de librer√≠as y su capacidad para integrarse con diversas tecnolog√≠as.\nDictada en el segundo cuatrimestre del primer a√±o, Programaci√≥n 2 completa los contenidos del √°rea de Fundamentos Computacionales en el Ciclo de Formaci√≥n T√©cnica en Estad√≠stica y Ciencia de Datos, iniciada en el primer cuatrimestre con Programaci√≥n 1. De este modo, consolida las competencias inform√°ticas de los estudiantes y los prepara para afrontar asignaturas m√°s avanzadas y desaf√≠os profesionales que requieren un dominio s√≥lido de la programaci√≥n. Asimismo, fomenta buenas pr√°cticas de desarrollo de c√≥digo, el uso eficiente de los recursos computacionales y el pensamiento cr√≠tico en la resoluci√≥n de problemas.",
    "crumbs": [
      "Informaci√≥n",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/programa.html#objetivos",
    "href": "informacion/programa.html#objetivos",
    "title": "Programa",
    "section": "Objetivos",
    "text": "Objetivos\nQue los estudiantes logren:\n\nanalizar problemas computacionales y formular soluciones algor√≠tmicas adecuadas;\nimplementar esas soluciones mediante el desarrollo de programas en Python, seleccionando estructuras de datos apropiadas y evaluando la eficiencia de los algoritmos involucrados;\nidentificar y aplicar los paradigmas funcional y orientado a objetos cuando resulte pertinente, desarrollando programas que integren estos enfoques; y\nutilizar e integrar m√≥dulos y librer√≠as que permitan extender, organizar y mejorar las funcionalidades de sus programas.",
    "crumbs": [
      "Informaci√≥n",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/programa.html#contenidos",
    "href": "informacion/programa.html#contenidos",
    "title": "Programa",
    "section": "Contenidos",
    "text": "Contenidos\n\nUnidad 1: Introducci√≥n a Python\n\nLenguaje Python y su ecosistema. Uso de la interfaz Positron. Sintaxis de Python. Expresiones. Variables y asignaciones. Tipos de datos elementales. Operadores num√©ricos, de comparaci√≥n y l√≥gicos. Funciones. Ejecuci√≥n condicional de c√≥digo. Bucles definidos y no definidos. Listas, tuplas y diccionarios. Uso de c√≥digo externo. M√≥dulos y librer√≠as. Librer√≠a est√°ndar de Python. Instalaci√≥n y gesti√≥n de librer√≠as. Scripting. Lectura y escritura de archivos de texto plano. Modularizaci√≥n de programas.\n\nUnidad 2: Programaci√≥n funcional\n\nPrincipios fundamentales. Funciones como ciudadanos de primera clase. Funciones puras. Funciones an√≥nimas. Closures. Recursi√≥n. Funciones de orden superior: map, filter, reduce. Evaluaci√≥n estricta y no estricta. Evaluaci√≥n perezosa (lazy) e inmediata (eager). Generadores. Aplicaci√≥n parcial de funciones. Decoradores.\n\nUnidad 3: Programaci√≥n orientada a objetos\n\nPrincipios fundamentales. Objetos, clases e instancias. Atributos y m√©todos. Propiedades p√∫blicas y privadas. M√©todos de clase y m√©todos de instancia. Encapsulamiento. Herencia simple y m√∫ltiple. Polimorfismo. M√©todos especiales (dunder methods). Decoradores aplicados a m√©todos. Sobrecarga de operadores.\n\nUnidad 4: Estructuras de datos\n\nConcepto y clasificaci√≥n. Estructuras lineales: listas, listas enlazadas, pilas y colas. Operaciones b√°sicas: agregar, quitar y recorrer. Estructuras no lineales: √°rboles y grafos. Recorridos de √°rboles y grafos. Uso de colecciones de Python (list, deque, dict, set). Arreglos multidimensionales de NumPy.\n\nUnidad 5: Algoritmos de b√∫squeda y ordenamiento\n\nConcepto de algoritmo y complejidad. Notaci√≥n Big O. B√∫squeda lineal y binaria. Algoritmos de ordenamiento: bubble sort, insertion sort, selection sort, quick sort y merge sort. Comparaci√≥n de eficiencia. Funciones de b√∫squeda y ordenamiento en Python (sorted, sort, heapq).",
    "crumbs": [
      "Informaci√≥n",
      "Programa"
    ]
  },
  {
    "objectID": "practica/01_introduccion_a_python/ejercicios.html",
    "href": "practica/01_introduccion_a_python/ejercicios.html",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "",
    "text": "Escriba una funci√≥n en Python que reciba el radio de un c√≠rculo y devuelva su √°rea. Luego, escriba otra funci√≥n que tambi√©n reciba el radio de un c√≠rculo, pero devuelva su per√≠metro. Finalmente, escriba una tercera funci√≥n que reciba el radio de un c√≠rculo y devuelva tanto el √°rea como el per√≠metro.\nUna vez que haya implementado todas las funciones, analice la diferencia entre:\narea, perimetro = calcular_area_y_perimetro(radio=5)\ny\nresultados = calcular_area_y_perimetro(radio=5)\nConsidere el tipo de las variables area, perimetro y resutlados.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\n\\[\n\\begin{aligned}\nA &= \\pi \\cdot r^2 \\\\\nP &= 2 \\cdot \\pi \\cdot r\n\\end{aligned}\n\\]",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Introducci√≥n a Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_introduccion_a_python/ejercicios.html#√°rea-y-per√≠metro-de-un-c√≠rculo",
    "href": "practica/01_introduccion_a_python/ejercicios.html#√°rea-y-per√≠metro-de-un-c√≠rculo",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "",
    "text": "Escriba una funci√≥n en Python que reciba el radio de un c√≠rculo y devuelva su √°rea. Luego, escriba otra funci√≥n que tambi√©n reciba el radio de un c√≠rculo, pero devuelva su per√≠metro. Finalmente, escriba una tercera funci√≥n que reciba el radio de un c√≠rculo y devuelva tanto el √°rea como el per√≠metro.\nUna vez que haya implementado todas las funciones, analice la diferencia entre:\narea, perimetro = calcular_area_y_perimetro(radio=5)\ny\nresultados = calcular_area_y_perimetro(radio=5)\nConsidere el tipo de las variables area, perimetro y resutlados.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\n\\[\n\\begin{aligned}\nA &= \\pi \\cdot r^2 \\\\\nP &= 2 \\cdot \\pi \\cdot r\n\\end{aligned}\n\\]",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Introducci√≥n a Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_introduccion_a_python/ejercicios.html#promociones",
    "href": "practica/01_introduccion_a_python/ejercicios.html#promociones",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "2 Promociones",
    "text": "2 Promociones\nEscriba una funci√≥n llamada calcular_precio que reciba dos argumentos: el monto total de una compra y el medio de pago utilizado.\nEl medio de pago puede ser \"efectivo\", \"d√©bito\" o \"cr√©dito\", y seg√∫n el caso se aplicar√° una modificaci√≥n sobre el monto:\n\nSi el medio de pago es \"efectivo\", el monto no se modifica.\nSi es \"d√©bito\", se aplica un descuento del 10% sobre el monto.\nSi es \"cr√©dito\", se aplica un recargo del 5% sobre el monto.\n\nLa funci√≥n debe retornar el monto final a pagar, con el descuento o recargo aplicado seg√∫n corresponda.\n\nPunto extra\nModifique la funci√≥n de modo tal que no sea necesario especificar el medio de pago. En tal caso, el medio de pago se asume \"efectivo\". Ayuda: asigne un valor por defecto al argumento medio. Considere una implementaci√≥n donde este sea \"efectivo\" y otra donde sea None.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Introducci√≥n a Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_introduccion_a_python/ejercicios.html#etapas-de-la-vida",
    "href": "practica/01_introduccion_a_python/ejercicios.html#etapas-de-la-vida",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "3 Etapas de la vida",
    "text": "3 Etapas de la vida\nImplemente una funci√≥n que reciba una edad y devuelva un mensaje que indique la etapa de la vida correspondiente.\nUtilice una cadena de condicionales if-elif-else para clasificar la edad en alguno de los siguientes grupos:\n\nMenor a 2 a√±os: beb√©.\nEntre 2 (inclusive) y 4 a√±os: infante.\nEntre 4 (inclusive) y 13 a√±os: ni√±o/a.\nEntre 13 (inclusive) y 20 a√±os: adolescente.\nEntre 20 (inclusive) y 65 a√±os: adulto/a.\n65 a√±os o m√°s: persona mayor.\n\nLa funci√≥n debe imprimir un mensaje del tipo: \"La persona es un/a &lt;etapa&gt;\".",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Introducci√≥n a Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_introduccion_a_python/ejercicios.html#conteo-de-caracteres",
    "href": "practica/01_introduccion_a_python/ejercicios.html#conteo-de-caracteres",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "4 Conteo de caracteres",
    "text": "4 Conteo de caracteres\nEscriba una funci√≥n que reciba una cadena de texto y devuelva un diccionario que indique cu√°ntas veces aparece cada caracter en la cadena. La funci√≥n no debe diferenciar entre may√∫sculas y min√∫sculas y debe ignorar espacios. Utilice el siguiente ejemplo como validaci√≥n:\ncontar_caracteres(\"Ahora es mejor que nunca\")\n# {\"a\": 3, \"h\": 1, \"o\": 2, \"r\": 2, \"e\": 3, \"s\": 1, \"m\": 1, \"j\": 1, \"q\": 1, \"u\": 2, \"n\": 2, \"c\": 1}\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara saltear pasos de un bucle cuando se encuentra un espacio se puede utilizar la sentencia continue.\nfor i in ...:\n    # ... &lt;- Se ejecuta en todas las iteraciones\n    if condicion_de_salto:\n        continue\n    # ... &lt;- Se ejecuta en las iteraciones 'condicion_de_salto' es False",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Introducci√≥n a Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_introduccion_a_python/ejercicios.html#orden-de-m√©rito",
    "href": "practica/01_introduccion_a_python/ejercicios.html#orden-de-m√©rito",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "5 Orden de m√©rito",
    "text": "5 Orden de m√©rito\nSe cuenta con una lista de tuplas que contienen las notas del examen final de Programaci√≥n 2 para un conjunto de alumnos:\nnotas = [\n    (\"Escalada\", 9),\n    (\"Alonso\", 7),\n    (\"P√©rez\", 8),\n    (\"Castro\", 8),\n    (\"Rossini\", 10),\n    (\"Mart√≠nez\", 9),\n    (\"P√©rez\", 6),\n    (\"Riquelme\", 5),\n]\n\nEscriba un programa que a partir de notas genere un diccionario donde las claves se corresponden con los apellidos y los valores con las notas del examen final.\nEscriba un programa que a partir de notas genere un diccionario donde las claves son las notas y el valor asociado sea una lista con los apellidos de quienes tuvieron esa nota.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Introducci√≥n a Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_introduccion_a_python/ejercicios.html#rendimento-acad√©mico",
    "href": "practica/01_introduccion_a_python/ejercicios.html#rendimento-acad√©mico",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "6 Rendimento acad√©mico",
    "text": "6 Rendimento acad√©mico\nSe cuenta con el siguiente diccionario que asocia nombres de estudiantes con una lista de sus calificaciones:\nnotas = {\n    \"Ana\": [8, 9, 10],\n    \"Luis\": [6, 7, 8, 3, 9],\n    \"Carla\": [10, 9, 10],\n    \"Marcos\": [5, 6],\n    \"Sof√≠a\": [7, 7, 8],\n    \"Pedro\": [6, 4, 5, 6, 3, 8],\n    \"Luc√≠a\": [9, 8, 10, 9]\n}\nImplemente una funci√≥n que resuma el rendimiento acad√©mico de los estudiantes. La funci√≥n debe recibir el diccionario de notas y un argumento adicional llamado modo. Seg√∫n el valor de modo, se debe devolver un nuevo diccionario con la siguiente informaci√≥n:\n\nSi modo es \"promedio\", se debe devolver el promedio de notas por estudiante.\nSi modo es \"proporcion\", se debe devolver la proporci√≥n de ex√°menes aprobados por estudiante (se considera aprobado todo valor mayor o igual a 6).",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Introducci√≥n a Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_introduccion_a_python/ejercicios.html#√≠ndice-de-precios",
    "href": "practica/01_introduccion_a_python/ejercicios.html#√≠ndice-de-precios",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "7 √çndice de precios",
    "text": "7 √çndice de precios\nSe cuenta con la serie mensual del √çndice de Precios al Consumidor (IPC) del a√±o 2024:\nipc_2024 = [20.6, 13.2, 11.0, 8.8, 4.2, 4.6, 4.0, 4.2, 3.5, 2.7, 2.4, 2.7]\nRealice los siguientes c√°lculos y an√°lisis:\n\nDetermine el menor y el mayor √≠ndice reportado durante el a√±o.\nCalcule el IPC promedio mensual del 2024.\nEncuentre la diferencia entre el IPC m√≠nimo y m√°ximo del a√±o.\n\n¬øEn qu√© mes se registr√≥ la inflaci√≥n m√°s alta?\n\nCalcule la inflaci√≥n mediana del 2024.\n¬øC√≥mo podr√≠a calcular el rango del IPC (diferencia entre el valor m√°ximo y m√≠nimo) sin usar las funciones min() ni max()?",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Introducci√≥n a Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_introduccion_a_python/ejercicios.html#res√∫menes-estad√≠sticos",
    "href": "practica/01_introduccion_a_python/ejercicios.html#res√∫menes-estad√≠sticos",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "8 Res√∫menes estad√≠sticos",
    "text": "8 Res√∫menes estad√≠sticos\nCree funciones que, dada una lista de n√∫meros, calculen los siguientes res√∫menes estad√≠sticos:\n\nLa media \\[\n\\text{media}(X) = \\frac{1}{n}\\sum_{i=1}^n{x_i}\n\\]\nEl rango \\[\n\\text{rango}(X) = \\text{max}(X) - \\text{min}(X)\n\\]\nLa varianza \\[\n\\text{var}(X) = \\frac{1}{n}\\sum_{i=1}^n{(x_i - \\bar{x})^2}\n\\]\nEl desv√≠o est√°ndar \\[\n\\text{sd}(X) = \\sqrt{\\text{var}(X)}\n\\]\nLa mediana \\[\n\\begin{array}{lr}\n\\text{mediana}(X) = x_{(\\frac{n + 1}{2})} & \\text{Si } n \\text{ es impar} \\\\\n\\text{mediana}(X) = \\frac{x_{(\\frac{n}{2})} + x_{(\\frac{n}{2}+1)}}{2} & \\text{Si } n \\text{ es par}\n\\end{array}\n\\]\ndonde los \\(x_{(i)}\\) est√°n ordenados de manera ascendente.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Introducci√≥n a Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_introduccion_a_python/ejercicios.html#validaci√≥n-de-dni",
    "href": "practica/01_introduccion_a_python/ejercicios.html#validaci√≥n-de-dni",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "9 Validaci√≥n de DNI",
    "text": "9 Validaci√≥n de DNI\nCrear una funci√≥n que dada una cadena de caracteres verifique si se corresponde con un DNI.\nSi es un DNI, devolver True. Caso contrario, devolver Falso.\nA tener en cuenta:\n\nAlgunos ejemplos de DNI v√°lidos\n\n40.094.127\n19053512\n6.392.780\n\nDNI no v√°lidos\n\n40,094,127\n19-053-512\n123456",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Introducci√≥n a Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_introduccion_a_python/ejercicios.html#la-f√≠sica-del-rebote",
    "href": "practica/01_introduccion_a_python/ejercicios.html#la-f√≠sica-del-rebote",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "10 La f√≠sica del rebote",
    "text": "10 La f√≠sica del rebote\nUna pelota de goma es lanzada desde una altura inicial de 100 metros. Cada vez que toca el suelo, rebota alcanzando una altura equivalente a 3/5 de la altura desde la que cay√≥.\nEscriba un programa que imprima una tabla mostrando las alturas alcanzadas por la pelota en cada uno de sus primeros 10 rebotes.\nLuego, implemente este programa como una funci√≥n que reciba dos par√°metros:\n\nAltura inicial desde la que se lanza la pelota.\nCantidad de rebotes que se desea calcular.\n\nLa funci√≥n debe devolver una lista con las alturas alcanzadas en cada rebote.\n\nPunto extra\nModifique la funci√≥n para que considere un rebote como ‚Äúsignificativo‚Äù solo si la altura alcanzada es mayor o igual a un valor m√≠nimo especificado (por ejemplo, 1 cent√≠metro).\nSi la pelota no alcanza esta altura m√≠nima en alg√∫n rebote, se considera que ha completado su trayectoria y queda quieta. En este caso, la funci√≥n debe devolver √∫nicamente los valores correspondientes a los ‚Äúrebotes significativos‚Äù.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Introducci√≥n a Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_introduccion_a_python/ejercicios.html#un-mont√≥n-de-plata",
    "href": "practica/01_introduccion_a_python/ejercicios.html#un-mont√≥n-de-plata",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "11 Un mont√≥n de plata",
    "text": "11 Un mont√≥n de plata\nUna ma√±ana pon√©s un billete en la vereda al lado del Monumento a la Bandera. A partir de ah√≠, cada d√≠a vas y duplic√°s la cantidad de billetes, apil√°ndolos prolijamente. ¬øCu√°nto tiempo pasa antes de que la pila de billetes sea m√°s alta que la del Monumento?\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nAlgunas constantes √∫tiles para resolver el problema:\nbillete_grosor = 0.11 * 0.001  # grosor de un billete en metros\naltura_monumento = 70          # altura en metros\nSugerencia: Usar un bucle while para realizar el c√°lculo.\n\n\n\n\nPunto extra\nEscribe una funci√≥n que permita determinar la cantidad de d√≠as necesarios para superar cualquier altura arbitraria.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Introducci√≥n a Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_introduccion_a_python/ejercicios.html#la-conjetura-de-collatz",
    "href": "practica/01_introduccion_a_python/ejercicios.html#la-conjetura-de-collatz",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "12 La conjetura de Collatz",
    "text": "12 La conjetura de Collatz\nLa conjetura de Collatz dice:\n\nSi tomamos un n√∫mero natural cualquiera, su secuencia de Collatz termina llegando siempre al n√∫mero 1.\n\nSecuencia de Collatz:\n\nSi el n√∫mero es par, se divide entre 2.\nSi el n√∫mero es impar, se multiplica por 3 y se le suma 1.\n\n\\[\nf(n) =\n\\begin{cases}\n    \\displaystyle \\frac{n}{2} & \\text{si } n \\text{ es par,} \\\\ \\\\\n    3n + 1 & \\text{si } n \\text{ es impar.}\n\\end{cases}\n\\]\nEscribir una funci√≥n que calcule la secuencia de Collatz para un n√∫mero natural cualquiera.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\n\nUtilizar bucle while.\nEl bucle debe correr solo cuando el valor de la secuencia sigue siendo mayor a 1. Si es 1, hay que frenar.\nInsertar los elementos de la secuencia en una lista.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Introducci√≥n a Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_introduccion_a_python/ejercicios.html#adivina-el-n√∫mero",
    "href": "practica/01_introduccion_a_python/ejercicios.html#adivina-el-n√∫mero",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "13 Adivina el n√∫mero",
    "text": "13 Adivina el n√∫mero\nEscriba un programa que implemente el cl√°sico juego ‚ÄúAdivina el n√∫mero‚Äù. El programa debe:\n\nTener un n√∫mero secreto (entero) que el usuario debe adivinar.\nSolicitar al usuario que ingrese un n√∫mero.\nSi el n√∫mero ingresado no coincide con el n√∫mero secreto:\n\nInformar si el n√∫mero ingresado es mayor o menor que el n√∫mero secreto.\nPedir al usuario que intente nuevamente.\n\nSi el usuario adivina el n√∫mero, el programa debe terminar mostrando un mensaje de felicitaciones.\n\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara generar n√∫meros aleatorios enteros en un rango dado puede utilizar randint() del m√≥dulo random:\nimport random\nrandom.randint(-100,¬†100)     # Genera un n√∫mero aleatorio entre -100 y 100\n\n\n\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nEl programa que resuelve este problema realiza una cantidad de iteraciones que se desconoce al momento de escribirlo. La soluci√≥n t√≠pica a este tipo de problema involucra el uso de while True junto a la sentencia break.\nwhile True:\n    # realizar alguna accion\n    if condicion_de_salida:\n        break\n\n\n\n\nPunto extra\nImplemente una versi√≥n de este programa donde el usuario cuenta con 10 intentos.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Introducci√≥n a Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_introduccion_a_python/ejercicios.html#conteo-de-caracteres-pythonico",
    "href": "practica/01_introduccion_a_python/ejercicios.html#conteo-de-caracteres-pythonico",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "14 Conteo de caracteres Pythonico",
    "text": "14 Conteo de caracteres Pythonico\nLos diccionarios en Python cuentan con un m√©todo .get() que devuelve el valor asociado a una clave. Este m√©todo permite pasarle un segundo argumento con un valor que se devuelve cuando no se encuentra un elemento asocaido a la clave que le pasamos. Por ejemplo:\nd = {\"a\": 1, \"b\": 20}\nd.get(\"b\", 0)\n20\nd.get(\"c\", 0)\n0\nModifique la funci√≥n contar_caracteres del ejercicio Conteo de caracteres utilizando el metodo .get() para obtener una implementaci√≥n m√°s sencilla. As√≠, deber√≠a poder eliminar el bloque if.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Introducci√≥n a Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_introduccion_a_python/ejercicios.html#validador-de-contrase√±as",
    "href": "practica/01_introduccion_a_python/ejercicios.html#validador-de-contrase√±as",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "15 Validador de contrase√±as üò±",
    "text": "15 Validador de contrase√±as üò±\nEscriba un programa que solicite al usuario una contrase√±a y verifique que cumpla con las siguientes condiciones:\n\nDebe tener entre de 8 y 24 caracteres.\nDebe incluir letras, n√∫meros y caracteres especiales (@#$%^&*()).\n\nSi la contrase√±a no es v√°lida, el programa debe informar al usuario qu√© condici√≥n no se cumple y permitirle ingresar una nueva contrase√±a. El proceso se repite hasta que el usuario ingrese una contrase√±a v√°lida o decida no continuar.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Introducci√≥n a Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_introduccion_a_python/ejercicios.html#conteo-de-caracteres-ii",
    "href": "practica/01_introduccion_a_python/ejercicios.html#conteo-de-caracteres-ii",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "16 Conteo de caracteres II üò±",
    "text": "16 Conteo de caracteres II üò±\nAgregue a la funci√≥n contar_frecuencias del ejercicio Conteo de caracteres un argumento llamado orden que admita los valores \"aparicion\", \"alfabetico\" y \"frecuencia\".\nEste argumento debe permitir ordenar las claves del diccionario resultante seg√∫n el siguiente criterio:\n\n\"aparicion\": mantiene el orden en que las palabras aparecen por primera vez en la lista original.\n\"alfabetico\": ordena las palabras alfab√©ticamente.\n\"frecuencia\": ordena las palabras por su frecuencia, de mayor a menor.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Introducci√≥n a Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "trabajos_practicos/descripcion.html",
    "href": "trabajos_practicos/descripcion.html",
    "title": "Descripci√≥n",
    "section": "",
    "text": "Ac√° explicamos las pautas para los TP.",
    "crumbs": [
      "Trabajos Pr√°cticos",
      "Descripci√≥n"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html",
    "href": "trabajos_practicos/trabajo_grupal.html",
    "title": "Trabajo Pr√°ctico",
    "section": "",
    "text": "Trabajo Pr√°ctico",
    "crumbs": [
      "Trabajos Pr√°cticos",
      "Trabajo Pr√°ctico"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_individual.html",
    "href": "trabajos_practicos/trabajo_individual.html",
    "title": "Trabajo Pr√°ctico Final",
    "section": "",
    "text": "Trabajo Pr√°ctico Final",
    "crumbs": [
      "Trabajos Pr√°cticos",
      "Trabajo Pr√°ctico Final"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programaci√≥n II",
    "section": "",
    "text": "Programaci√≥n II\n\n\n ¬† Ciclo de Formaci√≥n T√©cnica - Estad√≠stica y Ciencia de Datos\n ¬† Facultad de Ciencias Econ√≥micas y Estad√≠stica (UNR)\n ¬† 2¬∞ Cuatrimestre 2025"
  },
  {
    "objectID": "index.html#docentes",
    "href": "index.html#docentes",
    "title": "Programaci√≥n II",
    "section": "Docentes",
    "text": "Docentes\n\n\nTom√°s Capretto\n\n ¬† tomas.capretto@fcecon.unr.edu.ar\n ¬† Consultas: TBD\n\n\n\nLuciano Anselmino\n\n ¬† luciano.anselmino@fcecon.unr.edu.ar\n ¬† Consultas: TBD\n\n\n\nJoaqu√≠n Bermejo\n\n ¬† joaquin.bermejo@fcecon.unr.edu.ar\n ¬† Consultas: TBD\n\n\n\nDolores Sollberger\n\n ¬† dolores.sollberger@fcecon.unr.edu.ar\n ¬† Consultas: TBD"
  },
  {
    "objectID": "practica/01_introduccion_a_python/problemas.html",
    "href": "practica/01_introduccion_a_python/problemas.html",
    "title": "üß© Problemas",
    "section": "",
    "text": "En criptograf√≠a, el cifrado C√©sar es una de las t√©cnicas de cifrado m√°s simples y m√°s usadas.\nEs un tipo de cifrado en el que una letra en el texto original es reemplazada por otra letra que se encuentra un n√∫mero fijo de posiciones m√°s adelante en el alfabeto.\nPor ejemplo, con un desplazamiento de 3, la A ser√≠a sustituida por la D (situada 3 lugares a la derecha de la A), la B ser√≠a reemplazada por la E, etc.\n\n\n\n\n\nEscriba una funci√≥n, y luego un script, que permita cifrar y descifrar cadenas usando el cifrado C√©sar con un n√∫mero arbitrario de posiciones.\nDos funciones incluidas con Python que pueden ser √∫tiles para esta tarea son ord(), que convierte caracteres num√©ricos a n√∫meros, y chr(), que realiza la operaci√≥n inversa.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara el cifrado de un √∫nico caracter:\n\nDefinir un desplazamiento, por ejemplo 3.\nConvertir el caracter a n√∫mero usando ord().\nSumarle desplazamiento.\nFinalmente, convertirlo a caracter nuevamente utilizando chr().\n\nY para el descifrado:\n\nConvertir el caracter a n√∫mero.\nRestarle desplazamiento.\nConvertirlo a caracter nuevamente utilizando chr().\n\nAs√≠, se deber√≠a recuperar el caracter definido al principio.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Introducci√≥n a Python",
      "üß© Problemas"
    ]
  },
  {
    "objectID": "practica/01_introduccion_a_python/problemas.html#cifrado-c√©sar",
    "href": "practica/01_introduccion_a_python/problemas.html#cifrado-c√©sar",
    "title": "üß© Problemas",
    "section": "",
    "text": "En criptograf√≠a, el cifrado C√©sar es una de las t√©cnicas de cifrado m√°s simples y m√°s usadas.\nEs un tipo de cifrado en el que una letra en el texto original es reemplazada por otra letra que se encuentra un n√∫mero fijo de posiciones m√°s adelante en el alfabeto.\nPor ejemplo, con un desplazamiento de 3, la A ser√≠a sustituida por la D (situada 3 lugares a la derecha de la A), la B ser√≠a reemplazada por la E, etc.\n\n\n\n\n\nEscriba una funci√≥n, y luego un script, que permita cifrar y descifrar cadenas usando el cifrado C√©sar con un n√∫mero arbitrario de posiciones.\nDos funciones incluidas con Python que pueden ser √∫tiles para esta tarea son ord(), que convierte caracteres num√©ricos a n√∫meros, y chr(), que realiza la operaci√≥n inversa.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara el cifrado de un √∫nico caracter:\n\nDefinir un desplazamiento, por ejemplo 3.\nConvertir el caracter a n√∫mero usando ord().\nSumarle desplazamiento.\nFinalmente, convertirlo a caracter nuevamente utilizando chr().\n\nY para el descifrado:\n\nConvertir el caracter a n√∫mero.\nRestarle desplazamiento.\nConvertirlo a caracter nuevamente utilizando chr().\n\nAs√≠, se deber√≠a recuperar el caracter definido al principio.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Introducci√≥n a Python",
      "üß© Problemas"
    ]
  },
  {
    "objectID": "practica/01_introduccion_a_python/problemas.html#n√∫meros-aleatorios",
    "href": "practica/01_introduccion_a_python/problemas.html#n√∫meros-aleatorios",
    "title": "üß© Problemas",
    "section": "2 N√∫meros aleatorios",
    "text": "2 N√∫meros aleatorios\nConstruya un programa en Python que genere una cantidad determinada de n√∫meros aleatorios uniformes dentro de un rango definido por el usuario. El programa debe:\n\nSolicitar al usuario la cantidad de n√∫meros a generar y los valores m√≠nimo y m√°ximo del rango.\nGenerar los n√∫meros aleatorios\nGuardar los n√∫meros en un archivo de texto, uno por l√≠nea.\nOfrecer la opci√≥n de mostrar un resumen estad√≠stico con m√≠nimo, m√°ximo, media y desv√≠o est√°ndar, solo si el usuario lo solicita.\n\nPara resolver este problema utilice el m√≥dulo random y las funciones desarrolladas en el ejercicio Res√∫menes estad√≠sticos guardadas en un m√≥dulo llamado estadistica.py.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Introducci√≥n a Python",
      "üß© Problemas"
    ]
  },
  {
    "objectID": "practica/01_introduccion_a_python/problemas.html#mensaje-al-descubierto",
    "href": "practica/01_introduccion_a_python/problemas.html#mensaje-al-descubierto",
    "title": "üß© Problemas",
    "section": "3 Mensaje al descubierto",
    "text": "3 Mensaje al descubierto\nResulta que Franco, un amigo que estudia Ciencias de la Computaci√≥n en la FCEIA, te env√≠a por WhatsApp un archivo de texto plano con mensajes ‚Äúencriptados‚Äù usando caracteres sobrantes y s√≠mbolos extra√±os:\n    !!!,.,  aY??/u/DAM**e,, se =m!!e\n&&M&&e v!o!?LV...I.O /L/*oC/*o\n        __?e_?l//+ T++**e/*Cl!?aD==*O**\nTiene sentido pensar que est√° experimentando con nuevos algoritmos de cifrado y, de paso, te lanza el reto de descifrarlo.\nTu misi√≥n es escribir un programa que:\n\nLea un archivo de texto plano cualquiera.\nMuestre en pantalla su contenido original (tal cual llega).\nAplique un proceso de limpieza basado en las siguientes reglas:\n\nEliminar todos los caracteres +, *, -, /, =, !, ?, & y _.\nReemplazar cualquier secuencia de espacios m√∫ltiples por un solo espacio.\nHomogeinizar la capitalizaci√≥n de los caracteres.\nConservar los saltos de l√≠nea tal cual aparecen en el archivo original.\n\nMuestre en pantalla la versi√≥n desencriptada del texto.\nGuarde la versi√≥n limpia en un nuevo archivo de texto.\n\nEl usuario debe poder especificar el nombre del archivo de salida.\nSi no lo hace, se generar√° uno con el sufijo _limpio antes de la extensi√≥n original (por ejemplo, secreto.txt ‚Üí secreto_limpio.txt).",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Introducci√≥n a Python",
      "üß© Problemas"
    ]
  },
  {
    "objectID": "practica/01_introduccion_a_python/problemas.html#c√≥digo-morse",
    "href": "practica/01_introduccion_a_python/problemas.html#c√≥digo-morse",
    "title": "üß© Problemas",
    "section": "4 C√≥digo Morse",
    "text": "4 C√≥digo Morse\nEl c√≥digo Morse es un sistema utilizado para representar letras mediante combinaciones espec√≠ficas de se√±ales cortas y largas, denominadas puntos (.) y rayas (-). A continuaci√≥n se muestra un diccionario con el mapeo de caracteres alfab√©ticos, d√≠gitos del 0 al 9 y algunos s√≠mbolos de puntuaci√≥n comunes:\nmapeo_morse = {\n    \"A\": \".-\",\n    \"B\": \"-...\",\n    \"C\": \"-.-.\",\n    \"D\": \"-..\",\n    \"E\": \".\",\n    \"F\": \"..-.\",\n    \"G\": \"--.\",\n    \"H\": \"....\",\n    \"I\": \"..\",\n    \"J\": \".---\",\n    \"K\": \"-.-\",\n    \"L\": \".-..\",\n    \"M\": \"--\",\n    \"N\": \"-.\",\n    \"O\": \"---\",\n    \"P\": \".--.\",\n    \"Q\": \"--.-\",\n    \"R\": \".-.\",\n    \"S\": \"...\",\n    \"T\": \"-\",\n    \"U\": \"..-\",\n    \"V\": \"...-\",\n    \"W\": \".--\",\n    \"X\": \"-..-\",\n    \"Y\": \"-.--\",\n    \"Z\": \"--..\",\n    \"1\": \".----\",\n    \"2\": \"..---\",\n    \"3\": \"...--\",\n    \"4\": \"....-\",\n    \"5\": \".....\",\n    \"6\": \"-....\",\n    \"7\": \"--...\",\n    \"8\": \"---..\",\n    \"9\": \"----.\",\n    \"0\": \"-----\",\n    \", \": \"--..--\",\n    \".\": \".-.-.-\",\n}\nEscriba una funci√≥n en Python que permita convertir cualquier palabra a c√≥digo Morse utilizando este diccionario. Luego, escriba otra funci√≥n que haga exactamente lo contrario: dada una secuencia en c√≥digo Morse, debe recuperar la palabra original. Finalmente, incorpore ambas funciones en un script principal que combine ambas funciones y permita encriptar o desencriptar texto desde un archivo de texto plano. El programa debe recibir:\n\nEl nombre del archivo de entrada.\nEl nombre del archivo de salida.\nLa operaci√≥n a realizar (encriptar o desencriptar).\n\nAyuda: Para indicar espacios en c√≥digo Morse utilice /.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Introducci√≥n a Python",
      "üß© Problemas"
    ]
  },
  {
    "objectID": "informacion/calendario.html",
    "href": "informacion/calendario.html",
    "title": "Calendario",
    "section": "",
    "text": "Semana\nFecha\nTemas\nOtras actividades\n\n\n\n\n1\n4 de agosto\n‚Ä¢ Lenguaje Python y su ecosistema.‚Ä¢ Uso de Python en la terminal.‚Ä¢ Uso de Positron.‚Ä¢ Python en Positron.‚Ä¢ Python: expresiones; variables y asignaciones; tipos de datos elementales; operadores num√©ricos, de comparaci√≥n y l√≥gicos.‚Ä¢ Jupyter Notebooks.‚Ä¢ Definici√≥n de funciones.‚Ä¢ Ejecuci√≥n condicional de c√≥digo.\n\n\n\n2\n11 de agosto\n‚Ä¢ Bucles definidos y no definidos: for, while, break, continue.‚Ä¢ Estructuras de datos nativas de Python: list, tuple, set y dict.‚Ä¢ Complemento: str, bytes, bytearray y range.\n\n\n\n3\n17 de agosto\n‚Ä¢ Uso de c√≥digo externo (propio y de terceros).‚Ä¢ M√≥dulos y librer√≠as.‚Ä¢ Librer√≠a est√°ndar de Python.‚Ä¢ Instalaci√≥n y gesti√≥n de librer√≠as.‚Ä¢ Scripting.‚Ä¢ Lectura y escritura de archivos de texto plano.‚Ä¢ Modularizaci√≥n de programas.\n\n\n\n4\n25 de agosto\n‚Ä¢ Funciones como ciudadanos de primera clase.‚Ä¢ Funciones puras.‚Ä¢ Funciones an√≥nimas.‚Ä¢ Closures.‚Ä¢ Recursi√≥n.\n\n\n\n5\n1 de septiembre\n‚Ä¢ Funciones de orden superior: map, filter, reduce.‚Ä¢ Evaluaci√≥n estricta y no estricta.‚Ä¢ Evaluaci√≥n perezosa (lazy) e inmediata (eager).‚Ä¢ Generadores.‚Ä¢ Aplicaci√≥n parcial de funciones.‚Ä¢ Decoradores.\n\n\n\n6\n15 de septiembre\n‚Ä¢ Objetos, clases e instancias.‚Ä¢ Atributos y m√©todos.‚Ä¢ Propiedades p√∫blicas y privadas.‚Ä¢ M√©todos de clase y m√©todos de instancia.\n\n\n\n7\n22 de septiembre\n‚Ä¢ Encapsulamiento.‚Ä¢ Herencia simple y m√∫ltiple.‚Ä¢ Polimorfismo.‚Ä¢ Abstracci√≥n.\n\n\n\n8\n29 de septiembre\n‚Ä¢ M√©todos especiales (dunder methods).‚Ä¢ Decoradores aplicados a m√©todos.‚Ä¢ Sobrecarga de operadores.\nParcial\n\n\n9\n6 de octubre\n‚Ä¢ Concepto y clasificaci√≥n.‚Ä¢ Estructuras lineales y no lineales.‚Ä¢ Listas y listas enlazadas.‚Ä¢ Operaciones b√°sicas: agregar, quitar y recorrer.\nPresentaci√≥n TP Grupal\n\n\n10\n13 de octubre\n‚Ä¢ Hashing.‚Ä¢ Diccionarios y conjuntos como estructuras asociativas.‚Ä¢ √Årboles y grafos.\nRecuperatorio\n\n\n11\n20 de octubre\n‚Ä¢ Arreglos multidimensionales de NumPy.\n\n\n\n12\n27 de octubre\n‚Ä¢ Concepto de algoritmo y complejidad.‚Ä¢ Algoritmos de b√∫squeda.‚Ä¢ B√∫squeda lineal y binaria.‚Ä¢ Notaci√≥n Big O.\nEntrega TP Grupal\n\n\n13\n3 de noviembre\n‚Ä¢ Algoritmos de ordenamiento.‚Ä¢ bubble sort, insert sort, select sort, quick sort y merge sort.‚Ä¢ Comparaci√≥n de algoritmos de ordenamiento.\nPresentaci√≥n TP Individual\n\n\n14\n10 de noviembre\n‚Ä¢ Funciones de b√∫squeda y ordenamiento en Python.\n\n\n\n15\n17 de noviembre\n\n\n\n\n16\n24 de noviembre\n\nEntrega y defensa TP Individual",
    "crumbs": [
      "Informaci√≥n",
      "Calendario"
    ]
  },
  {
    "objectID": "informacion/bibliografia.html",
    "href": "informacion/bibliografia.html",
    "title": "Bibliograf√≠a",
    "section": "",
    "text": "Principal\n\nCormen et¬†al. (2022) Downey (2024) Kalb (2022) Kubica (2022) Lott y Phillips (2021) Lott (2022) Mertz (2015) Miller, Ranum, y Yasinovskyy (2023) Sedgewick y Wayne (2011) Sedgewick, Wayne, y Dondero (2015) Sweigart (2020) Tuckfield (2021)\n\n\n\nCormen, Thomas H., Charles E. Leiserson, Ronald L. Rivest, y Clifford Stein. 2022. Introduction to Algorithms. 4th ed. MIT.\n\n\nDowney, Allen B. 2024. Think Python. 3.¬™ ed. O‚ÄôReilly Media. https://allendowney.github.io/ThinkPython/.\n\n\nKalb, Irv. 2022. Object-Oriented Python. No Starch Press.\n\n\nKubica, Jacek. 2022. Data Structures the Fun Way. 1st ed. No Starch Press.\n\n\nLott, Steven F. 2022. Functional Python Programming. 3rd ed. Packt Publishing.\n\n\nLott, Steven F., y Dusty Phillips. 2021. Python Object-Oriented Programming. 4th ed. Packt Publishing.\n\n\nMertz, David. 2015. Functional Programming in Python. O‚ÄôReilly Media.\n\n\nMiller, Bradley, David Ranum, y Jan Yasinovskyy. 2023. Problem Solving with Algorithms and Data Structures Using Python. 3rd ed. Franklin, Beedle & Associates.\n\n\nSedgewick, Robert, y Kevin Wayne. 2011. Algorithms. 4th ed. Addison-Wesley Professional.\n\n\nSedgewick, Robert, Kevin Wayne, y Robert Dondero. 2015. Introduction to Programming in Python. Addison-Wesley Professional.\n\n\nSweigart, Al. 2020. Beyond the Basic Stuff with Python. No Starch Press. https://inventwithpython.com/beyond/.\n\n\nTuckfield, Bradford. 2021. Dive Into Algorithms. No Starch Press.\n\n\n\n\nComplementaria\n\nHetland (2014) Mailund (2023) Sweigart (2021) Vaughan (2019) Wickham (2019)\n\n\n\n\n\nHetland, Magnus Lie. 2014. Python Algorithms. 2.¬™ ed. Apress.\n\n\nMailund, Thomas. 2023. Functional Programming in R 4. 2.¬™ ed. Apress.\n\n\nSweigart, Al. 2021. The Big Book of Small Python Projects. No Starch Press. https://inventwithpython.com/bigbookpython/.\n\n\nVaughan, Lee. 2019. Impractical Python Projects. No Starch Press.\n\n\nWickham, Hadley. 2019. Advanced R. 2.¬™ ed. Chapman & Hall/CRC. https://adv-r.hadley.nz/.",
    "crumbs": [
      "Informaci√≥n",
      "Bibliograf√≠a"
    ]
  },
  {
    "objectID": "informacion/aprobacion.html",
    "href": "informacion/aprobacion.html",
    "title": "Condiciones de aprobaci√≥n",
    "section": "",
    "text": "üìù Examen parcial: individual y escrito. Hay un recuperatorio, de similares caracter√≠sticas, que reemplaza la nota del parcial.\nü§ù Trabajo pr√°ctico grupal: se hace fuera de clase, en grupos de entre dos y tres integrantes.\nüßë‚Äçüíª Trabajo pr√°ctico individual: opcional para promoci√≥n, con presentaci√≥n y defensa oral.\nTodas las instancias se califican en una escala de 0 a 10 y se aprueban con 6.",
    "crumbs": [
      "Informaci√≥n",
      "Condiciones de aprobaci√≥n"
    ]
  },
  {
    "objectID": "informacion/aprobacion.html#instancias-de-evaluaci√≥n",
    "href": "informacion/aprobacion.html#instancias-de-evaluaci√≥n",
    "title": "Condiciones de aprobaci√≥n",
    "section": "",
    "text": "üìù Examen parcial: individual y escrito. Hay un recuperatorio, de similares caracter√≠sticas, que reemplaza la nota del parcial.\nü§ù Trabajo pr√°ctico grupal: se hace fuera de clase, en grupos de entre dos y tres integrantes.\nüßë‚Äçüíª Trabajo pr√°ctico individual: opcional para promoci√≥n, con presentaci√≥n y defensa oral.\nTodas las instancias se califican en una escala de 0 a 10 y se aprueban con 6.",
    "crumbs": [
      "Informaci√≥n",
      "Condiciones de aprobaci√≥n"
    ]
  },
  {
    "objectID": "informacion/aprobacion.html#condiciones-de-aprobaci√≥n",
    "href": "informacion/aprobacion.html#condiciones-de-aprobaci√≥n",
    "title": "Condiciones de aprobaci√≥n",
    "section": "Condiciones de aprobaci√≥n",
    "text": "Condiciones de aprobaci√≥n\n\nPromoci√≥n\n\nQuienes aprueben el parcial individual (con nota \\(\\text{P}\\)), el trabajo pr√°ctico grupal (con nota \\(\\text{T}\\)) y el trabajo pr√°ctico individual con defensa oral (con nota \\(\\text{O}\\)), adquieren la condici√≥n de estudiante promovido y su nota final se calcula como \\(0.5 \\times \\text{P} + 0.2 \\times \\text{T} + 0.3 \\times \\text{O}\\).\n\nRegularidad\n\nQuienes aprueben el parcial individual (o su recuperatorio) y el trabajo pr√°ctico grupal, pero no accedan o no aprueben el trabajo pr√°ctico individual, adquieren la condici√≥n de estudiante regular.\n\nLibres\n\nQuienes no aprueben el parcial individual (ni su recuperatorio) o el trabajo pr√°ctico grupal, adquieren la condici√≥n de estudiante libre.",
    "crumbs": [
      "Informaci√≥n",
      "Condiciones de aprobaci√≥n"
    ]
  },
  {
    "objectID": "teoria/01_introduccion_a_python/clase_1.html",
    "href": "teoria/01_introduccion_a_python/clase_1.html",
    "title": "Clase 1",
    "section": "",
    "text": "Python es un lenguaje de programaci√≥n. Pero podemos pensarlo intuitivamente como una super-calculadora. Python nos ayuda a hacer lo mismo que una calculadora, y como vamos a ver, mucho m√°s.\nEmpecemos utilizando a Python como si fuese una calculadora. Para eso vamos a crear un bloque de c√≥digo en la notebook y escribimos algunas cuentas tal como lo hacemos en cualquier calculadora.\n\n2 * 3\n\n6\n\n\nNo tenemos la necesidad de pisar el c√≥digo todo el tiempo. Podemos escribir nuevas celdas de c√≥digo, y as√≠ podemos ir mostrando diferentes c√≥mputos y sus resultados.\n\n100 / 3.5\n\n28.571428571428573\n\n\n\n20 + 5\n\n25\n\n\n\n13 - 3\n\n10\n\n\n\n10 * 5.5\n\n55.0",
    "crumbs": [
      "Teor√≠a",
      "U1 - Introducci√≥n a Python",
      "Clase 1"
    ]
  },
  {
    "objectID": "teoria/01_introduccion_a_python/clase_1.html#una-super-calculadora",
    "href": "teoria/01_introduccion_a_python/clase_1.html#una-super-calculadora",
    "title": "Clase 1",
    "section": "",
    "text": "Python es un lenguaje de programaci√≥n. Pero podemos pensarlo intuitivamente como una super-calculadora. Python nos ayuda a hacer lo mismo que una calculadora, y como vamos a ver, mucho m√°s.\nEmpecemos utilizando a Python como si fuese una calculadora. Para eso vamos a crear un bloque de c√≥digo en la notebook y escribimos algunas cuentas tal como lo hacemos en cualquier calculadora.\n\n2 * 3\n\n6\n\n\nNo tenemos la necesidad de pisar el c√≥digo todo el tiempo. Podemos escribir nuevas celdas de c√≥digo, y as√≠ podemos ir mostrando diferentes c√≥mputos y sus resultados.\n\n100 / 3.5\n\n28.571428571428573\n\n\n\n20 + 5\n\n25\n\n\n\n13 - 3\n\n10\n\n\n\n10 * 5.5\n\n55.0",
    "crumbs": [
      "Teor√≠a",
      "U1 - Introducci√≥n a Python",
      "Clase 1"
    ]
  },
  {
    "objectID": "teoria/01_introduccion_a_python/clase_1.html#tipos-de-datos",
    "href": "teoria/01_introduccion_a_python/clase_1.html#tipos-de-datos",
    "title": "Clase 1",
    "section": "Tipos de datos",
    "text": "Tipos de datos\nComo cualquier lenguaje de programaci√≥n, Python ofrece diferentes tipos de datos. ¬°Una super-calculadora no se puede rebajar a trabajar solo con n√∫meros!\nCada tipo de dato nos ayuda a resolver una tarea distinta. Por ejemplo, si quiero hacer operaciones matem√°ticas voy a necesitar de n√∫meros, pero si quiero escribir un correo electr√≥nico voy a necesitar de texto.\nA continuaci√≥n vamos a introducir los tipos de datos m√°s b√°sicos que Python nos ofrece.\nM√°s adelante tambi√©n veremos otros tipos de datos m√°s complejos que nos van a permitir resolver problemas m√°s interesantes.\n\nN√∫meros\nAcabamos de hacer cuentas matem√°ticas somo si tuvieramos una calculadora. Para eso usamos n√∫meros, los conocidos de toda la vida.\nSin notarlo, utilizamos dos tipos de n√∫meros distintos: los n√∫meros de tipo entero (int) y los n√∫meros de tipo flotante (float).\nLo siguiente es un n√∫mero entero:\n\n50\n\n50\n\n\nY el siguiente es un ejemplo de un n√∫mero flotante:\n\n36.8\n\n36.8\n\n\nUtilizando la funci√≥n type() Python nos devuelve el tipo del objeto.\n\ntype(10)\n\nint\n\n\n\ntype(10.5)\n\nfloat\n\n\n\ntype(10.0)\n\nfloat\n\n\n\ntype(10.)\n\nfloat\n\n\n\n\n\n\n\n\nObservaci√≥n üëÄ\n\n\n\nA diferencia de R, Python no es un lenguaje vectorizado. Por lo tanto, los tipos int y float representan valores escalares, no vectores de longitud 1 como ocurre en R.\nEsta observaci√≥n aplica a todos los tipos de datos elementales que vienen a continuaci√≥n.\n\n\n\n\nCadenas de texto\nPara ser una super-calculadora, Python tiene que ser capaz de trabajar con objetos m√°s complejos que los n√∫meros.\nUn ejemplo de esto es el texto. El texto se representa con un objeto llamado cadena de texto.\nPara construir una cadena de texto se utilizan comillas.\nEstas se ponen al principio y al final del texto e indican el principio y el final de la cadena. Las comillas pueden ser dobles \" o simples '.\n\n\"Programando en Python\"\n\n'Programando en Python'\n\n\n\n'Con comillas simples, tambi√©n.'\n\n'Con comillas simples, tambi√©n.'\n\n\nEn Python no hay diferencia entre usar comillas simples ' o dobles \", pero es importante que el tipo de comilla que se usa para abrir la cadena sea el mismo que se usa para cerrarla.\nCuando imprimimos una cadena, las comillas no se muestran en la salida. Para imprimir cualquier objeto de Python utilizamos la funci√≥n print().\n\nprint('Con comillas simples, ¬°tambi√©n!')\n\nCon comillas simples, tambi√©n!\n\n\nUna forma un poco m√°s ex√≥tica, pero muy √∫til, de crear cadenas es utilizando comillas triples. Con esta sintaxis, se repiten tres comillas seguidas, lo que permite definir cadenas de texto que ocupan varias l√≠neas.\n\nprint(\"\"\"Se puede escribir texto\nen varias lineas.\n¬°Est√° muy bueno!\"\"\")\n\nSe puede escribir texto\nen varias lineas.\n¬°Est√° muy bueno!\n\n\nOtra manera de escribir texto que abarca m√∫ltiples l√≠neas es usando el car√°cter especial \\n, que representa un salto de l√≠nea.\n\nprint(\"Primera l√≠nea\\nsegunda l√≠nea\\ntercera l√≠nea.\")\n\nPrimera l√≠nea\nsegunda l√≠nea\ntercera l√≠nea.\n\n\nEn cambio, si mostramos una representaci√≥n del texto (sin usar print()), los \\n s√≠ se visualizan.\n\n\"Primera l√≠nea\\nsegunda l√≠nea\\ntercera l√≠nea.\"\n\n'Primera l√≠nea\\nsegunda l√≠nea\\ntercera l√≠nea.'\n\n\n\n\n\n\n\n\n¬°Atencion! ü§ì\n\n\n\n¬øCu√°l es la diferencia entre usar print() y no usarlo?\n\nCuando usamos print() se imprime el objeto de una manera humanamente legible.\nCuando no lo usamos, se muestra una representaci√≥n del objeto. Esta representaci√≥n tiene que ser lo menos ambigua posible.\n\nPor este motivo es que se muestran las comillas a la hora de representar una cadena.\n\n\n\n\nOtra situaci√≥n en la que usar print() genera una diferencia es cuando se quieren mostrar varios objetos. Por ejemplo, comparemos el resultado de los siguientes bloques:\n\n\"mensaje 1\"\n10\n\"mensaje 2\"\n\n'mensaje 2'\n\n\n\nprint(\"mensaje 1\")\nprint(10)\nprint(\"mensaje 2\")\n\nmensaje 1\n10\nmensaje 2\n\n\n\n\nL√≥gicos (o Booleanos)\nComo veremos m√°s adelante, nuestros programas suelen tener que decidir entre diferentes acciones a tomar seg√∫n se cumpla o no cierta condici√≥n.\nPara representar esta situaci√≥n utilizamos un tipo especial de dato conocido como l√≥gico o booleano, que puede tomar √∫nicamente dos valores: True o False.\nSi la condici√≥n se cumple, el resultado ser√° True; de lo contrario, ser√° False.\n\nTrue\n\nTrue\n\n\n\nFalse\n\nFalse\n\n\n\ntype(True)\n\nbool\n\n\n\ntype(False)\n\nbool\n\n\n\n\n\n\n\n\nRese√±a hist√≥rica üìú\n\n\n\nEste tipo de datos se llama Booleano en honor al matem√°tico George Boole.\n\n\n\n\nNulo\nEl valor nulo, llamado None en Python, representa la ausencia de valor o el vac√≠o.\nSe utiliza habitualmente para indicar que algo no tiene un valor asignado.\nSi intentamos mostrar el valor de None, veremos que no aparece nada.\n\nNone\n\nEn cambio, si imprimimos el objeto None, vemos el mensaje None.\n\nprint(None)\n\nNone\n\n\n¬øY cu√°l es su tipo?\n\ntype(None)\n\nNoneType\n\n\nSolamente los objetos None son del tipo NoneType.\n\n\n\n\n\n\n¬øPor qu√© existe el valor nulo? ü§î\n\n\n\nMuchas veces nuestro programa, o alguna parte del mismo, realiza una tarea que no devuelve ning√∫n resultado.\nPodr√≠amos ponernos de acuerdo en representar ‚Äúning√∫n resultado‚Äù usando un n√∫mero (0), una cadena vac√≠a (\"\") o algo parecido. Pero estos valores representan algo espec√≠fico, no la ausencia total de valor.\nPara expresar claramente que no hay ning√∫n resultado, Python incluye un valor especial llamado None.\n\n\nEjemplos\n\nUn usuario completa un formulario con datos personales, pero algunos campos no son obligatorios y quedan sin completar.\nUna funci√≥n busca un elemento en una lista; cuando no encuentra lo buscado, devuelve un valor especial indicando que el resultado est√° ausente.\n\nEn general, cuando se quiera representar la ausencia de informaci√≥n se utilizar√° None.\n\n\n\n\n\n\nObservaci√≥n üëÄ\n\n\n\nEn R existen dos tipos de datos para representar valores faltantes: NULL y NA. El None de Python equivale a NULL en R, ya que ambos indican ausencia de valor.\nPor otro lado, NA en R representa un valor existente pero desconocido, por ejemplo, porque se ha perdido. Python no ofrece un tipo de dato equivalente de forma nativa, aunque algunas librer√≠as s√≠ lo implementan.\n\n\n\n\nConversi√≥n entre tipos de datos\nQue existan distintos tipos de datos no significa que un objeto de un tipo no pueda ‚Äúconvertirse‚Äù a otro.\nEn muchos casos es posible convertir entre tipos de datos. Por ejemplo, un n√∫mero siempre se puede convertir a una cadena de caracteres, pero no cualquier cadena puede convertirse a un n√∫mero.\nPara convertir un objeto a otro tipo utilizamos funciones con el nombre del tipo al que queremos convertir, como str(), int() o bool(). Estas funciones reciben como argumento el objeto a convertir.\nVeamos algunos ejemplos:\n\nstr(256)\n\n'256'\n\n\n\nstr(None)\n\n'None'\n\n\n\nint(165.5)\n\n165\n\n\n\nint(165.8)\n\n165\n\n\n\nint(\"165\")\n\n165\n\n\n\nfloat(\"165.0\")\n\n165.0\n\n\n\n\nResumen\n\nPython tiene distintos tipos de datos.\nCada tipo de dato es √∫til para resolver diferentes problemas.\n\nA lo largo del curso veremos much√≠simos ejemplos.\n\nAl principio, tener varios tipos de datos puede parecer complejo.\n\nSin embargo, nos resultar√°n muy naturales a medida que los usemos para resolver problemas concretos.\n\n\n\n\n\n\n\n\n\nTipo de dato\nEjemplos\n\n\n\n\nN√∫meros enteros (int)\n-2, -1, 0, 10, 200\n\n\nN√∫meros de punto flotante (float)\n-200.789, -1.0, 0.0, 17.8\n\n\nCadenas de texto (str)\n\"a\", \"abc\", \"Rosario, Santa Fe\"\n\n\nBooleanos (bool)\nTrue, False\n\n\nValor nulo (NoneType)\nNone",
    "crumbs": [
      "Teor√≠a",
      "U1 - Introducci√≥n a Python",
      "Clase 1"
    ]
  },
  {
    "objectID": "teoria/01_introduccion_a_python/clase_1.html#variables",
    "href": "teoria/01_introduccion_a_python/clase_1.html#variables",
    "title": "Clase 1",
    "section": "Variables",
    "text": "Variables\n¬øEs necesario escribir expl√≠citamente los valores con los que trabajamos cada vez que los usamos? Afortunadamente, la respuesta es no.\nLos lenguajes de programaci√≥n m√°s populares permiten usar variables.\nPodemos pensar las variables como etiquetas o nombres que asignamos a los objetos en nuestro programa.\nUna vez creada una variable con cierto valor, podemos usar directamente su nombre en lugar de volver a escribir el valor completo.\n\nmensaje = \"¬°Hola, curso!\"\nprint(mensaje)\n\n¬°Hola, curso!\n\n\n\nprint(\"¬°Hola, curso!\")\n\n¬°Hola, curso!\n\n\nPara crear una variable se necesita:\n\nEl nombre.\nEl operador de asignaci√≥n.\nEl valor que queremos asignar a la variable.\n\nEn nuestro caso, el nombre de la variable es mensaje y el valor es \"¬°Hola, curso!\".\nLuego, cuando accedemos a la variable mensaje dentro de la funci√≥n print(), Python nos devuelve el valor de la variable, es decir, ¬°Hola, curso!\".\nVeamos otros ejemplos‚Ä¶\n\npi = 3.14159\nfruta_favorita = \"manzana\"\npython_bueno = True\n\nEn el siguiente diagrama se muestra c√≥mo las variables que creamos funcionan simplemente como etiquetas para los valores asignados.\nCada vez que utilizamos una de estas etiquetas, accedemos directamente al valor que representa.\n\n\n\n\n\n\nprint(pi * 10)\n\n31.4159\n\n\n\nfruta_favorita\n\n'manzana'\n\n\n\npython_bueno\n\nTrue\n\n\nLas variables no solo evitan que escribamos repetidamente los mismos valores en nuestro programa, sino que tambi√©n permiten:\n\nGeneralizar el programa\n\nAl cambiar el valor de una variable, todas las partes del programa que la usan se actualizan autom√°ticamente.\n\nMejorar la legibilidad del c√≥digo\n\nSi elegimos nombres claros y descriptivos, el programa ser√° mucho m√°s f√°cil de leer y entender.\n\n\nPor ejemplo, los siguientes bloques de c√≥digo producen el mismo resultado, pero el segundo es mucho m√°s informativo:\n\n1500 * 8\n\n12000\n\n\n\nprecio = 1500\ncantidad = 8\nprecio * cantidad\n\n12000\n\n\n\nNombres permitidos\nNo todos los nombres que imaginemos se pueden utilizar como variables en Python.\nTenemos que tener en cuenta las siguientes reglas. Los nombres de variables‚Ä¶\n\nSolo pueden contener letras, n√∫meros y guiones bajos (_).\nDeben comenzar con una letra o un gui√≥n bajo, pero no con un n√∫mero.\n\nPor ejemplo, mensaje_1 es v√°lido, pero 1_mensaje no lo es.\n\nNo pueden contener espacios.\n\nPor eso usamos fruta_favorita en lugar de fruta favorita.\n\nNo pueden ser palabras reservadas de Python.\n\nLas palabras reservadas se encuentran al final de este apunte.\n\n\nAdem√°s, tambi√©n vale la pena tener presente estos consejos:\n\nUs√° nombres breves pero descriptivos.\n\nnombre es preferible a n.\nfruta_favorita es preferible a frut_fav.\n\nEvit√° utilizar tildes, la letra √± u otros caracteres espec√≠ficos del castellano.\n\n\n\nEliminar variables\nEs posible que, despu√©s de crear nuestras variables y realizar las operaciones necesarias, queramos eliminarlas.\nPara borrar una variable, Python ofrece la sentencia del (del ingl√©s delete, que significa eliminar o borrar).\n\ndel fruta_favorita\n\n\n\nAsignaci√≥n m√∫ltiple\nYa vimos que para asignar (o crear) una variable necesitamos hacer variable = &lt;valor&gt;.\nSi queremos crear varias variables, podemos hacerlo en l√≠neas separadas:\n\npi = 3.1416\ne = 2.7182\n\nprint(pi)\nprint(e)\n\n3.1416\n2.7182\n\n\nUna caracter√≠stica conveniente de Python es que permite asignar m√∫ltiples variables en una misma l√≠nea:\n\npi, e = 3.1416, 2.7182\n\nprint(pi)\nprint(e)\n\n3.1416\n2.7182\n\n\nOtra ventaja es que las variables no tienen que ser del mismo tipo:\n\na, b, c = 100 + 20, \"un mensaje cualquiera\", None\n\nprint(a)\nprint(b)\nprint(c)\n\n120\nun mensaje cualquiera\nNone\n\n\nEsta t√©cnica es √∫til para escribir c√≥digo m√°s conciso, pero no conviene abusar de ella porque puede resultar en c√≥digo poco legible.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Introducci√≥n a Python",
      "Clase 1"
    ]
  },
  {
    "objectID": "teoria/01_introduccion_a_python/clase_1.html#operadores",
    "href": "teoria/01_introduccion_a_python/clase_1.html#operadores",
    "title": "Clase 1",
    "section": "Operadores",
    "text": "Operadores\nLos operadores son s√≠mbolos que se utilizan para realizar operaciones o acciones sobre los objetos con los que estamos trabajando.\nHasta ahora, vimos que podemos tener n√∫meros, texto, y otras objetos un poco mas extra√±os como los booleanos e incluso algo que representa a la nada misma.\nA continuaci√≥n, comenzamos a ver algunas de las tareas que podemos hacer con ellos.\n\nOperadores aritm√©ticos\nPython incluye los mismos operadores aritm√©ticos que solemos utilizar en nuestro d√≠a a d√≠a para hacer operaciones matem√°ticas.\nEstos se parecen much√≠simo a los que usamos en una calculadora, por lo que podr√≠amos entenderlo incluso sin saber de Python.\nAlgunos operadores son los siguientes:\n\nSuma (+)\nResta (-)\nMultiplicaci√≥n (*)\nPotencia (**)\nDivisi√≥n (/)\nDivisi√≥n entera (//)\nM√≥dulo (%)\n\n\nSuma (+)\n\n10 + 25\n\n35\n\n\n\n10.0 + 25.0\n\n35.0\n\n\n\n-8 + 12.1\n\n4.1\n\n\nEl operador suma tambi√©n puede ser usado con un solo argumento:\n\n+ 8\n\n8\n\n\nEn este caso no modifica en nada al valor 8.\n\n\n\nResta (-)\n\n11 - 8\n\n3\n\n\n\n100 - 100.0\n\n0.0\n\n\n\n-35 - 28\n\n-63\n\n\nEl operador resta tambi√©n puede ser usado con un solo argumento:\n\n- 7\n\n-7\n\n\n\n\nMultiplicaci√≥n (*) y potencia (**)\n\n21 * 5\n\n105\n\n\n\n21 * 5.0\n\n105.0\n\n\n\n21.0 * 5.0\n\n105.0\n\n\n\n2 ** 3\n\n8\n\n\n\n2 ** 3.0\n\n8.0\n\n\n\n\n\n\n\n\nConclusiones\n\n\n\nPara las operaciones de suma, resta, multiplicaci√≥n y potencia se cumple:\n\nSi ambos valores son enteros, el resultado ser√° un entero.\nSi al menos uno de los valores es flotante, el resultado ser√° flotante.\n\n\n\n\n\nDivisi√≥n (/ y //)\nPython provee dos operadores distintos para calcular el cociente entre dos n√∫meros.\n\nEl operador / que calcula la divisi√≥n flotante.\nEl operador // que calcula la divisi√≥n entera.\n\nEl operador / es el que m√°s se utiliza y siempre devuelve un n√∫mero de tipo flotante.\n\n10 / 5\n\n2.0\n\n\n\n10 / 5.5\n\n1.8181818181818181\n\n\nLa divisi√≥n entera se suele utilizar cuando uno quiere el resultado entero de la divisi√≥n, sin importar si el resto es 0 o no.\n\n10 // 5\n\n2\n\n\n\n10 // 5.5\n\n1.0\n\n\nVeamos los siguientes ejemplos donde comparamos la divisi√≥n flotante con la divisi√≥n entera, utilizando los mismos argumentos.\n\n15 / 4\n\n3.75\n\n\n\n15.0 // 4.0\n\n3.0\n\n\nConclusi√≥n: La divisi√≥n entera no redondea el resultado de la divisi√≥n flotante. M√°s sobre esto debajo.\n\n\nM√≥dulo (%)\nOtro operador relacionado a la divisi√≥n entera es el operador m√≥dulo o resto (%).\nEsta operaci√≥n nos devuelve el resto que se obtiene al realizar la divisi√≥n entera entre dos n√∫meros.\n\n17 % 3\n\n2\n\n\nDebajo se puede ver la relaci√≥n entre la divisi√≥n entera y el m√≥dulo:\n\n\n\n\n\nAunque ahora pueda parecer dif√≠cil encontrar una aplicaci√≥n pr√°ctica para los operadores de divisi√≥n entera // y resto %, m√°s adelante veremos ejemplos donde haremos un uso intensivo de ellos.\n\n\n\n\n\n\nObservaci√≥n üëÄ\n\n\n\nProbablemente en R hayan utilizado principalmente el operador /, que tambi√©n corresponde a la divisi√≥n flotante.\nEn ese lenguaje, los operadores para divisi√≥n entera y resto son %/% y %%, respectivamente.\n\n\n\n\nPrioridad de los operadores\nHasta ahora vimos operaciones bastante sencillas.\nCuando presentamos la suma, realizamos simplemente una suma. Cuando presentamos la multiplicaci√≥n, hicimos solo una multiplicaci√≥n.\nPor supuesto, al momento de hacer c√°lculos podemos combinar los operadores que ya conocemos, de la misma forma en que lo hacemos al resolver cuentas a mano.\nUn punto importante a tener en cuenta es que, al igual que cuando hacemos cuentas a mano, algunas operaciones se resuelven antes que otras, sin importar el orden en que aparecen. Esto ocurre porque algunos operadores tienen mayor prioridad y, por lo tanto, se eval√∫an antes.\nEn el siguiente ejemplo, ¬øpor qu√© se obtienen resultados distintos?\n\n10 - 2 * 4\n\n2\n\n\n\n(10 - 2) * 4\n\n32\n\n\nIndependientemente de que el s√≠mbolo + aparezca antes que el s√≠mbolo * en una expresi√≥n, Python realiza primero la multiplicaci√≥n.\nAl igual que cuando hacemos cuentas a mano, la multiplicaci√≥n tiene mayor prioridad que la suma.\nSi queremos forzar a Python a realizar una operaci√≥n antes que otra, sin importar la prioridad de los operadores, debemos usar par√©ntesis.\nOtro ejemplo es el siguiente‚Ä¶\n\n7 + 8 / 2\n\n11.0\n\n\n\n(7 + 8) / 2\n\n7.5\n\n\nA continuaci√≥n se incluye una tabla con los operadores que vimos y la prioridad que tiene cada uno.\nLos operadores que aparecen m√°s arriba tienen mayor prioridad.\nLos operadores que aparecen en la misma fila tienen el mismo nivel de prioridad y se resuelven seg√∫n el orden en que aparecen en el c√≥digo (de izquierda a derecha).\n\n\n\n\n\n\n\nOperador\nSignificado\n\n\n\n\n()\nAgrupamiento\n\n\n**\nPotencia\n\n\n*, /, //, %\nMultiplicaci√≥n, Divisi√≥n, Divisi√≥n entera, M√≥dulo\n\n\n+, -\nSuma, Resta\n\n\n\nEsta lista es una versi√≥n m√°s sencilla y resumida de la tabla de prioridades de todos los operadores que hay en Python. Una versi√≥n m√°s completa se puede encontrar en Programiz.\n\n\n\nOperadores l√≥gicos\nLos operadores l√≥gicos se llaman as√≠ porque el resultado que devuelven es de tipo l√≥gico (bool).\nEn algunos casos se utilizan s√≠mbolos, en otros se utilizan palabras claves.\nA partir de ahora vamos a ver varias operaciones que puedan resultar familiares para quienes hicieron alguna materia relacionada a l√≥gica.\n\nNegaci√≥n (not)\nDevuelve el opuesto del valor que le pasamos.\n\nnot False\n\nTrue\n\n\n\nnot True\n\nFalse\n\n\n\n\nConjunci√≥n o intersecci√≥n (and)\nEsta operaci√≥n devuelve True solamente cuando los dos operadores que le pasamos son True.\n\nTrue and True\n\nTrue\n\n\n\nFalse and True\n\nFalse\n\n\n\n\nDisyunci√≥n o uni√≥n (or)\nEsta operaci√≥n devuelve True cuando cualquiera de sus argumentos es True.\n\nTrue or False\n\nTrue\n\n\nSolo devuelve False cuando sus dos argumentos son False.\n\nFalse or False\n\nFalse\n\n\n\n\nIdentidad (is)\nExisten dos operadores para evaluar la identidad de los objetos.\n\nOperador is: es True cuando ambos operandos son el mismo objeto\nOperador is not: es True cuando los operandos no son el mismo objeto.\n\n\nFalse is False\n\nTrue\n\n\n\nFalse is True\n\nFalse\n\n\n\nNone is None\n\nTrue\n\n\n\n\nComparaci√≥n\nPython provee varios operadores para realizar comparaciones entre objetos.\nLos operadores que vemos a continuaci√≥n son los mismos que aprendimos en la secundaria.\n\n\n\n\n\n\n\nOperador\nDescripci√≥n\n\n\n\n\n==\nIgualdad: El resultado es True cuando los dos operandos son iguales.\n\n\n!=\nDesigualdad: El resultado es True si los operandos son distintos.\n\n\n&gt;\nMayor a: El resultado es True si el operando de la izquierda es mayor que el de la derecha.\n\n\n&gt;=\nMayor o igual a: El resultado es True si el operando de la izquierda es mayor o igual que el de la derecha.\n\n\n&lt;\nMenor a: El resultado es True si el operando de la izquierda es menor que el de la derecha.\n\n\n&lt;=\nMenor o igual a: El resultado es True si el operando de la izquierda es menor o igual que el de la derecha.\n\n\n\nAlgunos ejemplos‚Ä¶\n\n10 &gt; 5\n\nTrue\n\n\n\n10 &gt; 5 + 3\n\nTrue\n\n\n\n0 &lt; 0\n\nFalse\n\n\n\n1 &gt;= 1\n\nTrue\n\n\n\n10.0 != 10\n\nFalse\n\n\n\n10.0 == 10\n\nTrue\n\n\nA pesar de que 10.0 es de tipo flotante y 10 es de tipo entero, vemos que la comparaci√≥n de igualdad == dice que son iguales.\nNo siempre que comparemos objetos de distinto tipo va a suceder algo as√≠.\nLa comparaci√≥n de cadenas de texto distingue may√∫sculas de min√∫sculas\n\n\"UNR\" == \"unr\"\n\nFalse\n\n\nEs posible comparar objetos de distinto tipo, como lo vimos en el ejemplo anterior donde comparamos 10 y 10.0.\nSalvo casos particulares, como son los valores num√©ricos, estos objetos son considerados siempre distintos.\n\n\"10\" == 10\n\nFalse\n\n\n\n\"False\" == False\n\nFalse\n\n\nEs posible combinar mas de una comparaci√≥n en la misma l√≠nea.\n\n1 &lt; 2 and 2 &lt; 3\n\nTrue\n\n\nIncluso es posible omitir el operador and y tener una expresi√≥n m√°s clara\n\n1 &lt; 2 &lt; 3\n\nTrue\n\n\n\n-5 &lt; -4 &lt; -3\n\nTrue\n\n\nTambi√©n podemos mezclar not, and y or a gusto.\n\nFalse or not False\n\nTrue\n\n\nY es v√°lido utilizar par√©ntesis para agrupar operaciones.\n\n(False or True) and (True or False)\n\nTrue\n\n\nA continuaci√≥n se incluye una tabla con los operadores l√≥gicos y la prioridad que tiene cada uno.\nLos operadores que aparecen m√°s arriba tienen mayor prioridad.\nLos operadores que aparecen en la misma fila tienen el mismo nivel de prioridad y se resuelven seg√∫n el orden en que aparecen en el c√≥digo (de izquierda a derecha).\n\n\n\n\n\n\n\nOperadores\nSignificado\n\n\n\n\n==, !=, &gt;, &gt;=, &lt;, &lt;=, is, is not, in, not in\nComparaciones, identidad, pertenencia\n\n\nnot\nNegaci√≥n\n\n\nand\nConjunci√≥n o intersecci√≥n\n\n\nor\nDisyunci√≥n o uni√≥n\n\n\n\nTodos los operadores l√≥gicos tienen menor prioridad que los operadores aritm√©ticos que vimos arriba.\nEn otras palabras, si pegaramos ambas tablas, √©sta √∫ltima quedar√≠a por debajo.\nAnalicemos nuevamente uno de los ejemplos que ya vimos.\n\nnot True and not True\n\nFalse\n\n\nEl operador not tiene mayor prioridad que el operador and porque aparece primero en la tabla.\nEn consecuencia, en el c√≥digo anterior primero se resuelven los not True y luego el and. Esto es lo mismo que hacer\n\nFalse and False\n\nFalse",
    "crumbs": [
      "Teor√≠a",
      "U1 - Introducci√≥n a Python",
      "Clase 1"
    ]
  },
  {
    "objectID": "teoria/01_introduccion_a_python/clase_1.html#funciones",
    "href": "teoria/01_introduccion_a_python/clase_1.html#funciones",
    "title": "Clase 1",
    "section": "Funciones",
    "text": "Funciones\nUna funci√≥n puede pensarse como un ‚Äúmini-programa‚Äù dentro de un programa m√°s grande. Su prop√≥sito es cumplir una tarea u objetivo espec√≠fico, de forma independiente del resto del c√≥digo.\nEl uso de funciones tiene varias ventajas:\n\nReutilizaci√≥n de c√≥digo: se define una sola vez y se ejecuta cuando sea necesario.\nMejor organizaci√≥n: dividen el programa en partes m√°s f√°ciles de leer y mantener.\nModularidad: permiten construir programas como bloques independientes que pueden combinarse entre s√≠ (¬°funciones dentro de funciones!).\n\nConsideremos el siguiente caso donde se busca calcuar el precio final de un producto, considerando impuestos y descuentos.\n\nprecio_base = 800   # Precio del producto ($800)\nimpuesto = 0.21     # Impuesto (21%)\ndescuento = 0.10    # Descuento (10%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n871.2\n\n\n¬øQu√© pasa si queremos calcular el precio final para otros productos con diferentes precios, impuestos o descuentos?\nUna opci√≥n es repetir el c√≥digo tantas veces como sea necesario‚Ä¶\n\nprecio_base = 500   # Precio del producto ($500)\nimpuesto = 0.105    # Impuesto (10.5%)\ndescuento = 0.0     # Descuento (0%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n552.5\n\n\n\nprecio_base = 2000  # Precio del producto ($2000)\nimpuesto = 0.21     # Impuesto (21%)\ndescuento = 0.20    # Descuento (20%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n1936.0\n\n\nOtra opci√≥n, mucho mas conveniente, es utilizar funciones.\n\ndef calcular_precio(precio_base, impuesto, descuento):\n    resultado = precio_base * (1 + impuesto) * (1 - descuento)\n    return resultado\n\nLuego, para utilizar la funci√≥n simplemente la llamamos (o invocamos).\n\ncalcular_precio(800, 0.21, 0.10)\n\n871.2\n\n\nTambi√©n es posible indicar los valores de los argumentos utilizando sus nombres.\n\ncalcular_precio(precio_base=2000, impuesto=0.21, descuento=0.20)\n\n1936.0\n\n\n\nDefinici√≥n de funciones\nAnalicemos las diferentes partes que forman la definici√≥n de una funci√≥n en Python:\n\n\n\n\n\n\nLa palabra clave def:\n\nMarca el inicio de la definici√≥n de una funci√≥n.\nEs una palabra reservada (keyword).\n\nEl nombre de la funci√≥n:\n\nDebe seguir las mismas reglas que los nombres de las variables.\n\nLos argumentos de la funci√≥n, dentro de par√©ntesis:\n\nSe separan por comas y pueden ser 0 o m√°s.\n\nLos dos puntos (:):\n\nIndican el final de la l√≠nea de definici√≥n y el inicio del bloque de c√≥digo.\n\nEl bloque de c√≥digo, que es el cuerpo de la funci√≥n:\n\nEs el c√≥digo que se ejecuta cada vez que llamamos a la funci√≥n.\n\nLa sentencia return que indica el resultado que devuelve la funci√≥n.\n\nLuego del return viene el valor o nombre de la variable a devolver.\nEs opcional (ya vamos a ver ejemplos).",
    "crumbs": [
      "Teor√≠a",
      "U1 - Introducci√≥n a Python",
      "Clase 1"
    ]
  },
  {
    "objectID": "teoria/01_introduccion_a_python/clase_1.html#ap√©ndice",
    "href": "teoria/01_introduccion_a_python/clase_1.html#ap√©ndice",
    "title": "Clase 1",
    "section": "Ap√©ndice",
    "text": "Ap√©ndice\n\nPalabras claves y funciones predefinidas\nPython tiene un conjunto de palabras conocidas como keywords que sirven para realizar acciones especificas y que no podemos utilizar como nombres de variables.\nCuando intentemos utilizar una keyword como nombre de variable, obtendremos un error.\nPor otro lado, si intentamos utilizar el nombre de una funci√≥n (o clase) predefinida como nombre de una variable que nosotros creamos, no vamos a obtener un error pero no podremos usar la funci√≥n nuevamente porque la variable ahora representa otra cosa.\n\nPalabras claves\nFalse      await      else       import     pass\nNone       break      except     in         raise\nTrue       class      finally    is         return\nand        continue   for        lambda     try\nas         def        from       nonlocal   while\nassert     del        global     not        with\nasync      elif       if         or         yield\n\n\nFunciones y clases pre-definidas\nabs()          copyright()    getattr()      list()         range()        vars()\nall()          credits()      globals()      locals()       repr()         zip()\nany()          delattr()      hasattr()      map()          reversed()\nascii()        dict()         hash()         max()          round()\nbin()          dir()          help()         memoryview()   set()\nbool()         display()      hex()          min()          setattr()\nbreakpoint()   divmod()       id()           next()         slice()\nbytearray()    enumerate()    input()        object()       sorted()\nbytes()        eval()         int()          oct()          staticmethod()\ncallable()     exec()         isinstance()   open()         str()\nchr()          filter()       issubclass()   ord()          sum()\nclassmethod()  float()        iter()         pow()          super()\ncompile()      format()       len()          print()        tuple()\ncomplex()      frozenset()    license()      property()     type()",
    "crumbs": [
      "Teor√≠a",
      "U1 - Introducci√≥n a Python",
      "Clase 1"
    ]
  }
]