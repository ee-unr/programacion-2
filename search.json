[
  {
    "objectID": "practica/01_programacion_en_python/problemas.html",
    "href": "practica/01_programacion_en_python/problemas.html",
    "title": "üß© Problemas",
    "section": "",
    "text": "En criptograf√≠a, el cifrado C√©sar es una de las t√©cnicas de cifrado m√°s simples y m√°s usadas.\nEs un tipo de cifrado en el que una letra en el texto original es reemplazada por otra letra que se encuentra un n√∫mero fijo de posiciones m√°s adelante en el alfabeto.\nPor ejemplo, con un desplazamiento de 3, la A ser√≠a sustituida por la D (situada 3 lugares a la derecha de la A), la B ser√≠a reemplazada por la E, etc.\n\n\n\n\n\nEscriba una funci√≥n, y luego un script, que permita cifrar y descifrar cadenas usando el cifrado C√©sar con un n√∫mero arbitrario de posiciones.\nDos funciones incluidas con Python que pueden ser √∫tiles para esta tarea son ord(), que convierte caracteres num√©ricos a n√∫meros, y chr(), que realiza la operaci√≥n inversa.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara el cifrado de un √∫nico caracter:\n\nDefinir un desplazamiento, por ejemplo 3.\nConvertir el caracter a n√∫mero usando ord().\nSumarle desplazamiento.\nFinalmente, convertirlo a caracter nuevamente utilizando chr().\n\nY para el descifrado:\n\nConvertir el caracter a n√∫mero.\nRestarle desplazamiento.\nConvertirlo a caracter nuevamente utilizando chr().\n\nAs√≠, se deber√≠a recuperar el caracter definido al principio.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üß© Problemas"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/problemas.html#cifrado-c√©sar",
    "href": "practica/01_programacion_en_python/problemas.html#cifrado-c√©sar",
    "title": "üß© Problemas",
    "section": "",
    "text": "En criptograf√≠a, el cifrado C√©sar es una de las t√©cnicas de cifrado m√°s simples y m√°s usadas.\nEs un tipo de cifrado en el que una letra en el texto original es reemplazada por otra letra que se encuentra un n√∫mero fijo de posiciones m√°s adelante en el alfabeto.\nPor ejemplo, con un desplazamiento de 3, la A ser√≠a sustituida por la D (situada 3 lugares a la derecha de la A), la B ser√≠a reemplazada por la E, etc.\n\n\n\n\n\nEscriba una funci√≥n, y luego un script, que permita cifrar y descifrar cadenas usando el cifrado C√©sar con un n√∫mero arbitrario de posiciones.\nDos funciones incluidas con Python que pueden ser √∫tiles para esta tarea son ord(), que convierte caracteres num√©ricos a n√∫meros, y chr(), que realiza la operaci√≥n inversa.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara el cifrado de un √∫nico caracter:\n\nDefinir un desplazamiento, por ejemplo 3.\nConvertir el caracter a n√∫mero usando ord().\nSumarle desplazamiento.\nFinalmente, convertirlo a caracter nuevamente utilizando chr().\n\nY para el descifrado:\n\nConvertir el caracter a n√∫mero.\nRestarle desplazamiento.\nConvertirlo a caracter nuevamente utilizando chr().\n\nAs√≠, se deber√≠a recuperar el caracter definido al principio.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üß© Problemas"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/problemas.html#n√∫meros-aleatorios",
    "href": "practica/01_programacion_en_python/problemas.html#n√∫meros-aleatorios",
    "title": "üß© Problemas",
    "section": "2 N√∫meros aleatorios",
    "text": "2 N√∫meros aleatorios\nConstruya un programa en Python que genere una cantidad determinada de n√∫meros aleatorios uniformes dentro de un rango definido por el usuario. El programa debe:\n\nSolicitar al usuario la cantidad de n√∫meros a generar y los valores m√≠nimo y m√°ximo del rango.\nGenerar los n√∫meros aleatorios\nGuardar los n√∫meros en un archivo de texto, uno por l√≠nea.\nOfrecer la opci√≥n de mostrar un resumen estad√≠stico con m√≠nimo, m√°ximo, media y desv√≠o est√°ndar, solo si el usuario lo solicita.\n\nPara resolver este problema utilice el m√≥dulo random y las funciones desarrolladas en el ejercicio Res√∫menes estad√≠sticos guardadas en un m√≥dulo llamado estadistica.py.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üß© Problemas"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/problemas.html#mensaje-al-descubierto",
    "href": "practica/01_programacion_en_python/problemas.html#mensaje-al-descubierto",
    "title": "üß© Problemas",
    "section": "3 Mensaje al descubierto",
    "text": "3 Mensaje al descubierto\nResulta que Franco, un amigo que estudia Ciencias de la Computaci√≥n en la FCEIA, te env√≠a por WhatsApp un archivo de texto plano con mensajes ‚Äúencriptados‚Äù usando caracteres sobrantes y s√≠mbolos extra√±os:\n    !!!,.,  aY??/u/DAM**e,, se =m!!e\n&&M&&e v!o!?LV...I.O /L/*oC/*o\n        __?e_?l//+ T++**e/*Cl!?aD==*O**\nTiene sentido pensar que est√° experimentando con nuevos algoritmos de cifrado y, de paso, te lanza el reto de descifrarlo.\nTu misi√≥n es escribir un programa que:\n\nLea un archivo de texto plano cualquiera.\nMuestre en pantalla su contenido original (tal cual llega).\nAplique un proceso de limpieza basado en las siguientes reglas:\n\nEliminar todos los caracteres +, *, -, /, =, !, ?, & y _.\nReemplazar cualquier secuencia de espacios m√∫ltiples por un solo espacio.\nHomogeinizar la capitalizaci√≥n de los caracteres.\nConservar los saltos de l√≠nea tal cual aparecen en el archivo original.\n\nMuestre en pantalla la versi√≥n desencriptada del texto.\nGuarde la versi√≥n limpia en un nuevo archivo de texto.\n\nEl usuario debe poder especificar el nombre del archivo de salida.\nSi no lo hace, se generar√° uno con el sufijo _limpio antes de la extensi√≥n original (por ejemplo, secreto.txt ‚Üí secreto_limpio.txt).",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üß© Problemas"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/problemas.html#c√≥digo-morse",
    "href": "practica/01_programacion_en_python/problemas.html#c√≥digo-morse",
    "title": "üß© Problemas",
    "section": "4 C√≥digo Morse",
    "text": "4 C√≥digo Morse\nEl c√≥digo Morse es un sistema utilizado para representar letras mediante combinaciones espec√≠ficas de se√±ales cortas y largas, denominadas puntos (.) y rayas (-). A continuaci√≥n se muestra un diccionario con el mapeo de caracteres alfab√©ticos, d√≠gitos del 0 al 9 y algunos s√≠mbolos de puntuaci√≥n comunes:\nmapeo_morse = {\n    \"A\": \".-\",\n    \"B\": \"-...\",\n    \"C\": \"-.-.\",\n    \"D\": \"-..\",\n    \"E\": \".\",\n    \"F\": \"..-.\",\n    \"G\": \"--.\",\n    \"H\": \"....\",\n    \"I\": \"..\",\n    \"J\": \".---\",\n    \"K\": \"-.-\",\n    \"L\": \".-..\",\n    \"M\": \"--\",\n    \"N\": \"-.\",\n    \"O\": \"---\",\n    \"P\": \".--.\",\n    \"Q\": \"--.-\",\n    \"R\": \".-.\",\n    \"S\": \"...\",\n    \"T\": \"-\",\n    \"U\": \"..-\",\n    \"V\": \"...-\",\n    \"W\": \".--\",\n    \"X\": \"-..-\",\n    \"Y\": \"-.--\",\n    \"Z\": \"--..\",\n    \"1\": \".----\",\n    \"2\": \"..---\",\n    \"3\": \"...--\",\n    \"4\": \"....-\",\n    \"5\": \".....\",\n    \"6\": \"-....\",\n    \"7\": \"--...\",\n    \"8\": \"---..\",\n    \"9\": \"----.\",\n    \"0\": \"-----\",\n    \", \": \"--..--\",\n    \".\": \".-.-.-\",\n}\nEscriba una funci√≥n en Python que permita convertir cualquier palabra a c√≥digo Morse utilizando este diccionario. Luego, escriba otra funci√≥n que haga exactamente lo contrario: dada una secuencia en c√≥digo Morse, debe recuperar la palabra original. Finalmente, incorpore ambas funciones en un script principal que combine ambas funciones y permita encriptar o desencriptar texto desde un archivo de texto plano. El programa debe recibir:\n\nEl nombre del archivo de entrada.\nEl nombre del archivo de salida.\nLa operaci√≥n a realizar (encriptar o desencriptar).\n\nAyuda: Para indicar espacios en c√≥digo Morse utilice /.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üß© Problemas"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html",
    "title": "5 - Ejecuci√≥n repetitiva",
    "section": "",
    "text": "Anteriormente aprendimos a crear objetos que contienen otros objetos (listas, tuplas y diccionarios).\nCuando quer√≠amos realizar una acci√≥n con cada uno de los objetos que estos conten√≠an, ten√≠amos que escribir el mismo c√≥digo para acceder a cada uno de ellos de a uno.\nPor ejemplo, supongamos que tenemos un listado con nombres de nuestros amigos y queremos ponerlos a todos en may√∫sculas:\n\nnombres = [\"julieta\", \"facundo\", \"emiliano\", \"lorenzo\", \"victoria\"]\nprint(\"Nombres originales:\")\nprint(nombres)\n\nnombres[0] = nombres[0].upper()\nnombres[1] = nombres[1].upper()\nnombres[2] = nombres[2].upper()\nnombres[3] = nombres[3].upper()\nnombres[4] = nombres[4].upper()\n\nprint(\"\\nNombres modificados:\")\nprint(nombres)\n\nNombres originales:\n['julieta', 'facundo', 'emiliano', 'lorenzo', 'victoria']\n\nNombres modificados:\n['JULIETA', 'FACUNDO', 'EMILIANO', 'LORENZO', 'VICTORIA']\n\n\nVemos que realizamos exactamente la misma acci√≥n con cada nombre en la lista‚Ä¶ ¬øNo estar√≠a bueno poder automatizarlo?\nY para eso, en esta secci√≥n vamos a aprender sobre bucles.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "5 - Ejecuci√≥n repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#introducci√≥n",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#introducci√≥n",
    "title": "5 - Ejecuci√≥n repetitiva",
    "section": "",
    "text": "Anteriormente aprendimos a crear objetos que contienen otros objetos (listas, tuplas y diccionarios).\nCuando quer√≠amos realizar una acci√≥n con cada uno de los objetos que estos conten√≠an, ten√≠amos que escribir el mismo c√≥digo para acceder a cada uno de ellos de a uno.\nPor ejemplo, supongamos que tenemos un listado con nombres de nuestros amigos y queremos ponerlos a todos en may√∫sculas:\n\nnombres = [\"julieta\", \"facundo\", \"emiliano\", \"lorenzo\", \"victoria\"]\nprint(\"Nombres originales:\")\nprint(nombres)\n\nnombres[0] = nombres[0].upper()\nnombres[1] = nombres[1].upper()\nnombres[2] = nombres[2].upper()\nnombres[3] = nombres[3].upper()\nnombres[4] = nombres[4].upper()\n\nprint(\"\\nNombres modificados:\")\nprint(nombres)\n\nNombres originales:\n['julieta', 'facundo', 'emiliano', 'lorenzo', 'victoria']\n\nNombres modificados:\n['JULIETA', 'FACUNDO', 'EMILIANO', 'LORENZO', 'VICTORIA']\n\n\nVemos que realizamos exactamente la misma acci√≥n con cada nombre en la lista‚Ä¶ ¬øNo estar√≠a bueno poder automatizarlo?\nY para eso, en esta secci√≥n vamos a aprender sobre bucles.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "5 - Ejecuci√≥n repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#qu√©-son-los-bucles",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#qu√©-son-los-bucles",
    "title": "5 - Ejecuci√≥n repetitiva",
    "section": "¬øQu√© son los bucles?",
    "text": "¬øQu√© son los bucles?\nLos bucles son una estrcutura de los lenguajes de programaci√≥n que nos permite repetir la ejecuci√≥n de c√≥digo de manera autom√°tica.\nEn otras palabras, los bucles hacen que sea muy f√°cil ejecutar el mismo bloque de c√≥digo una y otra vez.\nA la repetici√≥n del mismo bloque de c√≥digo una y otra vez le decimos iteraci√≥n. Entonces, los bucles nos ayudan a iterar.\nEn Python tenemos dos tipos de bucles:\n\nEl bucle for (for-loop).\nEl bucle while (while-loop).\n\nLa diferencia entre este tipo de bucles es que con el for conocemos la cantidad de iteraciones que vamos a realizar de antemano.\nEn cambio, con el while no conocemos la cantidad de iteraciones que vamos a realizar de antemano.\nVeamos el ejemplo anterior pero utilizando un bucle for. En este caso, generamos una nueva lista llamada nombres_modificados donde vamos a almacenar los nombres modificados.\n\nnombres = [\"julieta\", \"facundo\", \"emiliano\", \"mariana\", \"victoria\"]\nnombres_modificados = []\n\n# Bucle for\nfor nombre in nombres:\n    nombres_modificados.append(nombre.upper())\n\nprint(\"Nombres originales:\")\nprint(nombres)\n\nprint(\"\\nNombres modificados:\")\nprint(nombres_modificados)\n\nNombres originales:\n['julieta', 'facundo', 'emiliano', 'mariana', 'victoria']\n\nNombres modificados:\n['JULIETA', 'FACUNDO', 'EMILIANO', 'MARIANA', 'VICTORIA']",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "5 - Ejecuci√≥n repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#el-bucle-for",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#el-bucle-for",
    "title": "5 - Ejecuci√≥n repetitiva",
    "section": "El bucle for",
    "text": "El bucle for\n\nPresentaci√≥n\nEn un bucle for encontramos los siguientes componentes.\n\nLa palabra clave for\nEl nombre de una variable que se usa para iterar (variable de iteraci√≥n)\nLa palabra clave in\nEl objeto sobre el cual iteramos, seguido por :\nEn la siguiente linea y con indentaci√≥n, el bloque de c√≥digo a ejecutar\n\n\n\n\n\n\nEn Python, al igual que en las sentencias if, else y otras estructuras de control, los dos puntos (:) se utilizan para indicar el comienzo de un bloque de c√≥digo, y la indentaci√≥n define el contenido de ese bloque. Nunca se emplean llaves {} como en otros lenguajes.\nEn el caso de un bucle for, se declara una variable que va tomando, en cada iteraci√≥n, uno de los valores del iterable que se est√° recorriendo. Por ejemplo, si el iterable contiene 10 objetos, el bucle ejecutar√° 10 iteraciones y la variable de iteraci√≥n (por convenci√≥n llamada i, aunque puede tener cualquier nombre) ir√° adoptando esos valores, uno por uno.\n\n\nEjemplos\nDado que a iterar se aprende iterando, veamos algunos ejemplos:\n\nfor i in [3, 1, 2]:\n    print(f\"El n√∫mero es {i}.\")\n\nEl n√∫mero es 3.\nEl n√∫mero es 1.\nEl n√∫mero es 2.\n\n\nTambi√©n podemos ordenar los valores de la lista sobre la que iteramos:\n\nfor i in sorted([3, 1, 2]):\n    print(f\"El n√∫mero es {i}.\")\n\nEl n√∫mero es 1.\nEl n√∫mero es 2.\nEl n√∫mero es 3.\n\n\nPero no es necesario iterar sobre listas. De hecho, podemos iterar sobre cualquier secuencia, por ejemplo, una tupla:\n\nfor i in (3, 1, 2):\n    print(f\"El n√∫mero es {i}.\")\n\nEl n√∫mero es 3.\nEl n√∫mero es 1.\nEl n√∫mero es 2.\n\n\n\nfor i in sorted((3, 1, 2)):\n    print(f\"El n√∫mero es {i}.\")\n\nEl n√∫mero es 1.\nEl n√∫mero es 2.\nEl n√∫mero es 3.\n\n\nE incluso una cadena de caracteres:\n\nfor c in \"Hola Curso\":\n    print(c)\n\nH\no\nl\na\n \nC\nu\nr\ns\no\n\n\n\n\n\n\n\n\nVariable de iteraci√≥n\n\n\n\nEl nombre de la variable que se usa para iterar es arbitrario. Sin embargo, es recomendable no utilizar el mismo nombre que el de otra variable en nuestro programa. Por ejemplo:\ni = 1\nfor i in [1, 2, 3]:\n    print(i)\nprint(i)\n1\n2\n3\n3\nLa variable de iteraci√≥n i va pisando su valor y cualquier valor que esta pudo haber tenido antes.\nAs√≠, luego de la finalizar el bucle, el valor de i es 3.\n\n\nLos bucles permiten generar nuevos objetos de forma autom√°tica.\nEn el siguiente ejemplo, partimos de una lista con cadenas que pueden contener n√∫meros o letras. Mediante un for, crearemos tres listas: una con los n√∫meros, otra con el texto y una tercera con los elementos que no sean ninguno de los dos.\n\nlista_original = [\"1\", \"@\", \"x\", \"y\", \"?\", \"3\", \"4\", \"7\", \"f\", \"l\", \"9\", \"10\", \"!\"]\n\n\n# Crear tres listas vac√≠as (que contienen los diferentes tipos de datos)\nnumeros = []\ntexto = []\notros = []\n\n# Iterar a traves de los valores de la lista original\nfor valor in lista_original:\n    # Si es num√©rico, lo agregamos en la lista 'numeros'\n    if valor.isnumeric():\n        numeros.append(valor)\n    # Sino es num√©rico, pregunto si es alfab√©tico (o una letra del abecedario)\n    elif valor.isalpha():\n        texto.append(valor)\n    # Caso contrario, lo metemos en la lista de otros\n    else:\n        print(f\"La cadena '{valor}' no es ni num√©rica ni alfab√©tica.\")\n        otros.append(valor)\n\nprint(lista_original)\nprint(numeros)\nprint(texto)\nprint(otros)\n\nLa cadena '@' no es ni num√©rica ni alfab√©tica.\nLa cadena '?' no es ni num√©rica ni alfab√©tica.\nLa cadena '!' no es ni num√©rica ni alfab√©tica.\n['1', '@', 'x', 'y', '?', '3', '4', '7', 'f', 'l', '9', '10', '!']\n['1', '3', '4', '7', '9', '10']\n['x', 'y', 'f', 'l']\n['@', '?', '!']\n\n\n\n\nCrear listas num√©ricas con range().\nPython provee una funci√≥n llamada range() que hace que sea muy f√°cil generar una secuencia de n√∫meros. Por ejemplo, podemos usar range() para imprimir una serie de n√∫meros.\n\nfor i in range(1, 5):\n    print(i)\n\n1\n2\n3\n4\n\n\nrange() funciona de manera similar a los slices, es decir, no incluye el l√≠mite superior. Adem√°s, si se usa con un solo argumento, es equivalente a range(0, numero).\n\nfor i in range(5):\n    print(i)\n\n0\n1\n2\n3\n4\n\n\nUna forma √∫til de entender range(n) es verlo como la creaci√≥n de una secuencia con los primeros n n√∫meros, comenzando desde 0.\n\nx = range(5)\nprint(x)\nprint(type(x))\n\nrange(0, 5)\n&lt;class 'range'&gt;\n\n\nPodemos obtener una lista a partir de un range usando la funci√≥n list().\n\nlist(x)\n\n[0, 1, 2, 3, 4]\n\n\nY, por qu√© no, una tupla tambi√©n.\n\ntuple(x)\n\n(0, 1, 2, 3, 4)\n\n\nrange() admite un tercer argumento opcional que especifica el paso entre valores. Por defecto es 1. Veamos algunos ejemplos:\nLista de n√∫meros entre 0 y 10 (no inclusivo), avanzando de a 2 en cada paso.\n\nlist(range(0, 10, 2))\n\n[0, 2, 4, 6, 8]\n\n\nIntento de lista de n√∫meros entre 10 y 0 (no inclusivo).\n\nlist(range(10, 0))\n\n[]\n\n\nVemos que el resultado no es el esperado. Esto se debe a que el paso es por defecto 1 y es imposible recorrer desde el 10 al 0 sumando de a 1. Si cambiamos el paso a -1, funciona correctamente:\n\nlist(range(10, 0, -1))\n\n[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n\n\n\n\n¬øSobre qu√© cosas podemos iterar en un bucle for?\nRecordemos el diagrama que vimos anteriormente‚Ä¶\n\n\n\n\n\nEn naranja tenemos resaltado iterable. Pero, ¬øqu√© significa que un objeto sea iterable?\n\nQue podemos iterar a trav√©s de el.\nQue podemos recorrerlo elemento por elemento.\nQue puede devolver sus elementos de a uno a la vez.\n\nDe manera similar a las secuencias, el t√©rmino iterable describe una categor√≠a de tipos de datos. De hecho, todas las secuencias son iterables (por eso podemos recorrer listas, tuplas y cadenas), pero no es requisito ser una secuencia para ser iterable. Por ejemplo, los diccionarios no son secuencias y, sin embargo, pueden recorrerse porque implementan un m√©todo para entregar sus elementos de uno en uno.\n\nfor i in {\"a\": 1, \"b\": 2}:\n    print(i)\n\na\nb",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "5 - Ejecuci√≥n repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#el-bucle-while",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#el-bucle-while",
    "title": "5 - Ejecuci√≥n repetitiva",
    "section": "El bucle while",
    "text": "El bucle while\nEn un bucle while encontramos los siguientes componentes.\n\nLa palabra clave while.\nUna condici√≥n, es decir, una expresi√≥n que se eval√∫a a True o False, seguido por los dos puntos :.\nEn la siguiente linea y con indentaci√≥n, el bloque de c√≥digo a ejecutar.\n\n\n\n\n\n\n\nnumero = 0\nwhile numero &lt; 5:\n    numero += 1 # Abreviaci√≥n de x = x + 1\n    print(f\"El numero es {numero}\")\n\nEl numero es 1\nEl numero es 2\nEl numero es 3\nEl numero es 4\nEl numero es 5\n\n\n\n\n\n\n\nAnalicemos el diagrama:\n\nMientras numero &lt; 5 sea True, Python ejecutar√° el cuerpo del bucle completo.\nEn la primera iteraci√≥n, numero es 0.\n\nComo 0 es menor a 5, Python imprime el n√∫mero y luego le agrega 1, haciendo que el n√∫mero sea 1.\n\nEn la segunda iteraci√≥n, numero es 1.\n\nComo 1 es menor a 5, Python imprime el n√∫mero y luego le agrega 1, haciendo que el n√∫mero sea 2.\n\n\nEl proceso contin√∫a hasta que numero deja de ser menor que 5, momento en el que el bucle se detiene.\n\n\n\n\n\n\nBucles infinitos ‚ôæÔ∏è\n\n\n\nVeamos el siguiente ejemplo:\nx = 0\nwhile x &lt; 5:\n    print(x)\nSi ejecutamos este c√≥digo, Python nunca detendr√° su ejecuci√≥n. Esto sucede porque el valor de x nunca cambia, por lo que la condici√≥n x &lt; 5 es siempre verdadera. Este es un caso t√≠pico de bucle infinito, algo que puede ocurrir con cualquier while, y en particular con while True si no incluimos una forma de salir del bucle (por ejemplo, con break).\nSi entramos en un bucle infinito, la √∫nica forma de detenerlo es interrumpir la ejecuci√≥n manualmente:\n\nEn la terminal: CTRL + C\nEn un editor de c√≥digo: usar el bot√≥n de interrupci√≥n\n\n\n\n\nLa sentencia break\nPython provee la sentencia break que sirve para terminar un bucle (for o while) de manera anticipada.\nVeamos algunos ejemplos de uso.\n\nwhile True:\n    print(\"¬°Hola!\")\n    break\n\n¬°Hola!\n\n\nEn el ejemplo anterior, la condici√≥n del bucle era True, lo que implicar√≠a una ejecuci√≥n infinita. Sin embargo, al final de la primera iteraci√≥n encontramos un break, que fuerza la salida del bucle. De forma similar, podemos reescribir el primer while utilizando esta estructura alternativa.\n\nnumero = 0\nwhile True:\n    if numero &gt;= 5:\n        break\n    numero += 1\n    print(f\"El numero es {numero}\")\n\nEl numero es 1\nEl numero es 2\nEl numero es 3\nEl numero es 4\nEl numero es 5\n\n\n\nnumero = 0\nwhile True:\n    numero += 1\n    print(f\"El numero es {numero}\")\n    if numero &gt;= 5:\n        break\n\nEl numero es 1\nEl numero es 2\nEl numero es 3\nEl numero es 4\nEl numero es 5\n\n\nSupongamos que queremos sumar los valores de una lista hasta que se cumpla cierta condici√≥n, por ejemplo, que el total sea mayor o igual a 20.\nSi partimos de una lista de n√∫meros cualquiera, no sabemos de antemano cu√°ntos elementos ser√° necesario sumar. Sin embargo, esto no ser√° un problema si utilizamos la estructura while en combinaci√≥n con la sentencia break.\n\nsuma = 0\numbral = 20\nvalores = [3, 5, 4, 4, 5, 5, 3, 5, 2, 7]\n\nwhile valores:\n    suma += valores.pop(0)\n    print(suma)\n    if suma &gt;= umbral:\n        break\n\n3\n8\n12\n16\n21\n\n\n\nvalores # valores que no se sumaron\n\n[5, 3, 5, 2, 7]\n\n\nEn el bloque de c√≥digo anterior puede llamar la atenci√≥n el uso de\nwhile valores:\nEl bucle while valores: se ejecuta mientras la lista tenga elementos. En cada iteraci√≥n, .pop(0) extrae el primer elemento, se suma a suma y se imprime el total acumulado. Si en alg√∫n momento suma alcanza o supera el umbral, se ejecuta break para detener el bucle aunque a√∫n queden elementos en la lista. Si la lista se vac√≠a antes de llegar al umbral, el bucle tambi√©n finaliza autom√°ticamente gracias a la condici√≥n while valores:.\nUn ejemplo m√°s conciso es el siguiente:\n\nif [1, 2, 3]:\n    print(\"Bloque 'if'\")\nelse:\n    print(\"Bloque 'else'\")\n\nBloque 'if'\n\n\n\nif []:\n    print(\"Bloque 'if'\")\nelse:\n    print(\"Bloque 'else'\")\n\nBloque 'else'\n\n\nAhora supongamos que tenemos una lista de n√∫meros aleatorios que representan alg√∫n conteo.\nEstamos interesados en la cantidad de extracciones que se necesitaron hasta que el conteo supere cierto umbral, por ejemplo, 30.\n\nnumeros_aleatorios = [\n    5, 7, 6, 4, 2, 2, 5, 3, 6, 4, 4, 6, 3, 6, 1,\n    3, 3, 1, 9, 5, 5, 6, 5, 1, 7, 3, 3, 1, 3, 4\n]\n\numbral = 30\n\n# Inicializamos suma y cantidad de iteraciones en 0\nsuma = 0\niteraciones = 0\n\n# Mientras la lista no est√© vac√≠a\nwhile numeros_aleatorios:\n    # Agregamos 1 al conteo de iteraciones realizadas\n    iteraciones += 1\n\n    # Extraemos el primer n√∫mero de la lista y lo sumamos a la suma\n    suma += numeros_aleatorios.pop(0)\n\n    # Si la suma es mayor o igual al umbral, dejamos de iterar\n    if suma &gt;= umbral:\n        break\n\nif suma &gt;= umbral:\n    print(f\"Se super√≥ el umbral de {umbral} en la iteraci√≥n {iteraciones}, sumando {suma}.\")\nelse:\n    print(f\"La suma de los elementos de la lista no llega a superar {umbral}\")\n\nSe super√≥ el umbral de 30 en la iteraci√≥n 7, sumando 31.\n\n\n\nSolicitar valores de entrada al usuario\nPython provee una funci√≥n llamada input() que sirve para solicitar al usuario que ingrese un valor.\n\nEl argumento es el mensaje que se mostrar√° en pantalla.\nEl tipo de dato que se devuelve es str.\n\n\nnombre = input(\"Ingresa tu nombre: \")\nprint(f\"El nombre ingresado es '{nombre}'\")\n\nEl nombre ingresado es 'Tomi'\n\n\nEsta funcion combinada con el bucle while nos permite generar programas interactivos que solicitan entrada al usuario hasta que se cumple una condici√≥n. Por ejemplo, supongamos que queremos solicitar una contrase√±a que tenga 8 caracteres o m√°s.\n\nwhile True:\n    pwd = input(\"Ingrese su contrase√±a: \")\n    if len(pwd) &gt;= 8:\n        print(\"¬°Muchas gracias!\")\n        break\n    else:\n        print(f\"La contrase√±a '{pwd}' es corta\")\nprint(f\"La contrase√±a ingresada es '{pwd}'\")\n\nLa contrase√±a '' es corta\nLa contrase√±a 'prueba' es corta\n¬°Muchas gracias!\nLa contrase√±a ingresada es 'prueba 2'\n\n\n\n\n\nLa sentencia continue\nAs√≠ como tenemos la sentencia break que le dice a Python que interrumpa la ejecuci√≥n de un bucle, tenemos la sentencia continue que le dice que pase a la siguiente iteraci√≥n sin ejecutar el c√≥digo a continuaci√≥n de la misma.\nCuando un programa se encuentra con continue se procede a la siguiente iteraci√≥n del bucle, re-evaluando la condici√≥n del while de ser necesario.\nEn el siguiente ejemplo tenemos una lista con n√∫meros del 1 al 10 y queremos sumar solamente los n√∫meros pares.\n\n# Crear lista del 1 al 10\nnumeros = list(range(1, 11))\nprint(numeros)\n\nsuma = 0\nwhile numeros:\n    numero = numeros.pop(0)\n    if numero % 2 != 0:\n        continue\n    suma += numero\n    print(\"Sumando el numero\", numero)\n\nprint(\"La suma es\", suma)\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nSumando el numero 2\nSumando el numero 4\nSumando el numero 6\nSumando el numero 8\nSumando el numero 10\nLa suma es 30\n\n\nEn este programa, si numero % 2 != 0, el continue le indica a Python que debe pasar a la siguiente iteraci√≥n sin evaluar lo que hay debajo. Por lo tanto, cuando el n√∫mero es impar, no se ejecuta ni la suma ni el print.\nEste problema se puede resolver tambi√©n utilizando un bucle for en vez de un bucle while.\n\nnumeros = list(range(1, 11))\nsuma = 0\nfor numero in numeros:\n    if numero % 2 != 0:\n        continue\n    suma += numero\n    print(\"Sumando el numero\", numero)\nprint(\"La suma es\", suma)\n\nSumando el numero 2\nSumando el numero 4\nSumando el numero 6\nSumando el numero 8\nSumando el numero 10\nLa suma es 30",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "5 - Ejecuci√≥n repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#conclusi√≥n",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#conclusi√≥n",
    "title": "5 - Ejecuci√≥n repetitiva",
    "section": "Conclusi√≥n",
    "text": "Conclusi√≥n\nCu√°ndo usar un bucle for.\n\nSabemos exactamente, y de antemano, cuantas veces queremos iterar.\nQueremos iterar a trav√©s de todos los elementos de un objeto determinado.\n\nCu√°ndo usar un bucle while.\n\nNo sabemos exactamente cuantas veces queremos iterar.\nQueremos iterar hasta que se cumpla (o se deje de cumplir) una condici√≥n determinada.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "5 - Ejecuci√≥n repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html",
    "title": "4 - Colecciones de datos",
    "section": "",
    "text": "Adem√°s de los tipos de datos elementales que se presentaron en cap√≠tulos anteriores, Python proporciona estructuras de datos m√°s complejas que permiten almacenar colecciones de objetos. Estas estructuras facilitan la organizaci√≥n de m√∫ltiples valores bajo un mismo nombre, posibilitando, entre otras tareas, su manipulaci√≥n de manera conjunta.\nEn este cap√≠tulo exploraremos tres colecciones b√°sicas de Python:\n\nListas (list)\nTuplas (tuple)\nDiccionarios (dict)\n\nEstas estructuras tienen en com√∫n que permiten agrupar varios objetos, aunque presentan diferencias importantes en cuanto a la sintaxis utilizada para definirlas, su mutabilidad (capacidad de modificarse tras su creaci√≥n) y las operaciones disponibles para manipular sus elementos. En definitiva, cada estructura est√° especialmente dise√±ada para representar relaciones particulares entre los datos, adapt√°ndose as√≠ a diversas situaciones y necesidades de programaci√≥n.\nSupongamos que contamos con el nombre y la edad de 4 personas y queremos utilizar estos datos en nuestro programa. Si solamente tenemos acceso a los tipos de datos elementales de Python, una alternativa para almacenar esta informaci√≥n consiste en crear 4 variables para las edades y 4 variables para los nombres:\n\nnombre_1 = \"Juan\"\nnombre_2 = \"Carla\"\nnombre_3 = \"Evelina\"\nnombre_4 = \"Leandro\"\n\nedad_1 = 29\nedad_2 = 34\nedad_3 = 33\nedad_4 = 38\n\nEn este caso, el c√≥digo es legible e incluso permite intuir la relaci√≥n entre los nombres y las edades.\nSin embargo, vale preguntarse qu√© ocurrir√≠a si quisi√©ramos almacenar la informaci√≥n de muchas m√°s personas. Python nos permitir√≠a crear tantas variables como necesitemos, pero trabajar de esa manera no ser√≠a pr√°ctico ni sostenible.\nPor eso, el lenguaje ofrece estructuras de datos que facilitan el manejo de grandes cantidades de valores del mismo tipo, de forma m√°s organizada y eficiente.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#introducci√≥n",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#introducci√≥n",
    "title": "4 - Colecciones de datos",
    "section": "",
    "text": "Adem√°s de los tipos de datos elementales que se presentaron en cap√≠tulos anteriores, Python proporciona estructuras de datos m√°s complejas que permiten almacenar colecciones de objetos. Estas estructuras facilitan la organizaci√≥n de m√∫ltiples valores bajo un mismo nombre, posibilitando, entre otras tareas, su manipulaci√≥n de manera conjunta.\nEn este cap√≠tulo exploraremos tres colecciones b√°sicas de Python:\n\nListas (list)\nTuplas (tuple)\nDiccionarios (dict)\n\nEstas estructuras tienen en com√∫n que permiten agrupar varios objetos, aunque presentan diferencias importantes en cuanto a la sintaxis utilizada para definirlas, su mutabilidad (capacidad de modificarse tras su creaci√≥n) y las operaciones disponibles para manipular sus elementos. En definitiva, cada estructura est√° especialmente dise√±ada para representar relaciones particulares entre los datos, adapt√°ndose as√≠ a diversas situaciones y necesidades de programaci√≥n.\nSupongamos que contamos con el nombre y la edad de 4 personas y queremos utilizar estos datos en nuestro programa. Si solamente tenemos acceso a los tipos de datos elementales de Python, una alternativa para almacenar esta informaci√≥n consiste en crear 4 variables para las edades y 4 variables para los nombres:\n\nnombre_1 = \"Juan\"\nnombre_2 = \"Carla\"\nnombre_3 = \"Evelina\"\nnombre_4 = \"Leandro\"\n\nedad_1 = 29\nedad_2 = 34\nedad_3 = 33\nedad_4 = 38\n\nEn este caso, el c√≥digo es legible e incluso permite intuir la relaci√≥n entre los nombres y las edades.\nSin embargo, vale preguntarse qu√© ocurrir√≠a si quisi√©ramos almacenar la informaci√≥n de muchas m√°s personas. Python nos permitir√≠a crear tantas variables como necesitemos, pero trabajar de esa manera no ser√≠a pr√°ctico ni sostenible.\nPor eso, el lenguaje ofrece estructuras de datos que facilitan el manejo de grandes cantidades de valores del mismo tipo, de forma m√°s organizada y eficiente.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#listas",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#listas",
    "title": "4 - Colecciones de datos",
    "section": "Listas",
    "text": "Listas\n\nDefinici√≥n\nEl siguiente bloque de c√≥digo genera una lista con los n√∫meros 1, 2, 3, 4 y 5.\n\n[1, 2, 3, 4, 5]\n\n[1, 2, 3, 4, 5]\n\n\nUna lista de Python es una secuencia ordenada de objetos mutable. De manera menos t√©cnica, podemos decir que una lista es un objeto que contiene otros objetos en un orden determinado y cuyo contenido puede modificarse.\nLas listas son una de las estructuras m√°s utilizadas en Python. De hecho, programar en este lenguaje implica trabajar constantemente con listas: crearlas, modificarlas, recorrerlas y transformarlas.\nAs√≠ que si queremos ser buenos Pythonistas, ¬°a aprender de listas!\n\n\nCreaci√≥n de listas\nLas listas en Python se crean escribiendo los elementos entre corchetes ([]), separ√°ndolos con comas.\nCreemos una lista que contenga los nombres de nuestras cafeterias de especialidad preferidas: Orlan, Infinita, Arto, Crist√≥bal, Ruffo y Heroica.\n\ncafeterias = [\"Orlan\", \"Infinita\", \"Arto\", \"Crist√≥bal\", \"Ruffo\", \"Heroica\"]\nprint(cafeterias)\n\n['Orlan', 'Infinita', 'Arto', 'Crist√≥bal', 'Ruffo', 'Heroica']\n\n\nCuando imprimimos una lista, Python muestra una representaci√≥n muy parecida a la que usamos al definirla: con corchetes para encerrar los elementos y comas para separarlos.\nSi consultamos el tipo de una lista, no hay sorpresas: es del tipo list.\n\ntype(cafeterias)\n\nlist\n\n\n\n\nObjetos permitidos en una lista\nEn Python, una lista puede contener objetos de cualquier tipo. Incluso es posible mezclar distintos tipos en una misma lista.\nCon los tipos de datos que vimos hasta ahora, podr√≠amos tener listas con n√∫meros, cadenas de texto, valores booleanos e incluso el valor nulo.\nPor ejemplo, la siguiente lista contiene elementos de cuatro tipos distintos:\n\npopurri = [1, \"dos\", True, None, \"dos\"]\npopurri\n\n[1, 'dos', True, None, 'dos']\n\n\nSi bien las listas pueden mezclar objetos de distinto tipo, y algunas veces hacerlo tiene sentido, en general vamos a trabajar con listas donde todos sus objetos son del mismo tipo.\n\n\nQu√© significa que una lista sea ordenada\nConsideremos las listas [1, 2, 3] y [2, 1, 3]. Vale preguntarse si ambas listas son iguales o no. Veamos que dice Python:\n\n[1, 2, 3] == [2, 1, 3]\n\nFalse\n\n\nDado que una lista es una secuencia en la que el orden de los elementos es relevante, dos listas son iguales solo si contienen los mismos elementos y en el mismo orden. A continuaci√≥n se muestra un ejemplo en el que ambas condiciones se cumplen.\n\n[1, 2, 3] == [1, 2, 3]\n\nTrue\n\n\nTambi√©n vale la pena preguntarse si dos listas iguales son, en memoria, el mismo objeto. Debajo definimos dos listas x e y con los mismos elementos, en el mismo orden. Como es de esperarse, ambas listas son iguales en valor.\n\nx = [\"a\", \"b\", \"c\"]\ny = [\"a\", \"b\", \"c\"]\n\nprint(x == y)\nprint(x is y)\n\nTrue\nFalse\n\n\nSin embargo, estas listas no son iguales en memoria, es decir, no son el mismo objeto.\n\nprint(\"id(x):\", id(x))\nprint(\"id(y):\", id(y))\n\nid(x): 140505658960960\nid(y): 140505658950912\n\n\n\n\n\n\n\n\nConclusi√≥n üìù\n\n\n\nDos listas son iguales (en valor) si en cada posici√≥n contienen elementos que tambi√©n son iguales en valor. Sin embargo, que dos listas sean iguales no implica que sean el mismo objeto en memoria.\n\n\n\n\n\n\n\n\nPara pensar üß†\n\n\n\n¬øCu√°l es el resultado de la siguiente comparaci√≥n?\n[1, 2, 3] == [1.0, 2, 3.0]\n\n\n\n\nAcceder a elementos\nDado que una lista es una secuencia ordenada, cada objeto tiene una posici√≥n determinada. Podemos acceder a cualquiera de los elementos de la lista indicando la posici√≥n del objeto que deseamos. Esta posici√≥n se conoce como √≠ndice (o index, en ingl√©s).\nPara acceder a un elemento de una lista, escribimos el nombre de la lista seguido de la posici√≥n del objeto que queremos seleccionar, encerrada entre corchetes [].\nVeamos un ejemplo utilizando la lista cafeterias que creamos anteriormente.\n\ncafeterias = [\"Orlan\", \"Infinita\", \"Arto\", \"Crist√≥bal\", \"Ruffo\", \"Heroica\"]\ncafeterias\n\n['Orlan', 'Infinita', 'Arto', 'Crist√≥bal', 'Ruffo', 'Heroica']\n\n\nIntentemos seleccionar el primer objeto de la lista:\n\ncafeterias[1]\n\n'Infinita'\n\n\nCuando accedemos a un elemento individual de una lista, el resultado no es, en principio, otra lista, sino el objeto que se encuentra en esa posici√≥n. Ese objeto puede ser de cualquier tipo: un n√∫mero, una cadena de texto, otra lista, etc.\nPor lo tanto, si el elemento obtenido es una cadena de caracteres, podemos aplicar directamente los m√©todos que corresponden a ese tipo de dato. Por ejemplo, podemos encadenar la selecci√≥n del elemento en la posici√≥n 1 con una llamada al m√©todo .upper(), sabiendo que es v√°lido porque ese elemento es de tipo str.\n\ncafeterias[1].upper()\n\n'INFINITA'\n\n\nComo es de esperarse, tambi√©n podemos incluir una operaci√≥n de indexaci√≥n dentro de una f-string.\n\nf\"¬°Qu√© rico que es el caf√© de {cafeterias[1]}!\"\n\n'¬°Qu√© rico que es el caf√© de Infinita!'\n\n\n\n\n\n\n\n\nIndexaci√≥n desde cero 0Ô∏è‚É£\n\n\n\nObservamos que cafeterias[1] devuelve \"Infinita\", que es el elemento de la segunda posici√≥n, y no \"Orlan\", que aparece primero. Este resultado no es un error, sino una consecuencia de que Python usa indexaci√≥n desde cero (zero-based indexing, en ingl√©s). Esto significa que, si una lista contiene 6 elementos, sus posiciones van desde el 0 al 5. En general:\n\nEl primer elemento est√° en la posici√≥n 0.\nEl √∫ltimo elemento est√° en la posici√≥n n - 1.\n\n\n\n\n\n\n\n\n\nMisma sintaxis, significados distintos üé≠\n\n\n\nEn Python, los corchetes no siempre significan lo mismo. Sus dos funciones principales son la creaci√≥n de listas y la indexaci√≥n de secuencias. Un ejemplo curioso que combina ambos usos es el siguiente:\n[0][0]\n0\n\n\nEn el siguiente diagrama se muestra que la variable cafeterias referencia a un objeto de tipo list, que a su vez contiene referencias a distintos objetos de tipo str. Cada uno de estos elementos est√° asociado a un √≠ndice, comenzando desde el 0.\n\n\n\nRepresentaci√≥n gr√°fica de la lista cafeterias en Python.\n\n\n\n√çndices negativos\nPython tambi√©n permite utilizar valores negativos como √≠ndices para seleccionar elemento.\n\nEl √≠ndice -1 indica el √∫ltimo elemento.\nEl √≠ndice -2 indica el pen√∫ltimo elemento.\nY as√≠ sucesivamente.\n\n\ncafeterias[-1]\n\n'Heroica'\n\n\n\ncafeterias[-2]\n\n'Ruffo'\n\n\n\n\n\nRepresentaci√≥n gr√°fica de cafeterias utilizando √≠ndices negativos para cada elemento.\n\n\n\n\n\nAcceder a sub-listas\nHasta ahora vimos que, al usar corchetes con un n√∫mero entero, podemos acceder a un √∫nico elemento de una lista. Si en cambio queremos obtener varios elementos a la vez, necesitamos usar una herramienta llamada slice (o rebanada) que permite seleccionar un subconjunto de elementos de una secuencia.\nLa sintaxis para usar slices es la siguiente:\nlista[inicio:fin]\nEsto crea una nueva lista con los elementos que van desde la posici√≥n inicio hasta la posici√≥n fin, sin incluir esta √∫ltima.\nPor ejemplo:\n\ncafeterias[1:4]\n\n['Infinita', 'Arto', 'Crist√≥bal']\n\n\n\n\n\nSelecci√≥n de sublista de cafeterias usando el slice 1:4.\n\n\nComo los slices incluyen el √≠ndice de inicio pero excluyen el de fin, el siguiente c√≥digo funciona correctamente:\n\ncafeterias[4:6]\n\n['Ruffo', 'Heroica']\n\n\n\n\n\nSelecci√≥n de sublista de cafeterias usando el slice 4:6.\n\n\nEn Python, la sintaxis de los slices permite omitir de forma impl√≠cita los valores de inicio o fin cuando se desea tomar una porci√≥n desde el principio o hasta el final de la lista. Por ejemplo:\n\n:n es equivalente a 0:n y selecciona los primeros n elementos.\nn: es equivalente a n:len(lista) y selecciona desde la posici√≥n n hasta el final.\n\nEstas formas abreviadas hacen el c√≥digo m√°s conciso sin perder claridad. Por ejemplo:\n\ncafeterias[:3]\n\n['Orlan', 'Infinita', 'Arto']\n\n\n\n\n\nSelecci√≥n de sublista de cafeterias hasta el √≠ndice 3 usando el slice de inicio impl√≠cito :3.\n\n\n\ncafeterias[3:]\n\n['Crist√≥bal', 'Ruffo', 'Heroica']\n\n\n\n\n\nSelecci√≥n de sublista de cafeterias desde el √≠ndice 3 usando el slice con fin impl√≠cito 3:.\n\n\n\n\nModificar, agregar y eliminar elementos\nEn general, nuestros programas utilizan las listas como objetos din√°micos, es decir, como estructuras cuyo contenido puede cambiar a lo largo del tiempo mediante la modificaci√≥n, agregaci√≥n o eliminaci√≥n de sus elementos.\nPor ejemplo, supongamos que desarrollamos una p√°gina web que permite el registro de usuarios. En este caso, es natural usar una lista para almacenar los nombres de quienes se registran. A medida que pase el tiempo, se espera que se registren nuevos usuarios, otros se den de baja, o algunos incluso decidan cambiar su nombre. Esto implica realizar operaciones sobre la lista, como agregar, eliminar o modificar sus elementos.\n\nModificar elementos\nPara modificar un elemento se utiliza una sintaxis muy similar a la que utilizamos para acceder a un elemento.\nEscribimos el nombre de la lista seguido del √≠ndice del objeto que queremos modificar y el valor que queremos asignar.\nSupongamos que tenemos una lista con diferentes marcas de caf√©: Puerto Blest, Mart√≠nez y Fuego Tostadores.\n\nmarcas = [\"Puerto Blest\", \"Mart√≠nez\", \"Fuego Tostadores\"]\nmarcas\n\n['Puerto Blest', 'Mart√≠nez', 'Fuego Tostadores']\n\n\n¬øC√≥mo hacemos para cambiar el valor del primer elemento?\n\nmarcas[0] = \"Cabrales\"\nmarcas\n\n['Cabrales', 'Mart√≠nez', 'Fuego Tostadores']\n\n\n\n\n\n\n\n\nUna dosis de precisi√≥n üéØ\n\n\n\nEn esta secci√≥n, cuando hablamos de modificar un elemento, nos referimos a reemplazar el objeto que se encuentra en una posici√≥n determinada de la lista. Observemos el siguiente ejemplo:\ningredientes = [\"azucar\", \"flores\", \"colores\"]\nid_original = id(ingredientes[0])\n\n# \"Modifico\" el primer elemento\ningredientes[0] = \"pimienta\"\nid_nuevo = id(ingredientes[0])\n\nprint(\"ID original:\", id_original)\nprint(\"ID nuevo:\", id_nuevo)\nID original: 139872198862160\nID nuevo: 139872198582832\nEste ejemplo muestra que la operaci√≥n no modific√≥ el objeto que se encontraba originalmente en el √≠ndice 0, sino que lo reemplaz√≥ por uno nuevo.\n\n\n\n\n\n\n\n\n\n\n\n\n\n¬°Atenci√≥n! ü§ì\n\n\n\nEl ejemplo del bloque anterior demuestra que la sintaxis lista[indice] = objeto reemplaza el objeto que se encuentra en una determinada posici√≥n, en vez de modificarlo. Sin embargo, vale la pena destacar que s√≠ es posible modificar un elemento de una lista. Para ello, es necesario que el elemento sea un objeto mutable.\n\n\n\n\nAgregar elementos\nSupongamos que queremos construir una lista con los nombres de las ciudades que forman parte del Gran Rosario. Para ello, vamos a utilizar el siguiente mapa como referencia. A medida que identifiquemos las distintas localidades, las vamos a ir incorporando a una lista de Python.\nAgregar elementos a una lista es una tarea com√∫n en programaci√≥n, y Python nos ofrece varias formas de hacerlo. En esta secci√≥n vamos a explorar algunos de estos m√©todos, entendiendo en qu√© se diferencian y cu√°ndo conviene utilizar cada uno.\n\n\n\nMapa ilustrado del Gran Rosario.\n\n\nPrimero vamos a armar una lista que contenga los vecinos de Rosario, considerando solo aquellas localidades que limitan con la ciudad.\nSupongamos que empezamos con una lista que contiene √∫nicamente a la localidad de Funes. A partir de ah√≠, iremos agregando otras localidades vecinas utilizando distintos m√©todos que ofrece Python.\n\nvecinos_de_rosario = [\"Funes\"]\nvecinos_de_rosario\n\n['Funes']\n\n\n\nAgregar elementos al final de la lista\nLa manera m√°s sencilla de agregar un nuevo elemento a una lista es utilizando el m√©todo .append().\nEste m√©todo recibe un √∫nico elemento como argumento y lo agrega al final de la lista.\n\nvecinos_de_rosario.append(\"Soldini\")\n\nLa llamada a este m√©todo parece no devolver ning√∫n resultado. Observemos la lista nuevamente:\n\nvecinos_de_rosario\n\n['Funes', 'Soldini']\n\n\nEl m√©todo .append() agreg√≥ \"Soldini\" al final de la lista sin retornar ning√∫n valor. En lugar de crear una nueva lista, modific√≥ directamente la que referencia nuestra variable vecinos_de_rosario. En otras palabras, el m√©todo .append() no crea una nueva lista, sino que modifica directamente la lista existente.\nVeamos el siguiente ejemplo:\n\nvecinos_de_rosario = []\nprint(\"ID:\", id(vecinos_de_rosario))\nprint(vecinos_de_rosario, \"\\n\")\n\nvecinos_de_rosario.append(\"Funes\")\nprint(\"ID:\", id(vecinos_de_rosario))\nprint(vecinos_de_rosario, \"\\n\")\n\nvecinos_de_rosario.append(\"Soldini\")\nprint(\"ID:\", id(vecinos_de_rosario))\nprint(vecinos_de_rosario)\n\nID: 140505659726976\n[] \n\nID: 140505659726976\n['Funes'] \n\nID: 140505659726976\n['Funes', 'Soldini']\n\n\nComo se puede observar, Python oper√≥ siempre sobre la misma lista. Esto se debe a que el m√©todo .append() modifica la lista existente, en lugar de crear una nueva en cada paso.\n\n\nInsertar elementos en cualquier posici√≥n de una lista\nPara insertar elementos en una lista tambi√©n podemos utilizar el m√©todo .insert().\n¬øCu√°l es la diferencia entre .append() e .insert()?\n\n.append() agrega el nuevo elemento al final de la lista.\n.insert() permite insertar un elemento en cualquier posici√≥n, indicando el √≠ndice donde queremos ubicarlo.\n\nPor ejemplo, si queremos insertar \"Villa Gobernador G√°lvez\" al principio de la lista, podemos hacerlo con .insert(0, \"Villa Gobernador G√°lvez\").\n\nvecinos_de_rosario.insert(0, \"Villa Gobernador G√°lvez\")\nvecinos_de_rosario\n\n['Villa Gobernador G√°lvez', 'Funes', 'Soldini']\n\n\nEl m√©todo .insert() agreg√≥ a \"Villa Gobernador G√°lvez\" en el inicio de la lista y corri√≥ o traslad√≥ al resto de los elementos hacia la derecha.\nY si ahora queremos agregar a \"P√©rez\" en la tercera posici√≥n de la lista, simplemente:\n\nvecinos_de_rosario.insert(2, \"P√©rez\")\nvecinos_de_rosario\n\n['Villa Gobernador G√°lvez', 'Funes', 'P√©rez', 'Soldini']\n\n\nAl igual que .append(), .insert() tambi√©n modifica la lista existente en vez de devolver una lista nueva.\n\n\n\n\n\n\n¬øQu√© significa in-place? ü§î\n\n\n\nQue una operaci√≥n sea in-place significa que la operaci√≥n modifica directamente el objeto original, sin crear uno nuevo. Por ejemplo, objetos.append(e) agrega el elemento e a la lista existente objetos en lugar de crear y devolver una lista nueva.\n\n\n\n\n\nCombinar listas\nEn la secci√≥n anterior vimos c√≥mo insertar elementos individuales en una lista. Ahora vamos a explorar otra operaci√≥n muy com√∫n: combinar listas.\nSupongamos que ya tenemos una lista llamada vecinos_de_rosario, y otra llamada vecinos_al_norte. Queremos unir ambas listas para tener toda la informaci√≥n en una sola. Para lograrlo, una opci√≥n es usar el m√©todo .extend(), que nos permite agregar todos los elementos de una lista al final de otra, modificando directamente la lista original.\n\nprint(vecinos_de_rosario)\n\n['Villa Gobernador G√°lvez', 'Funes', 'P√©rez', 'Soldini']\n\n\n\nvecinos_al_norte = [\"Granadero Baigorria\", \"Ibarlucea\"]\n\nvecinos_de_rosario.extend(vecinos_al_norte)\nvecinos_de_rosario\n\n['Villa Gobernador G√°lvez',\n 'Funes',\n 'P√©rez',\n 'Soldini',\n 'Granadero Baigorria',\n 'Ibarlucea']\n\n\nDe la misma manera que .append() agrega un elemento al final de una lista, el m√©todo .extend() permite agregar todos los elementos de otra lista al final.\nOtra forma de combinar listas es utilizando el operador de suma +, que realiza una concatenaci√≥n de listas. A diferencia de .extend(), este operador no modifica las listas originales, sino que devuelve una nueva lista con los elementos de las dos listas originales concatenados en una nueva.\nPara ver c√≥mo funciona, primero vamos a construir una lista llamada otras_localidades, que contiene localidades del Gran Rosario que no est√°n pegadas a Rosario. Luego, vamos a concatenar esa lista a la que ya tenemos.\n\notras_localidades = [\n    \"Puerto San Mart√≠n\",\n    \"San Lorenzo\",\n    \"Fray Luis Beltr√°n\",\n    \"Capit√°n Bermudez\",\n    \"Ricardone\",\n    \"Rold√°n\",\n    \"Alvear\",\n    \"Pueblo Esther\",\n    \"General Lagos\",\n    \"Arroyo Seco\"\n]\n\nPrimero, observemos los IDs de las listas que vamos a combinar:\n\nprint(id(vecinos_de_rosario))\nprint(id(otras_localidades))\n\n140505659726976\n140505659122496\n\n\nY concatenemos ambas listas utilizando el operador de suma:\n\nvecinos_de_rosario + otras_localidades\n\n['Villa Gobernador G√°lvez',\n 'Funes',\n 'P√©rez',\n 'Soldini',\n 'Granadero Baigorria',\n 'Ibarlucea',\n 'Puerto San Mart√≠n',\n 'San Lorenzo',\n 'Fray Luis Beltr√°n',\n 'Capit√°n Bermudez',\n 'Ricardone',\n 'Rold√°n',\n 'Alvear',\n 'Pueblo Esther',\n 'General Lagos',\n 'Arroyo Seco']\n\n\nPodemos notar que la operaci√≥n s√≠ retorna una lista como resultado, la cual podr√≠amos guardar en una nueva variable.\n\ngran_rosario = vecinos_de_rosario + otras_localidades\ngran_rosario\n\n['Villa Gobernador G√°lvez',\n 'Funes',\n 'P√©rez',\n 'Soldini',\n 'Granadero Baigorria',\n 'Ibarlucea',\n 'Puerto San Mart√≠n',\n 'San Lorenzo',\n 'Fray Luis Beltr√°n',\n 'Capit√°n Bermudez',\n 'Ricardone',\n 'Rold√°n',\n 'Alvear',\n 'Pueblo Esther',\n 'General Lagos',\n 'Arroyo Seco']\n\n\nY finalmente, se puede ver que las listas originales no se han modificado y que gran_rosario referencia una lista nueva.\n\nprint(id(vecinos_de_rosario))\nprint(vecinos_de_rosario, \"\\n\")\n\nprint(id(otras_localidades))\nprint(otras_localidades, \"\\n\")\n\nprint(id(gran_rosario))\nprint(gran_rosario, \"\\n\")\n\n140505659726976\n['Villa Gobernador G√°lvez', 'Funes', 'P√©rez', 'Soldini', 'Granadero Baigorria', 'Ibarlucea'] \n\n140505659122496\n['Puerto San Mart√≠n', 'San Lorenzo', 'Fray Luis Beltr√°n', 'Capit√°n Bermudez', 'Ricardone', 'Rold√°n', 'Alvear', 'Pueblo Esther', 'General Lagos', 'Arroyo Seco'] \n\n140505659128256\n['Villa Gobernador G√°lvez', 'Funes', 'P√©rez', 'Soldini', 'Granadero Baigorria', 'Ibarlucea', 'Puerto San Mart√≠n', 'San Lorenzo', 'Fray Luis Beltr√°n', 'Capit√°n Bermudez', 'Ricardone', 'Rold√°n', 'Alvear', 'Pueblo Esther', 'General Lagos', 'Arroyo Seco'] \n\n\n\n\n\nEliminar elementos\nAs√≠ como es com√∫n agregar elementos a una lista o combinar listas para crear nuevas, tambi√©n lo es eliminar elementos.\nPor ejemplo, si en una p√°gina web guardamos los nombres de los usuarios en una lista, y uno de ellos se da de baja, necesitaremos eliminar su nombre de esa lista.\nPara ilustrarlo, vamos a crear una lista de usuarios ficticios:\n\nusuarios = [\"cyberwolf\", \"neo_404\", \"pixelbyte\", \"alphaX\", \"quantum.dev\"]\nusuarios\n\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX', 'quantum.dev']\n\n\n\nEliminar elementos utilizando del\nLa sentencia del, que ya usamos para eliminar variables, tambi√©n puede usarse para eliminar elementos de una lista.\nPara hacerlo, necesitamos conocer la posici√≥n del elemento que queremos eliminar.\nPor ejemplo, si queremos eliminar a \"neo_404\", que est√° en la segunda posici√≥n, podemos hacerlo con:\n\nprint(usuarios)\n\ndel usuarios[-1]\n\nprint(usuarios)\n\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX', 'quantum.dev']\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX']\n\n\n\n\nEliminar elementos con .pop()\nSi bien la sentencia del permite eliminar elementos de una lista, no nos da acceso al elemento eliminado.\nSin embargo, en muchos casos queremos extraer un elemento de una lista para utilizarlo en otra parte de nuestro programa. Por ejemplo, si tenemos una lista de usuarios, tal vez nos interesa guardar el nombre del usuario que se elimina en otra lista que registre los usuarios dados de baja.\nPara eso podemos usar el m√©todo .pop(), que elimina un elemento de la lista y, al mismo tiempo, lo devuelve.\n\nusuarios = [\"cyberwolf\", \"neo_404\", \"pixelbyte\", \"alphaX\", \"quantum.dev\"]\nusuario_eliminado = usuarios.pop(2)\n\nprint(usuarios) # \"pixelbyte\" es 'extraido'\nprint(usuario_eliminado)\n\n['cyberwolf', 'neo_404', 'alphaX', 'quantum.dev']\npixelbyte\n\n\nEn resumen, usuarios.pop(2) busca el valor en la tercera posici√≥n, lo extrae de la lista y lo devuelve.\nTambi√©n es posible usar .pop() sin indicar una posici√≥n. En ese caso, extrae el √∫ltimo elemento de la lista por defecto.\n\nusuarios = [\"cyberwolf\", \"neo_404\", \"pixelbyte\", \"alphaX\", \"quantum.dev\"]\nprint(usuarios, \"\\n\")\n\nusuario_eliminado = usuarios.pop()\nprint(usuario_eliminado)\nprint(usuarios, \"\\n\")\n\nusuario_eliminado = usuarios.pop()\nprint(usuario_eliminado)\nprint(usuarios)\n\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX', 'quantum.dev'] \n\nquantum.dev\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX'] \n\nalphaX\n['cyberwolf', 'neo_404', 'pixelbyte']\n\n\nY podr√≠amos continuar as√≠ hasta vaciar la lista.\n\n\nEliminar elementos con .remove()\nEl m√©todo .remove() es √∫til para cuando queremos eliminar elementos de una lista a partir de su valor, en lugar de su posici√≥n. Por ejemplo:\n\nusuarios = [\"cyberwolf\", \"neo_404\", \"pixelbyte\", \"alphaX\", \"quantum.dev\"]\nprint(usuarios)\n\nusuarios.remove(\"cyberwolf\")\nprint(usuarios)\n\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX', 'quantum.dev']\n['neo_404', 'pixelbyte', 'alphaX', 'quantum.dev']\n\n\nAl igual que del, remove no devuelve el valor que se remueve.\n\n\n\n\n\n\nResumen üìå\n\n\n\n\n\n\n\n\n\n\n\n\nHerramienta\nQu√© hace\nC√≥mo se usa\nDevuelve\n\n\n\n\ndel\nElimina un elemento por √≠ndice o un segmento por slicing\ndel lista[i]  del lista[i:j]\nNada\n\n\n.pop()\nElimina un elemento por √≠ndice (por defecto el √∫ltimo)\nlista.pop(i)  lista.pop()\nEl elemento eliminado\n\n\n.remove()\nElimina la primera ocurrencia de un valor dado\nlista.remove(valor)\nNada\n\n\n\n\n\n\n\n\n\nFunciones y m√©todos √∫tiles\n\nOrdenamiento\nEs com√∫n que las listas se creen sin seguir un orden particular. Sin embargo, en algunas situaciones puede ser importante conservar el orden en que se agregaron los elementos, mientras que en otras puede resultar √∫til trabajar con los datos ordenados, por ejemplo, para facilitar su presentaci√≥n.\nEn Python existen al menos dos formas de obtener listas ordenadas.\n\nEl m√©todo .sort()\nPara ordenar una lista de manera sencilla, podemos usar el m√©todo .sort(). Veamos un par de ejemplos para entender c√≥mo funciona.\n\nproductos = [\"Fanta\", \"Coca Cola\", \"Sprite\"]\nproductos.sort()\nprint(productos)\n\n['Coca Cola', 'Fanta', 'Sprite']\n\n\n\nprecios = [100, 110, 80.0, 70]\nprecios.sort()\nprint(precios)\n\n[70, 80.0, 100, 110]\n\n\nPodemos concluir que el m√©todo .sort() realiza un ordenamiento permanente, ya que modifica directamente la lista sobre la que se aplica y no devuelve una nueva. Esto significa que, una vez ejecutado, no es posible recuperar la lista original a menos que la hayamos guardado previamente.\nPor defecto, el ordenamiento se hace de menor a mayor: en el caso de cadenas de texto, se compara caracter por caracter, y en el caso de n√∫meros, se ordenan a partir de su valor.\n¬øC√≥mo hacemos para ordenar de manera decreciente?\nEl m√©todo .sort() tiene un argumento llamado reverse. Si este valor es igual a True, se ordenan los elementos de mayor a menor.\n\nproductos = [\"Fanta\", \"Coca Cola\", \"Sprite\"]\nproductos.sort(reverse=True)\nprint(productos)\n\n['Sprite', 'Fanta', 'Coca Cola']\n\n\n\nprecios = [100, 110, 80, 70]\nprecios.sort(reverse=True)\nprint(precios)\n\n[110, 100, 80, 70]\n\n\n\n\nLa funci√≥n sorted()\nAl igual que el m√©todo .sort(), la funci√≥n sorted() permite ordenar una lista. La diferencia principal es que sorted() no modifica la lista original, sino que devuelve una nueva lista ordenada. Esto resulta √∫til cuando queremos conservar tanto el orden original como una versi√≥n ordenada de la misma lista.\nVeamos algunos ejemplos breves:\n\njuegos = [\"Counter Strike\", \"The Sims\", \"Age of Empires II\", \"League of Legends\", \"Among Us\"]\njuegos_ordenados = sorted(juegos)\n\nprint(\"Esta es la lista original:\")\nprint(juegos, \"\\n\")\n\nprint(\"Esta es la lista ordenada:\")\nprint(juegos_ordenados)\n\nEsta es la lista original:\n['Counter Strike', 'The Sims', 'Age of Empires II', 'League of Legends', 'Among Us'] \n\nEsta es la lista ordenada:\n['Age of Empires II', 'Among Us', 'Counter Strike', 'League of Legends', 'The Sims']\n\n\n\nprint(\"id(juegos):\".ljust(22), id(juegos))\nprint(\"id(juegos_ordenados):\".ljust(22), id(juegos_ordenados))\n\nid(juegos):            140506030874432\nid(juegos_ordenados):  140505657073920\n\n\nAl igual que .sort(), sorted() tambi√©n tiene un argumento que determina el orden:\n\nsorted(juegos, reverse=True)\n\n['The Sims',\n 'League of Legends',\n 'Counter Strike',\n 'Among Us',\n 'Age of Empires II']\n\n\n\n\n\nInvertir el orden con .reverse()\nHasta ahora vimos c√≥mo ordenar listas de menor a mayor y de mayor a menor.\nOtra operaci√≥n com√∫n es invertir el orden de los elementos, y para eso podemos usar el m√©todo .reverse().\nAl igual que .sort(), esta operaci√≥n modifica la lista original de forma permanente.\n\nproductos = [\"Fanta\", \"Coca Cola\", \"Sprite\"]\nproductos.reverse()\nprint(productos)\n\n['Sprite', 'Coca Cola', 'Fanta']\n\n\nSi nos arrepentimos de haber invertido el orden, podemos usar .reverse() nuevamente y recuperamos el orden original.\n\nproductos.reverse()\nprint(productos)\n\n['Fanta', 'Coca Cola', 'Sprite']\n\n\n\n\n\n\n\n\n¬øY la funci√≥n reversed()? ü§î\n\n\n\nAs√≠ como tenemos .sort() y sorted(), uno podr√≠a preguntarse si existe un reversed() que complemente .reverse().\nLa respuesta es s√≠, reversed() existe. Sin embargo, su resultado no es una lista, sino un tipo de objeto que a√∫n no hemos explorado.\nSin embargo, lo vamos a ver m√°s adelante üòä\n\n\n\n\nCantidad de elementos\nPara saber cuantos elementos hay en una lista utilizamos la funci√≥n len().\nPor ejemplo, para obtener la cantidad de usuarios de manera program√°tica:\n\nusuarios = [\"cyberwolf\", \"neo_404\", \"pixelbyte\", \"alphaX\", \"quantum.dev\"]\nprint(usuarios)\nlen(usuarios)\n\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX', 'quantum.dev']\n\n\n5\n\n\nY para obtener la cantidad de ciudades del Gran Rosario (aunque falte una üòâ):\n\nprint(gran_rosario)\nlen(gran_rosario)\n\n['Villa Gobernador G√°lvez', 'Funes', 'P√©rez', 'Soldini', 'Granadero Baigorria', 'Ibarlucea', 'Puerto San Mart√≠n', 'San Lorenzo', 'Fray Luis Beltr√°n', 'Capit√°n Bermudez', 'Ricardone', 'Rold√°n', 'Alvear', 'Pueblo Esther', 'General Lagos', 'Arroyo Seco']\n\n\n16\n\n\n\n\nExistencia de elemento\nPara evaluar si un determinado elemento se encuentra en una lista utilizamos el operador in.\n\nnuevo_usuario = \"pepito\"\nnuevo_usuario in usuarios\n\nFalse\n\n\nQue correctamente indica que \"pepito\" no est√° en nuestra base de usuarios. Por otro lado,\n\n\"cyberwolf\" in usuarios\n\nTrue\n\n\n¬øY c√≥mo preguntar si alg√∫n elemento no est√° dentro de la lista? Para eso, utilizamos el operador not in.\n\n\"Col√≥n\" not in gran_rosario\n\nTrue\n\n\nLa respuesta es True porque efectivamente \"Col√≥n\" no pertenece al Gran Rosario.\nEste es uno de los tantos ejemplos donde Python se parece mucho mas al lenguaje humano que al lenguaje de las computadoras.\n\n\nPosici√≥n de un elemento\nSi queremos conocer la posici√≥n de un elemento en la lista podemos utilizar el m√©todo .index(). Por ejemplo:\n\nvocales = [\"a\", \"e\", \"i\", \"o\", \"u\"]\nvocales\n\n['a', 'e', 'i', 'o', 'u']\n\n\n\nvocales.index(\"i\")\n\n2\n\n\nAl igual que .remove(), el m√©todo .index() act√∫a sobre el primer elemento de la lista que coincide con el valor indicado. Es decir, si hay m√∫ltiples apariciones del mismo valor, solo se considera la primera.\n\n[\"a\", \"a\", \"a\"].index(\"a\")\n\n0\n\n\nEl resultado es 0 porque esa es la primera posici√≥n en la que aparece \"a\" en la lista. Sin embargo, esto no quiere decir que \"a\" aparezca una sola vez; simplemente indica la ubicaci√≥n de su primera ocurrencia.\n\n\nFrecuencia de un elemento\nSi queremos saber cu√°ntas veces aparece un elemento en una lista, podemos usar el m√©todo .count(). Este m√©todo devuelve la cantidad de ocurrencias del valor indicado dentro de la lista.\n\n[\"a\", \"a\", \"a\"].count(\"a\")\n\n3\n\n\n\n[\"a\", \"a\", \"a\"].count(\"b\")\n\n0\n\n\n\n\nEstad√≠sticas b√°sicas\nPython ofrece funciones que nos permiten calcular f√°cilmente algunas estad√≠sticas b√°sicas o medidas resumen, como el m√≠nimo, el m√°ximo y la suma de los elementos de una lista.\nSe destacan:\n\nmin(), que devuelve el valor m√≠nimo\nmax(), que devuelve el valor m√°ximo\nsum(), que devuelve la suma total\n\nVeamos algunos ejemplos:\n\nnumeros = [3, 7.5, 12, 1.2, 9, 4.8, 6, 15.3, 2.1, 8]\nnumeros\n\n[3, 7.5, 12, 1.2, 9, 4.8, 6, 15.3, 2.1, 8]\n\n\n\nprint(\"Valor m√≠nimo:\", min(numeros))\nprint(\"Valor m√°ximo:\", max(numeros))\nprint(\"Suma de valores:\", sum(numeros))\n\nValor m√≠nimo: 1.2\nValor m√°ximo: 15.3\nSuma de valores: 68.9\n\n\n\n\n\nResumen de m√©todos in-place\n\n\n\n\n\n\n\nM√©todo\nDescripci√≥n\n\n\n\n\n.append(x)\nInserta el valor x al final de la lista\n\n\n.pop(i)\nRemueve y devuelve el elemento en la posici√≥n i\n\n\n.insert(i, x)\nInserta el valor x en la posici√≥n i\n\n\n.extend(iterable)\nInserta todos los valores de iterable al final de la lista\n\n\n.index(x)\nDevuelve el la posici√≥n donde x aparece por primera vez en la lista\n\n\n.count(x)\nDevuelve la cantidad de veces que aparece x en la lista\n\n\n.sort()\nOrdena los elementos de la lista, de menor a mayor\n\n\n.reverse()\nInvierte el orden de los elementos en la lista",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#tuplas",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#tuplas",
    "title": "4 - Colecciones de datos",
    "section": "Tuplas",
    "text": "Tuplas\n\nDefinici√≥n\nEl siguiente bloque de c√≥digo genera una tupla con los n√∫meros 1, 2, 3, 4 y 5.\n\n(1, 2, 3, 4, 5)\n\n(1, 2, 3, 4, 5)\n\n\nUna tupla es una secuencia ordenada de objetos inmutable. Al igual que las listas, permite almacenar m√∫ltiples elementos de cualquier tipo y acceder a ellos por posici√≥n. Muchas de las operaciones que usamos con listas tambi√©n funcionan con tuplas. La diferencia clave es que las listas son mutables (se pueden modificar), mientras que las tuplas son inmutables (no se pueden cambiar una vez creadas).\nLas tuplas suelen utilizarse para representar registros o estructuras simples. En general, las tuplas se utilizan para representar:\n\nUna colecci√≥n fija de valores posibles para un cierto atributo (e.g., Identificaciones v√°lidas), o\nLos distintos atributos de un objeto. En este caso, cada tupla es como un registro de una base de datos (e.g., Baraja espa√±ola).\n\n\n\nEjemplos\n\nIdentificaciones v√°lidas\nSupongamos que trabajamos en un aeropuerto internacional y estamos implementando un programa de autenticaci√≥n de personas. Para ello, necesitamos definir los tipos de identificaci√≥n que se aceptan. Por ejemplo: LE, LC, DNI, CUIT, CUIL y Pasaporte.\nComo esperamos que estos tipos no vayan a cambiar con el tiempo (¬°al menos mientras corre nuestro programa!), tiene sentido utilizar una tupla (inmutable) en vez de una lista (mutable).\n\ntipos_identificacion = (\"LE\", \"LC\", \"DNI\", \"CUIT\", \"CUIL\", \"Pasaporte\")\ntipos_identificacion\n\n('LE', 'LC', 'DNI', 'CUIT', 'CUIL', 'Pasaporte')\n\n\n\ntype(tipos_identificacion)\n\ntuple\n\n\nAl igual que con las listas, podemos utilizar los √≠ndices para acceder a los elementos de la tupla:\n\nprint(tipos_identificacion[0])\nprint(tipos_identificacion[-1])\n\nLE\nPasaporte\n\n\nAl contrario de lo que sucede con las listas, no es posible modificar ninguno de sus elementos existentes:\n\ntipos_identificacion[0] = \"NUEVO_TIPO\"\n\n\n---------------------------------------------------------------------------\n\nTypeError                                 Traceback (most recent call last)\n\nCell In[65], line 1\n\n----&gt; 1 tipos_identificacion[0] = \"NUEVO_TIPO\"\n\n\n\nTypeError: 'tuple' object does not support item assignment\n\n\n\nSin embargo, si necesitamos combinar una o m√°s tuplas en otra tupla, sigue siendo posible utilizar el operador de suma (+) para concatenar tuplas y as√≠ crear una nueva, con sus elementos concatenados.\n\ntupla_nueva = tipos_identificacion + (\"NT1\", \"NT2\")\ntupla_nueva\n\n('LE', 'LC', 'DNI', 'CUIT', 'CUIL', 'Pasaporte', 'NT1', 'NT2')\n\n\n\nprint(\"id(tipos_identificacion):\", id(tipos_identificacion))\nprint(\"id(tupla_nueva):\".ljust(25), id(tupla_nueva))\n\nid(tipos_identificacion): 140506105340224\nid(tupla_nueva):          140505653700160\n\n\nAs√≠, se genera una nueva tupla mientras que la original se mantiene intacta.\n\n\nBaraja espa√±ola\nSupongamos que queremos desarrollar un software para jugar al truco en l√≠nea con nuestros amigos. Tarde o temprano, vamos a necesitar una forma de representar las cartas de la baraja espa√±ola.\nEsta baraja est√° compuesta por 40 cartas, divididas en 4 palos: oros, copas, espadas y bastos. Cada palo incluye las siguientes cartas: 1, 2, 3, 4, 5, 6, 7, 10, 11 y 12.\nUna forma simple y efectiva de representar esta baraja en Python es utilizando una lista de tuplas: la lista representa el mazo completo, y cada tupla representa una carta individual. Cada tupla tiene dos elementos: el palo y el valor. Es decir, cada carta se representa as√≠:\n(palo, valor)\nPor ejemplo: (\"espadas\", 7) representa el 7 de espadas.\n\nbaraja = [\n    (\"oros\", 1), (\"oros\", 2), (\"oros\", 3), (\"oros\", 4), (\"oros\", 5),\n    (\"oros\", 6),  (\"oros\", 7), (\"oros\", 10), (\"oros\", 11), (\"oros\", 12),\n    (\"copas\", 1), (\"copas\", 2), (\"copas\", 3), (\"copas\", 4), (\"copas\", 5),\n    (\"copas\", 6), (\"copas\", 7), (\"copas\", 10), (\"copas\", 11), (\"copas\", 12),\n    (\"espadas\", 1), (\"espadas\", 2), (\"espadas\", 3), (\"espadas\", 4), (\"espadas\", 5),\n    (\"espadas\", 6), (\"espadas\", 7), (\"espadas\", 10), (\"espadas\", 11), (\"espadas\", 12),\n    (\"bastos\", 1), (\"bastos\", 2), (\"bastos\", 3), (\"bastos\", 4), (\"bastos\", 5),\n    (\"bastos\", 6), (\"bastos\", 7), (\"bastos\", 10), (\"bastos\", 11), (\"bastos\", 12)\n]\n\nDe este modo, cada tupla representa una carta y resalta su caracter√≠stica de inmutable.\n\n\n\nCu√°ndo usar tuplas\nSi las tuplas se parecen tanto a las listas, ¬øpara qu√© existen?\nLas tuplas son apropiadas cuando se necesita una colecci√≥n inmutable, es decir, una secuencia que no debe cambiar ni en contenido ni en tama√±o. Esto evita modificaciones accidentales y, adem√°s, es m√°s eficiente en memoria que una lista.\nAunque suelen usarse con datos heterog√©neos, el criterio m√°s importante es la inmutabilidad. Si la colecci√≥n va a cambiar, no corresponde usar una tupla, independientemente del tipo de datos que esta contenga.\nFinalmente, aunque usar una lista en lugar de una tupla no afecte significativamente el rendimiento de un programa particular, elegir la estructura adecuada mejora la legibilidad: una tupla deja en claro que esa secuencia no se modifica en ning√∫n momento.\n\n\nDiferencias entre listas y tuplas\nC√≥mo las creamos:\n\nPara crear listas usamos [].\nPara crear tuplas usamos () (no es del todo cierto, ver Definici√≥n de tuplas üîç).\n\nComportamiento ‚Äúdin√°mico‚Äù vs ‚Äúest√°tico‚Äù:\n\nEl tama√±o de las listas puede ser modificado luego de ser creado (din√°mico).\nEl tama√±o de las tuplas no puede ser modificado luego de ser creado (est√°tico).\n\nObjetos ‚Äúmutables‚Äù vs ‚Äúinmutables‚Äù:\n\nLos elementos de la lista se pueden modificar luego de ser creada (mutable).\nLos elementos de una tupla no se pueden modificar (inmutable).\n\nM√°s all√° de sus diferencias, las listas y las tuplas tienen muchas similitudes:\n\nSon secuencias ordenadas.\nPueden contener objetos de distintos tipos al mismo tiempo.\nPermiten acceder a los elementos mediante su √≠ndice.\nAdmiten operaciones de slicing para obtener subconjuntos.\n\n\n\n\n\n\n\nDefinici√≥n de tuplas üîç\n\n\n\nHasta ahora dijimos que las tuplas se crean utilizando par√©ntesis y separando los elementos con comas. Pero eso no es del todo cierto.\nEn realidad, los par√©ntesis no son necesarios para definir una tupla. Lo que define a una tupla en Python es la coma, no los par√©ntesis. Por ejemplo:\nt = 10, 25.0, 50\nprint(t)\nprint(type(t))\n(10, 25.0, 50)\n&lt;class 'tuple'&gt;\nLos par√©ntesis en Python se usan principalmente para agrupar expresiones y modificar el orden de evaluaci√≥n, pero no son lo que convierte una serie de valores en una tupla. Si pens√°ramos a los par√©ntesis como una funci√≥n, simplemente devuelven el mismo objeto que encierran.\nDicho esto, el uso de par√©ntesis es una convenci√≥n ampliamente aceptada a la hora de definir tuplas. De hecho, por m√°s que los par√©ntesis no sean necesarios para su definici√≥n, Python siempre muestra a las tuplas entre par√©ntesis.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#diccionarios",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#diccionarios",
    "title": "4 - Colecciones de datos",
    "section": "Diccionarios",
    "text": "Diccionarios\nEn el ejemplo al inicio de este apunte presentamos el siguiente bloque de c√≥digo:\nnombre_1 = \"Juan\"\nnombre_2 = \"Carla\"\nnombre_3 = \"Evelina\"\nnombre_4 = \"Leandro\"\n\nedad_1 = 29\nedad_2 = 34\nedad_3 = 33\nedad_4 = 38\nA simple vista, se pudo concluir que exist√≠a una relaci√≥n entre los nombres y las edades. Por ejemplo, pudimos deducir que la edad de Juan es de 29 a√±os.\nCon las herramientas adquiridas en este apunte podr√≠amos representar esta informaci√≥n de las siguientes dos maneras:\n\nnombres = [\"Juan\", \"Carla\", \"Evelina\", \"Leandro\"]\nedades = [29, 34, 33, 38]\n\nAs√≠, el elemento ubicado en la posici√≥n i-√©sima de la lista nombres se corresponde con el elemento de la misma posici√≥n en la lista edades.\nEn principio, este enfoque resuelve el problema de tener que crear una variable distinta para cada valor. Sin embargo, mantener dos colecciones mutables e independientes en sincron√≠a puede convertirse en un verdadero dolor de cabeza. De hecho, podemos estar casi seguros de que, tarde o temprano, esa sincron√≠a se va a romper.\nOtra alternativa es la siguiente:\n\npersonas = [(\"Juan\", 29), (\"Carla\", 34), (\"Evelina\", 33), (\"Leandro\", 38)]\n\nAhora, contamos con un √∫nico objeto de Python que re√∫ne toda la informaci√≥n de las personas. En esta lista de tuplas, cada tupla representa a una persona: el primer elemento es su nombre y el segundo, su edad. Una de las ventajas de este enfoque es que permite agregar o quitar registros sin preocuparse por mantener la sincronizaci√≥n entre distintas colecciones.\nSin embargo, existe otra estructura de datos que puede resultar a√∫n m√°s adecuada para este escenario: el diccionario.\nLos diccionarios son estructuras que establecen un mapeo (del ingl√©s, mapping) o relaci√≥n entre dos conjuntos de elementos: claves y valores (keys y values en Python). En nuestro caso, podemos crear un diccionario donde las claves sean los nombres y los valores, las edades.\nEn Python, los diccionarios se definen entre llaves ({}). Dentro de ellas, cada elemento se escribe como un par clave: valor, separado por comas para distinguirlo de los dem√°s.\n\npersonas = {\"Juan\": 29, \"Carla\": 34, \"Evelina\": 33, \"Leandro\": 38}\npersonas\n\n{'Juan': 29, 'Carla': 34, 'Evelina': 33, 'Leandro': 38}\n\n\n\ntype(dict)\n\ntype\n\n\n\nlen(personas)\n\n4\n\n\nPodemos usar este ejemplo para destacar algunos puntos clave sobre los diccionarios:\n\nLa longitud de un diccionario corresponde a la cantidad de pares clave: valor que contiene, no a la suma de la cantidad de claves y valores.\nAunque es com√∫n usar cadenas de texto como claves, no es obligatorio: cualquier objeto que sea hashable puede ser una clave (lo veremos m√°s adelante).\nLos valores pueden ser de cualquier tipo de objeto en Python.\nLas claves deben ser √∫nicas, pero los valores pueden repetirse.\n\nPor √∫ltimo, veremos con un ejemplo que, aunque desde Python 3.7 los diccionarios mantienen un orden, este no es relevante al compararlos.\n\nd1 = {\"nombre\": \"Juan\", \"apellido\": \"P√©rez\"}\nd2 = {\"apellido\": \"P√©rez\", \"nombre\": \"Juan\"}\n\nprint(d1)\nprint(d2)\nprint(d1 == d2)\n\n{'nombre': 'Juan', 'apellido': 'P√©rez'}\n{'apellido': 'P√©rez', 'nombre': 'Juan'}\nTrue\n\n\nAunque d1 y d2 tengan las claves en distinto orden, para Python son diccionarios equivalentes; lo que importa no es el orden de los elementos en los diccionarios, sino los pares clave: valor que contienen.\n\n\n\n\n\n\n¬øPor qu√© se llaman diccionarios? ü§î\n\n\n\nEl nombre proviene de la idea de que en un diccionario real, uno busca la definici√≥n de una palabra (su valor) a partir de la palabra misma (la clave).\n\n\n\nAcceder a los elementos\nA diferencia de las listas y las tuplas, que son objetos donde el orden importa y se puede acceder a sus elementos por posici√≥n, los diccionarios no utilizan posiciones: en ellos, el acceso a los elementos se realiza mediante sus claves. Por ejemplo, si queremos acceder a la edad de Juan utilizando el √≠ndice 0, vamos a obtener un error:\n\npersonas[0]\n\n\n---------------------------------------------------------------------------\n\nKeyError                                  Traceback (most recent call last)\n\nCell In[75], line 1\n\n----&gt; 1 personas[0]\n\n\n\nKeyError: 0\n\n\n\nEn cambio, si usamos la clave \"Juan\", que es lo que corresponde:\n\npersonas[\"Juan\"]\n\n29\n\n\n\n\nVerificar la existencia de un elemento\nLos operadores in y not in permiten determinar si un diccionario contiene a un elemento con una determinada clave.\n\nd = {\"color\": \"azul\", \"forma\": \"cuadrado\"}\n\n\"color\" in d\n\nTrue\n\n\n\n\"area\" in d\n\nFalse\n\n\n\n\"area\" not in d\n\nTrue\n\n\n\n\"azul\" in d\n\nFalse\n\n\nAunque \"azul\" aparece como valor de uno de los elementos del diccionario d, \"azul\" in d retorna False porque no hay ninguna clave que sea \"azul\".\n\n\nAcceder a claves y valores\nEs posible acceder solo a las claves:\n\nd = {\"color\": \"azul\", \"forma\": \"cuadrado\"}\nd.keys()\n\ndict_keys(['color', 'forma'])\n\n\nO a los valores:\n\nd.values()\n\ndict_values(['azul', 'cuadrado'])\n\n\nO a las claves y los valores:\n\nd.items()\n\ndict_items([('color', 'azul'), ('forma', 'cuadrado')])\n\n\nEn todos los casos se obtiene una estructura de datos especial: dict_keys, dict_values o dict_items. No profundizaremos en ellas, ya que rara vez es necesario interactuar directamente con estos objetos. En la pr√°ctica, lo relevante es que permiten iterar sobre sus elementos y convertirse f√°cilmente a tipos m√°s comunes, como las listas.\n\n\nModificar, agregar y eliminar elementos\nLos diccionarios son objetos mutables, lo que significa que podemos modificar, agregar o eliminar elementos. Su funcionamiento es muy similar al de las listas. La diferencia m√°s notable es que, en vez de usar √≠ndices, se usan claves.\n\nModificar elementos\nAl igual que en una lista, podemos modificar un elemento seleccion√°ndolo y asign√°ndole un nuevo valor.\n\npersonas\n\n{'Juan': 29, 'Carla': 34, 'Evelina': 33, 'Leandro': 38}\n\n\n\npersonas[\"Juan\"] = 54\n\n\npersonas\n\n{'Juan': 54, 'Carla': 34, 'Evelina': 33, 'Leandro': 38}\n\n\n\n\nAgregar elementos\nPara agregar un elemento, se utiliza la misma sintaxis que para modificar uno: se asigna un valor a una nueva clave en el diccionario.\n\npersonas[\"Marisa\"] = 29\n\nEn resumen, al asignar un valor a una clave, Python primero verifica si existe: si la encuentra, reemplaza su valor; si no, agrega un nuevo par clave-valor.\n\n\nEliminar elementos\nEn un diccionario, es posible eliminar elementos de distintas maneras. Las m√°s comunes son:\n\nLa sentencia del.\nEl m√©todo .pop().\n\nLa sentencia del elimina un elemento asociado a una clave sin devolver su valor, por lo que no puede usarse posteriormente.\nPor ejemplo:\n\ndescuentos = {\n    \"Lunes\": 0,\n    \"Martes\": 20,\n    \"Miercoles\": 10,\n    \"Jueves\": 20,\n    \"Viernes\": 30,\n    \"S√°bado\": 30,\n    \"Domingo\": 0\n}\ndescuentos\n\n{'Lunes': 0,\n 'Martes': 20,\n 'Miercoles': 10,\n 'Jueves': 20,\n 'Viernes': 30,\n 'S√°bado': 30,\n 'Domingo': 0}\n\n\n\ndel descuentos[\"Domingo\"]\ndescuentos\n\n{'Lunes': 0,\n 'Martes': 20,\n 'Miercoles': 10,\n 'Jueves': 20,\n 'Viernes': 30,\n 'S√°bado': 30}\n\n\nEs como si el elemento \"Domingo\": 0 se hubiera esfumado.\nEn cambio, el m√©todo .pop() extrae el valor del diccionario y lo devuelve, lo que permite almacenarlo o utilizarlo m√°s adelante en el programa.\n\ndescuento_lunes = descuentos.pop(\"Lunes\")\nprint(descuento_lunes)\nprint(descuentos)\n\n0\n{'Martes': 20, 'Miercoles': 10, 'Jueves': 20, 'Viernes': 30, 'S√°bado': 30}\n\n\n\n\nActualizar diccionarios\nLos diccionarios tienen acceso a un m√©todo .update() que permiten actualizar un diccionaroio a partir de otro diccionario. Supongamos que tenemos un diccionario con informaci√≥n relacionada a una persona y otro diccionario con informaci√≥n actualizada de esa persona.\n\ndatos = {\"nombre\": \"Guillermina\", \"ciudad\": \"Rosario\", \"estado civil\": \"soltera\"}\ndatos_nuevos = {\"ciudad\": \"Rold√°n\", \"estado civil\": \"casada\", \"hijos\": 2}\n\nSe puede actualizar el contenido del diccionario datos con el contenido del diccionario datos_nuevos de la sigiuente manera:\n\ndatos.update(datos_nuevos)\ndatos\n\n{'nombre': 'Guillermina',\n 'ciudad': 'Rold√°n',\n 'estado civil': 'casada',\n 'hijos': 2}\n\n\nEste m√©todo modifica el diccionario datos in-place.\nSi se quiere realizar la operaci√≥n sin alterar el diccionario original, se puede usar el operador pipe (|), que devuelve un nuevo diccionario.\n\nd1 = {\"a\": 1, \"b\": 2}\nd2 = {\"b\": 10, \"c\": 25}\nd3 = d1 | d2\n\nprint(d1)\nprint(d2)\nprint(d3)\n\n{'a': 1, 'b': 2}\n{'b': 10, 'c': 25}\n{'a': 1, 'b': 10, 'c': 25}\n\n\nPor √∫ltimo, vale la pena notar que al actualizar un diccionario podemos modificar elementos existentes o agregar otros nuevos.\n\n\n\nEstructuras anidadas\nAnteriormente mencionamos que los diccionarios pueden contener cualquier tipo de objeto de Python. Por lo tanto, significa que puede contener n√∫meros, cadenas, listas‚Ä¶ ¬°e incluso otros diccionarios!\nVeamos un ejemplo donde esta idea resulta √∫til. Supongamos que queremos representar la informaci√≥n de una persona llamada Julia, que tiene 33 a√±os y realiz√≥ tres cursos de Python: Introducci√≥n a Python, An√°lisis de datos con Python y Python avanzado. El tipo de dato para el nombre y la edad es evidente: str e int, respectivamente. En cambio, para los cursos necesitamos una colecci√≥n de valores, ya que no se trata de un √∫nico elemento. As√≠, podemos crear el siguiente diccionario:\n\npersona = {\n    \"nombre\": \"Julia\",\n    \"edad\": 33,\n    \"cursos\": [\"Introducci√≥n a Python\", \"An√°lisis de datos con Python\", \"Python avanzado\"]\n}\n\nprint(persona)\n\n{'nombre': 'Julia', 'edad': 33, 'cursos': ['Introducci√≥n a Python', 'An√°lisis de datos con Python', 'Python avanzado']}\n\n\n\nprint(f\"Nombre: {persona['nombre']}\")\nprint(f\"Edad: {persona['edad']}\")\nprint(f\"Cursos: {persona['cursos']}\")\n\nNombre: Julia\nEdad: 33\nCursos: ['Introducci√≥n a Python', 'An√°lisis de datos con Python', 'Python avanzado']\n\n\nTambi√©n es posible representar estructuras de datos m√°s complejas, como registros. En el siguiente ejemplo, el diccionario usuarios tiene como valores otros diccionarios. Las claves de usuarios corresponden a nombres de usuario (por ejemplo, \"aeinstein\"), mientras que los valores son diccionarios que almacenan atributos de ese usuario, como su nombre, apellido y ciudad de residencia.\n\nusuarios = {\n    \"aeinstein\": {\n        \"nombre\": \"albert\",\n        \"apellido\": \"einstein\",\n        \"ciudad\": \"princenton\"\n    },\n    \"mcurie\": {\n        \"nombre\": \"marie\",\n        \"apellido\": \"curie\",\n        \"ciudad\": \"paris\"\n    },\n    \"afleming\": {\n        \"nombre\": \"alexander\",\n        \"apellido\": \"fleming\",\n        \"ciudad\": \"londres\"\n    }\n}\n\nPara acceder a un elemento dentro de un diccionario anidado, se encadenan los accesos usando [] tantas veces como sea necesario: primero para obtener el diccionario interno y luego para acceder a la clave deseada dentro de √©l.\n\nprint(usuarios[\"aeinstein\"])\nprint(usuarios[\"aeinstein\"][\"ciudad\"])\n\n{'nombre': 'albert', 'apellido': 'einstein', 'ciudad': 'princenton'}\nprincenton\n\n\n\nusuario = \"aeinstein\"\ndatos = usuarios[usuario]\nf\"El usuario '{usuario}' se llama {datos['nombre'].capitalize()} {datos['apellido'].capitalize()}.\"\n\n\"El usuario 'aeinstein' se llama Albert Einstein.\"",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#secuencias",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#secuencias",
    "title": "4 - Colecciones de datos",
    "section": "Secuencias",
    "text": "Secuencias\nLos tres tipos de datos que presentamos en este apunte pertenecen a la categor√≠a de las colecciones, ya que permiten almacenar una colecci√≥n o conjunto de objetos.\nOtra categor√≠a muy interesante de tipos de datos son las secuencias.\nUna secuencia es una estructura de datos que contiene elementos organizados en orden, y se puede acceder a cada elemento mediante un √≠ndice entero que representa su posici√≥n en la secuencia. Por lo tanto, las listas y las tuplas son ejemplos de secuencias; los diccionarios, en cambio, no lo son.\nAunque pueda parecer sorprendente al principio, las cadenas de texto tambi√©n son secuencias.\nVale la pena destacar a las secuencias, ya que todos los tipos de datos que abarca comparten un conjunto com√∫n de operaciones, que se resumen en la siguiente tabla:\n\n\n\n\n\n\n\n\nOperaci√≥n\nResultado\nComentarios\n\n\n\n\ne in s\nIndica si el valor e se encuentra en s\n¬†\n\n\ne not in s\nIndica si el valor e no se encuentra en s\n¬†\n\n\ns + t\nConcatena las secuencias s y t\n¬†\n\n\ns * n\nConcatena n copias de s\n¬†\n\n\ns[i]\nObtiene el elemento i de s\n¬†\n\n\ns[i:j]\nPorci√≥n de la secuencia s desde i hasta j (no inclusive)\n¬†\n\n\ns[i:j:k]\nPorci√≥n de la secuencia s desde i hasta j (no inclusive), con paso k\n¬†\n\n\nlen(s)\nCantidad de elementos en la secuencia s\n¬†\n\n\nmin(s)\nM√≠nimo elemento en la secuencia s\nRequiere elementos comparables\n\n\nmax(s)\nM√°ximo elemento de la secuencia s\nRequiere elementos comparables\n\n\nsum(s)\nSuma de los elementos de la secuencia s\nNo aplica a str\n\n\nsorted(s)\nOrdena los elementos de la secuencia s y los devuelve en una lista\nRequiere elementos comparables\n\n\nenumerate(s)\nIterador sobre los elementos de s junto con sus posiciones\nPermite iterar con (√≠ndice, valor)\n\n\nreversed(s)\nIterador inverso sobre los elementos de s\n¬†\n\n\nall(s)\nIndica si bool(e) es True para todos los elementos de s\n¬†\n\n\nany(s)\nIndica si bool(e) es True para al menos un elementos de s\n¬†\n\n\ns.index(e)\nPosici√≥n del elemento e en la secuencia s\n¬†\n\n\ns.count(e)\nCantidad de veces que el elemento e aparece la secuencia s\n¬†\n\n\n\nPor ejemplo:\n\ntexto = \"Esto es un texto cualquiera\"\notro = \"y esto es otro texto\"\nprint(\"texto[0]:\", texto[0])\n\ntexto[0]: E\n\n\n\nprint(\"texto[-1]:\", texto[-1])\n\ntexto[-1]: a\n\n\n\nprint(\"texto[0:3]:\", texto[0:3])\n\ntexto[0:3]: Est\n\n\n\nprint(\"texto[0:10:2]:\", texto[0:20:2])\n\ntexto[0:10:2]: Et su et u\n\n\n\nprint(\"texto + otro:\", texto + otro)\n\ntexto + otro: Esto es un texto cualquieray esto es otro texto\n\n\n\nprint(\"texto * 2:\", texto * 2)\n\ntexto * 2: Esto es un texto cualquieraEsto es un texto cualquiera\n\n\n\nprint(\"len(texto):\", len(texto))\n\nlen(texto): 27\n\n\n\nprint(\"sorted(texto):\", sorted(texto))\n\nsorted(texto): [' ', ' ', ' ', ' ', 'E', 'a', 'a', 'c', 'e', 'e', 'e', 'i', 'l', 'n', 'o', 'o', 'q', 'r', 's', 's', 't', 't', 't', 'u', 'u', 'u', 'x']\n\n\nAdem√°s, es posible crear una secuencia (o colecci√≥n) a partir de otra secuencia (o colecci√≥n) utilizando el tipo de dato como constructor. Por ejemplo:\n\nlist(\"texto\")\n\n['t', 'e', 'x', 't', 'o']\n\n\n\ntuple(\"texto\")\n\n('t', 'e', 'x', 't', 'o')\n\n\n\nlist((1, 2, 3, 4))\n\n[1, 2, 3, 4]\n\n\nSin embargo, el resultado puede no ser de lo m√°s intuitivo incialmente:\n\nstr([\"1\", \"2\", \"3\"]) # ¬°Notar que no concatena los elementos!\n\n\"['1', '2', '3']\"\n\n\n\nlist({\"a\": 1, \"b\": 2}) # Crea una lista a partir de las claves\n\n['a', 'b']\n\n\n\nlist({\"a\": 1, \"b\": 2}.values()) # Es posible crear una lista a partir de los valores\n\n[1, 2]\n\n\nSi intentamos crear un diccionario a partir de una lista (o tupla) ‚Äúplana‚Äù, obtendremos un error, ya que no hay una forma clara de identificar las claves y los valores.\n\ndict([1, 2, 3])\n\n\n---------------------------------------------------------------------------\n\nTypeError                                 Traceback (most recent call last)\n\nCell In[113], line 1\n\n----&gt; 1 dict([1, 2, 3])\n\n\n\nTypeError: cannot convert dictionary update sequence element #0 to a sequence\n\n\n\nEn cambio, si usamos una lista (o tupla) compuesta por listas (o tuplas) de longitud 2, la conversi√≥n es posible:\n\ndict([[\"x\", 1], [\"y\", 2]])\n\n{'x': 1, 'y': 2}\n\n\n\ndict([(\"A\", \"aaa\"), (\"B\", \"bbb\")])\n\n{'A': 'aaa', 'B': 'bbb'}",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#resumen-1",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#resumen-1",
    "title": "4 - Colecciones de datos",
    "section": "Resumen",
    "text": "Resumen\n\nLista (list)\n\nSintaxis: [a, b, c]\nEs mutable\nTiene orden\nSe accede a los elementos por √≠ndice\nEs secuencia\nAdmite cualquier objeto\n\nTupla (tuple)\n\nSintaxis: (a, b, c) o a, b, c\nEs inmutable\nTiene orden\nSe accede a los elementos por √≠ndice\nEs secuencia\nAdmite cualquier objeto\n\nDiccionario (dict)\n\nSintaxis: {clave: valor, ...}\nEs mutable\nTiene orden, pero no importa para evaluar igualdad\nSe accede a los elementos por clave\nNo es secuencia\nLas claves admiten objetos hashable, los valores pueden ser cualquier objeto\n\nCadena (str)\n\nSintaxis: \"texto\" o 'texto'\nEs inmutable\nTiene orden\nSe accede a los elementos por √≠ndice\nEs secuencia\nSolo admite caracteres",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "informacion/calendario.html",
    "href": "informacion/calendario.html",
    "title": "Calendario",
    "section": "",
    "text": "Semana\nFecha\nTemas\nOtras actividades\n\n\n\n\n1\n4 de agosto\n‚Ä¢ Lenguaje Python y su ecosistema.‚Ä¢ Uso de Python en la terminal.‚Ä¢ Uso de Positron.‚Ä¢ Python en Positron.‚Ä¢ Python: expresiones; variables y asignaciones; tipos de datos elementales; operadores num√©ricos, de comparaci√≥n y l√≥gicos.‚Ä¢ Jupyter Notebooks.‚Ä¢ Definici√≥n de funciones.‚Ä¢ Ejecuci√≥n condicional de c√≥digo.\n\n\n\n2\n11 de agosto\n‚Ä¢ Bucles definidos y no definidos: for, while, break, continue.‚Ä¢ Estructuras de datos nativas de Python: list, tuple, set y dict.‚Ä¢ Complemento: str, bytes, bytearray y range.\n\n\n\n3\n17 de agosto\n‚Ä¢ Uso de c√≥digo externo (propio y de terceros).‚Ä¢ M√≥dulos y librer√≠as.‚Ä¢ Librer√≠a est√°ndar de Python.‚Ä¢ Instalaci√≥n y gesti√≥n de librer√≠as.‚Ä¢ Scripting.‚Ä¢ Lectura y escritura de archivos de texto plano.‚Ä¢ Modularizaci√≥n de programas.\n\n\n\n4\n25 de agosto\n‚Ä¢ Funciones como ciudadanos de primera clase.‚Ä¢ Funciones puras.‚Ä¢ Funciones an√≥nimas.‚Ä¢ Closures.‚Ä¢ Recursi√≥n.\n\n\n\n5\n1 de septiembre\n‚Ä¢ Funciones de orden superior: map, filter, reduce.‚Ä¢ Evaluaci√≥n estricta y no estricta.‚Ä¢ Evaluaci√≥n perezosa (lazy) e inmediata (eager).‚Ä¢ Generadores.‚Ä¢ Aplicaci√≥n parcial de funciones.‚Ä¢ Decoradores.\n\n\n\n6\n15 de septiembre\n‚Ä¢ Objetos, clases e instancias.‚Ä¢ Atributos y m√©todos.‚Ä¢ Propiedades p√∫blicas y privadas.‚Ä¢ M√©todos de clase y m√©todos de instancia.\n\n\n\n7\n22 de septiembre\n‚Ä¢ Encapsulamiento.‚Ä¢ Herencia simple y m√∫ltiple.‚Ä¢ Polimorfismo.‚Ä¢ Abstracci√≥n.\n\n\n\n8\n29 de septiembre\n‚Ä¢ M√©todos especiales (dunder methods).‚Ä¢ Decoradores aplicados a m√©todos.‚Ä¢ Sobrecarga de operadores.\nParcial\n\n\n9\n6 de octubre\n‚Ä¢ Concepto y clasificaci√≥n.‚Ä¢ Estructuras lineales y no lineales.‚Ä¢ Listas y listas enlazadas.‚Ä¢ Operaciones b√°sicas: agregar, quitar y recorrer.\nPresentaci√≥n TP Grupal\n\n\n10\n13 de octubre\n‚Ä¢ Hashing.‚Ä¢ Diccionarios y conjuntos como estructuras asociativas.‚Ä¢ √Årboles y grafos.\nRecuperatorio\n\n\n11\n20 de octubre\n‚Ä¢ Arreglos multidimensionales de NumPy.\n\n\n\n12\n27 de octubre\n‚Ä¢ Concepto de algoritmo y complejidad.‚Ä¢ Algoritmos de b√∫squeda.‚Ä¢ B√∫squeda lineal y binaria.‚Ä¢ Notaci√≥n Big O.\nEntrega TP Grupal\n\n\n13\n3 de noviembre\n‚Ä¢ Algoritmos de ordenamiento.‚Ä¢ bubble sort, insert sort, select sort, quick sort y merge sort.‚Ä¢ Comparaci√≥n de algoritmos de ordenamiento.\nPresentaci√≥n TP Individual\n\n\n14\n10 de noviembre\n‚Ä¢ Funciones de b√∫squeda y ordenamiento en Python.\n\n\n\n15\n17 de noviembre\n\n\n\n\n16\n24 de noviembre\n\nEntrega y defensa TP Individual",
    "crumbs": [
      "Informaci√≥n",
      "Calendario"
    ]
  },
  {
    "objectID": "informacion/bibliografia.html",
    "href": "informacion/bibliografia.html",
    "title": "Bibliograf√≠a",
    "section": "",
    "text": "Principal\n\nCormen et¬†al. (2022) Downey (2024) Kalb (2022) Kubica (2022) Lott y Phillips (2021) Lott (2022) Mertz (2015) Miller, Ranum, y Yasinovskyy (2023) Sedgewick y Wayne (2011) Sedgewick, Wayne, y Dondero (2015) Sweigart (2020) Tuckfield (2021)\n\n\n\nCormen, Thomas H., Charles E. Leiserson, Ronald L. Rivest, y Clifford Stein. 2022. Introduction to Algorithms. 4th ed. MIT.\n\n\nDowney, Allen B. 2024. Think Python. 3.¬™ ed. O‚ÄôReilly Media. https://allendowney.github.io/ThinkPython/.\n\n\nKalb, Irv. 2022. Object-Oriented Python. No Starch Press.\n\n\nKubica, Jacek. 2022. Data Structures the Fun Way. 1st ed. No Starch Press.\n\n\nLott, Steven F. 2022. Functional Python Programming. 3rd ed. Packt Publishing.\n\n\nLott, Steven F., y Dusty Phillips. 2021. Python Object-Oriented Programming. 4th ed. Packt Publishing.\n\n\nMertz, David. 2015. Functional Programming in Python. O‚ÄôReilly Media.\n\n\nMiller, Bradley, David Ranum, y Jan Yasinovskyy. 2023. Problem Solving with Algorithms and Data Structures Using Python. 3rd ed. Franklin, Beedle & Associates.\n\n\nSedgewick, Robert, y Kevin Wayne. 2011. Algorithms. 4th ed. Addison-Wesley Professional.\n\n\nSedgewick, Robert, Kevin Wayne, y Robert Dondero. 2015. Introduction to Programming in Python. Addison-Wesley Professional.\n\n\nSweigart, Al. 2020. Beyond the Basic Stuff with Python. No Starch Press. https://inventwithpython.com/beyond/.\n\n\nTuckfield, Bradford. 2021. Dive Into Algorithms. No Starch Press.\n\n\n\n\nComplementaria\n\nHetland (2014) Mailund (2023) Sweigart (2021) Vaughan (2019) Wickham (2019)\n\n\n\n\n\nHetland, Magnus Lie. 2014. Python Algorithms. 2.¬™ ed. Apress.\n\n\nMailund, Thomas. 2023. Functional Programming in R 4. 2.¬™ ed. Apress.\n\n\nSweigart, Al. 2021. The Big Book of Small Python Projects. No Starch Press. https://inventwithpython.com/bigbookpython/.\n\n\nVaughan, Lee. 2019. Impractical Python Projects. No Starch Press.\n\n\nWickham, Hadley. 2019. Advanced R. 2.¬™ ed. Chapman & Hall/CRC. https://adv-r.hadley.nz/.",
    "crumbs": [
      "Informaci√≥n",
      "Bibliograf√≠a"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programaci√≥n II",
    "section": "",
    "text": "Programaci√≥n II\n\n\n ¬† Ciclo de Formaci√≥n T√©cnica - Estad√≠stica y Ciencia de Datos\n ¬† Facultad de Ciencias Econ√≥micas y Estad√≠stica (UNR)\n ¬† 2¬∞ Cuatrimestre 2025"
  },
  {
    "objectID": "index.html#docentes",
    "href": "index.html#docentes",
    "title": "Programaci√≥n II",
    "section": "Docentes",
    "text": "Docentes\n\n\nTom√°s Capretto\n\n ¬† tomas.capretto@fcecon.unr.edu.ar \n\n\n\nLuciano Anselmino\n\n ¬† luciano.anselmino@fcecon.unr.edu.ar \n\n\n\nJoaqu√≠n Bermejo\n\n ¬† joaquin.bermejo@fcecon.unr.edu.ar \n\n\n\nDolores Sollberger\n\n ¬† dolores.sollberger@fcecon.unr.edu.ar"
  },
  {
    "objectID": "trabajos_practicos/trabajo_individual.html",
    "href": "trabajos_practicos/trabajo_individual.html",
    "title": "Trabajo Pr√°ctico Final",
    "section": "",
    "text": "Trabajo Pr√°ctico Final",
    "crumbs": [
      "Trabajos Pr√°cticos",
      "Trabajo Pr√°ctico Final"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html",
    "href": "trabajos_practicos/trabajo_grupal.html",
    "title": "Trabajo Pr√°ctico",
    "section": "",
    "text": "Trabajo Pr√°ctico",
    "crumbs": [
      "Trabajos Pr√°cticos",
      "Trabajo Pr√°ctico"
    ]
  },
  {
    "objectID": "trabajos_practicos/descripcion.html",
    "href": "trabajos_practicos/descripcion.html",
    "title": "Descripci√≥n",
    "section": "",
    "text": "Ac√° explicamos las pautas para los TP.",
    "crumbs": [
      "Trabajos Pr√°cticos",
      "Descripci√≥n"
    ]
  },
  {
    "objectID": "informacion/aprobacion.html",
    "href": "informacion/aprobacion.html",
    "title": "Condiciones de aprobaci√≥n",
    "section": "",
    "text": "üìù Examen parcial: individual y escrito. Hay un recuperatorio, de similares caracter√≠sticas, que reemplaza la nota del parcial.\nü§ù Trabajo pr√°ctico grupal: se hace fuera de clase, en grupos de entre dos y tres integrantes.\nüßë‚Äçüíª Trabajo pr√°ctico individual: opcional para promoci√≥n, con presentaci√≥n y defensa oral.\nTodas las instancias se califican en una escala de 0 a 10 y se aprueban con 6.",
    "crumbs": [
      "Informaci√≥n",
      "Condiciones de aprobaci√≥n"
    ]
  },
  {
    "objectID": "informacion/aprobacion.html#instancias-de-evaluaci√≥n",
    "href": "informacion/aprobacion.html#instancias-de-evaluaci√≥n",
    "title": "Condiciones de aprobaci√≥n",
    "section": "",
    "text": "üìù Examen parcial: individual y escrito. Hay un recuperatorio, de similares caracter√≠sticas, que reemplaza la nota del parcial.\nü§ù Trabajo pr√°ctico grupal: se hace fuera de clase, en grupos de entre dos y tres integrantes.\nüßë‚Äçüíª Trabajo pr√°ctico individual: opcional para promoci√≥n, con presentaci√≥n y defensa oral.\nTodas las instancias se califican en una escala de 0 a 10 y se aprueban con 6.",
    "crumbs": [
      "Informaci√≥n",
      "Condiciones de aprobaci√≥n"
    ]
  },
  {
    "objectID": "informacion/aprobacion.html#condiciones-de-aprobaci√≥n",
    "href": "informacion/aprobacion.html#condiciones-de-aprobaci√≥n",
    "title": "Condiciones de aprobaci√≥n",
    "section": "Condiciones de aprobaci√≥n",
    "text": "Condiciones de aprobaci√≥n\n\nPromoci√≥n\n\nQuienes aprueben el parcial individual (con nota \\(\\text{P}\\)), el trabajo pr√°ctico grupal (con nota \\(\\text{T}\\)) y el trabajo pr√°ctico individual con defensa oral (con nota \\(\\text{O}\\)), adquieren la condici√≥n de estudiante promovido y su nota final se calcula como \\(0.5 \\times \\text{P} + 0.2 \\times \\text{T} + 0.3 \\times \\text{O}\\).\n\nRegularidad\n\nQuienes aprueben el parcial individual (o su recuperatorio) y el trabajo pr√°ctico grupal, pero no accedan o no aprueben el trabajo pr√°ctico individual, adquieren la condici√≥n de estudiante regular.\n\nLibres\n\nQuienes no aprueben el parcial individual (ni su recuperatorio) o el trabajo pr√°ctico grupal, adquieren la condici√≥n de estudiante libre.",
    "crumbs": [
      "Informaci√≥n",
      "Condiciones de aprobaci√≥n"
    ]
  },
  {
    "objectID": "informacion/programa.html",
    "href": "informacion/programa.html",
    "title": "Programa",
    "section": "",
    "text": "Los profesionales en Estad√≠stica y Ciencia de Datos necesitan contar con habilidades avanzadas de programaci√≥n, que les permitan abordar problemas complejos y desarrollar soluciones eficientes y robustas.\nLa asignatura Programaci√≥n 2 introduce a los estudiantes a conceptos y pr√°cticas avanzadas de la programaci√≥n, incorporando herramientas y paradigmas que resultan fundamentales para el desarrollo profesional en Estad√≠stica y Ciencia de Datos.\nLa asignatura profundiza en enfoques como la programaci√≥n funcional y la programaci√≥n orientada a objetos, promoviendo el desarrollo de soluciones estructuradas, reutilizables, robustas y escalables. Adem√°s, se abordan conceptos fundamentales de estructuras de datos y algoritmos, relevantes para el dise√±o y an√°lisis de programas eficientes, as√≠ como para la comprensi√≥n de la complejidad computacional. Se focaliza en el lenguaje Python, ampliamente utilizado en la industria y la academia por su versatilidad, su ecosistema de librer√≠as y su capacidad para integrarse con diversas tecnolog√≠as.\nDictada en el segundo cuatrimestre del primer a√±o, Programaci√≥n 2 completa los contenidos del √°rea de Fundamentos Computacionales en el Ciclo de Formaci√≥n T√©cnica en Estad√≠stica y Ciencia de Datos, iniciada en el primer cuatrimestre con Programaci√≥n 1. De este modo, consolida las competencias inform√°ticas de los estudiantes y los prepara para afrontar asignaturas m√°s avanzadas y desaf√≠os profesionales que requieren un dominio s√≥lido de la programaci√≥n. Asimismo, fomenta buenas pr√°cticas de desarrollo de c√≥digo, el uso eficiente de los recursos computacionales y el pensamiento cr√≠tico en la resoluci√≥n de problemas.",
    "crumbs": [
      "Informaci√≥n",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/programa.html#fundamentaci√≥n",
    "href": "informacion/programa.html#fundamentaci√≥n",
    "title": "Programa",
    "section": "",
    "text": "Los profesionales en Estad√≠stica y Ciencia de Datos necesitan contar con habilidades avanzadas de programaci√≥n, que les permitan abordar problemas complejos y desarrollar soluciones eficientes y robustas.\nLa asignatura Programaci√≥n 2 introduce a los estudiantes a conceptos y pr√°cticas avanzadas de la programaci√≥n, incorporando herramientas y paradigmas que resultan fundamentales para el desarrollo profesional en Estad√≠stica y Ciencia de Datos.\nLa asignatura profundiza en enfoques como la programaci√≥n funcional y la programaci√≥n orientada a objetos, promoviendo el desarrollo de soluciones estructuradas, reutilizables, robustas y escalables. Adem√°s, se abordan conceptos fundamentales de estructuras de datos y algoritmos, relevantes para el dise√±o y an√°lisis de programas eficientes, as√≠ como para la comprensi√≥n de la complejidad computacional. Se focaliza en el lenguaje Python, ampliamente utilizado en la industria y la academia por su versatilidad, su ecosistema de librer√≠as y su capacidad para integrarse con diversas tecnolog√≠as.\nDictada en el segundo cuatrimestre del primer a√±o, Programaci√≥n 2 completa los contenidos del √°rea de Fundamentos Computacionales en el Ciclo de Formaci√≥n T√©cnica en Estad√≠stica y Ciencia de Datos, iniciada en el primer cuatrimestre con Programaci√≥n 1. De este modo, consolida las competencias inform√°ticas de los estudiantes y los prepara para afrontar asignaturas m√°s avanzadas y desaf√≠os profesionales que requieren un dominio s√≥lido de la programaci√≥n. Asimismo, fomenta buenas pr√°cticas de desarrollo de c√≥digo, el uso eficiente de los recursos computacionales y el pensamiento cr√≠tico en la resoluci√≥n de problemas.",
    "crumbs": [
      "Informaci√≥n",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/programa.html#objetivos",
    "href": "informacion/programa.html#objetivos",
    "title": "Programa",
    "section": "Objetivos",
    "text": "Objetivos\nQue los estudiantes logren:\n\nanalizar problemas computacionales y formular soluciones algor√≠tmicas adecuadas;\nimplementar esas soluciones mediante el desarrollo de programas en Python, seleccionando estructuras de datos apropiadas y evaluando la eficiencia de los algoritmos involucrados;\nidentificar y aplicar los paradigmas funcional y orientado a objetos cuando resulte pertinente, desarrollando programas que integren estos enfoques; y\nutilizar e integrar m√≥dulos y librer√≠as que permitan extender, organizar y mejorar las funcionalidades de sus programas.",
    "crumbs": [
      "Informaci√≥n",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/programa.html#contenidos",
    "href": "informacion/programa.html#contenidos",
    "title": "Programa",
    "section": "Contenidos",
    "text": "Contenidos\n\nUnidad 1: Introducci√≥n a Python\n\nLenguaje Python y su ecosistema. Uso de la interfaz Positron. Sintaxis de Python. Expresiones. Variables y asignaciones. Tipos de datos elementales. Operadores num√©ricos, de comparaci√≥n y l√≥gicos. Funciones. Ejecuci√≥n condicional de c√≥digo. Bucles definidos y no definidos. Listas, tuplas y diccionarios. Uso de c√≥digo externo. M√≥dulos y librer√≠as. Librer√≠a est√°ndar de Python. Instalaci√≥n y gesti√≥n de librer√≠as. Scripting. Lectura y escritura de archivos de texto plano. Modularizaci√≥n de programas.\n\nUnidad 2: Programaci√≥n funcional\n\nPrincipios fundamentales. Funciones como ciudadanos de primera clase. Funciones puras. Funciones an√≥nimas. Closures. Recursi√≥n. Funciones de orden superior: map, filter, reduce. Evaluaci√≥n estricta y no estricta. Evaluaci√≥n perezosa (lazy) e inmediata (eager). Generadores. Aplicaci√≥n parcial de funciones. Decoradores.\n\nUnidad 3: Programaci√≥n orientada a objetos\n\nPrincipios fundamentales. Objetos, clases e instancias. Atributos y m√©todos. Propiedades p√∫blicas y privadas. M√©todos de clase y m√©todos de instancia. Encapsulamiento. Herencia simple y m√∫ltiple. Polimorfismo. M√©todos especiales (dunder methods). Decoradores aplicados a m√©todos. Sobrecarga de operadores.\n\nUnidad 4: Estructuras de datos\n\nConcepto y clasificaci√≥n. Estructuras lineales: listas, listas enlazadas, pilas y colas. Operaciones b√°sicas: agregar, quitar y recorrer. Estructuras no lineales: √°rboles y grafos. Recorridos de √°rboles y grafos. Uso de colecciones de Python (list, deque, dict, set). Arreglos multidimensionales de NumPy.\n\nUnidad 5: Algoritmos de b√∫squeda y ordenamiento\n\nConcepto de algoritmo y complejidad. Notaci√≥n Big O. B√∫squeda lineal y binaria. Algoritmos de ordenamiento: bubble sort, insertion sort, selection sort, quick sort y merge sort. Comparaci√≥n de eficiencia. Funciones de b√∫squeda y ordenamiento en Python (sorted, sort, heapq).",
    "crumbs": [
      "Informaci√≥n",
      "Programa"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html",
    "title": "3 - Ejecuci√≥n condicional",
    "section": "",
    "text": "Las computadoras son muy buenas para much√≠simas cosas. En particular:\n\nDeterminar autom√°ticamente que secciones de un programa se debe ejecutar.\nRealizar tareas repetitivas.\n\nEl primer punto se refiere a la ejecuci√≥n condicional de c√≥digo y el segundo a la ejecuci√≥n repetitiva de c√≥digo.\nEstos dos puntos pueden ser vistos de manera general como control de flujo del c√≥digo.\nEn este apunte hablamos de la ejecuci√≥n condicional de c√≥digo.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "3 - Ejecuci√≥n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#introducci√≥n",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#introducci√≥n",
    "title": "3 - Ejecuci√≥n condicional",
    "section": "",
    "text": "Las computadoras son muy buenas para much√≠simas cosas. En particular:\n\nDeterminar autom√°ticamente que secciones de un programa se debe ejecutar.\nRealizar tareas repetitivas.\n\nEl primer punto se refiere a la ejecuci√≥n condicional de c√≥digo y el segundo a la ejecuci√≥n repetitiva de c√≥digo.\nEstos dos puntos pueden ser vistos de manera general como control de flujo del c√≥digo.\nEn este apunte hablamos de la ejecuci√≥n condicional de c√≥digo.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "3 - Ejecuci√≥n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if",
    "title": "3 - Ejecuci√≥n condicional",
    "section": "Bloques if",
    "text": "Bloques if\nLos bloques if utilizan la keyword if para evaluar una condici√≥n y ejecutar una secci√≥n de c√≥digo en base al resultado de esta evaluaci√≥n.\n\n\n\n\n\nVeamos un ejemplo.\n\ncondicion = True\nif condicion:\n    print(\"Se ejecuta el bloque if\")\n\nSe ejecuta el bloque if\n\n\n\ncondicion = False\nif condicion:\n    print(\"Se ejecuta el bloque if\")\n\nDe manera mas general, un bloque if es de la siguiente forma:\n\n\n\n\n\nTiene los siguientes componentes:\n\nLa palabra clave if.\nLa condici√≥n a evaluar, que tiene que ser True o False. Esta va seguida de los dos puntos : que indican el fin de la condici√≥n a evaluar y que lo siguiente es el bloque de c√≥digo a ejecutar condicionalmente.\nEl bloque de c√≥digo a evaluar si condici√≥n es verdadera.\n\nVeamos otro ejemplo.\n\ncondicion = True\nif condicion:\n    print(\"Se ejecuta el bloque if\")\n\nprint(\"Esto se imprime siempre\")\n\nSe ejecuta el bloque if\nEsto se imprime siempre\n\n\nEl segundo print() se imprime siempre porque est√° por fuera del bloque de ejecuci√≥n condicional.\n¬øC√≥mo nos damos cuenta que no est√° dentro del bloque condicional?\nSimplemente la indentaci√≥n vuelve a ser normal. El fin de la indentaci√≥n indica el fin del bloque de c√≥digo.\n\nvalor = 12\nif valor &gt; 10:\n    print(\"Se ejecuta el bloque if\")\n\nSe ejecuta el bloque if",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "3 - Ejecuci√≥n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if---else",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if---else",
    "title": "3 - Ejecuci√≥n condicional",
    "section": "Bloques if - else",
    "text": "Bloques if - else\nVimos que el bloque if nos permite ejecutar un bloque de c√≥digo de manera condicional, y que luego el programa sigue su ejecuci√≥n normal.\nTambi√©n es posible que necesitemos ejecutar un bloque de c√≥digo cuando las condiciones resulten en True y un bloque distinto en el caso contrario.\nPara eso, utilizamos el bloque if-else.\nUn bloque if-else es muy similar a un bloque if.\nLa diferencia es que nos permite definir otro bloque de c√≥digo que se ejecuta cuando la prueba condicional es False.\n\n\n\n\n\n\nedad = 21\nif edad &gt;= 16:\n    print(\"Ten√©s la edad suficiente para votar\")\nelse:\n    print(\"Lo siento, a√∫n sos demasiado j√≥ven para votar\")\n\nTen√©s la edad suficiente para votar\n\n\n\n\n\n\n\nAl igual que con el bloque if, cualquier parte del c√≥digo que se escriba luego del bloque if-else es ejecutada sin importar el valor de las condiciones.\nVeamos otro ejemplo donde evaluamos si un n√∫mero es par o impar.\n\nvalor = 10\nprint(valor)\n\nif valor % 2 == 0:\n    mensaje = \"Es par\"\nelse:\n    mensaje = \"Es impar\"\n\nprint(mensaje)\n\n10\nEs par\n\n\nEn este caso, print(mensaje) se ejecuta siempre.\nLo que var√≠a es el valor de la variable mensaje, que depende de si el n√∫mero es par o impar.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "3 - Ejecuci√≥n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if-elif-else",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if-elif-else",
    "title": "3 - Ejecuci√≥n condicional",
    "section": "Bloques if-elif-else",
    "text": "Bloques if-elif-else\nEs muy probable que tengamos situaciones donde necesitemos considerar m√°s de dos escenarios posibles.\nPara esto, Python ofrece los bloques if-elif-else.\nEste tipo de programa considera varias condiciones y las eval√∫a de a una a la vez hasta que alguna es verdadera. Luego se ejecuta solamente el bloque de c√≥digo que corresponde a la primer condici√≥n verdadera.\n\n\n\n\n\nSupongamos que viene un parque de diversiones a Rosario y tiene los siguientes precios para la entrada:\n\nMenores de 4 a√±os, gratis.\nPersonas entre 4 y 18 a√±os, $400.\nPersonas de 18 o mas a√±os, $600.\n\n\nedad = 3\n\nif edad &lt; 4:\n    print(\"El costo de entrada para vos es de $0.\")\nelif edad &lt; 18:\n    print(\"El costo de entrada para vos es de $400.\")\nelse:\n    print(\"El costo de entrada para vos es de $600.\")\n\nEl costo de entrada para vos es de $0.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "3 - Ejecuci√≥n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#m√∫ltiples-bloques-elif",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#m√∫ltiples-bloques-elif",
    "title": "3 - Ejecuci√≥n condicional",
    "section": "M√∫ltiples bloques elif",
    "text": "M√∫ltiples bloques elif\nHasta ahora utilizamos un √∫nico bloque elif, pero podemos usar tantos como sea necesario.\nPor ejemplo, si el parque de diversiones decide realizar un descuento para adultos mayores, dejando el precio en $350, podriamos agregar otro bloque elif que represente la evaluaci√≥n de esta condici√≥n.\n\nedad = 68\n\nif edad &lt; 4:\n    precio = 0\nelif edad &lt; 18:\n    precio = 400\nelif edad &lt; 65:\n    precio = 600\nelse:\n    precio = 350\n\nprint(f\"El precio de entrada para vos es de ${precio}.\")\n\nEl precio de entrada para vos es de $350.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "3 - Ejecuci√≥n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#omitir-el-bloque-else",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#omitir-el-bloque-else",
    "title": "3 - Ejecuci√≥n condicional",
    "section": "Omitir el bloque else",
    "text": "Omitir el bloque else\nNo hay ninguna regla que nos obligue a terminar un bloque de if-elif con un bloque else.\nUtilizar el bloque else a veces es lo correcto, pero otras veces puede ser mejor poner una condici√≥n expl√≠cita en un √∫ltimo elif que contemple solamente la condici√≥n que realmente nos interesa.\n\nedad = 10\n\nif edad &lt; 4:\n    precio = 0\nelif edad &lt; 18:\n    precio = 400\nelif edad &lt; 65:\n    precio = 600\nelif edad &gt;= 65:\n    precio = 350\n\nprint(f\"El precio de entrada para vos es de ${precio}.\")\n\nEl precio de entrada para vos es de $400.\n\n\nEl bloque elif que agregamos indica que el precio ser√° de $350 cuando la edad de la persona sea mayor o igual a 65 a√±os.\nEsta condici√≥n es m√°s expl√≠cita y f√°cil de entender que el bloque else que us√°bamos antes.\nSin embargo, todav√≠a hay un problema: el programa sigue funcionando incluso si se ingresan edades fuera de un rango razonable. A continuaci√≥n se muestra una versi√≥n m√°s completa:\n\nedad = 125\n\nif edad &lt; 0:\n    print(\"¬°Error!\")\n    precio = None\nelif edad &lt; 4:\n    precio = 0\nelif edad &lt; 18:\n    precio = 400\nelif edad &lt; 65:\n    precio = 600\nelif edad &gt;= 65 and edad &lt;= 120:\n    precio = 350\nelse:\n    print(\"¬°Error!\")\n    precio = None\n\nprint(f\"El precio de entrada para vos es ${precio}.\")\n\n¬°Error!\nEl precio de entrada para vos es $None.\n\n\nEl diagrama y el c√≥digo para el caso solo con elif se ven de la siguiente manera:",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "3 - Ejecuci√≥n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html",
    "href": "teoria/01_programacion_en_python/02_funciones.html",
    "title": "2 - Funciones",
    "section": "",
    "text": "Una funci√≥n puede pensarse como un ‚Äúmini-programa‚Äù dentro de un programa m√°s grande. Su prop√≥sito es cumplir una tarea u objetivo espec√≠fico, de forma independiente del resto del c√≥digo.\nEl uso de funciones tiene varias ventajas:\n\nReutilizaci√≥n de c√≥digo: se define una sola vez y se ejecuta cuando sea necesario.\nMejor organizaci√≥n: dividen el programa en partes m√°s f√°ciles de leer y mantener.\nModularidad: permiten construir programas como bloques independientes que pueden combinarse entre s√≠ (¬°funciones dentro de funciones!).\n\nConsideremos el siguiente caso donde se busca calcuar el precio final de un producto, considerando impuestos y descuentos.\n\nprecio_base = 800   # Precio del producto ($800)\nimpuesto = 0.21     # Impuesto (21%)\ndescuento = 0.10    # Descuento (10%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n871.2\n\n\n¬øQu√© pasa si queremos calcular el precio final para otros productos con diferentes precios, impuestos o descuentos?\nUna opci√≥n es repetir el c√≥digo tantas veces como sea necesario‚Ä¶\n\nprecio_base = 500   # Precio del producto ($500)\nimpuesto = 0.105    # Impuesto (10.5%)\ndescuento = 0.0     # Descuento (0%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n552.5\n\n\n\nprecio_base = 2000  # Precio del producto ($2000)\nimpuesto = 0.21     # Impuesto (21%)\ndescuento = 0.20    # Descuento (20%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n1936.0\n\n\nOtra opci√≥n, mucho mas conveniente, es utilizar funciones.\n\ndef calcular_precio(precio_base, impuesto, descuento):\n    resultado = precio_base * (1 + impuesto) * (1 - descuento)\n    return resultado\n\nLuego, para utilizar la funci√≥n simplemente la llamamos (o invocamos).\n\ncalcular_precio(800, 0.21, 0.10)\n\n871.2\n\n\nTambi√©n es posible indicar los valores de los argumentos utilizando sus nombres.\n\ncalcular_precio(precio_base=2000, impuesto=0.21, descuento=0.20)\n\n1936.0",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#qu√©-es-una-funci√≥n",
    "href": "teoria/01_programacion_en_python/02_funciones.html#qu√©-es-una-funci√≥n",
    "title": "2 - Funciones",
    "section": "",
    "text": "Una funci√≥n puede pensarse como un ‚Äúmini-programa‚Äù dentro de un programa m√°s grande. Su prop√≥sito es cumplir una tarea u objetivo espec√≠fico, de forma independiente del resto del c√≥digo.\nEl uso de funciones tiene varias ventajas:\n\nReutilizaci√≥n de c√≥digo: se define una sola vez y se ejecuta cuando sea necesario.\nMejor organizaci√≥n: dividen el programa en partes m√°s f√°ciles de leer y mantener.\nModularidad: permiten construir programas como bloques independientes que pueden combinarse entre s√≠ (¬°funciones dentro de funciones!).\n\nConsideremos el siguiente caso donde se busca calcuar el precio final de un producto, considerando impuestos y descuentos.\n\nprecio_base = 800   # Precio del producto ($800)\nimpuesto = 0.21     # Impuesto (21%)\ndescuento = 0.10    # Descuento (10%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n871.2\n\n\n¬øQu√© pasa si queremos calcular el precio final para otros productos con diferentes precios, impuestos o descuentos?\nUna opci√≥n es repetir el c√≥digo tantas veces como sea necesario‚Ä¶\n\nprecio_base = 500   # Precio del producto ($500)\nimpuesto = 0.105    # Impuesto (10.5%)\ndescuento = 0.0     # Descuento (0%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n552.5\n\n\n\nprecio_base = 2000  # Precio del producto ($2000)\nimpuesto = 0.21     # Impuesto (21%)\ndescuento = 0.20    # Descuento (20%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n1936.0\n\n\nOtra opci√≥n, mucho mas conveniente, es utilizar funciones.\n\ndef calcular_precio(precio_base, impuesto, descuento):\n    resultado = precio_base * (1 + impuesto) * (1 - descuento)\n    return resultado\n\nLuego, para utilizar la funci√≥n simplemente la llamamos (o invocamos).\n\ncalcular_precio(800, 0.21, 0.10)\n\n871.2\n\n\nTambi√©n es posible indicar los valores de los argumentos utilizando sus nombres.\n\ncalcular_precio(precio_base=2000, impuesto=0.21, descuento=0.20)\n\n1936.0",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#definici√≥n-de-funciones",
    "href": "teoria/01_programacion_en_python/02_funciones.html#definici√≥n-de-funciones",
    "title": "2 - Funciones",
    "section": "Definici√≥n de funciones",
    "text": "Definici√≥n de funciones\nAnalicemos las diferentes partes que forman la definici√≥n de una funci√≥n en Python:\n\n\n\n\n\n\nLa palabra clave def:\n\nMarca el inicio de la definici√≥n de una funci√≥n.\nEs una palabra reservada (keyword).\n\nEl nombre de la funci√≥n:\n\nDebe seguir las mismas reglas que los nombres de las variables.\n\nLos argumentos de la funci√≥n, dentro de par√©ntesis:\n\nSe separan por comas y pueden ser 0 o m√°s.\n\nLos dos puntos (:):\n\nIndican el final de la l√≠nea de definici√≥n y el inicio del bloque de c√≥digo.\n\nEl bloque de c√≥digo, que es el cuerpo de la funci√≥n:\n\nEs el c√≥digo que se ejecuta cada vez que llamamos a la funci√≥n.\n\nLa sentencia return que indica el resultado que devuelve la funci√≥n.\n\nLuego del return viene el valor o nombre de la variable a devolver.\nEs opcional (ya vamos a ver ejemplos).\n\n\n\n\n\n\n\n\nObservaci√≥n üëÄ\n\n\n\nEn R se tiene que asignar de manera expl√≠cita una funci√≥n a una variable. Por ejemplo:\nsumar &lt;- function(x, y) {\n    return(x + y)\n}\nEn cambio, en Python, la sentencia def define la funci√≥n y le asigna un nombre en un mismo paso.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#ejemplos",
    "href": "teoria/01_programacion_en_python/02_funciones.html#ejemplos",
    "title": "2 - Funciones",
    "section": "Ejemplos",
    "text": "Ejemplos\n\n1. Suma de n√∫meros\nComencemos con una funci√≥n super sencilla. La misma se llama sumar, recibe dos argumentos x e y, y devuelve la suma de ambos.\n\ndef sumar(x, y):\n    return x + y\n\n\nsumar(15, 21.9)\n\n36.9\n\n\n\ntype(sumar(15, 21.9))\n\nfloat\n\n\nEl valor que devuelve puede ser tratado como cualquier valor en Python. Por ejemplo, se lo puede asignar a una variable.\n\nresultado = sumar(10, 11)\nresultado\n\n21\n\n\nY el valor de esa variable puede ser luego pasado a una nueva llamada a sumar() (o a cualquier otra funci√≥n).\n\nsumar(resultado, 2.55)\n\n23.55\n\n\nIncluso es posible pasar expresiones y llamadas a funciones a la hora de pasar un argumento:\n\nsumar(sumar(1, 2), 3)\n\n6\n\n\nEn la l√≠nea sumar(sumar(1, 2), 3), Python comienza evaluando la funci√≥n sumar(). Pero para poder hacerlo, primero necesita conocer los valores de los argumentos. Al revisar el primer argumento, detecta que no es un valor directamente, sino otra llamada a la funci√≥n sumar(1, 2), por lo que la eval√∫a primero. El resultado de esa operaci√≥n es 3, que se toma como valor del primer argumento de la llamada externa. El segundo argumento ya est√° dado: tambi√©n es 3. Entonces, Python invoca la funci√≥n sumar() con los argumentos 3 y 3, cuyo resultado es 6. Finalmente, ese valor se muestra en pantalla.\n\n\n2. Saludo personalizado\nOtro ejemplo sencillo consiste en una funci√≥n que recibe un nombre e imprime un saludo en pantalla.\n\ndef saludar(nombre):\n    print(\"Hola\", nombre)\n\n\nsaludar(\"Pablo\")\n\nHola Pablo\n\n\nEsta funci√≥n no devuelve un resultado, sino que utiliza el argumento recibido para mostrar un mensaje en pantalla.\n\nsaludar(\"Juan\" + \" Manuel\")\n\nHola Juan Manuel\n\n\n\n\n3. Sin par√°metros\nY podemos tener funciones que no utilicen ning√∫n argumento.\n\ndef decir_hola():\n    print(\"¬°Hola!\")\n\n\ndecir_hola()\ndecir_hola()\ndecir_hola()\n\n¬°Hola!\n¬°Hola!\n¬°Hola!\n\n\n\n\n4. Devoluci√≥n de m√∫ltiples valores\nEn Python, las funciones pueden devolver m√∫ltiples valores separ√°ndolos por comas en la sentencia return. Por ejemplo:\n\ndef potencias(x):\n    cuadrado = x ** 2\n    cubo = x ** 3\n    return cuadrado, cubo\n\npotencias(2)\n\n(4, 8)\n\n\nEl resultado de este tipo de funciones puede ser asignado a m√∫ltiples variables. De esta forma, podemos obtener el cuadrado y el cubo de un n√∫mero con una sola llamada a una funci√≥n.\n\ncuadrado, cubo = potencias(8)\nprint(cuadrado)\nprint(cubo)\n\n64\n512\n\n\n\n\n\n\n\n\nObservaci√≥n üëÄ\n\n\n\nAl igual que en la asignaci√≥n m√∫ltiple de variables, lo que parece ser una funci√≥n que devuelve m√∫ltiples objetos es en realidad una funci√≥n que devuelve un √∫nico objeto llamado tupla (de tipo tuple) que permite la t√©cnica de unpacking.\nNo te preocupes, m√°s adelante vamos a ver bien c√≥mo funciona.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#diagrama-de-una-funci√≥n",
    "href": "teoria/01_programacion_en_python/02_funciones.html#diagrama-de-una-funci√≥n",
    "title": "2 - Funciones",
    "section": "Diagrama de una funci√≥n",
    "text": "Diagrama de una funci√≥n\n\n\n\n\n\nAlgunos efectos colaterales pueden ser:\n\nImprimir un texto o un gr√°fico.\nCambiar el valor de una variable global.\nCrear, eliminar o modificar un archivo de la computadora.\n\n\n\n\n\n\n\n¬øPuedo devolver una salida y generar efectos colaterales a la vez? ü§î\n\n\n\nUna funci√≥n en Python puede realizar m√∫ltiples tareas, como devolver un valor e imprimir un mensaje en pantalla.\nPor ejemplo:\ndef producto(x, y):\n    resultado = x * y\n    print(\"El producto es\", resultado)\n    return resultado\nLa funci√≥n producto() no solo calcula y devuelve el resultado de multiplicar x por y, sino que adem√°s muestra un mensaje por pantalla.\nSin embargo, en general no es una buena pr√°ctica combinar tareas distintas dentro de una misma funci√≥n, especialmente si son de distinta naturaleza (como devolver un valor y causar un efecto colateral). Esto puede dificultar la reutilizaci√≥n y el mantenimiento del c√≥digo.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#argumentos-nombrados-y-posicionales",
    "href": "teoria/01_programacion_en_python/02_funciones.html#argumentos-nombrados-y-posicionales",
    "title": "2 - Funciones",
    "section": "Argumentos nombrados y posicionales",
    "text": "Argumentos nombrados y posicionales\nAl definir una funci√≥n, debemos darle un nombre a cada uno de los argumentos que va a recibir.\nAl llamar a la funci√≥n, podemos pasar los valores de dos formas: por posici√≥n o por nombre.\nPor ejemplo, las siguientes llamadas a la funci√≥n sumar() son equivalentes:\n\nsumar(x = 10, y = 15)\n\n25\n\n\n\nsumar(10, 15)\n\n25\n\n\nSi utilizamos los nombres para pasar los argumentos no hace falta que est√©n en el mismo orden que en la definici√≥n de la funci√≥n.\n\nsumar(y = 15, x = 10)\n\n25\n\n\n¬°Que sea posible no significa que sea una buena pr√°ctica!",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#ausencia-de-return",
    "href": "teoria/01_programacion_en_python/02_funciones.html#ausencia-de-return",
    "title": "2 - Funciones",
    "section": "Ausencia de return",
    "text": "Ausencia de return\nLa funci√≥n sumar() termina con la siguiente l√≠nea:\n    return x + y\nEs decir, utiliza la sentencia return para devolver un valor.\nPor otro lado, la funci√≥n saludar() termina con un print() y no tiene ning√∫n return.\n    print(\"Hola\", nombre)\n\nresultado = sumar(1, 2)\nresultado\n\n3\n\n\n\nsaludo = saludar(\"Juan\")\n\nHola Juan\n\n\n\n¬øCu√°l es el valor de la variable saludo?\n¬øPor qu√©?\n¬øTiene sentido?\n\n\nprint(saludo)\n\nNone\n\n\nEn Python no existe el concepto de return impl√≠cito.\nSi queremos que una funci√≥n devuelva un valor, es necesario usar la instrucci√≥n return de forma expl√≠cita.\nEn caso de no hacerlo, la funci√≥n devuelve autom√°ticamente None.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#argumentos-por-defecto",
    "href": "teoria/01_programacion_en_python/02_funciones.html#argumentos-por-defecto",
    "title": "2 - Funciones",
    "section": "Argumentos por defecto",
    "text": "Argumentos por defecto\nCuando definimos una funci√≥n podemos determinar valores por defecto para uno o m√°s par√°metros.\nSi cuando llamamos a la funci√≥n le pasamos un valor a ese par√°metro, se utiliza el valor que pasamos. Sino, se usa el valor por defecto.\nEsta pr√°ctica es √∫til para simplificar las llamadas que realizamos a una funci√≥n.\nSupongamos la siguiente funci√≥n describir_mascota() que tiene los par√°metros nombre y tipo\n\ndef describir_mascota(nombre, tipo):\n    print(\"Tengo un\", tipo)\n    print(\"Y su nombre es\", nombre)\n\ndescribir_mascota(\"Bruno\", \"perro\")\n\nTengo un perro\nY su nombre es Bruno\n\n\nAhora, hacemos que el par√°metro nombre sea por defecto igual a \"perro\".\n\ndef describir_mascota(nombre, tipo=\"perro\"):\n    print(\"Tengo un\", tipo)\n    print(\"Y su nombre es\", nombre)\n\nDe este modo, es posible llamar a la funci√≥n solamente pasando valores para aquellos par√°metros sin valor por defecto:\n\ndescribir_mascota(\"Bruno\")\n\nTengo un perro\nY su nombre es Bruno\n\n\nComo es de esperar, tambi√©n es posible pasar valores distintos a los establecidos por defecto:\n\ndescribir_mascota(\"Nemo\", \"pez\")\n\nTengo un pez\nY su nombre es Nemo",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html",
    "href": "teoria/01_programacion_en_python/01_introduccion.html",
    "title": "1 - Introducci√≥n",
    "section": "",
    "text": "Python es un lenguaje de programaci√≥n interpretado, de prop√≥sito general y de alto nivel. Fue creado por Guido Van Rossum y su primera versi√≥n p√∫blica fue en el a√±o 1991.\n\nInterpretado: no requiere que realicemos un paso expl√≠cito de compilaci√≥n a lenguaje de m√°quina antes de ejecutarlo. Adem√°s, se puede ejecutar l√≠nea por l√≠nea.\nProp√≥sito general: no se limita a un tipo de aplicaci√≥n espec√≠fica, es decir, se puede usar para implementar programas en diferentes dominios:\n\nVox populi: No es el mejor en casi nada, pero suficientemente bueno para casi todo.\nAlgunos dominios:\n\nAn√°lisis estad√≠stico y ciencia de datos.\nInteligencia artificial.\nDesarrollo web.\nDesarrollo de videojuegos.\nScripting.\n\n\nAlto nivel: se parece m√°s al lenguaje humano que al lenguaje de las m√°quinas.\n\nAdem√°s‚Ä¶\n\nEs gratis: no requiere pagar licencias para usarlo, tanto a nivel personal como comercial.\nEs de c√≥digo abierto: su c√≥digo fuente est√° disponible p√∫blicamente y puede ser modificado por cualquiera.\nPosee un ecosistema de librer√≠as complet√≠simo: existen miles de paquetes para todo tipo de tareas.\nComunidad: millones de personas lo usan, contribuyen, resuelven dudas y crean contenido, lo que facilita aprender y encontrar ayuda.\n\nPara utilizar Python es necesario instalar un int√©rprete de Python. La versi√≥n oficial puede ser descargada desde python.org. Una vez instalado el int√©rprete, es posible ejecutar scripts de Python y programar en Python de manera interactiva desde la terminal.\nEn esta materia se utiliza un editor de c√≥digo para ciencia de datos llamado Positron. Este editor es desarrollado por Posit, los mismos creadores de RStudio, y permite trabajar tanto con Python como con R.\nLas instrucciones para instalar Python y Positron pueden ser encontradas en Instalaci√≥n de Python y Positron en Windows.\n\n\n\nEmpecemos utilizando a Python como si fuese una calculadora. Para eso vamos a crear un bloque de c√≥digo en la notebook y escribimos algunas cuentas tal como lo hacemos en cualquier calculadora.\n\n2 * 3\n\n6\n\n\nNo tenemos la necesidad de pisar el c√≥digo todo el tiempo. Podemos escribir nuevas celdas de c√≥digo, y as√≠ podemos ir mostrando diferentes c√≥mputos y sus resultados.\n\n100 / 3.5\n\n28.571428571428573\n\n\n\n20 + 5\n\n25\n\n\n\n13 - 3\n\n10\n\n\n\n10 * 5.5\n\n55.0",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "1 - Introducci√≥n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#qu√©-es-python",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#qu√©-es-python",
    "title": "1 - Introducci√≥n",
    "section": "",
    "text": "Python es un lenguaje de programaci√≥n interpretado, de prop√≥sito general y de alto nivel. Fue creado por Guido Van Rossum y su primera versi√≥n p√∫blica fue en el a√±o 1991.\n\nInterpretado: no requiere que realicemos un paso expl√≠cito de compilaci√≥n a lenguaje de m√°quina antes de ejecutarlo. Adem√°s, se puede ejecutar l√≠nea por l√≠nea.\nProp√≥sito general: no se limita a un tipo de aplicaci√≥n espec√≠fica, es decir, se puede usar para implementar programas en diferentes dominios:\n\nVox populi: No es el mejor en casi nada, pero suficientemente bueno para casi todo.\nAlgunos dominios:\n\nAn√°lisis estad√≠stico y ciencia de datos.\nInteligencia artificial.\nDesarrollo web.\nDesarrollo de videojuegos.\nScripting.\n\n\nAlto nivel: se parece m√°s al lenguaje humano que al lenguaje de las m√°quinas.\n\nAdem√°s‚Ä¶\n\nEs gratis: no requiere pagar licencias para usarlo, tanto a nivel personal como comercial.\nEs de c√≥digo abierto: su c√≥digo fuente est√° disponible p√∫blicamente y puede ser modificado por cualquiera.\nPosee un ecosistema de librer√≠as complet√≠simo: existen miles de paquetes para todo tipo de tareas.\nComunidad: millones de personas lo usan, contribuyen, resuelven dudas y crean contenido, lo que facilita aprender y encontrar ayuda.\n\nPara utilizar Python es necesario instalar un int√©rprete de Python. La versi√≥n oficial puede ser descargada desde python.org. Una vez instalado el int√©rprete, es posible ejecutar scripts de Python y programar en Python de manera interactiva desde la terminal.\nEn esta materia se utiliza un editor de c√≥digo para ciencia de datos llamado Positron. Este editor es desarrollado por Posit, los mismos creadores de RStudio, y permite trabajar tanto con Python como con R.\nLas instrucciones para instalar Python y Positron pueden ser encontradas en Instalaci√≥n de Python y Positron en Windows.\n\n\n\nEmpecemos utilizando a Python como si fuese una calculadora. Para eso vamos a crear un bloque de c√≥digo en la notebook y escribimos algunas cuentas tal como lo hacemos en cualquier calculadora.\n\n2 * 3\n\n6\n\n\nNo tenemos la necesidad de pisar el c√≥digo todo el tiempo. Podemos escribir nuevas celdas de c√≥digo, y as√≠ podemos ir mostrando diferentes c√≥mputos y sus resultados.\n\n100 / 3.5\n\n28.571428571428573\n\n\n\n20 + 5\n\n25\n\n\n\n13 - 3\n\n10\n\n\n\n10 * 5.5\n\n55.0",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "1 - Introducci√≥n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#tipos-de-datos",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#tipos-de-datos",
    "title": "1 - Introducci√≥n",
    "section": "Tipos de datos",
    "text": "Tipos de datos\nComo cualquier lenguaje de programaci√≥n, Python ofrece diferentes tipos de datos.\nCada tipo de dato nos ayuda a resolver una tarea distinta. Por ejemplo, si quiero hacer operaciones matem√°ticas voy a necesitar de n√∫meros, pero si quiero escribir un correo electr√≥nico voy a necesitar de texto.\nA continuaci√≥n vamos a introducir los tipos de datos m√°s b√°sicos que Python nos ofrece.\nM√°s adelante tambi√©n veremos otros tipos de datos m√°s complejos que nos van a permitir resolver problemas (much√≠simo) m√°s interesantes.\n\nN√∫meros\nAcabamos de hacer cuentas matem√°ticas somo si tuvieramos una calculadora. Para eso usamos n√∫meros, los conocidos de toda la vida.\nSin notarlo, utilizamos dos tipos de n√∫meros distintos: los n√∫meros de tipo entero (int) y los n√∫meros de tipo flotante (float).\nLo siguiente es un n√∫mero entero:\n\n50\n\n50\n\n\nY el siguiente es un ejemplo de un n√∫mero flotante:\n\n36.8\n\n36.8\n\n\nUtilizando la funci√≥n type() Python nos devuelve el tipo del objeto.\n\ntype(10)\n\nint\n\n\n\ntype(10.5)\n\nfloat\n\n\n\ntype(10.0)\n\nfloat\n\n\n\ntype(10.)\n\nfloat\n\n\n\n\n\n\n\n\nObservaci√≥n üëÄ\n\n\n\nA diferencia de R, Python no es un lenguaje vectorizado. Por lo tanto, los tipos int y float representan valores escalares, no vectores de longitud 1 como ocurre en R.\nEsta observaci√≥n aplica a todos los tipos de datos elementales que vienen a continuaci√≥n.\n\n\n\n\nCadenas de texto\nPara ser una lenguaje de programaci√≥n tan afamado, Python tiene que ser capaz de trabajar con objetos m√°s complejos que los n√∫meros.\nUn ejemplo de esto es el texto, que se representa con un objeto llamado cadena de texto y se construyen utilizando comillas.\nComo en la mayor√≠a de los lenguajes de programaci√≥n, las comillas se ponen al principio y al final del texto e indican el principio y el final de la cadena; estas pueden pueden ser dobles \" o simples '.\n\n\"Programando en Python\"\n\n'Programando en Python'\n\n\n\n'Con comillas simples, tambi√©n.'\n\n'Con comillas simples, tambi√©n.'\n\n\nEn Python no hay diferencia entre usar comillas simples ' o dobles \", pero es importante que el tipo de comilla que se usa para abrir la cadena sea el mismo que se usa para cerrarla.\nCuando imprimimos una cadena, las comillas no se muestran en la salida. Para imprimir cualquier objeto de Python utilizamos la funci√≥n print().\n\nprint('Con comillas simples, ¬°tambi√©n!')\n\nCon comillas simples, ¬°tambi√©n!\n\n\nUna forma un poco m√°s ex√≥tica, pero muy √∫til, de crear cadenas es utilizando comillas triples. Con esta sintaxis, se repiten tres comillas seguidas, lo que permite definir cadenas de texto que ocupan varias l√≠neas.\n\nprint(\"\"\"Se puede escribir texto\nen varias lineas.\n¬°Est√° muy bueno!\"\"\")\n\nSe puede escribir texto\nen varias lineas.\n¬°Est√° muy bueno!\n\n\nOtra manera de escribir texto que abarca m√∫ltiples l√≠neas es usando el car√°cter especial \\n, que representa un salto de l√≠nea.\n\nprint(\"Primera l√≠nea\\nsegunda l√≠nea\\ntercera l√≠nea.\")\n\nPrimera l√≠nea\nsegunda l√≠nea\ntercera l√≠nea.\n\n\nEn cambio, si mostramos una representaci√≥n del texto (sin usar print()), los \\n s√≠ se visualizan.\n\n\"Primera l√≠nea\\nsegunda l√≠nea\\ntercera l√≠nea.\"\n\n'Primera l√≠nea\\nsegunda l√≠nea\\ntercera l√≠nea.'\n\n\n\n\n\n\n\n\n¬°Atenci√≥n! ü§ì\n\n\n\n¬øCu√°l es la diferencia entre usar print() y no usarlo?\n\nCuando usamos print() se imprime el objeto de una manera humanamente legible.\nCuando no lo usamos, se muestra una representaci√≥n del objeto. Esta representaci√≥n tiene que ser lo menos ambigua posible.\n\nPor este motivo es que se muestran las comillas a la hora de representar una cadena.\n\n\n\n\nOtra situaci√≥n en la que usar print() genera una diferencia es cuando se quieren mostrar varios objetos en una notebook. Por ejemplo, comparemos el resultado de los siguientes bloques:\n\n\"mensaje 1\"\n10\n\"mensaje 2\"\n\n'mensaje 2'\n\n\n\nprint(\"mensaje 1\")\nprint(10)\nprint(\"mensaje 2\")\n\nmensaje 1\n10\nmensaje 2\n\n\n\n\nL√≥gicos (o Booleanos)\nComo veremos m√°s adelante, nuestros programas suelen tener que decidir entre diferentes acciones a tomar seg√∫n se cumpla o no cierta condici√≥n.\nPara representar esta situaci√≥n utilizamos un tipo especial de dato conocido como l√≥gico o booleano, que puede tomar √∫nicamente dos valores: True o False.\nSi la condici√≥n se cumple, el resultado ser√° True; de lo contrario, ser√° False.\n\nTrue\n\nTrue\n\n\n\nFalse\n\nFalse\n\n\n\ntype(True)\n\nbool\n\n\n\ntype(False)\n\nbool\n\n\n\n\n\n\n\n\nRese√±a hist√≥rica üìú\n\n\n\nEste tipo de datos se llama Booleano en honor al matem√°tico George Boole.\n\n\n\n\nNulo\nEl valor nulo, llamado None en Python, representa la ausencia de valor o el vac√≠o. Se utiliza habitualmente para indicar que algo no tiene un valor asignado. Si intentamos mostrar el valor de None, veremos que no aparece nada.\n\nNone\n\nEn cambio, si imprimimos el objeto None, vemos el mensaje None.\n\nprint(None)\n\nNone\n\n\n¬øY cu√°l es su tipo?\n\ntype(None)\n\nNoneType\n\n\nSolamente los objetos None son del tipo NoneType.\n\n\n\n\n\n\n¬øPor qu√© existe el valor nulo? ü§î\n\n\n\nMuchas veces nuestro programa, o alguna parte del mismo, realiza una tarea que no devuelve ning√∫n resultado.\nPodr√≠amos ponernos de acuerdo en representar ‚Äúning√∫n resultado‚Äù usando un n√∫mero (e.g., 0), una cadena vac√≠a (\"\"), o algo similar. Pero estos valores representan algo espec√≠fico, no la ausencia total de valor.\nPara expresar claramente que no hay ning√∫n resultado, Python incluye un valor especial llamado None.\n\n\nEjemplos\n\nUn usuario completa un formulario con datos personales, pero algunos campos no son obligatorios y quedan sin completar.\nUna funci√≥n busca un elemento en una lista; cuando no encuentra lo buscado, devuelve un valor especial indicando que el resultado est√° ausente.\n\nEn general, cuando se quiera representar la ausencia de informaci√≥n se utilizar√° None.\n\n\n\n\n\n\nObservaci√≥n üëÄ\n\n\n\nEn R existen dos tipos de datos para representar valores faltantes: NULL y NA. El None de Python equivale a NULL en R, ya que ambos indican ausencia de valor.\nPor otro lado, NA en R representa un valor existente pero desconocido, por ejemplo, porque se ha perdido. Python no ofrece un tipo de dato equivalente de forma nativa, aunque algunas librer√≠as s√≠ lo implementan.\n\n\n\n\nConversi√≥n entre tipos de datos\nQue existan distintos tipos de datos no significa que un objeto de un tipo no pueda ‚Äúconvertirse‚Äù a otro.\nEn muchos casos es posible convertir entre tipos de datos. Por ejemplo, un n√∫mero siempre se puede convertir a una cadena de caracteres, pero no cualquier cadena puede convertirse a un n√∫mero.\nPara convertir un objeto a otro tipo utilizamos funciones con el nombre del tipo al que queremos convertir, como str(), int() o bool(). Estas funciones reciben como argumento el objeto a convertir.\nVeamos algunos ejemplos:\n\nstr(256)\n\n'256'\n\n\n\nstr(None)\n\n'None'\n\n\n\nint(165.5)\n\n165\n\n\n\nint(165.8)\n\n165\n\n\n\nint(\"165\")\n\n165\n\n\n\nfloat(\"165.0\")\n\n165.0\n\n\n\n\nResumen\n\nPython tiene distintos tipos de datos.\nCada tipo de dato es √∫til para resolver diferentes problemas.\n\nA lo largo de la materia veremos much√≠simos ejemplos.\n\nAl principio, tener varios tipos de datos puede parecer complejo.\n\nSin embargo, nos resultar√°n muy naturales a medida que los usemos para resolver problemas concretos.\n\n\n\n\n\n\n\n\n\nTipo de dato\nEjemplos\n\n\n\n\nN√∫meros enteros (int)\n-2, -1, 0, 10, 200\n\n\nN√∫meros de punto flotante (float)\n-200.789, -1.0, 0.0, 17.8\n\n\nCadenas de texto (str)\n\"a\", \"abc\", \"Rosario, Santa Fe\"\n\n\nBooleanos (bool)\nTrue, False\n\n\nValor nulo (NoneType)\nNone",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "1 - Introducci√≥n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#variables",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#variables",
    "title": "1 - Introducci√≥n",
    "section": "Variables",
    "text": "Variables\n¬øEs necesario escribir expl√≠citamente los valores con los que trabajamos cada vez que los usamos? Afortunadamente, la respuesta es no.\nLos lenguajes de programaci√≥n m√°s populares permiten usar variables.\nPodemos pensar las variables como etiquetas o nombres que asignamos a los objetos en nuestro programa.\nUna vez creada una variable con cierto valor, podemos usar directamente su nombre en lugar de volver a escribir el valor completo.\n\nmensaje = \"¬°Hola, curso!\"\nprint(mensaje)\n\n¬°Hola, curso!\n\n\n\nprint(\"¬°Hola, curso!\")\n\n¬°Hola, curso!\n\n\nPara crear una variable se necesita:\n\nEl nombre.\nEl operador de asignaci√≥n.\nEl valor que queremos asignar a la variable.\n\nEn nuestro caso, el nombre de la variable es mensaje y el valor es \"¬°Hola, curso!\".\nLuego, cuando accedemos a la variable mensaje dentro de la funci√≥n print(), Python nos devuelve el valor de la variable, es decir, ¬°Hola, curso!\".\nVeamos otros ejemplos‚Ä¶\n\npi = 3.14159\nfruta_favorita = \"manzana\"\npython_bueno = True\n\nEn el siguiente diagrama se muestra c√≥mo las variables que creamos funcionan simplemente como etiquetas para los valores asignados.\nCada vez que utilizamos una de estas etiquetas, accedemos directamente al valor que representa.\n\n\n\n\n\n\nprint(pi * 10)\n\n31.4159\n\n\n\nfruta_favorita\n\n'manzana'\n\n\n\npython_bueno\n\nTrue\n\n\nLas variables no solo evitan que escribamos repetidamente los mismos valores en nuestro programa, sino que tambi√©n permiten:\n\nGeneralizar el programa\n\nAl cambiar el valor de una variable, todas las partes del programa que la usan se actualizan autom√°ticamente.\n\nMejorar la legibilidad del c√≥digo\n\nSi elegimos nombres claros y descriptivos, el programa ser√° mucho m√°s f√°cil de leer y entender.\n\n\nPor ejemplo, los siguientes bloques de c√≥digo producen el mismo resultado, pero el segundo es mucho m√°s informativo:\n\n1500 * 8\n\n12000\n\n\n\nprecio = 1500\ncantidad = 8\nprecio * cantidad\n\n12000\n\n\n\nNombres permitidos\nNo todos los nombres que imaginemos se pueden utilizar como variables en Python.\nTenemos que tener en cuenta las siguientes reglas. Los nombres de variables‚Ä¶\n\nSolo pueden contener letras, n√∫meros y guiones bajos (_).\nDeben comenzar con una letra o un gui√≥n bajo, pero no con un n√∫mero.\n\nPor ejemplo, mensaje_1 es v√°lido, pero 1_mensaje no lo es.\n\nNo pueden contener espacios.\n\nPor eso usamos fruta_favorita en lugar de fruta favorita.\n\nNo pueden ser palabras reservadas de Python.\n\nLas palabras reservadas se encuentran al final de este apunte.\n\n\nAdem√°s, tambi√©n vale la pena tener presente estos consejos:\n\nUs√° nombres breves pero descriptivos.\n\nnombre es preferible a n.\nfruta_favorita es preferible a frut_fav.\n\nEvit√° utilizar tildes, la letra √± u otros caracteres espec√≠ficos del castellano.\n\n\n\nEliminar variables\nEs posible que, despu√©s de crear nuestras variables y realizar las operaciones necesarias, queramos eliminarlas.\nPara borrar una variable, Python ofrece la sentencia del (del ingl√©s delete, que significa eliminar o borrar).\n\ndel fruta_favorita\n\n\n\nAsignaci√≥n m√∫ltiple\nYa vimos que para asignar (o crear) una variable necesitamos hacer variable = &lt;valor&gt;.\nSi queremos crear varias variables, podemos hacerlo en l√≠neas separadas:\n\npi = 3.1416\ne = 2.7182\n\nprint(pi)\nprint(e)\n\n3.1416\n2.7182\n\n\nUna caracter√≠stica conveniente de Python es que permite asignar m√∫ltiples variables en una misma l√≠nea:\n\npi, e = 3.1416, 2.7182\n\nprint(pi)\nprint(e)\n\n3.1416\n2.7182\n\n\nOtra ventaja es que las variables no tienen que ser del mismo tipo:\n\na, b, c = 100 + 20, \"un mensaje cualquiera\", None\n\nprint(a)\nprint(b)\nprint(c)\n\n120\nun mensaje cualquiera\nNone\n\n\nEsta t√©cnica es √∫til para escribir c√≥digo m√°s conciso, pero no conviene abusar de ella porque puede resultar en c√≥digo poco legible.\n\n\n\n\n\n\nObservaci√≥n üëÄ\n\n\n\nLa vida es m√°s compleja de lo que parece, y los lenguajes de programaci√≥n no son una excepci√≥n.\nEn Python, lo que parece una asignaci√≥n m√∫ltiple de variables es en realidad el uso de una t√©cnica m√°s avanzada llamada unpacking.\nA no desesperarse, m√°s adelante vamos a aprender de qu√© se trata.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "1 - Introducci√≥n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#operadores",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#operadores",
    "title": "1 - Introducci√≥n",
    "section": "Operadores",
    "text": "Operadores\nLos operadores son s√≠mbolos que se utilizan para realizar operaciones o acciones sobre los objetos con los que estamos trabajando.\nHasta ahora, vimos que podemos tener n√∫meros, texto, y otras objetos un poco mas extra√±os como los booleanos e incluso algo que representa a la nada misma.\nA continuaci√≥n, comenzamos a ver algunas de las tareas que podemos hacer con ellos.\n\nOperadores aritm√©ticos\nPython incluye los mismos operadores aritm√©ticos que solemos utilizar en nuestro d√≠a a d√≠a para hacer operaciones matem√°ticas.\nEstos se parecen much√≠simo a los que usamos en una calculadora, por lo que podr√≠amos entenderlo incluso sin saber de Python.\nAlgunos operadores son los siguientes:\n\nSuma (+)\nResta (-)\nMultiplicaci√≥n (*)\nPotencia (**)\nDivisi√≥n (/)\nDivisi√≥n entera (//)\nM√≥dulo (%)\n\n\nSuma (+)\n\n10 + 25\n\n35\n\n\n\n10.0 + 25.0\n\n35.0\n\n\n\n-8 + 12.1\n\n4.1\n\n\nEl operador suma tambi√©n puede ser usado con un solo argumento:\n\n+ 8\n\n8\n\n\nEn este caso no modifica en nada al valor 8.\n\n\n\nResta (-)\n\n11 - 8\n\n3\n\n\n\n100 - 100.0\n\n0.0\n\n\n\n-35 - 28\n\n-63\n\n\nEl operador resta tambi√©n puede ser usado con un solo argumento:\n\n- 7\n\n-7\n\n\n\n\nMultiplicaci√≥n (*) y potencia (**)\n\n21 * 5\n\n105\n\n\n\n21 * 5.0\n\n105.0\n\n\n\n21.0 * 5.0\n\n105.0\n\n\n\n2 ** 3\n\n8\n\n\n\n2 ** 3.0\n\n8.0\n\n\n\n\n\n\n\n\nConclusiones\n\n\n\nPara las operaciones de suma, resta, multiplicaci√≥n y potencia se cumple:\n\nSi ambos valores son enteros, el resultado ser√° un entero.\nSi al menos uno de los valores es flotante, el resultado ser√° flotante.\n\n\n\n\n\nDivisi√≥n (/ y //)\nPython provee dos operadores distintos para calcular el cociente entre dos n√∫meros.\n\nEl operador / que calcula la divisi√≥n flotante.\nEl operador // que calcula la divisi√≥n entera.\n\nEl operador / es el que m√°s se utiliza y siempre devuelve un n√∫mero de tipo flotante.\n\n10 / 5\n\n2.0\n\n\n\n10 / 5.5\n\n1.8181818181818181\n\n\nLa divisi√≥n entera se suele utilizar cuando uno quiere el resultado entero de la divisi√≥n, sin importar si el resto es 0 o no.\n\n10 // 5\n\n2\n\n\n\n10 // 5.5\n\n1.0\n\n\nVeamos los siguientes ejemplos donde comparamos la divisi√≥n flotante con la divisi√≥n entera, utilizando los mismos argumentos.\n\n15 / 4\n\n3.75\n\n\n\n15.0 // 4.0\n\n3.0\n\n\nConclusi√≥n: La divisi√≥n entera no redondea el resultado de la divisi√≥n flotante. M√°s sobre esto debajo.\n\n\nM√≥dulo (%)\nOtro operador relacionado a la divisi√≥n entera es el operador m√≥dulo o resto (%).\nEsta operaci√≥n nos devuelve el resto que se obtiene al realizar la divisi√≥n entera entre dos n√∫meros.\n\n17 % 3\n\n2\n\n\nDebajo se puede ver la relaci√≥n entre la divisi√≥n entera y el m√≥dulo:\n\n\n\n\n\nAunque ahora pueda parecer dif√≠cil encontrar una aplicaci√≥n pr√°ctica para los operadores de divisi√≥n entera // y resto %, m√°s adelante veremos ejemplos donde haremos un uso intensivo de ellos.\n\n\n\n\n\n\nObservaci√≥n üëÄ\n\n\n\nProbablemente en R hayan utilizado principalmente el operador /, que tambi√©n corresponde a la divisi√≥n flotante.\nEn ese lenguaje, los operadores para divisi√≥n entera y resto son %/% y %%, respectivamente.\n\n\n\n\nPrioridad de los operadores\nHasta ahora vimos operaciones bastante sencillas.\nCuando presentamos la suma, realizamos simplemente una suma. Cuando presentamos la multiplicaci√≥n, hicimos solo una multiplicaci√≥n.\nPor supuesto, al momento de hacer c√°lculos podemos combinar los operadores que ya conocemos, de la misma forma en que lo hacemos al resolver cuentas a mano.\nUn punto importante a tener en cuenta es que, al igual que cuando hacemos cuentas a mano, algunas operaciones se resuelven antes que otras, sin importar el orden en que aparecen. Esto ocurre porque algunos operadores tienen mayor prioridad y, por lo tanto, se eval√∫an antes.\nEn el siguiente ejemplo, ¬øpor qu√© se obtienen resultados distintos?\n\n10 - 2 * 4\n\n2\n\n\n\n(10 - 2) * 4\n\n32\n\n\nIndependientemente de que el s√≠mbolo + aparezca antes que el s√≠mbolo * en una expresi√≥n, Python realiza primero la multiplicaci√≥n.\nAl igual que cuando hacemos cuentas a mano, la multiplicaci√≥n tiene mayor prioridad que la suma.\nSi queremos forzar a Python a realizar una operaci√≥n antes que otra, sin importar la prioridad de los operadores, debemos usar par√©ntesis.\nOtro ejemplo es el siguiente‚Ä¶\n\n7 + 8 / 2\n\n11.0\n\n\n\n(7 + 8) / 2\n\n7.5\n\n\nA continuaci√≥n se incluye una tabla con los operadores que vimos y la prioridad que tiene cada uno.\nLos operadores que aparecen m√°s arriba tienen mayor prioridad.\nLos operadores que aparecen en la misma fila tienen el mismo nivel de prioridad y se resuelven seg√∫n el orden en que aparecen en el c√≥digo (de izquierda a derecha).\n\n\n\n\n\n\n\nOperador\nSignificado\n\n\n\n\n()\nAgrupamiento\n\n\n**\nPotencia\n\n\n*, /, //, %\nMultiplicaci√≥n, Divisi√≥n, Divisi√≥n entera, M√≥dulo\n\n\n+, -\nSuma, Resta\n\n\n\nEsta lista es una versi√≥n m√°s sencilla y resumida de la tabla de prioridades de todos los operadores que hay en Python. Una versi√≥n m√°s completa se puede encontrar en Programiz.\n\n\n\nOperadores l√≥gicos\nLos operadores l√≥gicos en Python son tres: not, and y or. Se llaman as√≠ porque combinan expresiones l√≥gicas (o directamente valores l√≥gicos) y devuelven tambi√©n valores l√≥gicos, es decir, del tipo bool, que pueden ser True o False. Estos operadores se utilizan para combinar o invertir condiciones en expresiones l√≥gicas.\n\nNegaci√≥n (not)\nDevuelve el opuesto del valor que le pasamos.\n\nnot False\n\nTrue\n\n\n\nnot True\n\nFalse\n\n\n\n\nConjunci√≥n o intersecci√≥n (and)\nEsta operaci√≥n devuelve True solamente cuando los dos operadores que le pasamos son True.\n\nTrue and True\n\nTrue\n\n\n\nFalse and True\n\nFalse\n\n\n\n\nDisyunci√≥n o uni√≥n (or)\nEsta operaci√≥n devuelve True cuando cualquiera de sus argumentos es True.\n\nTrue or False\n\nTrue\n\n\nSolo devuelve False cuando sus dos argumentos son False.\n\nFalse or False\n\nFalse\n\n\n\n\n\nOperadores de comparaci√≥n\n\nComparaci√≥n por identidad\nPython ofrece dos operadores para verificar si dos objetos son o no el mismo en identidad (es decir, en memoria):\n\nis: devuelve True si ambos operandos son el mismo objeto.\nis not: devuelve True si los operandos no son el mismo objeto.\n\n\nFalse is False\n\nTrue\n\n\n\nFalse is True\n\nFalse\n\n\n\nNone is None\n\nTrue\n\n\nEste tipo de comparaci√≥n es posible porque cada objeto en Python existe en la memoria de la computadora y tiene una identificaci√≥n √∫nica (ID). Para conocer el ID de un objeto, se puede usar la funci√≥n id().\n\nid(False)\n\n94152411564800\n\n\n\nid(False)\n\n94152411564800\n\n\n\nid(None)\n\n94152411476128\n\n\n\n\nComparaci√≥n por valor\nPor otro lado, Python tambi√©n provee operadores para realizar comparaciones entre objetos en t√©rminos de sus valores.\nLos operadores que vemos a continuaci√≥n son los mismos que aprendimos en la secundaria.\n\n\n\n\n\n\n\nOperador\nDescripci√≥n\n\n\n\n\n==\nIgualdad: El resultado es True cuando los dos operandos son iguales.\n\n\n!=\nDesigualdad: El resultado es True si los operandos son distintos.\n\n\n&gt;\nMayor a: El resultado es True si el operando de la izquierda es mayor que el de la derecha.\n\n\n&gt;=\nMayor o igual a: El resultado es True si el operando de la izquierda es mayor o igual que el de la derecha.\n\n\n&lt;\nMenor a: El resultado es True si el operando de la izquierda es menor que el de la derecha.\n\n\n&lt;=\nMenor o igual a: El resultado es True si el operando de la izquierda es menor o igual que el de la derecha.\n\n\n\nAlgunos ejemplos‚Ä¶\n\n10 &gt; 5\n\nTrue\n\n\n\n10 &gt; 5 + 3\n\nTrue\n\n\n\n0 &lt; 0\n\nFalse\n\n\n\n1 &gt;= 1\n\nTrue\n\n\n\n10.0 != 10\n\nFalse\n\n\n\n10.0 == 10\n\nTrue\n\n\nA pesar de que 10.0 es de tipo flotante y 10 es de tipo entero, vemos que la comparaci√≥n de igualdad == dice que son iguales.\nNo siempre que comparemos objetos de distinto tipo va a suceder algo as√≠.\nLa comparaci√≥n de cadenas de texto distingue may√∫sculas de min√∫sculas\n\n\"UNR\" == \"unr\"\n\nFalse\n\n\nEs posible comparar objetos de distinto tipo, como lo vimos en el ejemplo anterior donde comparamos 10 y 10.0.\nSalvo casos particulares, como son los valores num√©ricos, estos objetos son considerados siempre distintos.\n\n\"10\" == 10\n\nFalse\n\n\n\n\"False\" == False\n\nFalse\n\n\nEs posible combinar mas de una comparaci√≥n en la misma l√≠nea.\n\n1 &lt; 2 and 2 &lt; 3\n\nTrue\n\n\nIncluso es posible omitir el operador and y tener una expresi√≥n m√°s clara\n\n1 &lt; 2 &lt; 3\n\nTrue\n\n\n\n-5 &lt; -4 &lt; -3\n\nTrue\n\n\nTambi√©n podemos mezclar not, and y or a gusto.\n\nFalse or not False\n\nTrue\n\n\nY es v√°lido utilizar par√©ntesis para agrupar operaciones.\n\n(False or True) and (True or False)\n\nTrue\n\n\nA continuaci√≥n se incluye una tabla con los operadores de comparaci√≥n y la prioridad que tiene cada uno.\nLos operadores que aparecen m√°s arriba tienen mayor prioridad.\nLos operadores que aparecen en la misma fila tienen el mismo nivel de prioridad y se resuelven seg√∫n el orden en que aparecen en el c√≥digo (de izquierda a derecha).\n\n\n\n\n\n\n\nOperadores\nSignificado\n\n\n\n\n==, !=, &gt;, &gt;=, &lt;, &lt;=, is, is not, in, not in\nComparaciones, identidad, pertenencia\n\n\nnot\nNegaci√≥n\n\n\nand\nConjunci√≥n o intersecci√≥n\n\n\nor\nDisyunci√≥n o uni√≥n\n\n\n\nTodos los operadores de comparaci√≥n tienen menor prioridad que los operadores aritm√©ticos que vimos arriba.\nEn otras palabras, si pegaramos ambas tablas, √©sta √∫ltima quedar√≠a por debajo.\nAnalicemos nuevamente uno de los ejemplos que ya vimos.\n\nnot True and not True\n\nFalse\n\n\nEl operador not tiene mayor prioridad que el operador and porque aparece primero en la tabla.\nEn consecuencia, en el c√≥digo anterior primero se resuelven los not True y luego el and. Esto es lo mismo que hacer\n\nFalse and False\n\nFalse\n\n\n\n\n\n\n\n\nResumen üìù\n\n\n\nExisten dos operadores para comparar igualdad entre dos objetos de Python:\n\n== ‚Üí compara el valor (contenido).\nis ‚Üí compara la identidad (ubicaci√≥n en memoria).",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "1 - Introducci√≥n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#operaciones-con-cadenas-de-caracteres",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#operaciones-con-cadenas-de-caracteres",
    "title": "1 - Introducci√≥n",
    "section": "Operaciones con cadenas de caracteres",
    "text": "Operaciones con cadenas de caracteres\n\nSuma y producto\nAunque al principio pueda parecer extra√±o, en Python es posible usar operadores matem√°ticos con objetos que no son num√©ricos.\nEsto no significa que se puedan aplicar a cualquier objeto, ni que est√©n disponibles todos los operadores en esos casos.\nSin embargo, vale la pena resaltar el uso del operador de suma (+) y producto (*) con las cadenas de caracteres.\nVeamos que pasa si ‚Äúsumamos‚Äù dos cadenas de caracteres:\n\n\"¬øFunciona\" + \"bien?\"\n\n'¬øFuncionabien?'\n\n\n\n\"¬øesto\" + \" tambi√©n \" + \"funciona?\"\n\n'¬øesto tambi√©n funciona?'\n\n\nComo se puede observar, el operador de suma (+) aplicado a cadenas de texto indica concatenaci√≥n: crea una nueva cadena uniendo el contenido de las cadenas originales, en el mismo orden.\nSi la suma tiene sentido para cadenas, entonces el producto tambi√©n deber√≠a tenerlo (al menos con n√∫meros enteros). Veamos un ejemplo:\n\n\"ja\" * 2\n\n'jaja'\n\n\n\n\"ja\" * 4\n\n'jajajaja'\n\n\nDe manera coherente con la definici√≥n de producto para enteros, multiplicar una cadena por un n√∫mero entero N equivale a concatenar esa cadena consigo misma N veces.\n\n\nCadenas formateadas (formatted strings)\nLas cadenas de texto formateadas son de gran utilidad para crear una cadena de texto a partir de otros objetos.\nEn Python se las conoce como f-strings (abreviaci√≥n de formatted-strings) y tienen este nombre porque tenemos que poner una f antes de las comillas.\nEl resultado de una f-string no se diferencia de una cadena de texto com√∫n y corriente.\n\nf\"Un texto cualquiera\"\n\n'Un texto cualquiera'\n\n\nSin embargo, las f-strings nos permiten interpolar cadenas de texto.\n¬øQu√© es interpolar texto?\nVeamos algunos ejemplos.\n\nlenguaje = \"Python\"\nprint(\"Programando en \" + lenguaje)\n\nProgramando en Python\n\n\n\nque = \"bayer\"\ncomo = \"bueno\"\nprint(\"Si es \" + que + \" es \" + como + \".\")\n\nSi es bayer es bueno.\n\n\nEl proceso se vuelve un poco engorroso. Hay que estar atentos a las sumas y los espacios para que el resultado quede formateado de una manera correcta.\nLas f-strings vienen a facilitar este proceso y hacerlo menos tedioso.\nLo que tenemos que hacer es pasar el nombre de la variable entre llaves ({}) en el contenido de la f-string.\n\nprint(f\"Programando en {lenguaje}\")\nprint(f\"Si es {que} es {como}.\")\n\nProgramando en Python\nSi es bayer es bueno.\n\n\nVeamos un ejemplo menos trivial, donde utilizar f-strings reduce la cantidad de c√≥digo y lo hace m√°s claro.\n\nnombre = \"Tom√°s\"\nedad = 29\nciudad = \"Rosario\"\n\nprint(\"Hola, soy \" + nombre + \", tengo \" + str(edad) + \" a√±os y vivo en \" + ciudad + \".\")\n\nHola, soy Tom√°s, tengo 29 a√±os y vivo en Rosario.\n\n\nUtilizando f-strings‚Ä¶\n\nprint(f\"Hola, soy {nombre}, tengo {edad} a√±os y vivo en {ciudad}.\")\n\nHola, soy Tom√°s, tengo 29 a√±os y vivo en Rosario.\n\n\nAdem√°s, no es necesario convertir la variable edad a al tipo str manualmente.\nNo solo podemos utilizar variables dentro de las f-strings, tambi√©n podemos incluir expresiones de Python.\n\nminutos_por_hora = 60\nhoras = 2.7\n\nprint(f\"En {horas} horas hay {horas * minutos_por_hora} minutos.\")\n\nEn 2.7 horas hay 162.0 minutos.\n\n\n\n\nCadenas de texto y sus met√≥dos\n\nnombre = \"Lionel Messi\"\n\nLas cadenas de texto, es decir, los objetos de tipo str, vienen con varias funciones (llamados ‚Äúm√©todos‚Äù) que nos facilitan much√≠simas tareas en la pr√°ctica.\nPor ejemplo, tenemos los m√©todos .upper() y .lower(), que ponen el texto en may√∫scula y en min√∫scula, respectivamente.\n\nprint(nombre.upper())\nprint(nombre.lower())\n\nLIONEL MESSI\nlionel messi\n\n\nTambi√©n tenemos .capitalize(), que pone la primer letra en may√∫scula y el resto en min√∫sculas.\nEstos m√©todos se pueden combinar dentro de una f-string, sin necesidad de modificar los valores de nombre o apellido.\n\nnombre = \"lionel\"\napellido = \"messi\"\nnombre_completo = f\"{nombre.capitalize()} {apellido.capitalize()}\"\nprint(nombre_completo)\n\nLionel Messi\n\n\nOtra opci√≥n es usar .title().\nEste m√©todo pone la primera letra de cada palabra en may√∫sculas y al resto en min√∫sculas.\n\nmensaje = \"mensaje de prueba\"\nprint(mensaje.capitalize())\nprint(mensaje.title())\n\nMensaje de prueba\nMensaje De Prueba\n\n\n\n\nEliminar espacios en blanco\nEs muy com√∫n que en nuestros programas tengamos que lidiar con texto que vienen con espacios en blanco que est√°n dem√°s.\nEl espacio puede estar tanto al principio como al final de una cadena de texto.\nAfortunadamente, Python tambi√©n provee algunos m√©todos que nos permiten eliminar estos espacios con muy poco trabajo.\n\nlenguaje_favorito = \"  python  \"\nlenguaje_favorito\n\n'  python  '\n\n\n.rstrip() elimina los espacios en blanco a la derecha del texto.\n\nlenguaje_favorito.rstrip()\n\n'  python'\n\n\n.lstrip() elimina los espacios en blanco a la izquierda del texto.\n\nlenguaje_favorito.lstrip()\n\n'python  '\n\n\ny .strip() elimina los espacios en blanco a la izquierda y a la derecha del texto.\n\nlenguaje_favorito.strip()\n\n'python'\n\n\n\n\nReemplazar y eliminar caracteres no deseados\nTambi√©n es frecuente que el texto contenga caracteres err√≥neos, o caracteres que simplemente no queremos conservar.\nPara estos casos podemos usar el m√©todo .replace().\nA diferencia de los m√©todos que vimos hasta ahora, .replace() requiere que le pasemos algunos argumentos.\nEl primer valor que le pasamos es el texto que queremos reemplazar y el segundo es el texto de reemplazo.\nPodemos reemplazar caracteres, palabras, o frases enteras.\n\nanimal = \"pato\"\nanimal.replace(\"p\", \"g\")\n\n'gato'\n\n\n\nsaludo = \"Hola Mundo\"\nsaludo.replace(\"Mundo\", \"Curso\")\n\n'Hola Curso'\n\n\nCuando utilizamos el m√©todo .replace() se nos devuelve una nueva cadena de texto.\nEsto nos permite ‚Äúpegar‚Äù o ‚Äúencadenar‚Äù mas de un .replace() a la vez, ya que cada nuevo .replace() se aplica sobre el resultado de la operaci√≥n anterior.\n\nsaludo.replace(\"Mundo\", \"Curso\").replace(\"Hola\", \"Chau\")\n\n'Chau Curso'\n\n\nsaludo.replace(\"Mundo\", \"Curso\") devuelve \"Hola Curso\", al que luego se le aplica .replace(\"Hola\", \"Chau\") y el resultado final es \"Chau Curso\".",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "1 - Introducci√≥n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#ap√©ndice",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#ap√©ndice",
    "title": "1 - Introducci√≥n",
    "section": "Ap√©ndice",
    "text": "Ap√©ndice\n\nPalabras claves y funciones predefinidas\nPython tiene un conjunto de palabras conocidas como keywords que sirven para realizar acciones especificas y que no podemos utilizar como nombres de variables.\nCuando intentemos utilizar una keyword como nombre de variable, obtendremos un error.\nPor otro lado, si intentamos utilizar el nombre de una funci√≥n (o clase) predefinida como nombre de una variable que nosotros creamos, no vamos a obtener un error pero no podremos usar la funci√≥n nuevamente porque la variable ahora representa otra cosa.\n\nPalabras claves\nFalse      await      else       import     pass\nNone       break      except     in         raise\nTrue       class      finally    is         return\nand        continue   for        lambda     try\nas         def        from       nonlocal   while\nassert     del        global     not        with\nasync      elif       if         or         yield\n\n\nFunciones y clases pre-definidas\nabs()          copyright()    getattr()      list()         range()        vars()\nall()          credits()      globals()      locals()       repr()         zip()\nany()          delattr()      hasattr()      map()          reversed()\nascii()        dict()         hash()         max()          round()\nbin()          dir()          help()         memoryview()   set()\nbool()         display()      hex()          min()          setattr()\nbreakpoint()   divmod()       id()           next()         slice()\nbytearray()    enumerate()    input()        object()       sorted()\nbytes()        eval()         int()          oct()          staticmethod()\ncallable()     exec()         isinstance()   open()         str()\nchr()          filter()       issubclass()   ord()          sum()\nclassmethod()  float()        iter()         pow()          super()\ncompile()      format()       len()          print()        tuple()\ncomplex()      frozenset()    license()      property()     type()\n\n\nM√©todos de las cadenas de texto\n\n\n\n\n\n\n\n\n\nM√©todo\nDescripci√≥n\nEjemplo\nResultado\n\n\n\n\n.endswith(sufijo)\nVerifica si termina con el sufijo\n\"file.txt\".endswith(\".txt\")\nTrue\n\n\n.find(x)\nLa posicion de la primera aparici√≥n de x en la cadena (o -1 si no est√°)\n\"Python\".find(\"t\")\n2\n\n\n.index(x)\nLa posicion de la primera aparici√≥n de x en la cadena (error si no est√°)\n\"Python\".index(\"n\")\n5\n\n\n.isalpha()\nVerifica si los caracteres son alfab√©ticos\n\"256\".isalpha()\nFalse\n\n\n.isdigit()\nVerifica si los caracteres son num√©ricos\n\"256\".isdigit()\nTrue\n\n\n.islower()\nVerifica si los caracteres son min√∫sculas\n\"Python\".islower()\nFalse\n\n\n.isupper()\nVerifica si los caracteres son may√∫sculas\n\"Python\".isupper()\nFalse\n\n\n.join(lista)\nUne una lista de cadenas usando la cadena como delimitador\n\" y \".join([\"esto\", \"aquello\"])\n\"esto y aquello\"\n\n\n.lower()\nConvertir a min√∫sculas\n\"Python\".lower()\n\"python\"\n\n\n.replace(viejo, nuevo)\nReemplaza texto\n\"maximo\".replace(\"ax\", \"in\")\n\"minimo\"\n\n\n.split(sep)\nParte la cadena en una lista de subcadenas\n\"esto y aquello\".split(\" y \")\n[\"esto\", \"aquello\"]\n\n\n.startswith(prefijo)\nVerifica si comienza con un prefijo\n\"file.txt\".endswith(\"a\")\nFalse\n\n\n.strip()\nElimina espacios en blanco al inicio o al final\n\" oh la la \".strip()\n\"oh la la\"\n\n\n.upper()\nConvierte a may√∫sculas\n\"Python\".upper()\n\"PYTHON\"",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "1 - Introducci√≥n"
    ]
  },
  {
    "objectID": "recursos/ejemplos/01_funciones_y_bucles.html",
    "href": "recursos/ejemplos/01_funciones_y_bucles.html",
    "title": "Funciones y bucles: Python vs R",
    "section": "",
    "text": "El siguiente bloque de c√≥digo define una funci√≥n en R:\n\n\nfuncion.R\n\nsumar &lt;- function(a, b) {\n  resultado &lt;- a + b\n  return(resultado)\n}\n\ny el siguiente define una funci√≥n an√°loga en Python:\n\n\nfuncion.py\n\ndef sumar(a, b):\n    resultado = a + b\n    return resultado",
    "crumbs": [
      "Recursos",
      "Ejemplos"
    ]
  },
  {
    "objectID": "recursos/ejemplos/01_funciones_y_bucles.html#funciones",
    "href": "recursos/ejemplos/01_funciones_y_bucles.html#funciones",
    "title": "Funciones y bucles: Python vs R",
    "section": "",
    "text": "El siguiente bloque de c√≥digo define una funci√≥n en R:\n\n\nfuncion.R\n\nsumar &lt;- function(a, b) {\n  resultado &lt;- a + b\n  return(resultado)\n}\n\ny el siguiente define una funci√≥n an√°loga en Python:\n\n\nfuncion.py\n\ndef sumar(a, b):\n    resultado = a + b\n    return resultado",
    "crumbs": [
      "Recursos",
      "Ejemplos"
    ]
  },
  {
    "objectID": "recursos/ejemplos/01_funciones_y_bucles.html#ejecuci√≥n-condicional",
    "href": "recursos/ejemplos/01_funciones_y_bucles.html#ejecuci√≥n-condicional",
    "title": "Funciones y bucles: Python vs R",
    "section": "Ejecuci√≥n condicional",
    "text": "Ejecuci√≥n condicional\nPor otro lado, el siguiente bloque muestra el uso de ejecuci√≥n condicional en R:\n\n\ncondicional.R\n\nx &lt;- 5\n\nif (x &gt; 0) {\n  mensaje &lt;- \"El n√∫mero es positivo\"\n} else {\n  mensaje &lt;- \"El n√∫mero no es positivo\"\n}\n\nprint(mensaje)\n\nY debajo se muestra la versi√≥n an√°loga en Python:\n\n\ncondicional.py\n\nx = 5\n\nif x &gt; 0:\n    mensaje = \"El n√∫mero es positivo\"\nelse:\n    mensaje = \"El n√∫mero no es positivo\"\n\nprint(mensaje)",
    "crumbs": [
      "Recursos",
      "Ejemplos"
    ]
  },
  {
    "objectID": "recursos/ejemplos/01_funciones_y_bucles.html#resumen-de-diferencias",
    "href": "recursos/ejemplos/01_funciones_y_bucles.html#resumen-de-diferencias",
    "title": "Funciones y bucles: Python vs R",
    "section": "Resumen de diferencias",
    "text": "Resumen de diferencias\n\nComunes\n\nUso de bloques:\n\nEn R los bloques de c√≥digo siempre se delimitan con llaves {}.\nEn Python los bloques se definen exclusivamente mediante indentaci√≥n (sin llaves).\n\nIndentaci√≥n:\n\nEn Python la indentaci√≥n es obligatoria y tiene significado sint√°ctico.\nEn R la indentaci√≥n es opcional; sirve √∫nicamente para mejorar la legibilidad.\n\nUso de los dos puntos (:):\n\nEn Python las definiciones de funciones y condiciones terminan con :.\nEn R no se utilizan los dos puntos al final de estas estructuras.\n\n\n\n\nFunciones\n\nForma de definir la funci√≥n:\n\nEn R: sumar &lt;- function(a, b). Se crea la funci√≥n y se asigna a una variable.\nEn Python: def sumar(a, b):. La creaci√≥n de la funci√≥n ya crea la variable.\n\nRetorno de valores:\n\nEn R, aunque es com√∫n usar return(), el resultado de la √∫ltima expresi√≥n se devuelve autom√°ticamente (puede omitirse return).\nEn Python es obligatorio usar return si se desea devolver un valor.\n\n\n\n\nEjecuci√≥n condicional\n\nUso de par√©ntesis en condiciones:\n\nEn R es obligatorio usar par√©ntesis alrededor de la condici√≥n (if (x &gt; 0)).\nEn Python no se usan par√©ntesis (if x &gt; 0:).",
    "crumbs": [
      "Recursos",
      "Ejemplos"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html",
    "href": "practica/01_programacion_en_python/ejercicios.html",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "",
    "text": "Escriba una funci√≥n en Python que reciba el radio de un c√≠rculo y devuelva su √°rea. Luego, escriba otra funci√≥n que tambi√©n reciba el radio de un c√≠rculo, pero devuelva su per√≠metro. Finalmente, escriba una tercera funci√≥n que reciba el radio de un c√≠rculo y devuelva tanto el √°rea como el per√≠metro.\nUna vez que haya implementado todas las funciones, analice la diferencia entre:\narea, perimetro = calcular_area_y_perimetro(radio=5)\ny\nresultados = calcular_area_y_perimetro(radio=5)\nConsidere el tipo de las variables area, perimetro y resultados.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\n\\[\n\\begin{aligned}\nA &= \\pi \\cdot r^2 \\\\\nP &= 2 \\cdot \\pi \\cdot r\n\\end{aligned}\n\\]",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#√°rea-y-per√≠metro-de-un-c√≠rculo",
    "href": "practica/01_programacion_en_python/ejercicios.html#√°rea-y-per√≠metro-de-un-c√≠rculo",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "",
    "text": "Escriba una funci√≥n en Python que reciba el radio de un c√≠rculo y devuelva su √°rea. Luego, escriba otra funci√≥n que tambi√©n reciba el radio de un c√≠rculo, pero devuelva su per√≠metro. Finalmente, escriba una tercera funci√≥n que reciba el radio de un c√≠rculo y devuelva tanto el √°rea como el per√≠metro.\nUna vez que haya implementado todas las funciones, analice la diferencia entre:\narea, perimetro = calcular_area_y_perimetro(radio=5)\ny\nresultados = calcular_area_y_perimetro(radio=5)\nConsidere el tipo de las variables area, perimetro y resultados.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\n\\[\n\\begin{aligned}\nA &= \\pi \\cdot r^2 \\\\\nP &= 2 \\cdot \\pi \\cdot r\n\\end{aligned}\n\\]",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#promociones",
    "href": "practica/01_programacion_en_python/ejercicios.html#promociones",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "2 Promociones",
    "text": "2 Promociones\nEscriba una funci√≥n llamada calcular_precio que reciba dos argumentos: el monto total de una compra y el medio de pago utilizado.\nEl medio de pago puede ser \"efectivo\", \"d√©bito\" o \"cr√©dito\", y seg√∫n el caso se aplicar√° una modificaci√≥n sobre el monto:\n\nSi el medio de pago es \"efectivo\", el monto no se modifica.\nSi es \"d√©bito\", se aplica un descuento del 10% sobre el monto.\nSi es \"cr√©dito\", se aplica un recargo del 5% sobre el monto.\n\nLa funci√≥n debe retornar el monto final a pagar, con el descuento o recargo aplicado seg√∫n corresponda.\n\nPunto extra\nModifique la funci√≥n de modo tal que no sea necesario especificar el medio de pago. En tal caso, el medio de pago se asume \"efectivo\". Ayuda: asigne un valor por defecto al argumento medio. Considere una implementaci√≥n donde este sea \"efectivo\" y otra donde sea None.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#etapas-de-la-vida",
    "href": "practica/01_programacion_en_python/ejercicios.html#etapas-de-la-vida",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "3 Etapas de la vida",
    "text": "3 Etapas de la vida\nImplemente una funci√≥n que reciba una edad y devuelva un mensaje que indique la etapa de la vida correspondiente.\nUtilice una cadena de condicionales if-elif-else para clasificar la edad en alguno de los siguientes grupos:\n\nMenor a 2 a√±os: beb√©.\nEntre 2 (inclusive) y 4 a√±os: infante.\nEntre 4 (inclusive) y 13 a√±os: ni√±o/a.\nEntre 13 (inclusive) y 20 a√±os: adolescente.\nEntre 20 (inclusive) y 65 a√±os: adulto/a.\n65 a√±os o m√°s: persona mayor.\n\nLa funci√≥n debe imprimir un mensaje del tipo: \"La persona es un/a &lt;etapa&gt;\".",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres",
    "href": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "4 Conteo de caracteres",
    "text": "4 Conteo de caracteres\nEscriba una funci√≥n que reciba una cadena de texto y devuelva un diccionario que indique cu√°ntas veces aparece cada caracter en la cadena. La funci√≥n no debe diferenciar entre may√∫sculas y min√∫sculas y debe ignorar espacios. Utilice el siguiente ejemplo como validaci√≥n:\ncontar_caracteres(\"Ahora es mejor que nunca\")\n# {\"a\": 3, \"h\": 1, \"o\": 2, \"r\": 2, \"e\": 3, \"s\": 1, \"m\": 1, \"j\": 1, \"q\": 1, \"u\": 2, \"n\": 2, \"c\": 1}\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara saltear pasos de un bucle cuando se encuentra un espacio se puede utilizar la sentencia continue.\nfor i in ...:\n    # ... &lt;- Se ejecuta en todas las iteraciones\n    if condicion_de_salto:\n        continue\n    # ... &lt;- Se ejecuta en las iteraciones 'condicion_de_salto' es False",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#orden-de-m√©rito",
    "href": "practica/01_programacion_en_python/ejercicios.html#orden-de-m√©rito",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "5 Orden de m√©rito",
    "text": "5 Orden de m√©rito\nSe cuenta con una lista de tuplas que contienen las notas del examen final de Programaci√≥n 2 para un conjunto de alumnos:\nnotas = [\n    (\"Escalada\", 9),\n    (\"Alonso\", 7),\n    (\"P√©rez\", 8),\n    (\"Castro\", 8),\n    (\"Rossini\", 10),\n    (\"Mart√≠nez\", 9),\n    (\"P√©rez\", 6),\n    (\"Riquelme\", 5),\n]\n\nEscriba un programa que a partir de notas genere un diccionario donde las claves se corresponden con los apellidos y los valores con las notas del examen final.\nEscriba un programa que a partir de notas genere un diccionario donde las claves son las notas y el valor asociado sea una lista con los apellidos de quienes tuvieron esa nota.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#rendimento-acad√©mico",
    "href": "practica/01_programacion_en_python/ejercicios.html#rendimento-acad√©mico",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "6 Rendimento acad√©mico",
    "text": "6 Rendimento acad√©mico\nSe cuenta con el siguiente diccionario que asocia nombres de estudiantes con una lista de sus calificaciones:\nnotas = {\n    \"Ana\": [8, 9, 10],\n    \"Luis\": [6, 7, 8, 3, 9],\n    \"Carla\": [10, 9, 10],\n    \"Marcos\": [5, 6],\n    \"Sof√≠a\": [7, 7, 8],\n    \"Pedro\": [6, 4, 5, 6, 3, 8],\n    \"Luc√≠a\": [9, 8, 10, 9]\n}\nImplemente una funci√≥n que resuma el rendimiento acad√©mico de los estudiantes. La funci√≥n debe recibir el diccionario de notas y un argumento adicional llamado modo. Seg√∫n el valor de modo, se debe devolver un nuevo diccionario con la siguiente informaci√≥n:\n\nSi modo es \"promedio\", se debe devolver el promedio de notas por estudiante.\nSi modo es \"proporcion\", se debe devolver la proporci√≥n de ex√°menes aprobados por estudiante (se considera aprobado todo valor mayor o igual a 6).",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#√≠ndice-de-precios",
    "href": "practica/01_programacion_en_python/ejercicios.html#√≠ndice-de-precios",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "7 √çndice de precios",
    "text": "7 √çndice de precios\nSe cuenta con la serie mensual del √çndice de Precios al Consumidor (IPC) del a√±o 2024:\nipc_2024 = [20.6, 13.2, 11.0, 8.8, 4.2, 4.6, 4.0, 4.2, 3.5, 2.7, 2.4, 2.7]\nRealice los siguientes c√°lculos y an√°lisis:\n\nDetermine el menor y el mayor √≠ndice reportado durante el a√±o.\nCalcule el IPC promedio mensual del 2024.\nEncuentre la diferencia entre el IPC m√≠nimo y m√°ximo del a√±o.\n\n¬øEn qu√© mes se registr√≥ la inflaci√≥n m√°s alta?\n\nCalcule la inflaci√≥n mediana del 2024.\n¬øC√≥mo podr√≠a calcular el rango del IPC (diferencia entre el valor m√°ximo y m√≠nimo) sin usar las funciones min() ni max()?",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#res√∫menes-estad√≠sticos",
    "href": "practica/01_programacion_en_python/ejercicios.html#res√∫menes-estad√≠sticos",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "8 Res√∫menes estad√≠sticos",
    "text": "8 Res√∫menes estad√≠sticos\nCree funciones que, dada una lista de n√∫meros, calculen los siguientes res√∫menes estad√≠sticos:\n\nLa media \\[\n\\text{media}(X) = \\frac{1}{n}\\sum_{i=1}^n{x_i}\n\\]\nEl rango \\[\n\\text{rango}(X) = \\text{max}(X) - \\text{min}(X)\n\\]\nLa varianza \\[\n\\text{var}(X) = \\frac{1}{n}\\sum_{i=1}^n{(x_i - \\bar{x})^2}\n\\]\nEl desv√≠o est√°ndar \\[\n\\text{sd}(X) = \\sqrt{\\text{var}(X)}\n\\]\nLa mediana \\[\n\\begin{array}{lr}\n\\text{mediana}(X) = x_{(\\frac{n + 1}{2})} & \\text{Si } n \\text{ es impar} \\\\\n\\text{mediana}(X) = \\frac{x_{(\\frac{n}{2})} + x_{(\\frac{n}{2}+1)}}{2} & \\text{Si } n \\text{ es par}\n\\end{array}\n\\]\ndonde los \\(x_{(i)}\\) est√°n ordenados de manera ascendente.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#validaci√≥n-de-dni",
    "href": "practica/01_programacion_en_python/ejercicios.html#validaci√≥n-de-dni",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "9 Validaci√≥n de DNI",
    "text": "9 Validaci√≥n de DNI\nCrear una funci√≥n que dada una cadena de caracteres verifique si se corresponde con un DNI.\nSi es un DNI, devolver True. Caso contrario, devolver False.\nA tener en cuenta:\n\nAlgunos ejemplos de DNI v√°lidos\n\n40.094.127\n19053512\n6.392.780\n\nDNI no v√°lidos\n\n40,094,127\n19-053-512\n123456",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#la-f√≠sica-del-rebote",
    "href": "practica/01_programacion_en_python/ejercicios.html#la-f√≠sica-del-rebote",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "10 La f√≠sica del rebote",
    "text": "10 La f√≠sica del rebote\nUna pelota de goma es lanzada desde una altura inicial de 100 metros. Cada vez que toca el suelo, rebota alcanzando una altura equivalente a 3/5 de la altura desde la que cay√≥.\nEscriba un programa que imprima una tabla mostrando las alturas alcanzadas por la pelota en cada uno de sus primeros 10 rebotes.\nLuego, implemente este programa como una funci√≥n que reciba dos par√°metros:\n\nAltura inicial desde la que se lanza la pelota.\nCantidad de rebotes que se desea calcular.\n\nLa funci√≥n debe devolver una lista con las alturas alcanzadas en cada rebote.\n\nPunto extra\nModifique la funci√≥n para que considere un rebote como ‚Äúsignificativo‚Äù solo si la altura alcanzada es mayor o igual a un valor m√≠nimo especificado (por ejemplo, 1 cent√≠metro).\nSi la pelota no alcanza esta altura m√≠nima en alg√∫n rebote, se considera que ha completado su trayectoria y queda quieta. En este caso, la funci√≥n debe devolver √∫nicamente los valores correspondientes a los ‚Äúrebotes significativos‚Äù.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#un-mont√≥n-de-plata",
    "href": "practica/01_programacion_en_python/ejercicios.html#un-mont√≥n-de-plata",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "11 Un mont√≥n de plata",
    "text": "11 Un mont√≥n de plata\nUna ma√±ana pon√©s un billete en la vereda al lado del Monumento a la Bandera. A partir de ah√≠, cada d√≠a vas y duplic√°s la cantidad de billetes, apil√°ndolos prolijamente. ¬øCu√°nto tiempo pasa antes de que la pila de billetes sea m√°s alta que la del Monumento?\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nAlgunas constantes √∫tiles para resolver el problema:\nbillete_grosor = 0.11 * 0.001  # grosor de un billete en metros\naltura_monumento = 70          # altura en metros\nSugerencia: Usar un bucle while para realizar el c√°lculo.\n\n\n\n\nPunto extra\nEscribe una funci√≥n que permita determinar la cantidad de d√≠as necesarios para superar cualquier altura arbitraria.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#la-conjetura-de-collatz",
    "href": "practica/01_programacion_en_python/ejercicios.html#la-conjetura-de-collatz",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "12 La conjetura de Collatz",
    "text": "12 La conjetura de Collatz\nLa conjetura de Collatz dice:\n\nSi tomamos un n√∫mero natural cualquiera, su secuencia de Collatz termina llegando siempre al n√∫mero 1.\n\nSecuencia de Collatz:\n\nSi el n√∫mero es par, se divide entre 2.\nSi el n√∫mero es impar, se multiplica por 3 y se le suma 1.\n\n\\[\nf(n) =\n\\begin{cases}\n    \\displaystyle \\frac{n}{2} & \\text{si } n \\text{ es par,} \\\\ \\\\\n    3n + 1 & \\text{si } n \\text{ es impar.}\n\\end{cases}\n\\]\nEscribir una funci√≥n que calcule la secuencia de Collatz para un n√∫mero natural cualquiera.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\n\nUtilizar bucle while.\nEl bucle debe correr solo cuando el valor de la secuencia sigue siendo mayor a 1. Si es 1, hay que frenar.\nInsertar los elementos de la secuencia en una lista.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#adivina-el-n√∫mero",
    "href": "practica/01_programacion_en_python/ejercicios.html#adivina-el-n√∫mero",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "13 Adivina el n√∫mero",
    "text": "13 Adivina el n√∫mero\nEscriba un programa que implemente el cl√°sico juego ‚ÄúAdivina el n√∫mero‚Äù. El programa debe:\n\nTener un n√∫mero secreto (entero) que el usuario debe adivinar.\nSolicitar al usuario que ingrese un n√∫mero.\nSi el n√∫mero ingresado no coincide con el n√∫mero secreto:\n\nInformar si el n√∫mero ingresado es mayor o menor que el n√∫mero secreto.\nPedir al usuario que intente nuevamente.\n\nSi el usuario adivina el n√∫mero, el programa debe terminar mostrando un mensaje de felicitaciones.\n\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara generar n√∫meros aleatorios enteros en un rango dado puede utilizar randint() del m√≥dulo random:\nimport random\nrandom.randint(-100,¬†100)     # Genera un n√∫mero aleatorio entre -100 y 100\n\n\n\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nEl programa que resuelve este problema realiza una cantidad de iteraciones que se desconoce al momento de escribirlo. La soluci√≥n t√≠pica a este tipo de problema involucra el uso de while True junto a la sentencia break.\nwhile True:\n    # realizar alguna accion\n    if condicion_de_salida:\n        break\n\n\n\n\nPunto extra\nImplemente una versi√≥n de este programa donde el usuario cuenta con 10 intentos.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres-pythonico",
    "href": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres-pythonico",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "14 Conteo de caracteres Pythonico",
    "text": "14 Conteo de caracteres Pythonico\nLos diccionarios en Python cuentan con un m√©todo .get() que devuelve el valor asociado a una clave. Este m√©todo permite pasarle un segundo argumento con un valor que se devuelve cuando no se encuentra un elemento asociado a la clave que le pasamos. Por ejemplo:\nd = {\"a\": 1, \"b\": 20}\nd.get(\"b\", 0)\n20\nd.get(\"c\", 0)\n0\nModifique la funci√≥n contar_caracteres del ejercicio Conteo de caracteres utilizando el metodo .get() para obtener una implementaci√≥n m√°s sencilla. As√≠, deber√≠a poder eliminar el bloque if.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#validador-de-contrase√±as",
    "href": "practica/01_programacion_en_python/ejercicios.html#validador-de-contrase√±as",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "15 Validador de contrase√±as üò±",
    "text": "15 Validador de contrase√±as üò±\nEscriba un programa que solicite al usuario una contrase√±a y verifique que cumpla con las siguientes condiciones:\n\nDebe tener entre de 8 y 24 caracteres.\nDebe incluir letras, n√∫meros y caracteres especiales (@#$%^&*()).\n\nSi la contrase√±a no es v√°lida, el programa debe informar al usuario qu√© condici√≥n no se cumple y permitirle ingresar una nueva contrase√±a. El proceso se repite hasta que el usuario ingrese una contrase√±a v√°lida o decida no continuar.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres-ii",
    "href": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres-ii",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "16 Conteo de caracteres II üò±",
    "text": "16 Conteo de caracteres II üò±\nAgregue a la funci√≥n contar_frecuencias del ejercicio Conteo de caracteres un argumento llamado orden que admita los valores \"aparicion\", \"alfabetico\" y \"frecuencia\".\nEste argumento debe permitir ordenar las claves del diccionario resultante seg√∫n el siguiente criterio:\n\n\"aparicion\": mantiene el orden en que las palabras aparecen por primera vez en la lista original.\n\"alfabetico\": ordena las palabras alfab√©ticamente.\n\"frecuencia\": ordena las palabras por su frecuencia, de mayor a menor.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html",
    "href": "practica/01_programacion_en_python/autoevaluacion.html",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "",
    "text": "¬øQu√© valor contiene la variable contador luego de ejecutar el siguiente c√≥digo?\ncontador = 20\ncontador + 1\nComplete la siguiente tabla indicando si el nombre es v√°lido para una variable de Python.\n\n\n\nNombre\n¬øV√°lido?\nJustificaci√≥n\n\n\n\n\nbalance\n\n\n\n\nbalanceActual\n\n\n\n\nbalance-actual\n\n\n\n\nbalance actual\n\n\n\n\nbalance_actual\n\n\n\n\nmis.datos\n\n\n\n\n0cuenta\n\n\n\n\ncuenta0\n\n\n\n\n_cuenta\n\n\n\n\nSPAM\n\n\n\n\ncantidad$",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#variables",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#variables",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "",
    "text": "¬øQu√© valor contiene la variable contador luego de ejecutar el siguiente c√≥digo?\ncontador = 20\ncontador + 1\nComplete la siguiente tabla indicando si el nombre es v√°lido para una variable de Python.\n\n\n\nNombre\n¬øV√°lido?\nJustificaci√≥n\n\n\n\n\nbalance\n\n\n\n\nbalanceActual\n\n\n\n\nbalance-actual\n\n\n\n\nbalance actual\n\n\n\n\nbalance_actual\n\n\n\n\nmis.datos\n\n\n\n\n0cuenta\n\n\n\n\ncuenta0\n\n\n\n\n_cuenta\n\n\n\n\nSPAM\n\n\n\n\ncantidad$",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#n√∫meros",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#n√∫meros",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "2 N√∫meros",
    "text": "2 N√∫meros\n\n¬øCu√°l es el tipo de 10 / 2? ¬øPor qu√©?\n¬øCu√°l es el tipo de 5 * 2? ¬øPor qu√©?\n¬øPor qu√© 5 == 5.0 es True?",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#booleanos",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#booleanos",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "3 Booleanos",
    "text": "3 Booleanos\n\n¬øCu√°l es el resultado de las siguientes expresiones? ¬øPor qu√©?\nFalse or not False\nnot (True and True)\nnot True and True\n\"True\" != True\n10 &gt; 5 + 3\nNone is None\nFalse is False\nEjecute l√≠nea por l√≠nea los siguientes bloques y analice los resultados.\nint(True) * 50\nTrue * 50\n1 is True\nbool(1) is True\nid(True)\nid(bool(1))\nid(bool(1024))\n¬øCu√°les son los 3 operadores booleanos?",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#cadenas-de-caracteres",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#cadenas-de-caracteres",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "4 Cadenas de caracteres",
    "text": "4 Cadenas de caracteres\n\n¬øPor qu√© la siguiente comparaci√≥n resulta en True?\n\"spam\" + \"spamspam\" == \"spam\" * 3\n¬øPor qu√© la siguiente expresi√≥n resulta en un error? ¬øC√≥mo se puede arreglar?\n\"Me com√≠ \" + 6 + \" panchos.\"\n¬øEncuentra algo extra√±o en la siguiente expresi√≥n? ¬øC√≥mo la mejorar√≠a?\nmateria = \"Programaci√≥n 2\"\nprint(\"¬°Sean bienvenidos a la materia {materia}!\")\nExplique por qu√© es redundante utilizar str() en el siguiente bloque de c√≥digo:\nx, y = 10, 20\nprint(f\"La suma de {str(x)} y {str(y)} es: {str(x + y)}.\")\nConsidere el siguiente bloque de c√≥digo:\nmensaje = \"Hola, ¬øc√≥mo estes?\"\nmensaje[-3] = \"√°\"\n\n¬øCu√°l es la intenci√≥n detr√°s del programa?\n¬øPor qu√© no funciona?\n¬øC√≥mo podr√≠a arreglarlo? Alerta: la soluci√≥n no es muy elegante.\n\n¬øCu√°l es el resultado de list(\"abcdefgh\")? ¬øPor qu√©?\n¬øPor qu√© set(\"abcde\") es distinto de {\"abcde\"}?",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#funciones",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#funciones",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "5 Funciones",
    "text": "5 Funciones\n\n¬øCu√°l es la diferencia entre una funci√≥n y una llamada a funci√≥n?\n¬øCu√°l es el valor que devuelve una funci√≥n que no tiene return?\n¬øCu√°ndo se ejecuta el c√≥digo dentro de una funci√≥n: cuando la funci√≥n se define o cuando se la llama? Considere la siguiente funci√≥n:\ndef suma(x, y):\n    print(100 / 0)\n    return x + y\nLuego, ejecute el siguiente bloque:\nsuma(2, 4)",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#listas",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#listas",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "6 Listas",
    "text": "6 Listas\n\n¬øQu√© es []? ¬øCu√°l es el resultado de len([])?\n¬øPor qu√© la siguiente expresi√≥n resulta en False? Ayuda: use la funci√≥n id().\n[] is []\n¬øPor qu√© se obtiene un error en el siguiente bloque de c√≥digo?\nl = []\nl[0]\nSi [0][0] devuelve 0, ¬øpor qu√© [1][1] no devuelve [1]?\n¬øCu√°l es el valor de x en el siguiente bloque de c√≥digo? ¬øPor qu√©?\nl = [\"hola\", \"hola hola\", \"hasta luego\"]\nx = l.remove(\"hola\")\n¬øC√≥mo le asignar√≠a el valor \"hola\" como el tercer valor en una lista almacenada en una variable llamada cosas? Asuma que cosas contiene [2, 4, 6, 8, 10].\nAsuma que letras contiene la lista [\"a\", \"b\", \"c\", \"d\"]:\n\n¬øA qu√© eval√∫a letras[-1]?\n¬øA qu√© eval√∫a letras[:2]?\n¬øA qu√© eval√∫a letras[int(int('3' * 2) // 11)]? ¬øEs necesario usar dos veces int()?\n\nAsuma que bartulos contiene la lista [3.14, \"casa\", 11, \"casa\", True]:\n\n¬øA qu√© eval√∫a bartulos.index(\"casa\")? ¬øPor qu√©?\n¬øC√≥mo queda la lista en bartulos despu√©s de ejecutar bartulos.append(99)?\n¬øC√≥mo queda la lista en bartulos despu√©s de ejecutar bartulos.remove(\"casa\"') ?¬øPor qu√©?\n\n¬øCu√°les son los operadores para la concatenaci√≥n y la replicaci√≥n de listas?\n¬øCu√°l es la diferencia entre los m√©todos append() e insert() de las listas?\n¬øCu√°les son dos formas de eliminar valores de una lista?\nEl siguiente bloque de c√≥digo imprime ['a', 'b', True, 30]. ¬øPor qu√©?\ncosas = [\"a\", \"b\", True]\nbartulos = cosas\nbartulos.append(20 + 10)\nprint(cosas)\nConsidere el siguiente bloque de c√≥digo:\nmarcas = [\"Milka\", \"Cofler\", \"√Åguila\", \"Cadbury\", \"Lindt\", \"Toblerone\", \"After Eight\"]\nmarcas[2:5]\nque correctamente muestra [\"√Åguila\", \"Cadbury\", \"Lindt\"]. ¬øPor qu√© el siguiente bloque de c√≥digo no funciona?\nmarcas = [\"Milka\", \"Cofler\", \"√Åguila\", \"Cadbury\", \"Lindt\", \"Toblerone\", \"After Eight\"]\nindices = 2:5\nmarcas[indices]",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#tuplas",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#tuplas",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "7 Tuplas",
    "text": "7 Tuplas\n\n¬øPor qu√© la tupla no implementa un m√©todo similar al m√©todo .extend() de las listas?\nLas tuplas de Python son conocidas por ser inmutables. Por ejemplo, el siguiente bloque de c√≥digo resulta en un error:\ntupla = (1, 2, 3)\ntupla[1] = 10\nSin embargo, el siguiente bloque no arroja ning√∫n error y pareciera que se logra modificar la tupla exitosamente:\nbartulos = [\"Hola\", 10, None]\ntupla = (1, bartulos, 3)\n\ntupla[1].append(\"¬°Sorpesa!\")\n\nprint(tupla)\n¬øQu√© pas√≥?",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#diccionarios",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#diccionarios",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "8 Diccionarios",
    "text": "8 Diccionarios\n\n¬øC√≥mo se escribe en c√≥digo un diccionario vac√≠o?\n¬øC√≥mo se ve un diccionario que tiene la clave \"cosa\" y el valor 15?\n¬øCu√°l es la principal diferencia entre un diccionario y una lista?\n¬øQu√© ocurre si se intenta acceder a bartulos[\"cosa\"] cuando bartulos es {\"coso\": 100}?\nSi un diccionario est√° almacenado en bartulos, ¬øcu√°l es la diferencia entre las siguientes expresiones?\n\"cosa\" in bartulos\n\"cosa\" in bartulos.keys()\nSuponga el diccionario datos = {\"nombre\": \"Juan\"}. ¬øPor qu√© la siguiente expresi√≥n resulta en False?\n\"Juan\" in datos",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#control-de-flujo",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#control-de-flujo",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "9 Control de flujo",
    "text": "9 Control de flujo\n\n9.1 Condicionales\n\nExplique qu√© es una condici√≥n y en qu√© situaciones se utilizar√≠a.\nIdentifique los tres bloques de c√≥digo en el siguiente ejemplo:\ncodigo = 0\n\nif codigo == 10:\n    print(\"mensaje 1\")\n    if codigo &gt; 5:\n        print(\"mensaje 2\")\n    else:\n        print(\"mensaje alternativo\")\n    print(\"mensaje final\")\n\nprint(\"Fin del programa\")\n¬øTienen sentido las comparaciones utilizadas?\n¬øCu√°l es el problema con el siguiente programa? Proponga una soluci√≥n.\nnumero = 10\nif numero &lt; 0:\n    print(f\"El numero {numero} es negativo\")\nelif numero &lt; -5:\n    print(f\"El numero {numero} es menor a -5\")\nelif numero &gt; 0:\n    print(f\"El numero {numero} es positivo\")\nelse:\n    print(f\"El numero {numero} es 0\")\n\n\n\n9.2 Bucles\n\nConsidere el siguiente programa:\nfor i in range(10):\n    print(i)\nEscriba un programa que realice la misma tarea utilizando un bucle while.\n¬øCu√°l es la diferencia entre range(10), range(0, 10) y range(0, 10, 1) en un bucle for?\nSuponga que numeros es una lista que contiene numeros enteros, ¬øen qu√© se diferencian los siguientes bloques de c√≥digo?\nfor i in numeros:\n    if i % 2 == 0:\n        break\n    print(i)\nfor i in numeros:\n    if i % 2 == 0:\n        continue\n    print(i)\n¬øEs posible re-escribir el siguiente bloque de c√≥digo usando while True? ¬øQu√© modificaciones habr√≠a que hacer?\nsuma = 0\ni = 0\nwhile suma &lt;= limite:\n    suma += numeros[i]\n    i += 1",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  }
]