[
  {
    "objectID": "practica/01_programacion_en_python/problemas.html",
    "href": "practica/01_programacion_en_python/problemas.html",
    "title": "üß© Problemas",
    "section": "",
    "text": "En criptograf√≠a, el cifrado C√©sar es una de las t√©cnicas de cifrado m√°s simples y m√°s usadas.\nEs un tipo de cifrado en el que una letra en el texto original es reemplazada por otra letra que se encuentra un n√∫mero fijo de posiciones m√°s adelante en el alfabeto.\nPor ejemplo, con un desplazamiento de 3, la A ser√≠a sustituida por la D (situada 3 lugares a la derecha de la A), la B ser√≠a reemplazada por la E, etc.\n\n\n\n\n\nEscriba una funci√≥n, y luego un script, que permita cifrar y descifrar cadenas usando el cifrado C√©sar con un n√∫mero arbitrario de posiciones.\nDos funciones incluidas con Python que pueden ser √∫tiles para esta tarea son ord(), que convierte caracteres num√©ricos a n√∫meros, y chr(), que realiza la operaci√≥n inversa.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara el cifrado de un √∫nico caracter:\n\nDefinir un desplazamiento, por ejemplo 3.\nConvertir el caracter a n√∫mero usando ord().\nSumarle desplazamiento.\nFinalmente, convertirlo a caracter nuevamente utilizando chr().\n\nY para el descifrado:\n\nConvertir el caracter a n√∫mero.\nRestarle desplazamiento.\nConvertirlo a caracter nuevamente utilizando chr().\n\nAs√≠, se deber√≠a recuperar el caracter definido al principio.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üß© Problemas"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/problemas.html#cifrado-c√©sar",
    "href": "practica/01_programacion_en_python/problemas.html#cifrado-c√©sar",
    "title": "üß© Problemas",
    "section": "",
    "text": "En criptograf√≠a, el cifrado C√©sar es una de las t√©cnicas de cifrado m√°s simples y m√°s usadas.\nEs un tipo de cifrado en el que una letra en el texto original es reemplazada por otra letra que se encuentra un n√∫mero fijo de posiciones m√°s adelante en el alfabeto.\nPor ejemplo, con un desplazamiento de 3, la A ser√≠a sustituida por la D (situada 3 lugares a la derecha de la A), la B ser√≠a reemplazada por la E, etc.\n\n\n\n\n\nEscriba una funci√≥n, y luego un script, que permita cifrar y descifrar cadenas usando el cifrado C√©sar con un n√∫mero arbitrario de posiciones.\nDos funciones incluidas con Python que pueden ser √∫tiles para esta tarea son ord(), que convierte caracteres num√©ricos a n√∫meros, y chr(), que realiza la operaci√≥n inversa.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara el cifrado de un √∫nico caracter:\n\nDefinir un desplazamiento, por ejemplo 3.\nConvertir el caracter a n√∫mero usando ord().\nSumarle desplazamiento.\nFinalmente, convertirlo a caracter nuevamente utilizando chr().\n\nY para el descifrado:\n\nConvertir el caracter a n√∫mero.\nRestarle desplazamiento.\nConvertirlo a caracter nuevamente utilizando chr().\n\nAs√≠, se deber√≠a recuperar el caracter definido al principio.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üß© Problemas"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/problemas.html#n√∫meros-aleatorios",
    "href": "practica/01_programacion_en_python/problemas.html#n√∫meros-aleatorios",
    "title": "üß© Problemas",
    "section": "2 N√∫meros aleatorios",
    "text": "2 N√∫meros aleatorios\nConstruya un programa en Python que genere una cantidad determinada de n√∫meros aleatorios uniformes dentro de un rango definido por el usuario. El programa debe:\n\nSolicitar al usuario la cantidad de n√∫meros a generar y los valores m√≠nimo y m√°ximo del rango.\nGenerar los n√∫meros aleatorios\nGuardar los n√∫meros en un archivo de texto, uno por l√≠nea.\nOfrecer la opci√≥n de mostrar un resumen estad√≠stico con m√≠nimo, m√°ximo, media y desv√≠o est√°ndar, solo si el usuario lo solicita.\n\nPara resolver este problema utilice el m√≥dulo random y las funciones desarrolladas en el ejercicio Res√∫menes estad√≠sticos guardadas en un m√≥dulo llamado estadistica.py.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üß© Problemas"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/problemas.html#mensaje-al-descubierto",
    "href": "practica/01_programacion_en_python/problemas.html#mensaje-al-descubierto",
    "title": "üß© Problemas",
    "section": "3 Mensaje al descubierto",
    "text": "3 Mensaje al descubierto\nResulta que Franco, un amigo que estudia Ciencias de la Computaci√≥n en la FCEIA, te env√≠a por WhatsApp un archivo de texto plano con mensajes ‚Äúencriptados‚Äù usando caracteres sobrantes y s√≠mbolos extra√±os:\n    !!!,.,  aY??/u/DAM**e,, se =m!!e\n&&M&&e v!o!?LV...I.O /L/*oC/*o\n        __?e_?l//+ T++**e/*Cl!?aD==*O**\nTiene sentido pensar que est√° experimentando con nuevos algoritmos de cifrado y, de paso, te lanza el reto de descifrarlo.\nTu misi√≥n es escribir un programa que:\n\nLea un archivo de texto plano cualquiera.\nMuestre en pantalla su contenido original (tal cual llega).\nAplique un proceso de limpieza basado en las siguientes reglas:\n\nEliminar todos los caracteres +, *, -, /, =, !, ?, & y _.\nReemplazar cualquier secuencia de espacios m√∫ltiples por un solo espacio.\nHomogeinizar la capitalizaci√≥n de los caracteres.\nConservar los saltos de l√≠nea tal cual aparecen en el archivo original.\n\nMuestre en pantalla la versi√≥n desencriptada del texto.\nGuarde la versi√≥n limpia en un nuevo archivo de texto.\n\nEl usuario debe poder especificar el nombre del archivo de salida.\nSi no lo hace, se generar√° uno con el sufijo _limpio antes de la extensi√≥n original (por ejemplo, secreto.txt ‚Üí secreto_limpio.txt).",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üß© Problemas"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/problemas.html#c√≥digo-morse",
    "href": "practica/01_programacion_en_python/problemas.html#c√≥digo-morse",
    "title": "üß© Problemas",
    "section": "4 C√≥digo Morse",
    "text": "4 C√≥digo Morse\nEl c√≥digo Morse es un sistema utilizado para representar letras mediante combinaciones espec√≠ficas de se√±ales cortas y largas, denominadas puntos (.) y rayas (-). A continuaci√≥n se muestra un diccionario con el mapeo de caracteres alfab√©ticos, d√≠gitos del 0 al 9 y algunos s√≠mbolos de puntuaci√≥n comunes:\nmapeo_morse = {\n    \"A\": \".-\",\n    \"B\": \"-...\",\n    \"C\": \"-.-.\",\n    \"D\": \"-..\",\n    \"E\": \".\",\n    \"F\": \"..-.\",\n    \"G\": \"--.\",\n    \"H\": \"....\",\n    \"I\": \"..\",\n    \"J\": \".---\",\n    \"K\": \"-.-\",\n    \"L\": \".-..\",\n    \"M\": \"--\",\n    \"N\": \"-.\",\n    \"O\": \"---\",\n    \"P\": \".--.\",\n    \"Q\": \"--.-\",\n    \"R\": \".-.\",\n    \"S\": \"...\",\n    \"T\": \"-\",\n    \"U\": \"..-\",\n    \"V\": \"...-\",\n    \"W\": \".--\",\n    \"X\": \"-..-\",\n    \"Y\": \"-.--\",\n    \"Z\": \"--..\",\n    \"1\": \".----\",\n    \"2\": \"..---\",\n    \"3\": \"...--\",\n    \"4\": \"....-\",\n    \"5\": \".....\",\n    \"6\": \"-....\",\n    \"7\": \"--...\",\n    \"8\": \"---..\",\n    \"9\": \"----.\",\n    \"0\": \"-----\",\n    \", \": \"--..--\",\n    \".\": \".-.-.-\",\n}\nEscriba una funci√≥n en Python que permita convertir cualquier palabra a c√≥digo Morse utilizando este diccionario. Luego, escriba otra funci√≥n que haga exactamente lo contrario: dada una secuencia en c√≥digo Morse, debe recuperar la palabra original. Finalmente, incorpore ambas funciones en un script principal que combine ambas funciones y permita encriptar o desencriptar texto desde un archivo de texto plano. El programa debe recibir:\n\nEl nombre del archivo de entrada.\nEl nombre del archivo de salida.\nLa operaci√≥n a realizar (encriptar o desencriptar).\n\nAyuda: Para indicar espacios en c√≥digo Morse utilice /.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üß© Problemas"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/07_scripting.html",
    "href": "teoria/01_programacion_en_python/07_scripting.html",
    "title": "7 - Scripting",
    "section": "",
    "text": "En programaci√≥n, un script es un archivo de texto que contiene una secuencia l√≥gica de pasos que se pueden ejecutar para realizar una tarea espec√≠fica, ya sea simple o compleja. Esta serie de pasos suele expresarse en un lenguaje de scripting, un lenguaje de programaci√≥n que permite manipular, personalizar y automatizar tareas.\nA diferencia de los programas compilados, los scripts suelen interpretarse en tiempo de ejecuci√≥n. Es decir, un int√©rprete se encarga de leer, procesar y ejecutar cada instrucci√≥n en orden.\nEn el caso de Python, un script es un archivo con extensi√≥n .py que puede automatizar procesos, analizar datos, crear aplicaciones o pr√°cticamente cualquier otra tarea que el lenguaje permita. El int√©rprete de Python ejecuta el c√≥digo l√≠nea por l√≠nea, lo que facilita probar, modificar y reutilizar el programa de manera √°gil\nDebido a su uso frecuente para desarrollar scripts, Python es conocido tambi√©n como un lenguaje de scripting, aunque en la pr√°ctica su uso sea mucho m√°s amplio.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "7 - _Scripting_"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/07_scripting.html#qu√©-es-un-script",
    "href": "teoria/01_programacion_en_python/07_scripting.html#qu√©-es-un-script",
    "title": "7 - Scripting",
    "section": "",
    "text": "En programaci√≥n, un script es un archivo de texto que contiene una secuencia l√≥gica de pasos que se pueden ejecutar para realizar una tarea espec√≠fica, ya sea simple o compleja. Esta serie de pasos suele expresarse en un lenguaje de scripting, un lenguaje de programaci√≥n que permite manipular, personalizar y automatizar tareas.\nA diferencia de los programas compilados, los scripts suelen interpretarse en tiempo de ejecuci√≥n. Es decir, un int√©rprete se encarga de leer, procesar y ejecutar cada instrucci√≥n en orden.\nEn el caso de Python, un script es un archivo con extensi√≥n .py que puede automatizar procesos, analizar datos, crear aplicaciones o pr√°cticamente cualquier otra tarea que el lenguaje permita. El int√©rprete de Python ejecuta el c√≥digo l√≠nea por l√≠nea, lo que facilita probar, modificar y reutilizar el programa de manera √°gil\nDebido a su uso frecuente para desarrollar scripts, Python es conocido tambi√©n como un lenguaje de scripting, aunque en la pr√°ctica su uso sea mucho m√°s amplio.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "7 - _Scripting_"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/07_scripting.html#script-vs-m√≥dulo",
    "href": "teoria/01_programacion_en_python/07_scripting.html#script-vs-m√≥dulo",
    "title": "7 - Scripting",
    "section": "Script vs m√≥dulo",
    "text": "Script vs m√≥dulo\nPython es un lenguaje de programaci√≥n interpretado, y por ello sus programas suelen denominarse scripts. Sin embargo, no siempre es correcto usar este t√©rmino. Si bien muchos programas en Python consisten en instrucciones destinadas a resolver tareas puntuales, otros programas tienen por objetivo principal implementar herramientas que luego van a ser utilizadas por otros programas.\nUn programa de Python puede denominarse script o m√≥dulo. El prop√≥sito del c√≥digo en un archivo de texto .py es lo que determina si lo llamamos de una manera o de la otra. Cuando un archivo contiene c√≥digo ejecutable cuyo fin es realizar una tarea espec√≠fica, se lo considera script. En cambio, cuando el archivo est√° dise√±ado para ser importado y utilizado desde otro programa de Python, se lo denomina m√≥dulo.\nEn s√≠ntesis, la principal diferencia entre un m√≥dulo y un script es que los m√≥dulos almacenan c√≥digo importable mientras que los scripts contienen c√≥digo ejecutable.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "7 - _Scripting_"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/07_scripting.html#script-y-m√≥dulo",
    "href": "teoria/01_programacion_en_python/07_scripting.html#script-y-m√≥dulo",
    "title": "7 - Scripting",
    "section": "Script y m√≥dulo",
    "text": "Script y m√≥dulo\nPython es un lenguaje tan flexible que un mismo programa puede funcionar como script y como m√≥dulo al mismo tiempo. Esto ocurre cuando el archivo define herramientas reutilizables (por ejemplo, funciones o clases) y, adem√°s, incluye c√≥digo que se ejecuta directamente al correrlo desde la l√≠nea de comandos.\nPara ilustrarlo, consideremos un peque√±o programa en Python que solicita una fecha al usuario y luego indica cu√°ntos d√≠as faltan para llegar a ella:\n\n\ncalcular_dias.py\n\nfrom datetime import datetime\n\ndef diferencia_dias(fecha_str):\n    fecha = datetime.strptime(fecha_str, \"%Y-%m-%d\").date()\n    hoy = datetime.today().date()\n    diferencia = (fecha - hoy).days\n    return diferencia\n\nfecha_str = input(\"Ingres√° una fecha (formato AAAA-MM-DD): \")\ndiferencia = diferencia_dias(fecha_str)\n\nif diferencia &gt; 0:\n    print(f\"Faltan {diferencia} d√≠as para el {fecha_str}.\")\nelif diferencia == 0:\n    print(\"¬°La fecha es hoy!\")\nelse:\n    print(f\"Esa fecha ya pas√≥ hace {-diferencia} d√≠as.\")\n\nDebajo se muestra una animaci√≥n de la ejecuci√≥n de este script en la terminal:\n\n\n\n\n\nAhora, supongamos que queremos importar la funci√≥n diferencia_dias en otro programa de Python.\n\n\n\n\n\nCuando importamos una funci√≥n del m√≥dulo calcular_dias, observamos que Python tambi√©n ejecuta la parte del programa que solicita una fecha y muestra cu√°ntos d√≠as faltan para alcanzarla.\nEsto ocurre porque, al importar un m√≥dulo (o cualquier objeto definido en √©l), Python ejecuta todo el c√≥digo del archivo de principio a fin, sin importar qu√© elementos en particular estemos importando.\nPara evitar este comportamiento no deseado, y permitir que un mismo archivo pueda funcionar tanto como m√≥dulo reutilizable como script ejecutable, se encapsula la parte que debe ejecutarse solo al correr el archivo directamente dentro del siguiente bloque:\nif __name__ == \"__main__\":\n    # c√≥digo ejecutable\nCon esta estructura, el c√≥digo dentro de ese bloque se ejecutar√° √∫nicamente cuando el archivo se ejecute directamente como programa, y no cuando se lo importe desde otro m√≥dulo.\nDe esta manera, nuestro programa actualizado quedar√≠a as√≠:\n\n\ncalcular_dias.py\n\nfrom datetime import datetime\n\ndef diferencia_dias(fecha_str):\n    fecha = datetime.strptime(fecha_str, \"%Y-%m-%d\").date()\n    hoy = datetime.today().date()\n    diferencia = (fecha - hoy).days\n    return diferencia\n\nif __name__ == \"__main__\":\n    fecha_str = input(\"Ingres√° una fecha (formato AAAA-MM-DD): \")\n    diferencia = diferencia_dias(fecha_str)\n\n    if diferencia &gt; 0:\n        print(f\"Faltan {diferencia} d√≠as para el {fecha_str}.\")\n    elif diferencia == 0:\n        print(\"¬°La fecha es hoy!\")\n    else:\n        print(f\"Esa fecha ya pas√≥ hace {-diferencia} d√≠as.\")\n\nAhora, cuando se importa cualquier objeto desde calcular_dias, Python no ejecuta la parte del programa que interact√∫a con el usuario.\n\n\n\n\n\n\n\n\n\n\n\nLa variable especial __name__ üè∑Ô∏è\n\n\n\nLa variable __name__ es una variable especial que indica el nombre del m√≥dulo actual. Cuando un archivo Python se ejecuta directamente, __name__ toma el valor \"__main__\", lo que indica que es el m√≥dulo principal. En cambio, si el archivo se importa como un m√≥dulo en otro script, __name__ contendr√° el nombre del archivo (sin la extensi√≥n .py).",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "7 - _Scripting_"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/07_scripting.html#clis-con-argparse",
    "href": "teoria/01_programacion_en_python/07_scripting.html#clis-con-argparse",
    "title": "7 - Scripting",
    "section": "CLIs con argparse",
    "text": "CLIs con argparse\nargparse es un m√≥dulo de la librer√≠a est√°ndar de Python que sirve para crear interfaces de l√≠nea de comandos (CLIs, por sus siglas en ingl√©s).\nCon este m√≥dulo se pueden definir qu√© argumentos y opciones acepta nuestra programa. Luego, Python se encargar√° de:\n\nLeerlos desde la terminal al ejecutar el script.\nConvertirlos al tipo de dato indicado (int, float, str, etc.).\nValidarlos seg√∫n las reglas definidas.\nGenerar un mensaje de ayuda (--help) sin que tengamos que hacer nada.\n\n\nEjemplo: saludos personalizados\nEl siguiente programa recibe el nombre de una persona como argumento obligatorio y, de manera opcional, la cantidad de veces que se la debe saludar.\nimport argparse\n\nparser = argparse.ArgumentParser(description=\"Saluda a una persona\")\nparser.add_argument(\"nombre\", help=\"El nombre de la persona\") # Argumento posicional\nparser.add_argument(\"--veces\", type=int, default=1, help=\"Cu√°ntas veces saludar\") # Argumento nombrado\n\nargs = parser.parse_args()\n\nfor _ in range(args.veces):\n    print(f\"¬°Hola, {args.nombre}!\")\nLuego, en la terminal:\npython hola.py Tom√°s\n¬°Hola, Tom√°s!\nY si usamos el argumento --veces:\npython hola.py Tom√°s --veces 3\n¬°Hola, Tom√°s!\n¬°Hola, Tom√°s!\n¬°Hola, Tom√°s!\nLa ayuda se puede ver de la siguiente manera:\npython hola.py --help\nusage: hola.py [-h] [--veces VECES] nombre\n\nSaluda a una persona\n\npositional arguments:\n  nombre         El nombre de la persona\n\noptions:\n  -h, --help     show this help message and exit\n  --veces VECES  Cu√°ntas veces saludar\nSi usamos un valor de tipo err√≥neo para --veces, obtenemos un error informativo de manera autom√°tica:\npython hola.py Tom√°s --veces 3.5\nusage: hola.py [-h] [--veces VECES] nombre\nhola.py: error: argument --veces: invalid int value: '3.5'\n\n\n\n\n\n\ninput() vs argparse\n\n\n\nTanto input() como ArgumentParser de argparse permiten pasar datos a nuestro script. La diferencia entre ellos es que input() se usa para pedir datos mientras corre el programa, mientras que el m√≥dulo argparse se usa apra pedir datos al momento de ejecutar el programa desde al terminal.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "7 - _Scripting_"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html",
    "href": "teoria/01_programacion_en_python/02_funciones.html",
    "title": "2 - Funciones",
    "section": "",
    "text": "Una funci√≥n puede pensarse como un ‚Äúmini-programa‚Äù dentro de un programa m√°s grande. Su prop√≥sito es cumplir una tarea u objetivo espec√≠fico, de forma independiente del resto del c√≥digo.\nEl uso de funciones tiene varias ventajas:\n\nReutilizaci√≥n de c√≥digo: se define una sola vez y se ejecuta cuando sea necesario.\nMejor organizaci√≥n: dividen el programa en partes m√°s f√°ciles de leer y mantener.\nModularidad: permiten construir programas como bloques independientes que pueden combinarse entre s√≠ (¬°funciones dentro de funciones!).\n\nConsideremos el siguiente caso donde se busca calcuar el precio final de un producto, considerando impuestos y descuentos.\n\nprecio_base = 800   # Precio del producto ($800)\nimpuesto = 0.21     # Impuesto (21%)\ndescuento = 0.10    # Descuento (10%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n871.2\n\n\n¬øQu√© pasa si queremos calcular el precio final para otros productos con diferentes precios, impuestos o descuentos?\nUna opci√≥n es repetir el c√≥digo tantas veces como sea necesario‚Ä¶\n\nprecio_base = 500   # Precio del producto ($500)\nimpuesto = 0.105    # Impuesto (10.5%)\ndescuento = 0.0     # Descuento (0%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n552.5\n\n\n\nprecio_base = 2000  # Precio del producto ($2000)\nimpuesto = 0.21     # Impuesto (21%)\ndescuento = 0.20    # Descuento (20%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n1936.0\n\n\nOtra opci√≥n, mucho mas conveniente, es utilizar funciones.\n\ndef calcular_precio(precio_base, impuesto, descuento):\n    resultado = precio_base * (1 + impuesto) * (1 - descuento)\n    return resultado\n\nLuego, para utilizar la funci√≥n simplemente la llamamos (o invocamos).\n\ncalcular_precio(800, 0.21, 0.10)\n\n871.2\n\n\nTambi√©n es posible indicar los valores de los argumentos utilizando sus nombres.\n\ncalcular_precio(precio_base=2000, impuesto=0.21, descuento=0.20)\n\n1936.0",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#qu√©-es-una-funci√≥n",
    "href": "teoria/01_programacion_en_python/02_funciones.html#qu√©-es-una-funci√≥n",
    "title": "2 - Funciones",
    "section": "",
    "text": "Una funci√≥n puede pensarse como un ‚Äúmini-programa‚Äù dentro de un programa m√°s grande. Su prop√≥sito es cumplir una tarea u objetivo espec√≠fico, de forma independiente del resto del c√≥digo.\nEl uso de funciones tiene varias ventajas:\n\nReutilizaci√≥n de c√≥digo: se define una sola vez y se ejecuta cuando sea necesario.\nMejor organizaci√≥n: dividen el programa en partes m√°s f√°ciles de leer y mantener.\nModularidad: permiten construir programas como bloques independientes que pueden combinarse entre s√≠ (¬°funciones dentro de funciones!).\n\nConsideremos el siguiente caso donde se busca calcuar el precio final de un producto, considerando impuestos y descuentos.\n\nprecio_base = 800   # Precio del producto ($800)\nimpuesto = 0.21     # Impuesto (21%)\ndescuento = 0.10    # Descuento (10%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n871.2\n\n\n¬øQu√© pasa si queremos calcular el precio final para otros productos con diferentes precios, impuestos o descuentos?\nUna opci√≥n es repetir el c√≥digo tantas veces como sea necesario‚Ä¶\n\nprecio_base = 500   # Precio del producto ($500)\nimpuesto = 0.105    # Impuesto (10.5%)\ndescuento = 0.0     # Descuento (0%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n552.5\n\n\n\nprecio_base = 2000  # Precio del producto ($2000)\nimpuesto = 0.21     # Impuesto (21%)\ndescuento = 0.20    # Descuento (20%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n1936.0\n\n\nOtra opci√≥n, mucho mas conveniente, es utilizar funciones.\n\ndef calcular_precio(precio_base, impuesto, descuento):\n    resultado = precio_base * (1 + impuesto) * (1 - descuento)\n    return resultado\n\nLuego, para utilizar la funci√≥n simplemente la llamamos (o invocamos).\n\ncalcular_precio(800, 0.21, 0.10)\n\n871.2\n\n\nTambi√©n es posible indicar los valores de los argumentos utilizando sus nombres.\n\ncalcular_precio(precio_base=2000, impuesto=0.21, descuento=0.20)\n\n1936.0",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#definici√≥n-de-funciones",
    "href": "teoria/01_programacion_en_python/02_funciones.html#definici√≥n-de-funciones",
    "title": "2 - Funciones",
    "section": "Definici√≥n de funciones",
    "text": "Definici√≥n de funciones\nAnalicemos las diferentes partes que forman la definici√≥n de una funci√≥n en Python:\n\n\n\n\n\n\nLa palabra clave def:\n\nMarca el inicio de la definici√≥n de una funci√≥n.\nEs una palabra reservada (keyword).\n\nEl nombre de la funci√≥n:\n\nDebe seguir las mismas reglas que los nombres de las variables.\n\nLos argumentos de la funci√≥n, dentro de par√©ntesis:\n\nSe separan por comas y pueden ser 0 o m√°s.\n\nLos dos puntos (:):\n\nIndican el final de la l√≠nea de definici√≥n y el inicio del bloque de c√≥digo.\n\nEl bloque de c√≥digo, que es el cuerpo de la funci√≥n:\n\nEs el c√≥digo que se ejecuta cada vez que llamamos a la funci√≥n.\n\nLa sentencia return que indica el resultado que devuelve la funci√≥n.\n\nLuego del return viene el valor o nombre de la variable a devolver.\nEs opcional (ya vamos a ver ejemplos).\n\n\n\n\n\n\n\n\nObservaci√≥n üëÄ\n\n\n\nEn R se tiene que asignar de manera expl√≠cita una funci√≥n a una variable. Por ejemplo:\nsumar &lt;- function(x, y) {\n    return(x + y)\n}\nEn cambio, en Python, la sentencia def define la funci√≥n y le asigna un nombre en un mismo paso.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#ejemplos",
    "href": "teoria/01_programacion_en_python/02_funciones.html#ejemplos",
    "title": "2 - Funciones",
    "section": "Ejemplos",
    "text": "Ejemplos\n\n1. Suma de n√∫meros\nComencemos con una funci√≥n super sencilla. La misma se llama sumar, recibe dos argumentos x e y, y devuelve la suma de ambos.\n\ndef sumar(x, y):\n    return x + y\n\n\nsumar(15, 21.9)\n\n36.9\n\n\n\ntype(sumar(15, 21.9))\n\nfloat\n\n\nEl valor que devuelve puede ser tratado como cualquier valor en Python. Por ejemplo, se lo puede asignar a una variable.\n\nresultado = sumar(10, 11)\nresultado\n\n21\n\n\nY el valor de esa variable puede ser luego pasado a una nueva llamada a sumar() (o a cualquier otra funci√≥n).\n\nsumar(resultado, 2.55)\n\n23.55\n\n\nIncluso es posible pasar expresiones y llamadas a funciones a la hora de pasar un argumento:\n\nsumar(sumar(1, 2), 3)\n\n6\n\n\nEn la l√≠nea sumar(sumar(1, 2), 3), Python comienza evaluando la funci√≥n sumar(). Pero para poder hacerlo, primero necesita conocer los valores de los argumentos. Al revisar el primer argumento, detecta que no es un valor directamente, sino otra llamada a la funci√≥n sumar(1, 2), por lo que la eval√∫a primero. El resultado de esa operaci√≥n es 3, que se toma como valor del primer argumento de la llamada externa. El segundo argumento ya est√° dado: tambi√©n es 3. Entonces, Python invoca la funci√≥n sumar() con los argumentos 3 y 3, cuyo resultado es 6. Finalmente, ese valor se muestra en pantalla.\n\n\n2. Saludo personalizado\nOtro ejemplo sencillo consiste en una funci√≥n que recibe un nombre e imprime un saludo en pantalla.\n\ndef saludar(nombre):\n    print(\"Hola\", nombre)\n\n\nsaludar(\"Pablo\")\n\nHola Pablo\n\n\nEsta funci√≥n no devuelve un resultado, sino que utiliza el argumento recibido para mostrar un mensaje en pantalla.\n\nsaludar(\"Juan\" + \" Manuel\")\n\nHola Juan Manuel\n\n\n\n\n3. Sin par√°metros\nY podemos tener funciones que no utilicen ning√∫n argumento.\n\ndef decir_hola():\n    print(\"¬°Hola!\")\n\n\ndecir_hola()\ndecir_hola()\ndecir_hola()\n\n¬°Hola!\n¬°Hola!\n¬°Hola!\n\n\n\n\n4. Devoluci√≥n de m√∫ltiples valores\nEn Python, las funciones pueden devolver m√∫ltiples valores separ√°ndolos por comas en la sentencia return. Por ejemplo:\n\ndef potencias(x):\n    cuadrado = x ** 2\n    cubo = x ** 3\n    return cuadrado, cubo\n\npotencias(2)\n\n(4, 8)\n\n\nEl resultado de este tipo de funciones puede ser asignado a m√∫ltiples variables. De esta forma, podemos obtener el cuadrado y el cubo de un n√∫mero con una sola llamada a una funci√≥n.\n\ncuadrado, cubo = potencias(8)\nprint(cuadrado)\nprint(cubo)\n\n64\n512\n\n\n\n\n\n\n\n\nObservaci√≥n üëÄ\n\n\n\nAl igual que en la asignaci√≥n m√∫ltiple de variables, lo que parece ser una funci√≥n que devuelve m√∫ltiples objetos es en realidad una funci√≥n que devuelve un √∫nico objeto llamado tupla (de tipo tuple) que permite la t√©cnica de unpacking.\nNo te preocupes, m√°s adelante vamos a ver bien c√≥mo funciona.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#diagrama-de-una-funci√≥n",
    "href": "teoria/01_programacion_en_python/02_funciones.html#diagrama-de-una-funci√≥n",
    "title": "2 - Funciones",
    "section": "Diagrama de una funci√≥n",
    "text": "Diagrama de una funci√≥n\n\n\n\n\n\nAlgunos efectos colaterales pueden ser:\n\nImprimir un texto o un gr√°fico.\nCambiar el valor de una variable global.\nCrear, eliminar o modificar un archivo de la computadora.\n\n\n\n\n\n\n\n¬øPuedo devolver una salida y generar efectos colaterales a la vez? ü§î\n\n\n\nUna funci√≥n en Python puede realizar m√∫ltiples tareas, como devolver un valor e imprimir un mensaje en pantalla.\nPor ejemplo:\ndef producto(x, y):\n    resultado = x * y\n    print(\"El producto es\", resultado)\n    return resultado\nLa funci√≥n producto() no solo calcula y devuelve el resultado de multiplicar x por y, sino que adem√°s muestra un mensaje por pantalla.\nSin embargo, en general no es una buena pr√°ctica combinar tareas distintas dentro de una misma funci√≥n, especialmente si son de distinta naturaleza (como devolver un valor y causar un efecto colateral). Esto puede dificultar la reutilizaci√≥n y el mantenimiento del c√≥digo.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#argumentos-nombrados-y-posicionales",
    "href": "teoria/01_programacion_en_python/02_funciones.html#argumentos-nombrados-y-posicionales",
    "title": "2 - Funciones",
    "section": "Argumentos nombrados y posicionales",
    "text": "Argumentos nombrados y posicionales\nAl definir una funci√≥n, debemos darle un nombre a cada uno de los argumentos que va a recibir.\nAl llamar a la funci√≥n, podemos pasar los valores de dos formas: por posici√≥n o por nombre.\nPor ejemplo, las siguientes llamadas a la funci√≥n sumar() son equivalentes:\n\nsumar(x = 10, y = 15)\n\n25\n\n\n\nsumar(10, 15)\n\n25\n\n\nSi utilizamos los nombres para pasar los argumentos no hace falta que est√©n en el mismo orden que en la definici√≥n de la funci√≥n.\n\nsumar(y = 15, x = 10)\n\n25\n\n\n¬°Que sea posible no significa que sea una buena pr√°ctica!",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#ausencia-de-return",
    "href": "teoria/01_programacion_en_python/02_funciones.html#ausencia-de-return",
    "title": "2 - Funciones",
    "section": "Ausencia de return",
    "text": "Ausencia de return\nLa funci√≥n sumar() termina con la siguiente l√≠nea:\n    return x + y\nEs decir, utiliza la sentencia return para devolver un valor.\nPor otro lado, la funci√≥n saludar() termina con un print() y no tiene ning√∫n return.\n    print(\"Hola\", nombre)\n\nresultado = sumar(1, 2)\nresultado\n\n3\n\n\n\nsaludo = saludar(\"Juan\")\n\nHola Juan\n\n\n\n¬øCu√°l es el valor de la variable saludo?\n¬øPor qu√©?\n¬øTiene sentido?\n\n\nprint(saludo)\n\nNone\n\n\nEn Python no existe el concepto de return impl√≠cito.\nSi queremos que una funci√≥n devuelva un valor, es necesario usar la instrucci√≥n return de forma expl√≠cita.\nEn caso de no hacerlo, la funci√≥n devuelve autom√°ticamente None.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#argumentos-por-defecto",
    "href": "teoria/01_programacion_en_python/02_funciones.html#argumentos-por-defecto",
    "title": "2 - Funciones",
    "section": "Argumentos por defecto",
    "text": "Argumentos por defecto\nCuando definimos una funci√≥n podemos determinar valores por defecto para uno o m√°s par√°metros.\nSi cuando llamamos a la funci√≥n le pasamos un valor a ese par√°metro, se utiliza el valor que pasamos. Sino, se usa el valor por defecto.\nEsta pr√°ctica es √∫til para simplificar las llamadas que realizamos a una funci√≥n.\nSupongamos la siguiente funci√≥n describir_mascota() que tiene los par√°metros nombre y tipo\n\ndef describir_mascota(nombre, tipo):\n    print(\"Tengo un\", tipo)\n    print(\"Y su nombre es\", nombre)\n\ndescribir_mascota(\"Bruno\", \"perro\")\n\nTengo un perro\nY su nombre es Bruno\n\n\nAhora, hacemos que el par√°metro tipo sea por defecto igual a \"perro\".\n\ndef describir_mascota(nombre, tipo=\"perro\"):\n    print(\"Tengo un\", tipo)\n    print(\"Y su nombre es\", nombre)\n\nDe este modo, es posible llamar a la funci√≥n solamente pasando valores para aquellos par√°metros sin valor por defecto:\n\ndescribir_mascota(\"Bruno\")\n\nTengo un perro\nY su nombre es Bruno\n\n\nComo es de esperar, tambi√©n es posible pasar valores distintos a los establecidos por defecto:\n\ndescribir_mascota(\"Nemo\", \"pez\")\n\nTengo un pez\nY su nombre es Nemo",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html",
    "title": "4 - Colecciones de datos",
    "section": "",
    "text": "Adem√°s de los tipos de datos elementales que se presentaron en cap√≠tulos anteriores, Python proporciona estructuras de datos m√°s complejas que permiten almacenar colecciones de objetos. Estas estructuras facilitan la organizaci√≥n de m√∫ltiples valores bajo un mismo nombre, posibilitando, entre otras tareas, su manipulaci√≥n de manera conjunta.\nEn este cap√≠tulo exploraremos tres colecciones b√°sicas de Python:\n\nListas (list)\nTuplas (tuple)\nDiccionarios (dict)\n\nEstas estructuras tienen en com√∫n que permiten agrupar varios objetos, aunque presentan diferencias importantes en cuanto a la sintaxis utilizada para definirlas, su mutabilidad (capacidad de modificarse tras su creaci√≥n) y las operaciones disponibles para manipular sus elementos. En definitiva, cada estructura est√° especialmente dise√±ada para representar relaciones particulares entre los datos, adapt√°ndose as√≠ a diversas situaciones y necesidades de programaci√≥n.\nSupongamos que contamos con el nombre y la edad de 4 personas y queremos utilizar estos datos en nuestro programa. Si solamente tenemos acceso a los tipos de datos elementales de Python, una alternativa para almacenar esta informaci√≥n consiste en crear 4 variables para las edades y 4 variables para los nombres:\n\nnombre_1 = \"Juan\"\nnombre_2 = \"Carla\"\nnombre_3 = \"Evelina\"\nnombre_4 = \"Leandro\"\n\nedad_1 = 29\nedad_2 = 34\nedad_3 = 33\nedad_4 = 38\n\nEn este caso, el c√≥digo es legible e incluso permite intuir la relaci√≥n entre los nombres y las edades.\nSin embargo, vale preguntarse qu√© ocurrir√≠a si quisi√©ramos almacenar la informaci√≥n de muchas m√°s personas. Python nos permitir√≠a crear tantas variables como necesitemos, pero trabajar de esa manera no ser√≠a pr√°ctico ni sostenible.\nPor eso, el lenguaje ofrece estructuras de datos que facilitan el manejo de grandes cantidades de valores del mismo tipo, de forma m√°s organizada y eficiente.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#introducci√≥n",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#introducci√≥n",
    "title": "4 - Colecciones de datos",
    "section": "",
    "text": "Adem√°s de los tipos de datos elementales que se presentaron en cap√≠tulos anteriores, Python proporciona estructuras de datos m√°s complejas que permiten almacenar colecciones de objetos. Estas estructuras facilitan la organizaci√≥n de m√∫ltiples valores bajo un mismo nombre, posibilitando, entre otras tareas, su manipulaci√≥n de manera conjunta.\nEn este cap√≠tulo exploraremos tres colecciones b√°sicas de Python:\n\nListas (list)\nTuplas (tuple)\nDiccionarios (dict)\n\nEstas estructuras tienen en com√∫n que permiten agrupar varios objetos, aunque presentan diferencias importantes en cuanto a la sintaxis utilizada para definirlas, su mutabilidad (capacidad de modificarse tras su creaci√≥n) y las operaciones disponibles para manipular sus elementos. En definitiva, cada estructura est√° especialmente dise√±ada para representar relaciones particulares entre los datos, adapt√°ndose as√≠ a diversas situaciones y necesidades de programaci√≥n.\nSupongamos que contamos con el nombre y la edad de 4 personas y queremos utilizar estos datos en nuestro programa. Si solamente tenemos acceso a los tipos de datos elementales de Python, una alternativa para almacenar esta informaci√≥n consiste en crear 4 variables para las edades y 4 variables para los nombres:\n\nnombre_1 = \"Juan\"\nnombre_2 = \"Carla\"\nnombre_3 = \"Evelina\"\nnombre_4 = \"Leandro\"\n\nedad_1 = 29\nedad_2 = 34\nedad_3 = 33\nedad_4 = 38\n\nEn este caso, el c√≥digo es legible e incluso permite intuir la relaci√≥n entre los nombres y las edades.\nSin embargo, vale preguntarse qu√© ocurrir√≠a si quisi√©ramos almacenar la informaci√≥n de muchas m√°s personas. Python nos permitir√≠a crear tantas variables como necesitemos, pero trabajar de esa manera no ser√≠a pr√°ctico ni sostenible.\nPor eso, el lenguaje ofrece estructuras de datos que facilitan el manejo de grandes cantidades de valores del mismo tipo, de forma m√°s organizada y eficiente.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#listas",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#listas",
    "title": "4 - Colecciones de datos",
    "section": "Listas",
    "text": "Listas\n\nDefinici√≥n\nEl siguiente bloque de c√≥digo genera una lista con los n√∫meros 1, 2, 3, 4 y 5.\n\n[1, 2, 3, 4, 5]\n\n[1, 2, 3, 4, 5]\n\n\nUna lista de Python es una secuencia ordenada de objetos mutable. De manera menos t√©cnica, podemos decir que una lista es un objeto que contiene otros objetos en un orden determinado y cuyo contenido puede modificarse.\nLas listas son una de las estructuras m√°s utilizadas en Python. De hecho, programar en este lenguaje implica trabajar constantemente con listas: crearlas, modificarlas, recorrerlas y transformarlas.\nAs√≠ que si queremos ser buenos Pythonistas, ¬°a aprender de listas!\n\n\nCreaci√≥n de listas\nLas listas en Python se crean escribiendo los elementos entre corchetes ([]), separ√°ndolos con comas.\nCreemos una lista que contenga los nombres de nuestras cafeterias de especialidad preferidas: Orlan, Infinita, Arto, Crist√≥bal, Ruffo y Heroica.\n\ncafeterias = [\"Orlan\", \"Infinita\", \"Arto\", \"Crist√≥bal\", \"Ruffo\", \"Heroica\"]\nprint(cafeterias)\n\n['Orlan', 'Infinita', 'Arto', 'Crist√≥bal', 'Ruffo', 'Heroica']\n\n\nCuando imprimimos una lista, Python muestra una representaci√≥n muy parecida a la que usamos al definirla: con corchetes para encerrar los elementos y comas para separarlos.\nSi consultamos el tipo de una lista, no hay sorpresas: es del tipo list.\n\ntype(cafeterias)\n\nlist\n\n\n\n\nObjetos permitidos en una lista\nEn Python, una lista puede contener objetos de cualquier tipo. Incluso es posible mezclar distintos tipos en una misma lista.\nCon los tipos de datos que vimos hasta ahora, podr√≠amos tener listas con n√∫meros, cadenas de texto, valores booleanos e incluso el valor nulo.\nPor ejemplo, la siguiente lista contiene elementos de cuatro tipos distintos:\n\npopurri = [1, \"dos\", True, None, \"dos\"]\npopurri\n\n[1, 'dos', True, None, 'dos']\n\n\nSi bien las listas pueden mezclar objetos de distinto tipo, y algunas veces hacerlo tiene sentido, en general vamos a trabajar con listas donde todos sus objetos son del mismo tipo.\n\n\nQu√© significa que una lista sea ordenada\nConsideremos las listas [1, 2, 3] y [2, 1, 3]. Vale preguntarse si ambas listas son iguales o no. Veamos que dice Python:\n\n[1, 2, 3] == [2, 1, 3]\n\nFalse\n\n\nDado que una lista es una secuencia en la que el orden de los elementos es relevante, dos listas son iguales solo si contienen los mismos elementos y en el mismo orden. A continuaci√≥n se muestra un ejemplo en el que ambas condiciones se cumplen.\n\n[1, 2, 3] == [1, 2, 3]\n\nTrue\n\n\nTambi√©n vale la pena preguntarse si dos listas iguales son, en memoria, el mismo objeto. Debajo definimos dos listas x e y con los mismos elementos, en el mismo orden. Como es de esperarse, ambas listas son iguales en valor.\n\nx = [\"a\", \"b\", \"c\"]\ny = [\"a\", \"b\", \"c\"]\n\nprint(x == y)\nprint(x is y)\n\nTrue\nFalse\n\n\nSin embargo, estas listas no son iguales en memoria, es decir, no son el mismo objeto.\n\nprint(\"id(x):\", id(x))\nprint(\"id(y):\", id(y))\n\nid(x): 139718308051328\nid(y): 139718306480896\n\n\n\n\n\n\n\n\nConclusi√≥n üìù\n\n\n\nDos listas son iguales (en valor) si en cada posici√≥n contienen elementos que tambi√©n son iguales en valor. Sin embargo, que dos listas sean iguales no implica que sean el mismo objeto en memoria.\n\n\n\n\n\n\n\n\nPara pensar üß†\n\n\n\n¬øCu√°l es el resultado de la siguiente comparaci√≥n?\n[1, 2, 3] == [1.0, 2, 3.0]\n\n\n\n\nAcceder a elementos\nDado que una lista es una secuencia ordenada, cada objeto tiene una posici√≥n determinada. Podemos acceder a cualquiera de los elementos de la lista indicando la posici√≥n del objeto que deseamos. Esta posici√≥n se conoce como √≠ndice (o index, en ingl√©s).\nPara acceder a un elemento de una lista, escribimos el nombre de la lista seguido de la posici√≥n del objeto que queremos seleccionar, encerrada entre corchetes [].\nVeamos un ejemplo utilizando la lista cafeterias que creamos anteriormente.\n\ncafeterias = [\"Orlan\", \"Infinita\", \"Arto\", \"Crist√≥bal\", \"Ruffo\", \"Heroica\"]\ncafeterias\n\n['Orlan', 'Infinita', 'Arto', 'Crist√≥bal', 'Ruffo', 'Heroica']\n\n\nIntentemos seleccionar el primer objeto de la lista:\n\ncafeterias[1]\n\n'Infinita'\n\n\nCuando accedemos a un elemento individual de una lista, el resultado no es, en principio, otra lista, sino el objeto que se encuentra en esa posici√≥n. Ese objeto puede ser de cualquier tipo: un n√∫mero, una cadena de texto, otra lista, etc.\nPor lo tanto, si el elemento obtenido es una cadena de caracteres, podemos aplicar directamente los m√©todos que corresponden a ese tipo de dato. Por ejemplo, podemos encadenar la selecci√≥n del elemento en la posici√≥n 1 con una llamada al m√©todo .upper(), sabiendo que es v√°lido porque ese elemento es de tipo str.\n\ncafeterias[1].upper()\n\n'INFINITA'\n\n\nComo es de esperarse, tambi√©n podemos incluir una operaci√≥n de indexaci√≥n dentro de una f-string.\n\nf\"¬°Qu√© rico que es el caf√© de {cafeterias[1]}!\"\n\n'¬°Qu√© rico que es el caf√© de Infinita!'\n\n\n\n\n\n\n\n\nIndexaci√≥n desde cero 0Ô∏è‚É£\n\n\n\nObservamos que cafeterias[1] devuelve \"Infinita\", que es el elemento de la segunda posici√≥n, y no \"Orlan\", que aparece primero. Este resultado no es un error, sino una consecuencia de que Python usa indexaci√≥n desde cero (zero-based indexing, en ingl√©s). Esto significa que, si una lista contiene 6 elementos, sus posiciones van desde el 0 al 5. En general:\n\nEl primer elemento est√° en la posici√≥n 0.\nEl √∫ltimo elemento est√° en la posici√≥n n - 1.\n\n\n\n\n\n\n\n\n\nMisma sintaxis, significados distintos üé≠\n\n\n\nEn Python, los corchetes no siempre significan lo mismo. Sus dos funciones principales son la creaci√≥n de listas y la indexaci√≥n de secuencias. Un ejemplo curioso que combina ambos usos es el siguiente:\n[0][0]\n0\n\n\nEn el siguiente diagrama se muestra que la variable cafeterias referencia a un objeto de tipo list, que a su vez contiene referencias a distintos objetos de tipo str. Cada uno de estos elementos est√° asociado a un √≠ndice, comenzando desde el 0.\n\n\n\nRepresentaci√≥n gr√°fica de la lista cafeterias en Python.\n\n\n\n√çndices negativos\nPython tambi√©n permite utilizar valores negativos como √≠ndices para seleccionar elementos.\n\nEl √≠ndice -1 indica el √∫ltimo elemento.\nEl √≠ndice -2 indica el pen√∫ltimo elemento.\nY as√≠ sucesivamente.\n\n\ncafeterias[-1]\n\n'Heroica'\n\n\n\ncafeterias[-2]\n\n'Ruffo'\n\n\n\n\n\nRepresentaci√≥n gr√°fica de cafeterias utilizando √≠ndices negativos para cada elemento.\n\n\n\n\n\nAcceder a sub-listas\nHasta ahora vimos que, al usar corchetes con un n√∫mero entero, podemos acceder a un √∫nico elemento de una lista. Si en cambio queremos obtener varios elementos a la vez, necesitamos usar una herramienta llamada slice (o rebanada) que permite seleccionar un subconjunto de elementos de una secuencia.\nLa sintaxis para usar slices es la siguiente:\nlista[inicio:fin]\nEsto crea una nueva lista con los elementos que van desde la posici√≥n inicio hasta la posici√≥n fin, sin incluir esta √∫ltima.\nPor ejemplo:\n\ncafeterias[1:4]\n\n['Infinita', 'Arto', 'Crist√≥bal']\n\n\n\n\n\nSelecci√≥n de sublista de cafeterias usando el slice 1:4.\n\n\nComo los slices incluyen el √≠ndice de inicio pero excluyen el de fin, el siguiente c√≥digo funciona correctamente:\n\ncafeterias[4:6]\n\n['Ruffo', 'Heroica']\n\n\n\n\n\nSelecci√≥n de sublista de cafeterias usando el slice 4:6.\n\n\nEn Python, la sintaxis de los slices permite omitir de forma impl√≠cita los valores de inicio o fin cuando se desea tomar una porci√≥n desde el principio o hasta el final de la lista. Por ejemplo:\n\n:n es equivalente a 0:n y selecciona los primeros n elementos.\nn: es equivalente a n:len(lista) y selecciona desde la posici√≥n n hasta el final.\n\nEstas formas abreviadas hacen el c√≥digo m√°s conciso sin perder claridad. Por ejemplo:\n\ncafeterias[:3]\n\n['Orlan', 'Infinita', 'Arto']\n\n\n\n\n\nSelecci√≥n de sublista de cafeterias hasta el √≠ndice 3 usando el slice de inicio impl√≠cito :3.\n\n\n\ncafeterias[3:]\n\n['Crist√≥bal', 'Ruffo', 'Heroica']\n\n\n\n\n\nSelecci√≥n de sublista de cafeterias desde el √≠ndice 3 usando el slice con fin impl√≠cito 3:.\n\n\n\n\nModificar, agregar y eliminar elementos\nEn general, nuestros programas utilizan las listas como objetos din√°micos, es decir, como estructuras cuyo contenido puede cambiar a lo largo del tiempo mediante la modificaci√≥n, agregaci√≥n o eliminaci√≥n de sus elementos.\nPor ejemplo, supongamos que desarrollamos una p√°gina web que permite el registro de usuarios. En este caso, es natural usar una lista para almacenar los nombres de quienes se registran. A medida que pase el tiempo, se espera que se registren nuevos usuarios, otros se den de baja, o algunos incluso decidan cambiar su nombre. Esto implica realizar operaciones sobre la lista, como agregar, eliminar o modificar sus elementos.\n\nModificar elementos\nPara modificar un elemento se utiliza una sintaxis muy similar a la que utilizamos para acceder a un elemento.\nEscribimos el nombre de la lista seguido del √≠ndice del objeto que queremos modificar y el valor que queremos asignar.\nSupongamos que tenemos una lista con diferentes marcas de caf√©: Puerto Blest, Mart√≠nez y Fuego Tostadores.\n\nmarcas = [\"Puerto Blest\", \"Mart√≠nez\", \"Fuego Tostadores\"]\nmarcas\n\n['Puerto Blest', 'Mart√≠nez', 'Fuego Tostadores']\n\n\n¬øC√≥mo hacemos para cambiar el valor del primer elemento?\n\nmarcas[0] = \"Cabrales\"\nmarcas\n\n['Cabrales', 'Mart√≠nez', 'Fuego Tostadores']\n\n\n\n\n\n\n\n\nUna dosis de precisi√≥n üéØ\n\n\n\nEn esta secci√≥n, cuando hablamos de modificar un elemento, nos referimos a reemplazar el objeto que se encuentra en una posici√≥n determinada de la lista. Observemos el siguiente ejemplo:\ningredientes = [\"azucar\", \"flores\", \"colores\"]\nid_original = id(ingredientes[0])\n\n# \"Modifico\" el primer elemento\ningredientes[0] = \"pimienta\"\nid_nuevo = id(ingredientes[0])\n\nprint(\"ID original:\", id_original)\nprint(\"ID nuevo:\", id_nuevo)\nID original: 139872198862160\nID nuevo: 139872198582832\nEste ejemplo muestra que la operaci√≥n no modific√≥ el objeto que se encontraba originalmente en el √≠ndice 0, sino que lo reemplaz√≥ por uno nuevo.\n\n\n\n\n\n\n\n\n\n\n\n\n\n¬°Atenci√≥n! ü§ì\n\n\n\nEl ejemplo del bloque anterior demuestra que la sintaxis lista[indice] = objeto reemplaza el objeto que se encuentra en una determinada posici√≥n, en vez de modificarlo. Sin embargo, vale la pena destacar que s√≠ es posible modificar un elemento de una lista. Para ello, es necesario que el elemento sea un objeto mutable.\n\n\n\n\nAgregar elementos\nSupongamos que queremos construir una lista con los nombres de las ciudades que forman parte del Gran Rosario. Para ello, vamos a utilizar el siguiente mapa como referencia. A medida que identifiquemos las distintas localidades, las vamos a ir incorporando a una lista de Python.\nAgregar elementos a una lista es una tarea com√∫n en programaci√≥n, y Python nos ofrece varias formas de hacerlo. En esta secci√≥n vamos a explorar algunos de estos m√©todos, entendiendo en qu√© se diferencian y cu√°ndo conviene utilizar cada uno.\n\n\n\nMapa ilustrado del Gran Rosario.\n\n\nPrimero vamos a armar una lista que contenga los vecinos de Rosario, considerando solo aquellas localidades que limitan con la ciudad.\nSupongamos que empezamos con una lista que contiene √∫nicamente a la localidad de Funes. A partir de ah√≠, iremos agregando otras localidades vecinas utilizando distintos m√©todos que ofrece Python.\n\nvecinos_de_rosario = [\"Funes\"]\nvecinos_de_rosario\n\n['Funes']\n\n\n\nAgregar elementos al final de la lista\nLa manera m√°s sencilla de agregar un nuevo elemento a una lista es utilizando el m√©todo .append().\nEste m√©todo recibe un √∫nico elemento como argumento y lo agrega al final de la lista.\n\nvecinos_de_rosario.append(\"Soldini\")\n\nLa llamada a este m√©todo parece no devolver ning√∫n resultado. Observemos la lista nuevamente:\n\nvecinos_de_rosario\n\n['Funes', 'Soldini']\n\n\nEl m√©todo .append() agreg√≥ \"Soldini\" al final de la lista sin retornar ning√∫n valor. En lugar de crear una nueva lista, modific√≥ directamente la que referencia nuestra variable vecinos_de_rosario. En otras palabras, el m√©todo .append() no crea una nueva lista, sino que modifica directamente la lista existente.\nVeamos el siguiente ejemplo:\n\nvecinos_de_rosario = []\nprint(\"ID:\", id(vecinos_de_rosario))\nprint(vecinos_de_rosario, \"\\n\")\n\nvecinos_de_rosario.append(\"Funes\")\nprint(\"ID:\", id(vecinos_de_rosario))\nprint(vecinos_de_rosario, \"\\n\")\n\nvecinos_de_rosario.append(\"Soldini\")\nprint(\"ID:\", id(vecinos_de_rosario))\nprint(vecinos_de_rosario)\n\nID: 139718307382528\n[] \n\nID: 139718307382528\n['Funes'] \n\nID: 139718307382528\n['Funes', 'Soldini']\n\n\nComo se puede observar, Python oper√≥ siempre sobre la misma lista. Esto se debe a que el m√©todo .append() modifica la lista existente, en lugar de crear una nueva en cada paso.\n\n\nInsertar elementos en cualquier posici√≥n de una lista\nPara insertar elementos en una lista tambi√©n podemos utilizar el m√©todo .insert().\n¬øCu√°l es la diferencia entre .append() e .insert()?\n\n.append() agrega el nuevo elemento al final de la lista.\n.insert() permite insertar un elemento en cualquier posici√≥n, indicando el √≠ndice donde queremos ubicarlo.\n\nPor ejemplo, si queremos insertar \"Villa Gobernador G√°lvez\" al principio de la lista, podemos hacerlo con .insert(0, \"Villa Gobernador G√°lvez\").\n\nvecinos_de_rosario.insert(0, \"Villa Gobernador G√°lvez\")\nvecinos_de_rosario\n\n['Villa Gobernador G√°lvez', 'Funes', 'Soldini']\n\n\nEl m√©todo .insert() agreg√≥ a \"Villa Gobernador G√°lvez\" en el inicio de la lista y corri√≥ o traslad√≥ al resto de los elementos hacia la derecha.\nY si ahora queremos agregar a \"P√©rez\" en la tercera posici√≥n de la lista, simplemente:\n\nvecinos_de_rosario.insert(2, \"P√©rez\")\nvecinos_de_rosario\n\n['Villa Gobernador G√°lvez', 'Funes', 'P√©rez', 'Soldini']\n\n\nAl igual que .append(), .insert() tambi√©n modifica la lista existente en vez de devolver una lista nueva.\n\n\n\n\n\n\n¬øQu√© significa in-place? ü§î\n\n\n\nQue una operaci√≥n sea in-place significa que la operaci√≥n modifica directamente el objeto original, sin crear uno nuevo. Por ejemplo, objetos.append(e) agrega el elemento e a la lista existente objetos en lugar de crear y devolver una lista nueva.\n\n\n\n\n\nCombinar listas\nEn la secci√≥n anterior vimos c√≥mo insertar elementos individuales en una lista. Ahora vamos a explorar otra operaci√≥n muy com√∫n: combinar listas.\nSupongamos que ya tenemos una lista llamada vecinos_de_rosario, y otra llamada vecinos_al_norte. Queremos unir ambas listas para tener toda la informaci√≥n en una sola. Para lograrlo, una opci√≥n es usar el m√©todo .extend(), que nos permite agregar todos los elementos de una lista al final de otra, modificando directamente la lista original.\n\nprint(vecinos_de_rosario)\n\n['Villa Gobernador G√°lvez', 'Funes', 'P√©rez', 'Soldini']\n\n\n\nvecinos_al_norte = [\"Granadero Baigorria\", \"Ibarlucea\"]\n\nvecinos_de_rosario.extend(vecinos_al_norte)\nvecinos_de_rosario\n\n['Villa Gobernador G√°lvez',\n 'Funes',\n 'P√©rez',\n 'Soldini',\n 'Granadero Baigorria',\n 'Ibarlucea']\n\n\nDe la misma manera que .append() agrega un elemento al final de una lista, el m√©todo .extend() permite agregar todos los elementos de otra lista al final.\nOtra forma de combinar listas es utilizando el operador de suma +, que realiza una concatenaci√≥n de listas. A diferencia de .extend(), este operador no modifica las listas originales, sino que devuelve una nueva lista con los elementos de las dos listas originales concatenados en una nueva.\nPara ver c√≥mo funciona, primero vamos a construir una lista llamada otras_localidades, que contiene localidades del Gran Rosario que no est√°n pegadas a Rosario. Luego, vamos a concatenar esa lista a la que ya tenemos.\n\notras_localidades = [\n    \"Puerto San Mart√≠n\",\n    \"San Lorenzo\",\n    \"Fray Luis Beltr√°n\",\n    \"Capit√°n Bermudez\",\n    \"Ricardone\",\n    \"Rold√°n\",\n    \"Alvear\",\n    \"Pueblo Esther\",\n    \"General Lagos\",\n    \"Arroyo Seco\"\n]\n\nPrimero, observemos los IDs de las listas que vamos a combinar:\n\nprint(id(vecinos_de_rosario))\nprint(id(otras_localidades))\n\n139718307382528\n139718306450176\n\n\nY concatenemos ambas listas utilizando el operador de suma:\n\nvecinos_de_rosario + otras_localidades\n\n['Villa Gobernador G√°lvez',\n 'Funes',\n 'P√©rez',\n 'Soldini',\n 'Granadero Baigorria',\n 'Ibarlucea',\n 'Puerto San Mart√≠n',\n 'San Lorenzo',\n 'Fray Luis Beltr√°n',\n 'Capit√°n Bermudez',\n 'Ricardone',\n 'Rold√°n',\n 'Alvear',\n 'Pueblo Esther',\n 'General Lagos',\n 'Arroyo Seco']\n\n\nPodemos notar que la operaci√≥n s√≠ retorna una lista como resultado, la cual podr√≠amos guardar en una nueva variable.\n\ngran_rosario = vecinos_de_rosario + otras_localidades\ngran_rosario\n\n['Villa Gobernador G√°lvez',\n 'Funes',\n 'P√©rez',\n 'Soldini',\n 'Granadero Baigorria',\n 'Ibarlucea',\n 'Puerto San Mart√≠n',\n 'San Lorenzo',\n 'Fray Luis Beltr√°n',\n 'Capit√°n Bermudez',\n 'Ricardone',\n 'Rold√°n',\n 'Alvear',\n 'Pueblo Esther',\n 'General Lagos',\n 'Arroyo Seco']\n\n\nY finalmente, se puede ver que las listas originales no se han modificado y que gran_rosario referencia una lista nueva.\n\nprint(id(vecinos_de_rosario))\nprint(vecinos_de_rosario, \"\\n\")\n\nprint(id(otras_localidades))\nprint(otras_localidades, \"\\n\")\n\nprint(id(gran_rosario))\nprint(gran_rosario, \"\\n\")\n\n139718307382528\n['Villa Gobernador G√°lvez', 'Funes', 'P√©rez', 'Soldini', 'Granadero Baigorria', 'Ibarlucea'] \n\n139718306450176\n['Puerto San Mart√≠n', 'San Lorenzo', 'Fray Luis Beltr√°n', 'Capit√°n Bermudez', 'Ricardone', 'Rold√°n', 'Alvear', 'Pueblo Esther', 'General Lagos', 'Arroyo Seco'] \n\n139718306451456\n['Villa Gobernador G√°lvez', 'Funes', 'P√©rez', 'Soldini', 'Granadero Baigorria', 'Ibarlucea', 'Puerto San Mart√≠n', 'San Lorenzo', 'Fray Luis Beltr√°n', 'Capit√°n Bermudez', 'Ricardone', 'Rold√°n', 'Alvear', 'Pueblo Esther', 'General Lagos', 'Arroyo Seco'] \n\n\n\n\n\nEliminar elementos\nAs√≠ como es com√∫n agregar elementos a una lista o combinar listas para crear nuevas, tambi√©n lo es eliminar elementos.\nPor ejemplo, si en una p√°gina web guardamos los nombres de los usuarios en una lista, y uno de ellos se da de baja, necesitaremos eliminar su nombre de esa lista.\nPara ilustrarlo, vamos a crear una lista de usuarios ficticios:\n\nusuarios = [\"cyberwolf\", \"neo_404\", \"pixelbyte\", \"alphaX\", \"quantum.dev\"]\nusuarios\n\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX', 'quantum.dev']\n\n\n\nEliminar elementos utilizando del\nLa sentencia del, que ya usamos para eliminar variables, tambi√©n puede usarse para eliminar elementos de una lista.\nPara hacerlo, necesitamos conocer la posici√≥n del elemento que queremos eliminar.\nPor ejemplo, si queremos eliminar a \"neo_404\", que est√° en la segunda posici√≥n, podemos hacerlo con:\n\nprint(usuarios)\n\ndel usuarios[1]\n\nprint(usuarios)\n\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX', 'quantum.dev']\n['cyberwolf', 'pixelbyte', 'alphaX', 'quantum.dev']\n\n\n\n\nEliminar elementos con .pop()\nSi bien la sentencia del permite eliminar elementos de una lista, no nos da acceso al elemento eliminado.\nSin embargo, en muchos casos queremos extraer un elemento de una lista para utilizarlo en otra parte de nuestro programa. Por ejemplo, si tenemos una lista de usuarios, tal vez nos interesa guardar el nombre del usuario que se elimina en otra lista que registre los usuarios dados de baja.\nPara eso podemos usar el m√©todo .pop(), que elimina un elemento de la lista y, al mismo tiempo, lo devuelve.\n\nusuarios = [\"cyberwolf\", \"neo_404\", \"pixelbyte\", \"alphaX\", \"quantum.dev\"]\nusuario_eliminado = usuarios.pop(2)\n\nprint(usuarios) # \"pixelbyte\" es 'extraido'\nprint(usuario_eliminado)\n\n['cyberwolf', 'neo_404', 'alphaX', 'quantum.dev']\npixelbyte\n\n\nEn resumen, usuarios.pop(2) busca el valor en la tercera posici√≥n, lo extrae de la lista y lo devuelve.\nTambi√©n es posible usar .pop() sin indicar una posici√≥n. En ese caso, extrae el √∫ltimo elemento de la lista por defecto.\n\nusuarios = [\"cyberwolf\", \"neo_404\", \"pixelbyte\", \"alphaX\", \"quantum.dev\"]\nprint(usuarios, \"\\n\")\n\nusuario_eliminado = usuarios.pop()\nprint(usuario_eliminado)\nprint(usuarios, \"\\n\")\n\nusuario_eliminado = usuarios.pop()\nprint(usuario_eliminado)\nprint(usuarios)\n\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX', 'quantum.dev'] \n\nquantum.dev\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX'] \n\nalphaX\n['cyberwolf', 'neo_404', 'pixelbyte']\n\n\nY podr√≠amos continuar as√≠ hasta vaciar la lista.\n\n\nEliminar elementos con .remove()\nEl m√©todo .remove() es √∫til para cuando queremos eliminar elementos de una lista a partir de su valor, en lugar de su posici√≥n. Por ejemplo:\n\nusuarios = [\"cyberwolf\", \"neo_404\", \"pixelbyte\", \"alphaX\", \"quantum.dev\"]\nprint(usuarios)\n\nusuarios.remove(\"cyberwolf\")\nprint(usuarios)\n\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX', 'quantum.dev']\n['neo_404', 'pixelbyte', 'alphaX', 'quantum.dev']\n\n\nAl igual que del, remove no devuelve el valor que se remueve.\n\n\n\n\n\n\nResumen üìå\n\n\n\n\n\n\n\n\n\n\n\n\nHerramienta\nQu√© hace\nC√≥mo se usa\nDevuelve\n\n\n\n\ndel\nElimina un elemento por √≠ndice o un segmento por slicing\ndel lista[i]  del lista[i:j]\nNada\n\n\n.pop()\nElimina un elemento por √≠ndice (por defecto el √∫ltimo)\nlista.pop(i)  lista.pop()\nEl elemento eliminado\n\n\n.remove()\nElimina la primera ocurrencia de un valor dado\nlista.remove(valor)\nNada\n\n\n\n\n\n\n\n\n\nFunciones y m√©todos √∫tiles\n\nOrdenamiento\nEs com√∫n que las listas se creen sin seguir un orden particular. Sin embargo, en algunas situaciones puede ser importante conservar el orden en que se agregaron los elementos, mientras que en otras puede resultar √∫til trabajar con los datos ordenados, por ejemplo, para facilitar su presentaci√≥n.\nEn Python existen al menos dos formas de obtener listas ordenadas.\n\nEl m√©todo .sort()\nPara ordenar una lista de manera sencilla, podemos usar el m√©todo .sort(). Veamos un par de ejemplos para entender c√≥mo funciona.\n\nproductos = [\"Fanta\", \"Coca Cola\", \"Sprite\"]\nproductos.sort()\nprint(productos)\n\n['Coca Cola', 'Fanta', 'Sprite']\n\n\n\nprecios = [100, 110, 80.0, 70]\nprecios.sort()\nprint(precios)\n\n[70, 80.0, 100, 110]\n\n\nPodemos concluir que el m√©todo .sort() realiza un ordenamiento permanente, ya que modifica directamente la lista sobre la que se aplica y no devuelve una nueva. Esto significa que, una vez ejecutado, no es posible recuperar la lista original a menos que la hayamos guardado previamente.\nPor defecto, el ordenamiento se hace de menor a mayor: en el caso de cadenas de texto, se compara caracter por caracter, y en el caso de n√∫meros, se ordenan a partir de su valor.\n¬øC√≥mo hacemos para ordenar de manera decreciente?\nEl m√©todo .sort() tiene un argumento llamado reverse. Si este valor es igual a True, se ordenan los elementos de mayor a menor.\n\nproductos = [\"Fanta\", \"Coca Cola\", \"Sprite\"]\nproductos.sort(reverse=True)\nprint(productos)\n\n['Sprite', 'Fanta', 'Coca Cola']\n\n\n\nprecios = [100, 110, 80, 70]\nprecios.sort(reverse=True)\nprint(precios)\n\n[110, 100, 80, 70]\n\n\n\n\nLa funci√≥n sorted()\nAl igual que el m√©todo .sort(), la funci√≥n sorted() permite ordenar una lista. La diferencia principal es que sorted() no modifica la lista original, sino que devuelve una nueva lista ordenada. Esto resulta √∫til cuando queremos conservar tanto el orden original como una versi√≥n ordenada de la misma lista.\nVeamos algunos ejemplos breves:\n\njuegos = [\"Counter Strike\", \"The Sims\", \"Age of Empires II\", \"League of Legends\", \"Among Us\"]\njuegos_ordenados = sorted(juegos)\n\nprint(\"Esta es la lista original:\")\nprint(juegos, \"\\n\")\n\nprint(\"Esta es la lista ordenada:\")\nprint(juegos_ordenados)\n\nEsta es la lista original:\n['Counter Strike', 'The Sims', 'Age of Empires II', 'League of Legends', 'Among Us'] \n\nEsta es la lista ordenada:\n['Age of Empires II', 'Among Us', 'Counter Strike', 'League of Legends', 'The Sims']\n\n\n\nprint(\"id(juegos):\".ljust(22), id(juegos))\nprint(\"id(juegos_ordenados):\".ljust(22), id(juegos_ordenados))\n\nid(juegos):            139718306677440\nid(juegos_ordenados):  139718306597952\n\n\nAl igual que .sort(), sorted() tambi√©n tiene un argumento que determina el orden:\n\nsorted(juegos, reverse=True)\n\n['The Sims',\n 'League of Legends',\n 'Counter Strike',\n 'Among Us',\n 'Age of Empires II']\n\n\n\n\n\nInvertir el orden con .reverse()\nHasta ahora vimos c√≥mo ordenar listas de menor a mayor y de mayor a menor.\nOtra operaci√≥n com√∫n es invertir el orden de los elementos, y para eso podemos usar el m√©todo .reverse().\nAl igual que .sort(), esta operaci√≥n modifica la lista original de forma permanente.\n\nproductos = [\"Fanta\", \"Coca Cola\", \"Sprite\"]\nproductos.reverse()\nprint(productos)\n\n['Sprite', 'Coca Cola', 'Fanta']\n\n\nSi nos arrepentimos de haber invertido el orden, podemos usar .reverse() nuevamente y recuperamos el orden original.\n\nproductos.reverse()\nprint(productos)\n\n['Fanta', 'Coca Cola', 'Sprite']\n\n\n\n\n\n\n\n\n¬øY la funci√≥n reversed()? ü§î\n\n\n\nAs√≠ como tenemos .sort() y sorted(), uno podr√≠a preguntarse si existe un reversed() que complemente .reverse().\nLa respuesta es s√≠, reversed() existe. Sin embargo, su resultado no es una lista, sino un tipo de objeto que a√∫n no hemos explorado.\nSin embargo, lo vamos a ver m√°s adelante üòä\n\n\n\n\nCantidad de elementos\nPara saber cuantos elementos hay en una lista utilizamos la funci√≥n len().\nPor ejemplo, para obtener la cantidad de usuarios de manera program√°tica:\n\nusuarios = [\"cyberwolf\", \"neo_404\", \"pixelbyte\", \"alphaX\", \"quantum.dev\"]\nprint(usuarios)\nlen(usuarios)\n\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX', 'quantum.dev']\n\n\n5\n\n\nY para obtener la cantidad de ciudades del Gran Rosario (aunque falte una üòâ):\n\nprint(gran_rosario)\nlen(gran_rosario)\n\n['Villa Gobernador G√°lvez', 'Funes', 'P√©rez', 'Soldini', 'Granadero Baigorria', 'Ibarlucea', 'Puerto San Mart√≠n', 'San Lorenzo', 'Fray Luis Beltr√°n', 'Capit√°n Bermudez', 'Ricardone', 'Rold√°n', 'Alvear', 'Pueblo Esther', 'General Lagos', 'Arroyo Seco']\n\n\n16\n\n\n\n\nExistencia de elemento\nPara evaluar si un determinado elemento se encuentra en una lista utilizamos el operador in.\n\nnuevo_usuario = \"pepito\"\nnuevo_usuario in usuarios\n\nFalse\n\n\nQue correctamente indica que \"pepito\" no est√° en nuestra base de usuarios. Por otro lado,\n\n\"cyberwolf\" in usuarios\n\nTrue\n\n\n¬øY c√≥mo preguntar si alg√∫n elemento no est√° dentro de la lista? Para eso, utilizamos el operador not in.\n\n\"Col√≥n\" not in gran_rosario\n\nTrue\n\n\nLa respuesta es True porque efectivamente \"Col√≥n\" no pertenece al Gran Rosario.\nEste es uno de los tantos ejemplos donde Python se parece mucho mas al lenguaje humano que al lenguaje de las computadoras.\n\n\nPosici√≥n de un elemento\nSi queremos conocer la posici√≥n de un elemento en la lista podemos utilizar el m√©todo .index(). Por ejemplo:\n\nvocales = [\"a\", \"e\", \"i\", \"o\", \"u\"]\nvocales\n\n['a', 'e', 'i', 'o', 'u']\n\n\n\nvocales.index(\"i\")\n\n2\n\n\nAl igual que .remove(), el m√©todo .index() act√∫a sobre el primer elemento de la lista que coincide con el valor indicado. Es decir, si hay m√∫ltiples apariciones del mismo valor, solo se considera la primera.\n\n[\"a\", \"a\", \"a\"].index(\"a\")\n\n0\n\n\nEl resultado es 0 porque esa es la primera posici√≥n en la que aparece \"a\" en la lista. Sin embargo, esto no quiere decir que \"a\" aparezca una sola vez; simplemente indica la ubicaci√≥n de su primera ocurrencia.\n\n\nFrecuencia de un elemento\nSi queremos saber cu√°ntas veces aparece un elemento en una lista, podemos usar el m√©todo .count(). Este m√©todo devuelve la cantidad de ocurrencias del valor indicado dentro de la lista.\n\n[\"a\", \"a\", \"a\"].count(\"a\")\n\n3\n\n\n\n[\"a\", \"a\", \"a\"].count(\"b\")\n\n0\n\n\n\n\nEstad√≠sticas b√°sicas\nPython ofrece funciones que nos permiten calcular f√°cilmente algunas estad√≠sticas b√°sicas o medidas resumen, como el m√≠nimo, el m√°ximo y la suma de los elementos de una lista.\nSe destacan:\n\nmin(), que devuelve el valor m√≠nimo\nmax(), que devuelve el valor m√°ximo\nsum(), que devuelve la suma total\n\nVeamos algunos ejemplos:\n\nnumeros = [3, 7.5, 12, 1.2, 9, 4.8, 6, 15.3, 2.1, 8]\nnumeros\n\n[3, 7.5, 12, 1.2, 9, 4.8, 6, 15.3, 2.1, 8]\n\n\n\nprint(\"Valor m√≠nimo:\", min(numeros))\nprint(\"Valor m√°ximo:\", max(numeros))\nprint(\"Suma de valores:\", sum(numeros))\n\nValor m√≠nimo: 1.2\nValor m√°ximo: 15.3\nSuma de valores: 68.9\n\n\n\n\n\nResumen de m√©todos in-place\n\n\n\n\n\n\n\nM√©todo\nDescripci√≥n\n\n\n\n\n.append(x)\nInserta el valor x al final de la lista\n\n\n.pop(i)\nRemueve y devuelve el elemento en la posici√≥n i\n\n\n.insert(i, x)\nInserta el valor x en la posici√≥n i\n\n\n.extend(iterable)\nInserta todos los valores de iterable al final de la lista\n\n\n.index(x)\nDevuelve el la posici√≥n donde x aparece por primera vez en la lista\n\n\n.count(x)\nDevuelve la cantidad de veces que aparece x en la lista\n\n\n.sort()\nOrdena los elementos de la lista, de menor a mayor\n\n\n.reverse()\nInvierte el orden de los elementos en la lista",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#tuplas",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#tuplas",
    "title": "4 - Colecciones de datos",
    "section": "Tuplas",
    "text": "Tuplas\n\nDefinici√≥n\nEl siguiente bloque de c√≥digo genera una tupla con los n√∫meros 1, 2, 3, 4 y 5.\n\n(1, 2, 3, 4, 5)\n\n(1, 2, 3, 4, 5)\n\n\nUna tupla es una secuencia ordenada de objetos inmutable. Al igual que las listas, permite almacenar m√∫ltiples elementos de cualquier tipo y acceder a ellos por posici√≥n. Muchas de las operaciones que usamos con listas tambi√©n funcionan con tuplas. La diferencia clave es que las listas son mutables (se pueden modificar), mientras que las tuplas son inmutables (no se pueden cambiar una vez creadas).\nLas tuplas suelen utilizarse para representar registros o estructuras simples. En general, las tuplas se utilizan para representar:\n\nUna colecci√≥n fija de valores posibles para un cierto atributo (e.g., Identificaciones v√°lidas), o\nLos distintos atributos de un objeto. En este caso, cada tupla es como un registro de una base de datos (e.g., Baraja espa√±ola).\n\n\n\nEjemplos\n\nIdentificaciones v√°lidas\nSupongamos que trabajamos en un aeropuerto internacional y estamos implementando un programa de autenticaci√≥n de personas. Para ello, necesitamos definir los tipos de identificaci√≥n que se aceptan. Por ejemplo: LE, LC, DNI, CUIT, CUIL y Pasaporte.\nComo esperamos que estos tipos no vayan a cambiar con el tiempo (¬°al menos mientras corre nuestro programa!), tiene sentido utilizar una tupla (inmutable) en vez de una lista (mutable).\n\ntipos_identificacion = (\"LE\", \"LC\", \"DNI\", \"CUIT\", \"CUIL\", \"Pasaporte\")\ntipos_identificacion\n\n('LE', 'LC', 'DNI', 'CUIT', 'CUIL', 'Pasaporte')\n\n\n\ntype(tipos_identificacion)\n\ntuple\n\n\nAl igual que con las listas, podemos utilizar los √≠ndices para acceder a los elementos de la tupla:\n\nprint(tipos_identificacion[0])\nprint(tipos_identificacion[-1])\n\nLE\nPasaporte\n\n\nAl contrario de lo que sucede con las listas, no es posible modificar ninguno de sus elementos existentes:\ntipos_identificacion[0] = \"NUEVO_TIPO\"\n    tipos_identificacion[0] = \"NUEVO_TIPO\"\n    ~~~~~~~~~~~~~~~~~~~~^^^\nTypeError: 'tuple' object does not support item assignment\nSin embargo, si necesitamos combinar una o m√°s tuplas en otra tupla, sigue siendo posible utilizar el operador de suma (+) para concatenar tuplas y as√≠ crear una nueva, con sus elementos concatenados.\n\ntupla_nueva = tipos_identificacion + (\"NT1\", \"NT2\")\ntupla_nueva\n\n('LE', 'LC', 'DNI', 'CUIT', 'CUIL', 'Pasaporte', 'NT1', 'NT2')\n\n\n\nprint(\"id(tipos_identificacion):\", id(tipos_identificacion))\nprint(\"id(tupla_nueva):\".ljust(25), id(tupla_nueva))\n\nid(tipos_identificacion): 139718618931520\nid(tupla_nueva):          139718306406336\n\n\nAs√≠, se genera una nueva tupla mientras que la original se mantiene intacta.\n\n\nBaraja espa√±ola\nSupongamos que queremos desarrollar un software para jugar al truco en l√≠nea con nuestros amigos. Tarde o temprano, vamos a necesitar una forma de representar las cartas de la baraja espa√±ola.\nEsta baraja est√° compuesta por 40 cartas, divididas en 4 palos: oros, copas, espadas y bastos. Cada palo incluye las siguientes cartas: 1, 2, 3, 4, 5, 6, 7, 10, 11 y 12.\nUna forma simple y efectiva de representar esta baraja en Python es utilizando una lista de tuplas: la lista representa el mazo completo, y cada tupla representa una carta individual. Cada tupla tiene dos elementos: el palo y el valor. Es decir, cada carta se representa as√≠:\n(palo, valor)\nPor ejemplo: (\"espadas\", 7) representa el 7 de espadas.\n\nbaraja = [\n    (\"oros\", 1), (\"oros\", 2), (\"oros\", 3), (\"oros\", 4), (\"oros\", 5),\n    (\"oros\", 6),  (\"oros\", 7), (\"oros\", 10), (\"oros\", 11), (\"oros\", 12),\n    (\"copas\", 1), (\"copas\", 2), (\"copas\", 3), (\"copas\", 4), (\"copas\", 5),\n    (\"copas\", 6), (\"copas\", 7), (\"copas\", 10), (\"copas\", 11), (\"copas\", 12),\n    (\"espadas\", 1), (\"espadas\", 2), (\"espadas\", 3), (\"espadas\", 4), (\"espadas\", 5),\n    (\"espadas\", 6), (\"espadas\", 7), (\"espadas\", 10), (\"espadas\", 11), (\"espadas\", 12),\n    (\"bastos\", 1), (\"bastos\", 2), (\"bastos\", 3), (\"bastos\", 4), (\"bastos\", 5),\n    (\"bastos\", 6), (\"bastos\", 7), (\"bastos\", 10), (\"bastos\", 11), (\"bastos\", 12)\n]\n\nDe este modo, cada tupla representa una carta y resalta su caracter√≠stica de inmutable.\n\n\n\nCu√°ndo usar tuplas\nSi las tuplas se parecen tanto a las listas, ¬øpara qu√© existen?\nLas tuplas son apropiadas cuando se necesita una colecci√≥n inmutable, es decir, una secuencia que no debe cambiar ni en contenido ni en tama√±o. Esto evita modificaciones accidentales y, adem√°s, es m√°s eficiente en memoria que una lista.\nAunque suelen usarse con datos heterog√©neos, el criterio m√°s importante es la inmutabilidad. Si la colecci√≥n va a cambiar, no corresponde usar una tupla, independientemente del tipo de datos que esta contenga.\nFinalmente, aunque usar una lista en lugar de una tupla no afecte significativamente el rendimiento de un programa particular, elegir la estructura adecuada mejora la legibilidad: una tupla deja en claro que esa secuencia no se modifica en ning√∫n momento.\n\n\nDiferencias entre listas y tuplas\nC√≥mo las creamos:\n\nPara crear listas usamos [].\nPara crear tuplas usamos () (no es del todo cierto, ver Definici√≥n de tuplas üîç).\n\nComportamiento ‚Äúdin√°mico‚Äù vs ‚Äúest√°tico‚Äù:\n\nEl tama√±o de las listas puede ser modificado luego de ser creado (din√°mico).\nEl tama√±o de las tuplas no puede ser modificado luego de ser creado (est√°tico).\n\nObjetos ‚Äúmutables‚Äù vs ‚Äúinmutables‚Äù:\n\nLos elementos de la lista se pueden modificar luego de ser creada (mutable).\nLos elementos de una tupla no se pueden modificar (inmutable).\n\nM√°s all√° de sus diferencias, las listas y las tuplas tienen muchas similitudes:\n\nSon secuencias ordenadas.\nPueden contener objetos de distintos tipos al mismo tiempo.\nPermiten acceder a los elementos mediante su √≠ndice.\nAdmiten operaciones de slicing para obtener subconjuntos.\n\n\n\n\n\n\n\nDefinici√≥n de tuplas üîç\n\n\n\nHasta ahora dijimos que las tuplas se crean utilizando par√©ntesis y separando los elementos con comas. Pero eso no es del todo cierto.\nEn realidad, los par√©ntesis no son necesarios para definir una tupla. Lo que define a una tupla en Python es la coma, no los par√©ntesis. Por ejemplo:\nt = 10, 25.0, 50\nprint(t)\nprint(type(t))\n(10, 25.0, 50)\n&lt;class 'tuple'&gt;\nLos par√©ntesis en Python se usan principalmente para agrupar expresiones y modificar el orden de evaluaci√≥n, pero no son lo que convierte una serie de valores en una tupla. Si pens√°ramos a los par√©ntesis como una funci√≥n, simplemente devuelven el mismo objeto que encierran.\nDicho esto, el uso de par√©ntesis es una convenci√≥n ampliamente aceptada a la hora de definir tuplas. De hecho, por m√°s que los par√©ntesis no sean necesarios para su definici√≥n, Python siempre muestra a las tuplas entre par√©ntesis.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#diccionarios",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#diccionarios",
    "title": "4 - Colecciones de datos",
    "section": "Diccionarios",
    "text": "Diccionarios\nEn el ejemplo al inicio de este apunte presentamos el siguiente bloque de c√≥digo:\nnombre_1 = \"Juan\"\nnombre_2 = \"Carla\"\nnombre_3 = \"Evelina\"\nnombre_4 = \"Leandro\"\n\nedad_1 = 29\nedad_2 = 34\nedad_3 = 33\nedad_4 = 38\nA simple vista, se pudo concluir que exist√≠a una relaci√≥n entre los nombres y las edades. Por ejemplo, pudimos deducir que la edad de Juan es de 29 a√±os.\nCon las herramientas adquiridas en este apunte podr√≠amos representar esta informaci√≥n de las siguientes dos maneras:\n\nnombres = [\"Juan\", \"Carla\", \"Evelina\", \"Leandro\"]\nedades = [29, 34, 33, 38]\n\nAs√≠, el elemento ubicado en la posici√≥n i-√©sima de la lista nombres se corresponde con el elemento de la misma posici√≥n en la lista edades.\nEn principio, este enfoque resuelve el problema de tener que crear una variable distinta para cada valor. Sin embargo, mantener dos colecciones mutables e independientes en sincron√≠a puede convertirse en un verdadero dolor de cabeza. De hecho, podemos estar casi seguros de que, tarde o temprano, esa sincron√≠a se va a romper.\nOtra alternativa es la siguiente:\n\npersonas = [(\"Juan\", 29), (\"Carla\", 34), (\"Evelina\", 33), (\"Leandro\", 38)]\n\nAhora, contamos con un √∫nico objeto de Python que re√∫ne toda la informaci√≥n de las personas. En esta lista de tuplas, cada tupla representa a una persona: el primer elemento es su nombre y el segundo, su edad. Una de las ventajas de este enfoque es que permite agregar o quitar registros sin preocuparse por mantener la sincronizaci√≥n entre distintas colecciones.\nSin embargo, existe otra estructura de datos que puede resultar a√∫n m√°s adecuada para este escenario: el diccionario.\nLos diccionarios son estructuras que establecen un mapeo (del ingl√©s, mapping) o relaci√≥n entre dos conjuntos de elementos: claves y valores (keys y values en Python). En nuestro caso, podemos crear un diccionario donde las claves sean los nombres y los valores, las edades.\nEn Python, los diccionarios se definen entre llaves ({}). Dentro de ellas, cada elemento se escribe como un par clave: valor, separado por comas para distinguirlo de los dem√°s.\n\npersonas = {\"Juan\": 29, \"Carla\": 34, \"Evelina\": 33, \"Leandro\": 38}\npersonas\n\n{'Juan': 29, 'Carla': 34, 'Evelina': 33, 'Leandro': 38}\n\n\n\ntype(personas)\n\ndict\n\n\n\nlen(personas)\n\n4\n\n\nPodemos usar este ejemplo para destacar algunos puntos clave sobre los diccionarios:\n\nLa longitud de un diccionario corresponde a la cantidad de pares clave: valor que contiene, no a la suma de la cantidad de claves y valores.\nAunque es com√∫n usar cadenas de texto como claves, no es obligatorio: cualquier objeto que sea hashable puede ser una clave (lo veremos m√°s adelante).\nLos valores pueden ser de cualquier tipo de objeto en Python.\nLas claves deben ser √∫nicas, pero los valores pueden repetirse.\n\nPor √∫ltimo, veremos con un ejemplo que, aunque desde Python 3.7 los diccionarios mantienen un orden, este no es relevante al compararlos.\n\nd1 = {\"nombre\": \"Juan\", \"apellido\": \"P√©rez\"}\nd2 = {\"apellido\": \"P√©rez\", \"nombre\": \"Juan\"}\n\nprint(d1)\nprint(d2)\nprint(d1 == d2)\n\n{'nombre': 'Juan', 'apellido': 'P√©rez'}\n{'apellido': 'P√©rez', 'nombre': 'Juan'}\nTrue\n\n\nAunque d1 y d2 tengan las claves en distinto orden, para Python son diccionarios equivalentes; lo que importa no es el orden de los elementos en los diccionarios, sino los pares clave: valor que contienen.\n\n\n\n\n\n\n¬øPor qu√© se llaman diccionarios? ü§î\n\n\n\nEl nombre proviene de la idea de que en un diccionario real, uno busca la definici√≥n de una palabra (su valor) a partir de la palabra misma (la clave).\n\n\n\nAcceder a los elementos\nA diferencia de las listas y las tuplas, que son objetos donde el orden importa y se puede acceder a sus elementos por posici√≥n, los diccionarios no utilizan posiciones: en ellos, el acceso a los elementos se realiza mediante sus claves. Por ejemplo, si queremos acceder a la edad de Juan utilizando el √≠ndice 0, vamos a obtener un error:\npersonas[0]\n    personas[0]\n    ~~~~~~~~^^^\nKeyError: 0\nEn cambio, si usamos la clave \"Juan\", que es lo que corresponde:\n\npersonas[\"Juan\"]\n\n29\n\n\n\n\nVerificar la existencia de un elemento\nLos operadores in y not in permiten determinar si un diccionario contiene a un elemento con una determinada clave.\n\nd = {\"color\": \"azul\", \"forma\": \"cuadrado\"}\n\n\"color\" in d\n\nTrue\n\n\n\n\"area\" in d\n\nFalse\n\n\n\n\"area\" not in d\n\nTrue\n\n\n\n\"azul\" in d\n\nFalse\n\n\nAunque \"azul\" aparece como valor de uno de los elementos del diccionario d, \"azul\" in d retorna False porque no hay ninguna clave que sea \"azul\".\n\n\nAcceder a claves y valores\nEs posible acceder solo a las claves:\n\nd = {\"color\": \"azul\", \"forma\": \"cuadrado\"}\nd.keys()\n\ndict_keys(['color', 'forma'])\n\n\nO a los valores:\n\nd.values()\n\ndict_values(['azul', 'cuadrado'])\n\n\nO a las claves y los valores:\n\nd.items()\n\ndict_items([('color', 'azul'), ('forma', 'cuadrado')])\n\n\nEn todos los casos se obtiene una estructura de datos especial: dict_keys, dict_values o dict_items. No profundizaremos en ellas, ya que rara vez es necesario interactuar directamente con estos objetos. En la pr√°ctica, lo relevante es que permiten iterar sobre sus elementos y convertirse f√°cilmente a tipos m√°s comunes, como las listas.\n\n\nModificar, agregar y eliminar elementos\nLos diccionarios son objetos mutables, lo que significa que podemos modificar, agregar o eliminar elementos. Su funcionamiento es muy similar al de las listas. La diferencia m√°s notable es que, en vez de usar √≠ndices, se usan claves.\n\nModificar elementos\nAl igual que en una lista, podemos modificar un elemento seleccion√°ndolo y asign√°ndole un nuevo valor.\n\npersonas\n\n{'Juan': 29, 'Carla': 34, 'Evelina': 33, 'Leandro': 38}\n\n\n\npersonas[\"Juan\"] = 54\n\n\npersonas\n\n{'Juan': 54, 'Carla': 34, 'Evelina': 33, 'Leandro': 38}\n\n\n\n\nAgregar elementos\nPara agregar un elemento, se utiliza la misma sintaxis que para modificar uno: se asigna un valor a una nueva clave en el diccionario.\n\npersonas[\"Marisa\"] = 29\n\nEn resumen, al asignar un valor a una clave, Python primero verifica si existe: si la encuentra, reemplaza su valor; si no, agrega un nuevo par clave-valor.\n\n\nEliminar elementos\nEn un diccionario, es posible eliminar elementos de distintas maneras. Las m√°s comunes son:\n\nLa sentencia del.\nEl m√©todo .pop().\n\nLa sentencia del elimina un elemento asociado a una clave sin devolver su valor, por lo que no puede usarse posteriormente.\nPor ejemplo:\n\ndescuentos = {\n    \"Lunes\": 0,\n    \"Martes\": 20,\n    \"Miercoles\": 10,\n    \"Jueves\": 20,\n    \"Viernes\": 30,\n    \"S√°bado\": 30,\n    \"Domingo\": 0\n}\ndescuentos\n\n{'Lunes': 0,\n 'Martes': 20,\n 'Miercoles': 10,\n 'Jueves': 20,\n 'Viernes': 30,\n 'S√°bado': 30,\n 'Domingo': 0}\n\n\n\ndel descuentos[\"Domingo\"]\ndescuentos\n\n{'Lunes': 0,\n 'Martes': 20,\n 'Miercoles': 10,\n 'Jueves': 20,\n 'Viernes': 30,\n 'S√°bado': 30}\n\n\nEs como si el elemento \"Domingo\": 0 se hubiera esfumado.\nEn cambio, el m√©todo .pop() extrae el valor del diccionario y lo devuelve, lo que permite almacenarlo o utilizarlo m√°s adelante en el programa.\n\ndescuento_lunes = descuentos.pop(\"Lunes\")\nprint(descuento_lunes)\nprint(descuentos)\n\n0\n{'Martes': 20, 'Miercoles': 10, 'Jueves': 20, 'Viernes': 30, 'S√°bado': 30}\n\n\n\n\nActualizar diccionarios\nLos diccionarios tienen acceso a un m√©todo .update() que permiten actualizar un diccionario a partir de otro diccionario. Supongamos que tenemos un diccionario con informaci√≥n relacionada a una persona y otro diccionario con informaci√≥n actualizada de esa persona.\n\ndatos = {\"nombre\": \"Guillermina\", \"ciudad\": \"Rosario\", \"estado civil\": \"soltera\"}\ndatos_nuevos = {\"ciudad\": \"Rold√°n\", \"estado civil\": \"casada\", \"hijos\": 2}\n\nSe puede actualizar el contenido del diccionario datos con el contenido del diccionario datos_nuevos de la sigiuente manera:\n\ndatos.update(datos_nuevos)\ndatos\n\n{'nombre': 'Guillermina',\n 'ciudad': 'Rold√°n',\n 'estado civil': 'casada',\n 'hijos': 2}\n\n\nEste m√©todo modifica el diccionario datos in-place.\nSi se quiere realizar la operaci√≥n sin alterar el diccionario original, se puede usar el operador pipe (|), que devuelve un nuevo diccionario.\n\nd1 = {\"a\": 1, \"b\": 2}\nd2 = {\"b\": 10, \"c\": 25}\nd3 = d1 | d2\n\nprint(d1)\nprint(d2)\nprint(d3)\n\n{'a': 1, 'b': 2}\n{'b': 10, 'c': 25}\n{'a': 1, 'b': 10, 'c': 25}\n\n\nPor √∫ltimo, vale la pena notar que al actualizar un diccionario podemos modificar elementos existentes o agregar otros nuevos.\n\n\n\nEstructuras anidadas\nAnteriormente mencionamos que los diccionarios pueden contener cualquier tipo de objeto de Python. Por lo tanto, significa que puede contener n√∫meros, cadenas, listas‚Ä¶ ¬°e incluso otros diccionarios!\nVeamos un ejemplo donde esta idea resulta √∫til. Supongamos que queremos representar la informaci√≥n de una persona llamada Julia, que tiene 33 a√±os y realiz√≥ tres cursos de Python: Introducci√≥n a Python, An√°lisis de datos con Python y Python avanzado. El tipo de dato para el nombre y la edad es evidente: str e int, respectivamente. En cambio, para los cursos necesitamos una colecci√≥n de valores, ya que no se trata de un √∫nico elemento. As√≠, podemos crear el siguiente diccionario:\n\npersona = {\n    \"nombre\": \"Julia\",\n    \"edad\": 33,\n    \"cursos\": [\"Introducci√≥n a Python\", \"An√°lisis de datos con Python\", \"Python avanzado\"]\n}\n\nprint(persona)\n\n{'nombre': 'Julia', 'edad': 33, 'cursos': ['Introducci√≥n a Python', 'An√°lisis de datos con Python', 'Python avanzado']}\n\n\n\nprint(f\"Nombre: {persona['nombre']}\")\nprint(f\"Edad: {persona['edad']}\")\nprint(f\"Cursos: {persona['cursos']}\")\n\nNombre: Julia\nEdad: 33\nCursos: ['Introducci√≥n a Python', 'An√°lisis de datos con Python', 'Python avanzado']\n\n\nTambi√©n es posible representar estructuras de datos m√°s complejas, como registros. En el siguiente ejemplo, el diccionario usuarios tiene como valores otros diccionarios. Las claves de usuarios corresponden a nombres de usuario (por ejemplo, \"aeinstein\"), mientras que los valores son diccionarios que almacenan atributos de ese usuario, como su nombre, apellido y ciudad de residencia.\n\nusuarios = {\n    \"aeinstein\": {\n        \"nombre\": \"albert\",\n        \"apellido\": \"einstein\",\n        \"ciudad\": \"princenton\"\n    },\n    \"mcurie\": {\n        \"nombre\": \"marie\",\n        \"apellido\": \"curie\",\n        \"ciudad\": \"paris\"\n    },\n    \"afleming\": {\n        \"nombre\": \"alexander\",\n        \"apellido\": \"fleming\",\n        \"ciudad\": \"londres\"\n    }\n}\n\nPara acceder a un elemento dentro de un diccionario anidado, se encadenan los accesos usando [] tantas veces como sea necesario: primero para obtener el diccionario interno y luego para acceder a la clave deseada dentro de √©l.\n\nprint(usuarios[\"aeinstein\"])\nprint(usuarios[\"aeinstein\"][\"ciudad\"])\n\n{'nombre': 'albert', 'apellido': 'einstein', 'ciudad': 'princenton'}\nprincenton\n\n\n\nusuario = \"aeinstein\"\ndatos = usuarios[usuario]\nf\"El usuario '{usuario}' se llama {datos['nombre'].capitalize()} {datos['apellido'].capitalize()}.\"\n\n\"El usuario 'aeinstein' se llama Albert Einstein.\"",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#secuencias",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#secuencias",
    "title": "4 - Colecciones de datos",
    "section": "Secuencias",
    "text": "Secuencias\nLos tres tipos de datos que presentamos en este apunte pertenecen a la categor√≠a de las colecciones, ya que permiten almacenar una colecci√≥n o conjunto de objetos.\nOtra categor√≠a muy interesante de tipos de datos son las secuencias.\nUna secuencia es una estructura de datos que contiene elementos organizados en orden, y se puede acceder a cada elemento mediante un √≠ndice entero que representa su posici√≥n en la secuencia. Por lo tanto, las listas y las tuplas son ejemplos de secuencias; los diccionarios, en cambio, no lo son.\nAunque pueda parecer sorprendente al principio, las cadenas de texto tambi√©n son secuencias.\nVale la pena destacar a las secuencias, ya que todos los tipos de datos que abarca comparten un conjunto com√∫n de operaciones, que se resumen en la siguiente tabla:\n\n\n\n\n\n\n\n\nOperaci√≥n\nResultado\nComentarios\n\n\n\n\ne in s\nIndica si el valor e se encuentra en s\n¬†\n\n\ne not in s\nIndica si el valor e no se encuentra en s\n¬†\n\n\ns + t\nConcatena las secuencias s y t\n¬†\n\n\ns * n\nConcatena n copias de s\n¬†\n\n\ns[i]\nObtiene el elemento i de s\n¬†\n\n\ns[i:j]\nPorci√≥n de la secuencia s desde i hasta j (no inclusive)\n¬†\n\n\ns[i:j:k]\nPorci√≥n de la secuencia s desde i hasta j (no inclusive), con paso k\n¬†\n\n\nlen(s)\nCantidad de elementos en la secuencia s\n¬†\n\n\nmin(s)\nM√≠nimo elemento en la secuencia s\nRequiere elementos comparables\n\n\nmax(s)\nM√°ximo elemento de la secuencia s\nRequiere elementos comparables\n\n\nsum(s)\nSuma de los elementos de la secuencia s\nNo aplica a str\n\n\nsorted(s)\nOrdena los elementos de la secuencia s y los devuelve en una lista\nRequiere elementos comparables\n\n\nenumerate(s)\nIterador sobre los elementos de s junto con sus posiciones\nPermite iterar con (√≠ndice, valor)\n\n\nreversed(s)\nIterador inverso sobre los elementos de s\n¬†\n\n\nall(s)\nIndica si bool(e) es True para todos los elementos de s\n¬†\n\n\nany(s)\nIndica si bool(e) es True para al menos un elemento de s\n¬†\n\n\ns.index(e)\nPosici√≥n del elemento e en la secuencia s\n¬†\n\n\ns.count(e)\nCantidad de veces que el elemento e aparece la secuencia s\n¬†\n\n\n\nPor ejemplo:\n\ntexto = \"Esto es un texto cualquiera\"\notro = \"y esto es otro texto\"\nprint(\"texto[0]:\", texto[0])\n\ntexto[0]: E\n\n\n\nprint(\"texto[-1]:\", texto[-1])\n\ntexto[-1]: a\n\n\n\nprint(\"texto[0:3]:\", texto[0:3])\n\ntexto[0:3]: Est\n\n\n\nprint(\"texto[0:10:2]:\", texto[0:20:2])\n\ntexto[0:10:2]: Et su et u\n\n\n\nprint(\"texto + otro:\", texto + otro)\n\ntexto + otro: Esto es un texto cualquieray esto es otro texto\n\n\n\nprint(\"texto * 2:\", texto * 2)\n\ntexto * 2: Esto es un texto cualquieraEsto es un texto cualquiera\n\n\n\nprint(\"len(texto):\", len(texto))\n\nlen(texto): 27\n\n\n\nprint(\"sorted(texto):\", sorted(texto))\n\nsorted(texto): [' ', ' ', ' ', ' ', 'E', 'a', 'a', 'c', 'e', 'e', 'e', 'i', 'l', 'n', 'o', 'o', 'q', 'r', 's', 's', 't', 't', 't', 'u', 'u', 'u', 'x']\n\n\nAdem√°s, es posible crear una secuencia (o colecci√≥n) a partir de otra secuencia (o colecci√≥n) utilizando el tipo de dato como constructor. Por ejemplo:\n\nlist(\"texto\")\n\n['t', 'e', 'x', 't', 'o']\n\n\n\ntuple(\"texto\")\n\n('t', 'e', 'x', 't', 'o')\n\n\n\nlist((1, 2, 3, 4))\n\n[1, 2, 3, 4]\n\n\nSin embargo, el resultado puede no ser de lo m√°s intuitivo incialmente:\n\nstr([\"1\", \"2\", \"3\"]) # ¬°Notar que no concatena los elementos!\n\n\"['1', '2', '3']\"\n\n\n\nlist({\"a\": 1, \"b\": 2}) # Crea una lista a partir de las claves\n\n['a', 'b']\n\n\n\nlist({\"a\": 1, \"b\": 2}.values()) # Es posible crear una lista a partir de los valores\n\n[1, 2]\n\n\nSi intentamos crear un diccionario a partir de una lista (o tupla) ‚Äúplana‚Äù, obtendremos un error, ya que no hay una forma clara de identificar las claves y los valores.\ndict([1, 2, 3])\n    dict([1, 2, 3])\n    ~~~~^^^^^^^^^^^\nTypeError: cannot convert dictionary update sequence element #0 to a sequence\nEn cambio, si usamos una lista (o tupla) compuesta por listas (o tuplas) de longitud 2, la conversi√≥n es posible:\n\ndict([[\"x\", 1], [\"y\", 2]])\n\n{'x': 1, 'y': 2}\n\n\n\ndict([(\"A\", \"aaa\"), (\"B\", \"bbb\")])\n\n{'A': 'aaa', 'B': 'bbb'}",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#resumen-1",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#resumen-1",
    "title": "4 - Colecciones de datos",
    "section": "Resumen",
    "text": "Resumen\n\nLista (list)\n\nSintaxis: [a, b, c]\nEs mutable\nTiene orden\nSe accede a los elementos por √≠ndice\nEs secuencia\nAdmite cualquier objeto\n\nTupla (tuple)\n\nSintaxis: (a, b, c) o a, b, c\nEs inmutable\nTiene orden\nSe accede a los elementos por √≠ndice\nEs secuencia\nAdmite cualquier objeto\n\nDiccionario (dict)\n\nSintaxis: {clave: valor, ...}\nEs mutable\nTiene orden, pero no importa para evaluar igualdad\nSe accede a los elementos por clave\nNo es secuencia\nLas claves admiten objetos hashable, los valores pueden ser cualquier objeto\n\nCadena (str)\n\nSintaxis: \"texto\" o 'texto'\nEs inmutable\nTiene orden\nSe accede a los elementos por √≠ndice\nEs secuencia\nSolo admite caracteres",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/08_io.html",
    "href": "teoria/01_programacion_en_python/08_io.html",
    "title": "8 - Lectura y escritura de archivos",
    "section": "",
    "text": "En nuestros programas de Python utilizamos variables para almacenar datos durante la ejecuci√≥n. Estos datos pueden estar escritos directamente en el c√≥digo o ser ingresados por el usuario (por ejemplo, mediante la funci√≥n input()). Por otro lado, cuando necesitamos mostrar una salida en pantalla, usamos la funci√≥n print().\nSin embargo, el uso exclusivo de input() y print() para la entrada y salida de datos tiene limitaciones. Por ejemplo:\n\nSi trabajamos con m√°s de unos pocos datos, o ni siquiera sabemos cu√°les datos necesitaremos al momento de ejecutar el programa, no resulta pr√°ctico declararlos en el c√≥digo o ingresarlos manualmente.\nSi el resultado de nuestro programa consiste en una gran cantidad de datos que no pueden analizarse visualmente con rapidez, o si necesitamos reutilizarlos en otro programa o proceso m√°s adelante, se hace necesario almacenarlos de manera persistente.\n\nEn resumen, para resolver problemas de mayor complejidad, vamos a necesitar leer y guardar archivos en la computadora.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "8 - Lectura y escritura de archivos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/08_io.html#introducci√≥n",
    "href": "teoria/01_programacion_en_python/08_io.html#introducci√≥n",
    "title": "8 - Lectura y escritura de archivos",
    "section": "",
    "text": "En nuestros programas de Python utilizamos variables para almacenar datos durante la ejecuci√≥n. Estos datos pueden estar escritos directamente en el c√≥digo o ser ingresados por el usuario (por ejemplo, mediante la funci√≥n input()). Por otro lado, cuando necesitamos mostrar una salida en pantalla, usamos la funci√≥n print().\nSin embargo, el uso exclusivo de input() y print() para la entrada y salida de datos tiene limitaciones. Por ejemplo:\n\nSi trabajamos con m√°s de unos pocos datos, o ni siquiera sabemos cu√°les datos necesitaremos al momento de ejecutar el programa, no resulta pr√°ctico declararlos en el c√≥digo o ingresarlos manualmente.\nSi el resultado de nuestro programa consiste en una gran cantidad de datos que no pueden analizarse visualmente con rapidez, o si necesitamos reutilizarlos en otro programa o proceso m√°s adelante, se hace necesario almacenarlos de manera persistente.\n\nEn resumen, para resolver problemas de mayor complejidad, vamos a necesitar leer y guardar archivos en la computadora.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "8 - Lectura y escritura de archivos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/08_io.html#lectura-y-escritura",
    "href": "teoria/01_programacion_en_python/08_io.html#lectura-y-escritura",
    "title": "8 - Lectura y escritura de archivos",
    "section": "Lectura y escritura",
    "text": "Lectura y escritura\n\nArchivos de texto vs archivos binarios\nEn esta secci√≥n vamos a aprender a leer y escribir archivos de texto plano.\nLos archivos de texto plano contienen √∫nicamente caracteres b√°sicos de texto, sin ning√∫n tipo de informaci√≥n adicional. Algunos ejemplos son:\n\nArchivos de texto gen√©ricos con extensi√≥n .txt\nArchivos de c√≥digo Python con extensi√≥n .py\n\nEstos archivos pueden abrirse sin dificultad en cualquier editor de texto como el Notepad o Positron, y Python puede leer su contenido y tratarlo como cadenas de texto normales (str).\nEn contraste, existen los archivos binarios, que contienen secuencias de bits que no se limitan a representar caracteres de texto. Estos pueden almacenar cualquier tipo de datos, como im√°genes, sonidos, videos, PDFs, ejecutables, etc. Aunque en este apunte nos enfocamos en los archivos de texto plato, muchos de los principios que veremos tambi√©n se aplican a los archivos binarios.\n\n\nLos tres pasos fundamentales\nA la hora de trabajar con archivos en Python, normalmente se siguen tres pasos:\n\nAbrir el archivo con la funci√≥n open(), que devuelve un objeto de tipo TextIOWrapper.\nLeer o escribir en el archivo con los m√©todos read() o write() del objeto TextIOWrapper.\nCerrar el archivo con el m√©todo close() para liberar los recursos y asegurarse de que todos los cambios se guarden correctamente.\n\n\n\nLeer archivos\nPara abrir un archivo en Python se utiliza la funci√≥n open(), a la cual se le pasa como argumento la ruta del archivo. Esta ruta puede estar representada con una cadena de texto str o un objeto Path del m√≥dulo pathlib (que veremos en una secci√≥n m√°s adelante). La funci√≥n open() devuelve un objeto de tipo TextIOWrapper que representa al archivo abierto y permite interactuar con √©l.\nSupongamos que tenemos un archivo llamado pensamientos.txt con el siguiente contenido:\nEstoy aprendiendo a leer archivos en Python.\nNo se con qu√© me voy a encontrar.\nPero ac√° vamos.\ny usamos la funci√≥n open() para abrir el archivo.\narchivo = open(\"pensamientos.txt\")\narchivo\n&lt;_io.TextIOWrapper name='pensamientos.txt' mode='r' encoding='cp1252'&gt;\nVemos que el objeto devuelto por open() no solo incluye el nombre del archivo (pensamientos.txt), sino tambi√©n mode=\"r\" y encoding=\"cp1252\".\nTanto mode como encoding son argumentos de la funci√≥n open(). El primero indica el modo en el que se abre el archivo. Por defecto, este valor es \"r\", lo que significa que el archivo se abre en modo lectura de texto plano. En este modo es posible leer su contenido, pero no escribir sobre √©l.\nEl segundo argumento, encoding, especifica la codificaci√≥n que se usar√° para convertir los bytes del archivo en cadenas de texto de Python. En macOS y Linux el valor por defecto es \"utf-8\". En cambio, en Windows, la codificaci√≥n predeterminada es \"cp1252\" (ASCII extendido). Como esto puede generar errores al leer archivos de texto UTF-8 que contengan caracteres no ingleses en Windows, se recomienda siempre incluir expl√≠citamente el argumento encoding=\"utf-8\".\nEl objeto de la variable archivo es de tipo TextIOWrapper. A pesar de que el nombre pueda parecer complicado, no es m√°s que otro tipo de objeto en Python, como son las listas o los diccionarios. Cada vez que necesitemos leer o escribir en el archivo, lo haremos a trav√©s de los m√©todos asociados a este objeto.\n\n\n\n\n\n\nPuede fallar\n\n\n\nSi le pasamos a la funci√≥n open() un nombre de un archivo que no existe, ya sea porque escribimos mal la ruta o cometimos un error de tipeo, obtendremos un FileNotFoundError.\nopen(\"pensamiento.txt\")\nFileNotFoundError: [Errno 2] No such file or directory: 'pensamiento.txt'\n\n\n\nLeer todo el contenido\nUna forma de leer un archivo de texto plano en Python es cargar todo su contenido de una sola vez como una √∫nica cadena de texto. Para ello se utiliza el m√©todo .read() del objeto TextIOWrapper.\n\narchivo = open(\"pensamientos.txt\", encoding=\"utf-8\")\ncontenido = archivo.read()\ncontenido\n\n'Estoy aprendiendo a leer archivos en Python.\\nNo se con qu√© me voy a encontrar.\\nPero ac√° vamos.'\n\n\nSe puede observar que, salvo la √∫ltima, cada l√≠nea termina con un car√°cter de nueva l√≠nea (\\n). Si hubi√©ramos agregado un salto de l√≠nea al final del archivo pensamientos.txt, la cadena resultante tambi√©n habr√≠a terminado en \"\\n\".\n\n\nLeer l√≠nea a l√≠nea\nUna alternativa al m√©todo .read(), que carga todo el contenido como una √∫nica cadena de texto, es el m√©todo .readlines(). Este devuelve una lista de cadenas, donde cada elemento corresponde a una l√≠nea del archivo.\n\narchivo = open(\"pensamientos.txt\", encoding=\"utf-8\")\narchivo.readlines()\n\n['Estoy aprendiendo a leer archivos en Python.\\n',\n 'No se con qu√© me voy a encontrar.\\n',\n 'Pero ac√° vamos.']\n\n\nTrabajar con una lista de cadenas suele ser m√°s c√≥modo que manejar un √∫nico bloque de texto, ya que te permite acceder directamente a cada l√≠nea por separado.\n\n\nLeer solo algunas l√≠neas\nTambi√©n es posible leer un n√∫mero limitado de l√≠neas en lugar de cargar todo el archivo de una sola vez. Para ello se utiliza el m√©todo .readline(), en singular. Cada vez que se invoca, se obtiene la siguiente l√≠nea del archivo. Cuando ya no quedan m√°s l√≠neas, devuelve una cadena vac√≠a.\n\narchivo = open(\"pensamientos.txt\", encoding=\"utf-8\")\nwhile True:\n    linea = archivo.readline()\n    if linea == \"\":\n        break\n    print(linea, end=\"\") # `end=\"\"` para que Python no agregue salto de l√≠nea\n\nEstoy aprendiendo a leer archivos en Python.\nNo se con qu√© me voy a encontrar.\nPero ac√° vamos.\n\n\nEste m√©todo tambi√©n acepta un argumento opcional size, que permite especificar la cantidad de caracteres a leer en cada llamada.\n\n\nCerrar archivo\nCuando terminamos de trabajar con un archivo, es importante cerrarlo con el m√©todo .close(). Esto libera los recursos asociados y, en caso de escritura, asegura que todo lo que estaba en el b√∫fer se guarde correctamente.\nAunque Python suele cerrar los archivos autom√°ticamente al final del programa, es una buena pr√°ctica hacerlo de forma expl√≠cita para evitar comportamientos inesperados.\n\n\n\n\n\n\nLecturas sucesivas\n\n\n\nCuando se lee un archivo en Python, existe un puntero interno (a veces llamado posici√≥n en el b√∫fer) que avanza a medida que se consume el contenido. Por eso, despu√©s de una primera lectura completa, las siguientes llamadas a m√©todos como .read() o .readlines() no devuelven nada: el puntero ya est√° al final del archivo.\narchivo = open(\"pensamientos.txt\")\narchivo.read()\n'Estoy aprendiendo a leer archivos en Python.\\nNo se con qu√© me voy a encontrar.\\nPero ac√° vamos.'\narchivo.read()\n''\narchivo.readlines()\n[]\nPara volver a leer desde el inicio, hay dos opciones:\n\nCerrar y volver a abrir el archivo.\nUsar el m√©todo .seek(0) para mover el puntero de vuelta al principio.\n\n\n\n\n\n\nEscribir archivos\nPara escribir un archivo en Python, primero debemos abrirlo con la funci√≥n open(), de la misma manera que al leer. Sin embargo, no podemos usar los argumentos por defecto, ya que en ese caso el archivo se abre en modo lectura, lo que impide escribir en √©l.\nPara poder escribir, el archivo debe abrirse en uno de los siguientes modos:\n\nModo escritura (\"w\"): sobrescribe por completo el archivo existente, de forma similar a cuando asignamos un nuevo valor a una variable reemplazando el anterior.\nModo adici√≥n (\"a\"): agrega nuevo contenido al final del archivo existente, sin borrar lo que ya conten√≠a.\n\nSi el archivo indicado en open() no existe, tanto el modo escritura como el modo adici√≥n crear√°n un archivo nuevo y vac√≠o.\nDebajo, abrimos un archivo llamado conclusiones.txt en modo escritura. Como el archivo todav√≠a no existe, Python lo crea autom√°ticamente. Luego, llamamos a write() sobre el archivo abierto y le pasamos la cadena \"Escribir en Python no es tan grave como parece.\\n\" y el texto se escribe dentro del archivo.\n\narchivo = open(\"conclusiones.txt\", mode=\"w\", encoding=\"utf-8\") # Este paso ya crea el archivo\narchivo.write(\"Escribir en Python no es tan grave como parece.\\n\")\n\n48\n\n\nEl m√©todo .write() devuelve el n√∫mero de caracteres escritos, incluyendo el salto de l√≠nea \\n. Despu√©s, cerramos el archivo.\n\narchivo.close()\n\nPara agregar texto sin reemplazar el contenido existente, abrimos el archivo en modo adici√≥n. Escribimos la cadena \"Es solo cuesti√≥n de practica.\" y lo cerramos nuevamente.\n\narchivo = open(\"conclusiones.txt\", mode=\"a\", encoding=\"utf-8\")\narchivo.write(\"Es solo cuesti√≥n de practica.\")\narchivo.close()\n\nFinalmente, para mostrar en pantalla el contenido de conclusiones.txt, abrimos el archivo en modo lectura, cargamos su contenido con .read(), lo guardamos en la variable texto, cerramos el archivo y luego imprimimos texto.\n\narchivo = open(\"conclusiones.txt\", mode=\"r\", encoding=\"utf-8\")\ntexto = archivo.read()\narchivo.close()\nprint(texto)\n\nEscribir en Python no es tan grave como parece.\nEs solo cuesti√≥n de practica.\n\n\n\n\n\n\n\n\nSaltos de l√≠nea\n\n\n\nEs importante tener presente que el m√©todo .write() no agrega un salto de l√≠nea al final del texto de forma autom√°tica, a diferencia de print(). Si queremos que el contenido se escriba en una nueva l√≠nea dentro del archivo, debemos incluir manualmente el car√°cter \\n.\n\n\n\n\nUso de la sentencia with\nCuando abrimos un archivo con open(), debemos cerrarlo despu√©s con .close(). El problema es que a veces podemos olvidarlo o que el programa falle antes de llegar a esa l√≠nea.\nPara evitarlo, Python ofrece la sentencia with, que se encarga de cerrar el archivo autom√°ticamente al terminar el bloque de c√≥digo, incluso si ocurre un error en el medio.\nDebajo, utilizamos la sentencia with para crear un archivo y escribir texto en √©l.\n\nwith open(\"ejemplo.txt\", mode=\"w\", encoding=\"utf-8\") as archivo:\n    archivo.write(\"¬°Hola, mundo!\\n\")\n\nprint(archivo.closed) # Verificar que el archivo est√° cerrado\n\nTrue\n\n\nLuego, podemos utilizar un patr√≥n similar, pero pasando mode=\"r\", para leer el contenido del archivo.\n\nwith open(\"ejemplo.txt\", mode=\"r\", encoding=\"utf-8\") as archivo:\n    contenido = archivo.read()\n\nprint(contenido)\nprint(archivo.closed)\n\n¬°Hola, mundo!\n\nTrue\n\n\n\n\n\n\n\n\nContext managers\n\n\n\nLa sentencia with no es exclusiva para leer o escribir archivos: en realidad funciona con un objeto especial llamado context manager.\nUn context manager se usa en Python para manejar recursos que necesitan ser adquiridos y luego liberados de forma segura, como archivos, conexiones de red o bloqueos de concurrencia.\nLa clave es que with define un bloque de c√≥digo dentro del cual el recurso est√° disponible. Al entrar en el bloque, el recurso se prepara (por ejemplo, se abre un archivo) y, al salir, se libera autom√°ticamente, sin importar si la salida fue normal, si hubo un return o si se produjo una excepci√≥n.\nEsto permite que el c√≥digo sea m√°s claro y seguro, ya que todo el ciclo de vida del recurso queda encapsulado dentro de ese bloque.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "8 - Lectura y escritura de archivos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/08_io.html#archivos-y-rutas",
    "href": "teoria/01_programacion_en_python/08_io.html#archivos-y-rutas",
    "title": "8 - Lectura y escritura de archivos",
    "section": "Archivos y rutas",
    "text": "Archivos y rutas\nUn archivo tiene dos caracter√≠sticas principales: su nombre y su ruta.\nLa ruta indica la ubicaci√≥n exacta del archivo dentro de la computadora y puede incluir directorios, subdirectorios y el nombre del archivo con su extensi√≥n (por ejemplo, .txt, .csv, .py).\nA modo de ejemplo, supongamos que tenemos un archivo con el nombre reporte.docx, que se encuentra en la ruta:\nC:\\Users\\Tomi\\Documentos\nLa parte C:\\ de la ruta es la carpeta ra√≠z (conocida como root directory en ingl√©s), la cual contiene a todas las dem√°s carpetas.\nEn Windows, la carpeta ra√≠z se llama C:\\ y tambi√©n se le conoce como la unidad C:. En macOS y Linux, la carpeta ra√≠z se representa con una simple barra inclinada: /.\nPor otro lado, Users, Tomi y Documentos son carpetas, tambi√©n llamadas directorios. Las carpetas pueden contener archivos y tambi√©n otras carpetas (llamadas subcarpetas o subdirectorios).\n\nEspecificaci√≥n de rutas con pathlib.Path\n\nPor qu√© no es suficiente con str\nPor defecto, Python busca los archivos en el directorio de trabajo actual (current working directory). Por ejemplo:\nopen(\"archivo.txt\")\nEn este caso, archivo.txt debe estar en la misma carpeta desde donde se ejecuta el programa. Si no est√° all√≠, hay que indicar su ruta absoluta o relativa.\nAunque se pueden usar cadenas de texto (str) para definir rutas, esto puede generar problemas porque los sistemas operativos usan separadores distintos. Mientras que Windows usa la barra inclinada hacia atr√°s \\, macOS y Linux usan la barra inclinada hacia delante /.\n\n\nLa soluci√≥n\nPara evitar errores y escribir c√≥digo que funcione en cualquier sistema, conviene usar Path del m√≥dulo pathlib, que maneja autom√°ticamente las diferencias entre las formas de especificar rutas entre los distintos sistemas operativos.\nfrom pathlib import Path\nruta = Path(\"Users/Tomi/Documentos/projecto.docx\")\nprint(ruta)\nEn Windows se mostrar√° como:\nUsers\\Tomi\\Documentos\\project.docx\nY en macOS o Linux como:\nUsers/Tomi/Documentos/projecto.docx\nSi en Windows convertimos al objeto ruta a una cadena de caracteres, nos encontraremos con el siguiente resultado:\nstr(ruta)\n\"Users\\\\Tomi\\\\Documentos\\\\projecto.docx\"\nLas barras invertidas aparecen como dobles barras invertidas porque en Python cada barra invertida debe escaparse con otra barra invertida.\n\n\n\nCombinaci√≥n de rutas con el operador /\nEl operador /, que normalmente usamos para dividir n√∫meros, tambi√©n sirve en Python para combinar rutas cuando trabajamos con pathlib.Path. Esto permite construir rutas de forma clara y sin preocuparse por los separadores que cambian seg√∫n el sistema operativo. Por ejemplo:\nfrom pathlib import Path\n\nruta = Path(\"datos\") / \"usuarios\" / \"reporte.txt\"\nprint(ruta)\nEl resultado ser√° distinto seg√∫n el sistema:\nEn Windows:\ndatos\\usuarios\\reporte.txt\nEn macOS/Linux:\ndatos/usuarios/reporte.txt\nDe esta manera, podemos ir ‚Äúpegando‚Äù carpetas y archivos paso a paso, evitando concatenar cadenas manualmente y asegurando compatibilidad multiplataforma.\n\n\nRutas absolutas y relativas\nExisten dos formas principales de escribir la ruta de un archivo:\n\nRuta absoluta: indica la ubicaci√≥n completa desde la carpeta ra√≠z. En Windows comienza con la letra de unidad, por ejemplo C:\\, y en macOS/Linux comienza con /.\nRuta relativa: se interpreta a partir del directorio de trabajo actual del programa.\n\nAdem√°s, es com√∫n usar dos ‚Äúatajos especiales‚Äù dentro de una ruta:\n\n.: indica el directorio actual.\n..: indica el directorio padre, del ingles parent directory, que es el directorio que contiene al directorio actual.\n\nPor ejemplo, si el directorio de trabajo es C:\\trabajo y queremos acceder al archivo C:\\trabajo\\datos.txt mediante una ruta relativa, podemos usar simplemente:\ndatos.txt\no\n.\\datos.txt\nPor otro lado, si queremos acceder al archivo C:\\estudio\\reporte.txt, la ruta relativa ser√≠a:\n..\\estudio\\reporte.txt\nEsto facilita moverse entre carpetas sin necesidad de escribir rutas absolutas cada vez.\n\n\nAcceso a directorios de inter√©s\n\nDirectorio de trabajo actual\nEl directorio de trabajo actual es la carpeta desde la cual Python busca los archivos cuando usamos rutas relativas. En Python se puede obtener como una cadena de texto usando el m√©todo .cwd() (del ingl√©s, current working directory) de Path:\nfrom pathlib import Path\nprint(Path.cwd())\nSi necesitamos cambiar el directorio de trabajo actual, se puede usar chdir del m√≥dulo os:\nimport os\nos.chdir(\"nueva_ruta\")\n\n\n\n\n\n\nPrecauciones\n\n\n\nHay que tener en cuenta que al modificar el directorio de trabajo cambian todas las rutas relativas en el programa. Por eso, en proyectos grandes suele ser m√°s seguro usar rutas absolutas o construirlas a partir de un directorio base bien definido.\n\n\n\n\nDirectorio personal (home)\nCada usuario tiene un directorio personal que depende del sistema operativo: en Windows suele estar en C:\\Users\\&lt;usuario&gt;, en macOS en /Users/&lt;usuario&gt; y en Linux en /home/&lt;usuario&gt;.\nEn Python se puede acceder a este directorio con el m√©todo Path.home():\nfrom pathlib import Path\nprint(Path.home())\nNormalmente, los programas tienen permisos de lectura y escritura dentro de este directorio, por lo que es un lugar seguro y conveniente para guardar archivos y configuraciones creadas por tus scripts.\n\n\n\nUtilidades\n\nObtenci√≥n ruta absoluta y normalizada\nEl m√©todo .resolve() de Path convierte una ruta relativa en absoluta y, cuando es posible, normaliza la ruta colapsando los atajos . y ... En el siguiente ejemplo, el directorio de trabajo actual es C:\\Users\\Tomi\\Desktop\\proyecto:\nfrom pathlib import Path\n\nruta = Path(\"../datos.txt\")\nprint(ruta.resolve()) # ruta absoluta y normalizada\nC:\\Users\\Tomi\\Desktop\\datos.txt\n\n\nCreaci√≥n de directorios\nEl m√©todo .mkdir() de los objetos Path permite crear un directorio a partir de una ruta.\nfrom pathlib import Path\n\nPath(\"nueva_carpeta\").mkdir(exist_ok=True)\nCon exist_ok=True evitamos errores si la carpeta ya existe.\nPara crear todos los directorios en una ruta de m√∫ltiples directorios en una sola llamada, se puede a√±adir parents=True:\nPath(\"datos/limpios/2025\").mkdir(parents=True, exist_ok=True)\n\n\nVerificaci√≥n de validez y tipo de rutas\nLos objetos Path permiten comprobar si una ruta existe y qu√© tipo de recurso representa:\nfrom pathlib import Path\n\nruta = Path(\"C:/Users/Tomi/Documentos/projecto.docx\")\n\nprint(ruta.exists())   # True si existe\nprint(ruta.is_file())  # True si existe y es archivo\nprint(ruta.is_dir())   # True si existe y es directorio",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "8 - Lectura y escritura de archivos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/08_io.html#ap√©ndice",
    "href": "teoria/01_programacion_en_python/08_io.html#ap√©ndice",
    "title": "8 - Lectura y escritura de archivos",
    "section": "Ap√©ndice",
    "text": "Ap√©ndice\n\nEl arugmento mode de open()\n\nCaracteres v√°lidos\n\n\n\n\n\n\n\nCaracter\nSignificado\n\n\n\n\nr\nabrir para lectura (predeterminado)\n\n\nw\nabrir para escritura, truncando primero el archivo\n\n\nx\ncrear un archivo nuevo y abrirlo para escritura\n\n\na\nabrir para escritura, agregando al final del archivo si existe\n\n\nb\nmodo binario\n\n\nt\nmodo texto (predeterminado)\n\n\n+\nabrir un archivo en disco para actualizaci√≥n (lectura y escritura)\n\n\n\n\n\nEjemplos\n\n\n\n\n\n\n\n\nModo\nEjemplo\nDescripci√≥n\n\n\n\n\nr\nopen(\"datos.txt\", \"r\")\nAbre datos.txt para leer en modo texto.\n\n\nrb\nopen(\"imagen.png\", \"rb\")\nAbre imagen.png para leer en modo binario (√∫til para im√°genes, PDFs, etc).\n\n\nw\nopen(\"salida.txt\", \"w\")\nAbre salida.txt para escritura en texto, truncando el archivo si existe.\n\n\nwb\nopen(\"audio.raw\", \"wb\")\nAbre audio.raw para escritura en binario, truncando si existe.\n\n\na\nopen(\"log.txt\", \"a\")\nAbre log.txt para a√±adir texto al final del archivo.\n\n\nab\nopen(\"video.mp4\", \"ab\")\nAbre video.mp4 en binario para a√±adir datos al final.\n\n\nx\nopen(\"nuevo.txt\", \"x\")\nCrea nuevo.txt y lo abre para escritura en texto. Falla si ya existe.\n\n\nxb\nopen(\"nuevo.dat\", \"xb\")\nCrea nuevo.dat y lo abre para escritura en binario. Falla si ya existe.\n\n\nr+\nopen(\"datos.txt\", \"r+\")\nAbre datos.txt para leer y escribir en texto.\n\n\nrb+\nopen(\"imagen.png\", \"rb+\")\nAbre imagen.png para leer y escribir en binario.\n\n\nw+\nopen(\"datos.txt\", \"w+\")\nAbre datos.txt para leer y escribir en texto, truncando si existe.\n\n\nwb+\nopen(\"datos.bin\", \"wb+\")\nAbre datos.bin para leer y escribir en binario, truncando si existe.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "8 - Lectura y escritura de archivos"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/02_recursion.html",
    "href": "teoria/02_programacion_funcional/02_recursion.html",
    "title": "2 - Recursi√≥n",
    "section": "",
    "text": "En el apunte anterior vimos que en Python las funciones son ciudadanos de primera clase. Esto significa que una funci√≥n es un objeto, al igual que un n√∫mero, una cadena de texto o incluso un diccionario anidado con una estructura bastante enredada. Gracias a esto, no solo podemos inspeccionar sus atributos o hacer que una funci√≥n llame a otras, sino que tambi√©n es posible que una funci√≥n cree y retorne nuevas funciones.\nAdem√°s de los casos ya mencionados, tambi√©n es posible que una funci√≥n se llame a s√≠ misma. Es decir, que en el cuerpo de la definici√≥n de esa funci√≥n se incluya una llamada a la funci√≥n que se est√° definiendo. A este tipo de funciones se las llama recursivas, y la t√©cnica en s√≠ recibe el nombre de recursi√≥n.\nAunque pueda sonar extra√±o que una funci√≥n se invoque a s√≠ misma, en programaci√≥n existen problemas para los que funciones recursivas resultan una soluci√≥n natural y efectiva.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "2 - Recursi√≥n"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/02_recursion.html#introducci√≥n",
    "href": "teoria/02_programacion_funcional/02_recursion.html#introducci√≥n",
    "title": "2 - Recursi√≥n",
    "section": "",
    "text": "En el apunte anterior vimos que en Python las funciones son ciudadanos de primera clase. Esto significa que una funci√≥n es un objeto, al igual que un n√∫mero, una cadena de texto o incluso un diccionario anidado con una estructura bastante enredada. Gracias a esto, no solo podemos inspeccionar sus atributos o hacer que una funci√≥n llame a otras, sino que tambi√©n es posible que una funci√≥n cree y retorne nuevas funciones.\nAdem√°s de los casos ya mencionados, tambi√©n es posible que una funci√≥n se llame a s√≠ misma. Es decir, que en el cuerpo de la definici√≥n de esa funci√≥n se incluya una llamada a la funci√≥n que se est√° definiendo. A este tipo de funciones se las llama recursivas, y la t√©cnica en s√≠ recibe el nombre de recursi√≥n.\nAunque pueda sonar extra√±o que una funci√≥n se invoque a s√≠ misma, en programaci√≥n existen problemas para los que funciones recursivas resultan una soluci√≥n natural y efectiva.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "2 - Recursi√≥n"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/02_recursion.html#cuenta-regresiva",
    "href": "teoria/02_programacion_funcional/02_recursion.html#cuenta-regresiva",
    "title": "2 - Recursi√≥n",
    "section": "Cuenta regresiva",
    "text": "Cuenta regresiva\nSupongamos que queremos crear una funci√≥n que imprima una cuenta regresiva desde un n√∫mero entero dado hasta el 0. Es decir, la funci√≥n se deber√≠a comportar de la siguiente manera:\nregresiva(3)\n3\n2\n1\n0\nregresiva(5)\n5\n4\n3\n2\n1\n0\nUna implementaci√≥n no recursiva es la siguiente, basada en un bucle while:\ndef regresiva(n):\n    while n &gt; 0:\n        print(n)\n        n = n - 1\nOtra alternativa, que usa un bucle for y un range es:\ndef regresiva(n):\n    for i in range(n, -1, -1):\n        print(i)\nAmbas implementaciones resultan en funciones que se comportan correctamente y producen el resultado deseado.\nSin embargo, existe una alternativa recursiva para obtener la secuencia de n√∫meros deseados.\n\ndef regresiva(i):\n    print(i)\n1    if i &gt; 0:\n        regresiva(i - 1)\n2    else:\n        return\n\n\n1\n\nEl caso recursivo: Es la condici√≥n donde la funci√≥n se llama a s√≠ misma. En este caso, regresiva vuelve a llamarse a s√≠ misma solo cuando el n√∫mero impreso sea mayor que 0. La llamada se hace pasando como argumento el valor i - 1, lo que nos acerca progresivamente al caso base.\n\n2\n\nEl caso base: Es la condici√≥n que detiene la recursi√≥n. Cuando se cumple, la funci√≥n devuelve un valor sin volver a llamarse a s√≠ misma, lo que evita que la ejecuci√≥n contin√∫e de manera infinita.\n\n\n\n\nAmbos casos trabajan en conjunto. Por un lado, el caso recursivo es la parte de la funci√≥n que se llama a s√≠ misma, pero con una entrada modificada que se acerca progresivamente al caso base. Por el otro, el caso base es la condici√≥n que detiene las llamadas recursivas, representando la versi√≥n m√°s simple del problema que puede ser resuelta directamente.\n\nregresiva(3)\n\n3\n2\n1\n0\n\n\n\nregresiva(5)\n\n5\n4\n3\n2\n1\n0\n\n\n\n\n\n\n\n\nVersi√≥n con return impl√≠cito\n\n\n\nLa funci√≥n recursiva regresiva usa return para terminar su ejecuci√≥n devolviendo un None impl√≠cito en el caso base. Otra forma de implementar la misma funci√≥n es omitiendo el return:\ndef regresiva(i):\n    print(i)\n    if i &gt; 0:\n1        regresiva(i - 1)\n2\n\n1\n\nEsta l√≠nea marca el caso recursivo y es id√©ntica a la anterior.\n\n2\n\nAc√° no se usa return para devolver None: directamente no se escribe nada. El efecto es el mismo y constituye el caso base. En Python, si una funci√≥n no incluye ning√∫n return, se comporta como si al final hubiera un return o return None, es decir, la funci√≥n termina y devuelve None.\n\n\n\n\n\nVersi√≥n comentada\nPara entender mejor el funcionamiento de la funci√≥n recursiva progresiva, se pueden incorporar unos print en el cuerpo de la misma. En el ejemplo de abajo se muestra un print justo cuando la funci√≥n es llamada, y otro cuando la funci√≥n vuelve a invocarse a s√≠ misma.\ndef regresiva(i):\n    print(f\"regresiva({i})\")\n    print(i)\n    if i &gt; 0:\n        print(f\"regresiva({i}) --&gt; regresiva({i -1})\")\n        regresiva(i - 1)\n\nregresiva(2)\n1regresiva(2)\n22\n3regresiva(2) --&gt; regresiva(1)\n4regresiva(1)\n51\n6regresiva(1) --&gt; regresiva(0)\n7regresiva(0)\n80\n\n1\n\nSe ejecuta regresiva con i = 2\n\n2\n\nregresiva(2) imprime 2\n\n3\n\nregresiva(2) llama a regresiva(1)\n\n4\n\nSe ejecuta regresiva con i = 1\n\n5\n\nregresiva(1) imprime 1\n\n6\n\nregresiva(1) llama a regresiva(0)\n\n7\n\nSe ejecuta regresiva con i = 0\n\n8\n\nregresiva(0) imprime 0\n\n\n\n\n¬°Qu√© no falte el caso base!\nCuando escribimos una funci√≥n recursiva es fundamental implementar el caso base, que determina la condici√≥n donde la funci√≥n deja de llamarse a s√≠ misma y comienza a devolver un valor.\nDebajo se muestra una implementaci√≥n incorrecta de la funci√≥n regresiva como funci√≥n recursiva. La misma tiene el caso recursivo, donde la funci√≥n se llama a s√≠ misma, pero le falta el caso base, que es el que detiene esa cadena de llamadas. Como resultado, la funci√≥n sigue contando n√∫meros, incluso negativos, y Python termina frenando la ejecuci√≥n con un RecursionError. Este error aperece cuando la profundidad de la pila de llamadas recursivas supera un l√≠mite predeterminado y, como regla general, indica que hay un problema en nuestra recursi√≥n.\ndef regresiva(i):\n    print(i)\n    regresiva(i - 1)\n\nregresiva(1)\n1\n0\n-1\n-2\n...\n-988\n-989\nTraceback (most recent call last):\n  File \"&lt;python-input-5&gt;\", line 1, in &lt;module&gt;\n    regresiva(1)\n    ~~~~~~~~~^^^\n  File \"&lt;python-input-2&gt;\", line 3, in regresiva\n    regresiva(i - 1)\n    ~~~~~~~~~^^^^^^^\n  File \"&lt;python-input-2&gt;\", line 3, in regresiva\n    regresiva(i - 1)\n    ~~~~~~~~~^^^^^^^\n  File \"&lt;python-input-2&gt;\", line 3, in regresiva\n    regresiva(i - 1)\n    ~~~~~~~~~^^^^^^^\n  [Previous line repeated 988 more times]\nRecursionError: maximum recursion depth exceeded",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "2 - Recursi√≥n"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/02_recursion.html#factorial",
    "href": "teoria/02_programacion_funcional/02_recursion.html#factorial",
    "title": "2 - Recursi√≥n",
    "section": "Factorial",
    "text": "Factorial\nUn ejemplo cl√°sico para estudiar c√≥mo funciona la recursi√≥n en programaci√≥n es el c√°lculo del factorial. El factorial de un n√∫mero positivo \\(n\\) se define como:\n\\[\nn! = n \\times (n - 1) \\times (n - 2) \\times \\cdots \\times 2 \\times 1\n\\]\nEs decir, el factorial de un n√∫mero es el producto de todos los enteros desde \\(1\\) hasta \\(n\\). Por convenci√≥n, adem√°s, se establece que \\(0! = 1\\).\nUna forma de calcular el factorial de un n√∫mero sin recurrir a la recursi√≥n es la siguiente:\n\ndef factorial(n):\n    resultado = 1\n    for i in range(2, n + 1):\n        resultado = resultado * i\n    return resultado\n\nfactorial(6)\n\n720\n\n\nSin embargo, y dado que el factorial admite la siguiente expresi√≥n como funci√≥n recursiva,\n\\[\nn! = \\begin{cases}\n1 & \\text{para } n = 0 \\text{ o } n = 1 \\\\\nn \\times (n - 1)! & \\text {para } n \\ge 2\n\\end{cases}\n\\]\nse puede implementar en Python de la siguiente manera:\n\ndef factorial(n):\n    if n &lt;= 1:\n1        return 1\n    else:\n2        return n * factorial(n - 1)\n\n\n1\n\nCaso base.\n\n2\n\nCaso recursivo. La funci√≥n hace uso del resultado que ella misma produce.\n\n\n\n\nPodemos ver algunos ejemplos:\n\nprint(\"factorial(1):\", factorial(1))\nprint(\"factorial(0):\", factorial(0))\nprint(\"factorial(6):\", factorial(6))\nprint(\"factorial(10):\", factorial(10))\n\nfactorial(1): 1\nfactorial(0): 1\nfactorial(6): 720\nfactorial(10): 3628800\n\n\n\nVersi√≥n comentada\nLa funci√≥n regresiva nos sirvi√≥ como primera aproximaci√≥n a la recursi√≥n. Sin embargo, en ella, no se hace uso del resultado que la misma funci√≥n produce. En cambio, con factorial s√≠ se utiliza el valor producido en el caso recursivo, lo que la vuelve m√°s interesante para analizar c√≥mo se van encadenando los distintos pasos.\n\ndef factorial(n):\n    print(f\"factorial({n})\")\n    if n &lt;= 1:\n        salida = 1\n    else:\n        print(f\"factorial({n}) -&gt; factorial({n - 1})\")\n        salida = n * factorial(n - 1)\n\n    print(f\"&gt; factorial({n}) devuelve {salida}\")\n    return salida\n\nfactorial(4)\n\nfactorial(4)\nfactorial(4) -&gt; factorial(3)\nfactorial(3)\nfactorial(3) -&gt; factorial(2)\nfactorial(2)\nfactorial(2) -&gt; factorial(1)\nfactorial(1)\n&gt; factorial(1) devuelve 1\n&gt; factorial(2) devuelve 2\n&gt; factorial(3) devuelve 6\n&gt; factorial(4) devuelve 24\n\n\n24\n\n\nEl proceso arranca con la llamada a factorial(4). Para calcular su resultado, la funci√≥n necesita antes el valor de factorial(3). Esa, a su vez, depende de factorial(2), que depende de factorial(1). Finalmente, cuando llegamos a factorial(1), entramos en el caso base, que devuelve un resultado sin hacer m√°s llamadas.\nPor eso primero vemos c√≥mo se acumula la pila de llamadas, que crece paso a paso hasta llegar al caso base. Reci√©n ah√≠ comienza el camino de regreso: cada llamada se va resolviendo con el valor devuelto por la anterior, hasta llegar de nuevo a factorial(4), donde se completa el c√°lculo y obtenemos el resultado final.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "2 - Recursi√≥n"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/02_recursion.html#letra-chica",
    "href": "teoria/02_programacion_funcional/02_recursion.html#letra-chica",
    "title": "2 - Recursi√≥n",
    "section": "Letra chica",
    "text": "Letra chica\nCada vez que una funci√≥n se invoca a s√≠ misma, crea un nuevo contexto de ejecuci√≥n (con sus propias variables locales y el punto al que debe regresar) y lo apila sobre el anterior en una estructura que se llama pila de llamadas (del ingl√©s, call stack). Por lo tanto, cuando llamamos a factorial(4), apilamos cuatro contextos de ejecuci√≥n distintos, uno por cada llamada que va quedando pendiente, antes de empezar a devolver resultados.\nEste apilamiento no es gratis, consume memoria de nuestra computadora. Aunque para factorial(4) el consumo de memoria es insignificante, si intent√°ramos calcular un factorial muy grande, la pila podr√≠a crecer hasta agotar la cantidad de memoria disponible en nuestra computadora. Para evitar que las funciones recursivas causen una falla estrepitosa, Python establece un l√≠mite en la profundidad de la recursi√≥n. Al alcanzarlo, el int√©rprete se detiene con la excepci√≥n RecursionError que nos proteje de una ejecuci√≥n recursiva infinita o excesivamente profunda.\nDado su potencial alto consumo de memoria y la sobrecarga que genera gestionar la pila de llamadas, una implementaci√≥n recursiva no suele ser la m√°s eficiente. De hecho, su equivalente iterativo suele ser m√°s eficiente y adem√°s evita los riesgos asociados al desbordamiento de la pila. Sin embargo, el principal valor de la recursi√≥n reside en la claridad conceptual para modelar problemas de naturaleza inherentemente recursiva.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "2 - Recursi√≥n"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/01_paradigma.html",
    "href": "teoria/02_programacion_funcional/01_paradigma.html",
    "title": "1 - El paradigma funcional",
    "section": "",
    "text": "La programaci√≥n funcional es un paradigma de programaci√≥n que se centra en el uso de funciones puras y en concebir la computaci√≥n como la evaluaci√≥n de funciones. En lugar de dar instrucciones paso a paso que cambian variables o estados (como ocurre en la programaci√≥n imperativa), la idea es construir programas a partir de funciones que transforman datos.\nExisten lenguajes dise√±ados espec√≠ficamente para la programaci√≥n funcional (como Haskell), pero Python no es uno de ellos. Python es un lenguaje multiparadigma, lo que significa que nos permite combinar diferentes estilos de programaci√≥n. Por este motivo, la programaci√≥n funcional en Python no suele ser el enfoque principal, pero puede ser muy √∫til para escribir c√≥digo m√°s claro, conciso y f√°cil de probar.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "1 - El paradigma funcional"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/01_paradigma.html#introducci√≥n",
    "href": "teoria/02_programacion_funcional/01_paradigma.html#introducci√≥n",
    "title": "1 - El paradigma funcional",
    "section": "",
    "text": "La programaci√≥n funcional es un paradigma de programaci√≥n que se centra en el uso de funciones puras y en concebir la computaci√≥n como la evaluaci√≥n de funciones. En lugar de dar instrucciones paso a paso que cambian variables o estados (como ocurre en la programaci√≥n imperativa), la idea es construir programas a partir de funciones que transforman datos.\nExisten lenguajes dise√±ados espec√≠ficamente para la programaci√≥n funcional (como Haskell), pero Python no es uno de ellos. Python es un lenguaje multiparadigma, lo que significa que nos permite combinar diferentes estilos de programaci√≥n. Por este motivo, la programaci√≥n funcional en Python no suele ser el enfoque principal, pero puede ser muy √∫til para escribir c√≥digo m√°s claro, conciso y f√°cil de probar.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "1 - El paradigma funcional"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/01_paradigma.html#funciones-puras",
    "href": "teoria/02_programacion_funcional/01_paradigma.html#funciones-puras",
    "title": "1 - El paradigma funcional",
    "section": "Funciones puras",
    "text": "Funciones puras\nUna funci√≥n es pura cuando su salida depende √∫nicamente de los valores de entrada y no produce ning√∫n efecto secundario o colateral (side effect, en ingl√©s).\nLa funci√≥n sumar, que calcula y devuelve la suma de dos n√∫meros, es un ejemplo de funci√≥n pura: su resultado depende solo de sus argumentos y no genera efectos colaterales.\n\ndef sumar(x, y):\n    return x + y\n\nsumar(3, 11)\n\n14\n\n\nEn cambio, la funci√≥n agregar no es una funci√≥n pura. Esto se debe a que modifica un objeto global, lo que se conoce como un efecto secundario. Adem√°s, el valor de su salida no depende √∫nicamente de la entrada, sino tambi√©n de un estado global: la cantidad de elementos en lista.\n\nlista = []\n\ndef agregar(x):\n    \"\"\"Agrega el elemento `x` al final de `lista` y devuelve la longitud de `lista`\"\"\"\n    lista.append(x)\n    return len(lista)\n\n\nagregar(\"azucar\")\n\n1\n\n\n\nagregar(\"flores\")\n\n2\n\n\n\nagregar(\"colores\")\n\n3\n\n\n\nlista\n\n['azucar', 'flores', 'colores']\n\n\n\nEfectos secundarios\nUn efecto secundario (side effect) es cualquier cambio de estado observable que ocurre fuera del √°mbito local de una funci√≥n. En otras palabras, se trata de una modificaci√≥n del entorno externo de la funci√≥n que va m√°s all√° de simplemente devolver un valor.\nAlgunos ejemplos de side effects son:\n\nModificar una variable global o un objeto mutable.\nImprimir en la consola.\nEscribir en un archivo.\nRealizar una llamada a una API o a una base de datos.\n\nLas funciones con efectos secundarios pueden ser problem√°ticas porque, al modificar elementos externos, hacen que el c√≥digo sea impredecible y dif√≠cil de probar.\nEn el ejemplo de la funci√≥n agregar que creamos anteriormente, no es posible predecir el valor de salida para un valor de entrada determinado.\nPor eso, la programaci√≥n funcional promueve el uso de funciones puras, que no producen efectos secundarios. De esta manera, con las mismas entradas siempre se obtiene la misma salida, logrando un c√≥digo m√°s confiable, predecible y sencillo de mantener.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "1 - El paradigma funcional"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/01_paradigma.html#sec-ciudadanos",
    "href": "teoria/02_programacion_funcional/01_paradigma.html#sec-ciudadanos",
    "title": "1 - El paradigma funcional",
    "section": "Ciudadanos de primera clase",
    "text": "Ciudadanos de primera clase\nDefinamos otra funci√≥n muy sencilla, restar, que calcula y devuelve la diferencia entre dos objetos.\n\ndef restar(x, y):\n    return x - y\n\nrestar(10, 5)\n\n5\n\n\nPodemos observar que esta funci√≥n es un objeto de tipo function.\nprint(type(restar))\nprint(restar)\nrestar\n&lt;class 'function'&gt;\n&lt;function restar at 0x7f71cee62020&gt;\n&lt;function __main__.restar(x, y)&gt;\nAl imprimir la funci√≥n, Python nos muestra su nombre y la direcci√≥n de memoria donde est√° almacenada (en formato hexadecimal). En cambio, al mostrar su representaci√≥n, obtenemos informaci√≥n adicional: el m√≥dulo en el que fue definida (en este caso __main__) y la lista de par√°metros que recibe (x e y).\nDado que la funci√≥n restar es un objeto de Python, podemos asignarla a una nueva variable y realizar una llamada utilizando esa nueva etiqueta en vez de la original.\n\nresta_especial = restar\nresta_especial(10, 5)\n\n5\n\n\nNotemos que resta_especial no es una nueva funci√≥n; es solamente una nueva referencia a la funci√≥n antes definida.\n\nresta_especial # muestra 'restar', no 'resta_especial'\n\n&lt;function __main__.restar(x, y)&gt;\n\n\n\nresta_especial is restar\n\nTrue\n\n\nEn Python, las funciones son ciudadanos de primera clase. Esto significa que son objetos, al igual que las cadenas o los n√∫meros. Por lo tanto, todo lo que se puede hacer con una cadena o un n√∫mero tambi√©n puede hacerse con una funci√≥n.\nPor ejemplo, se pueden almacenar dentro de una lista junto con otros objetos de distintos tipos:\npopurri = [128, restar, None]\nprint(popurri[0])\nprint(popurri[1])\nprint(popurri[2])\n128\n&lt;function restar at 0x7f71cee62020&gt;\nNone\nIncluso una funci√≥n puede ser almacenada como valor en un diccionario:\n\nmapeo = {\n    \"sum\": sumar,\n    \"sub\": restar,\n}\n\nLuego, se las puede usar de la siguiente manera:\n\nmapeo[\"sum\"](25, 4)\n\n29\n\n\n\nmapeo[\"sub\"](25, 4)\n\n21\n\n\n\nFunciones de orden superior\nComo cualquier objeto de Python, una funci√≥n puede ser pasada como argumento de otra funci√≥n. Debajo definimos dos funciones muy simples. Una imprime un mensaje de bienvenida y la otra uno de despedida.\n\ndef bienvenida():\n    print(\"¬°Hola!\")\n\ndef despedida():\n    print(\"¬°Chau!\")\n\n\nbienvenida()\ndespedida()\n\n¬°Hola!\n¬°Chau!\n\n\nSe puede otra funci√≥n, que llamamos externa (del ingl√©s outer function), que tiene un √∫nico par√°metro interna. En su cuerpo, la funci√≥n externa llama a la funci√≥n interna y devuelve lo que sea que interna haya devuelto.\n\ndef externa(interna):\n    return interna()\n\nDe este modo, si llamamos a externa pas√°ndole como argumento a bienvenida, se imprimir√° ¬°Hola!; y si lo hacemos con despedida, se imprimir√° ¬°Chau!.\n\nexterna(bienvenida)\n\n¬°Hola!\n\n\n\nexterna(despedida)\n\n¬°Chau!\n\n\nA esta funci√≥n podemos pasarle cualquier funci√≥n que pueda ser llamada sin ning√∫n argumento. Por ejemplo:\n\ndef crear_lista():\n    return []\n\nexterna(crear_lista)\n\n[]\n\n\nTambi√©n es posible que una funci√≥n devuelva como resultado otra funci√≥n. Debajo, la funci√≥n fabrica devuelva una funci√≥n que computa la suma de dos objetos.\n\ndef fabricar():\n    def interna(x, y):\n        return x + y\n    return interna\n\n# La llamada a 'fabricar' genera y devuelve una funci√≥n\nf = fabricar()\n\n# La funci√≥n obtenida puede ser tratada como cualquier otra funci√≥n\nf(10, 15)\n\n25\n\n\nComo veremos m√°s adelante en este apunte, una funci√≥n que fabrica otras funciones puede recibir par√°metros que luego son utilizados dentro de la funci√≥n interna.\nEn el bloque siguiente, la funci√≥n crear_multiplicador recibe un par√°metro x, que define el valor por el cual se multiplicar√° el argumento de la funci√≥n interna que se devuelve.\n\ndef crear_multiplicador(x):\n    def interna(y):\n        return y * x\n    return interna\n\nAs√≠, es posible crear funciones para duplicar, triplicar, etc.\n\nduplicar = crear_multiplicador(2)\ntriplicar = crear_multiplicador(3)\n\nprint(duplicar(5))\nprint(triplicar(5))\n\n10\n15\n\n\n\ntriplicar(18)\n\n54\n\n\n\n\n\n\n\n\nObservaci√≥n üëÄ\n\n\n\nCada vez que se invoca la funci√≥n fabricar, se crea y devuelve una nueva funci√≥n. Por eso, el resultado de la comparaci√≥n en el siguiente bloque es False.\nf1 = fabricar()\nf2 = fabricar()\nprint(f1 is f2)\nFalse\n\n\n\n\n\n\n\n\nFunction factory üè≠\n\n\n\nA las funciones que crean y devuelven funciones se las conoce como f√°brica de funciones, del ingl√©s function factory.\n\n\n\n\nAtributos de una funci√≥n\nEn Python, las funciones tambi√©n cuentan con atributos, del mismo modo que otros objetos. En el siguiente ejemplo definimos la funci√≥n resolvente, que recibe las constantes a, b y c de un polinomio de segundo grado, calcula sus ra√≠ces usando la f√≥rmula resolvente y las devuelve en una tupla.\n\ndef resolvente(a, b, c):\n    discriminante = b ** 2 - 4 * a * c\n    x0 = (-b + (discriminante) ** 0.5) / (2 * a)\n    x1 = (-b - (discriminante) ** 0.5) / (2 * a)\n\n    return x0, x1\n\nresolvente(2, 5, -3)\n\n(0.5, -3.0)\n\n\nA trav√©s del atributo especial __code__ es posible consultar ciertos atributos o detalles internos de una funci√≥n:\n\nprint(resolvente.__code__.co_argcount) # Cantidad de argumentos\nprint(resolvente.__code__.co_name)     # Nombre de la funci√≥n\nprint(resolvente.__code__.co_varnames) #  Variables en el √°mbito local\n\n3\nresolvente\n('a', 'b', 'c', 'discriminante', 'x0', 'x1')\n\n\nAcceder a la informaci√≥n de una funci√≥n a trav√©s de __code__ puede resultar poco pr√°ctico, ya que los atributos disponibles son t√©cnicos y no siempre coinciden directamente con lo que solemos necesitar (por ejemplo, obtener solo los nombres de los argumentos).\nPara facilitar esta tarea, la librer√≠a est√°ndar de Python incluye el m√≥dulo inspect que ofrece herramientas m√°s claras e intuitivas para explorar los atributos y detalles de una funci√≥n.\nComo ejemplo, la funci√≥n signature que devuelve un objeto que representa la firma de la funci√≥n resolvente.\n\nimport inspect\n\nfirma = inspect.signature(resolvente)\nfirma\n\n&lt;Signature (a, b, c)&gt;\n\n\nA partir de esta firma podemos consultar distintos aspectos de los par√°metros, como sus valores por defecto:\n\nfirma.parameters[\"a\"].default # 'a' no tiene asignado un valor por defecto\n\ninspect._empty\n\n\nFinalmente, inspect tambi√©n permite acceder al c√≥digo fuente de la funci√≥n en forma de cadena de texto:\n\nprint(inspect.getsource(resolvente))\n\ndef resolvente(a, b, c):\n    discriminante = b ** 2 - 4 * a * c\n    x0 = (-b + (discriminante) ** 0.5) / (2 * a)\n    x1 = (-b - (discriminante) ** 0.5) / (2 * a)\n\n    return x0, x1",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "1 - El paradigma funcional"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/01_paradigma.html#funciones-an√≥nimas",
    "href": "teoria/02_programacion_funcional/01_paradigma.html#funciones-an√≥nimas",
    "title": "1 - El paradigma funcional",
    "section": "Funciones an√≥nimas",
    "text": "Funciones an√≥nimas\nLa programaci√≥n funcional se basa en llamar funciones y pasarlas, por lo que, naturalmente, implica definir muchas funciones. En Python, adem√°s de usar def, podemos crear funciones an√≥nimas de forma r√°pida con una expresi√≥n lambda.\nLa sintaxis es la siguiente:\nlambda &lt;argumentos&gt;: &lt;expresi√≥n&gt;\ny devuelve como resultado una funci√≥n an√≥nima. Un ejemplo es el siguiente:\n\nlambda x, y: x + y\n\n&lt;function __main__.&lt;lambda&gt;(x, y)&gt;\n\n\nComo la funci√≥n an√≥nima que acabamos de crear no fue asignada a ninguna variable, ya no podemos usarla.\nUna posibilidad es invocarla inmediatamente al momento de su creaci√≥n:\n\n(lambda x, y: x + y)(7, 15)\n\n22\n\n\nOtra opci√≥n es asignarla a una variable para poder llamarla m√°s adelante:\n\nsumar = lambda x, y: x + y\nsumar(7, 15)\n\n22\n\n\n\n\n\n\n\n\nAusencia de return\n\n\n\nA diferencia de las funciones definidas con def, las expresiones lambda no requieren la sentencia return. De forma impl√≠cita, siempre devuelven el resultado de la √∫nica expresi√≥n que contienen.\n\n\n\nUsos de funciones an√≥nimas\nEn ninguno de los ejemplos anteriores parece que obtengamos alguna ventaja frente a usar def para definir una funci√≥n. De hecho, da la impresi√≥n de que estamos complicando innecesariamente las cosas.\nLo cierto es que las funciones an√≥nimas no est√°n pensadas para emplearse de la manera expuesta en nuestros ejemplos. Su uso principal es en operaciones simples y puntuales, cuando no resulta pr√°ctico definir una funci√≥n completa con def.\nUn caso t√≠pico es al utilizarlas como argumentos de otras funciones.\nSupongamos que queremos ordenar la siguiente lista de refranes seg√∫n diferentes criterios.\n\nrefranes = [\n    \"Al mal tiempo, buena cara\",\n    \"Perro que ladra no muerde\",\n    \"A caballo regalado no se le miran los dientes\",\n    \"Cada loco con su tema\",\n    \"El que mucho abarca, poco aprieta\",\n    \"M√°s vale p√°jaro en mano que cien volando\",\n]\n\nPor defecto, la funci√≥n sorted ordena una lista de cadenas de manera alfab√©tica.\n\nsorted(refranes)\n\n['A caballo regalado no se le miran los dientes',\n 'Al mal tiempo, buena cara',\n 'Cada loco con su tema',\n 'El que mucho abarca, poco aprieta',\n 'M√°s vale p√°jaro en mano que cien volando',\n 'Perro que ladra no muerde']\n\n\nSi quisi√©ramos ordenar los refranes por su longitud, podemos usar el argumento opcional key de sorted. Este argumento recibe una funci√≥n que, aplicada a cada elemento, devuelve el valor a utilizar en la comparaci√≥n. En nuestro caso, basta con usar len, ya que solo nos interesa la cantidad de caracteres de cada cadena.\n\nsorted(refranes, key=len)\n\n['Cada loco con su tema',\n 'Al mal tiempo, buena cara',\n 'Perro que ladra no muerde',\n 'El que mucho abarca, poco aprieta',\n 'M√°s vale p√°jaro en mano que cien volando',\n 'A caballo regalado no se le miran los dientes']\n\n\n¬øY si quisi√©ramos ordenarlos seg√∫n la cantidad de palabras? Para eso necesitamos una funci√≥n que reciba una cadena, la divida en palabras y cuente cu√°ntas tiene.\nSin funciones an√≥nimas podr√≠amos hacer lo siguiente:\n\ndef contar_palabras(x):\n    return len(x.split())\n\nsorted(refranes, key=contar_palabras)\n\n['Al mal tiempo, buena cara',\n 'Perro que ladra no muerde',\n 'Cada loco con su tema',\n 'El que mucho abarca, poco aprieta',\n 'M√°s vale p√°jaro en mano que cien volando',\n 'A caballo regalado no se le miran los dientes']\n\n\nEn cambio, con una funci√≥n an√≥nima podemos escribir todo el programa en una sola l√≠nea:\n\nsorted(refranes, key=lambda x: len(x.split(\" \")))\n\n['Al mal tiempo, buena cara',\n 'Perro que ladra no muerde',\n 'Cada loco con su tema',\n 'El que mucho abarca, poco aprieta',\n 'M√°s vale p√°jaro en mano que cien volando',\n 'A caballo regalado no se le miran los dientes']\n\n\nDe esta forma el c√≥digo es m√°s conciso y evitamos definir funciones ‚Äúdescartables‚Äù que no volver√°n a usarse.\n\n\n\n\n\n\nOrigen del nombre lambda Œª‚ú®\n\n\n\nEl t√©rmino lambda proviene del c√°lculo lambda, un sistema formal de l√≥gica matem√°tica para expresar c√°lculos basados en la abstracci√≥n y aplicaci√≥n de funciones.\nSe le dio ese nombre porque Alonzo Church, creador del c√°lculo lambda en la d√©cada de 1930, us√≥ la letra griega Œª para denotar la operaci√≥n de abstracci√≥n de funciones.\n\n\n\n\n\n\n\n\nFunciones an√≥nimas sin par√°metros\n\n\n\nUna funci√≥n lambda normalmente recibe uno o m√∫ltiples par√°metros, pero no es obligatorio, por lo que es posibile escribir una funci√≥n an√≥nima sin par√°metros:\ncrear_numero_magico = lambda: 128\ncrear_numero magico()\n128\nLa funci√≥n an√≥nima crear_numero_magico es equivalente a la siguiente funci√≥n\ndef f():\n    return 128",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "1 - El paradigma funcional"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/01_paradigma.html#funciones-vari√°dicas",
    "href": "teoria/02_programacion_funcional/01_paradigma.html#funciones-vari√°dicas",
    "title": "1 - El paradigma funcional",
    "section": "Funciones vari√°dicas",
    "text": "Funciones vari√°dicas\nLas funciones vari√°dicas son funciones que pueden recibir una cantidad variable de argumentos.\nA lo largo de estos apuntes hemos utilizado funciones vari√°dicas en tant√≠simas oportunidades. Un ejemplo de funci√≥n vari√°dica es print, que acepta tantos argumentos posicionales como necesitemos.\n\nprint(\"Primero\")\n\nPrimero\n\n\n\nprint(\"Primero\", \"segundo\")\n\nPrimero segundo\n\n\n\nprint(\"Primero\", \"segundo\", \"tercero\")\n\nPrimero segundo tercero\n\n\nLas funciones vari√°dicas no son exclusivas de Python; tambi√©n podemos implementarlas nosotros mismos.\n\nCantidad variable de argumentos posicionales *args\nSupongamos que queremos una funci√≥n que recibe una cantidad arbitraria de gustos de helado y e imprime un mensaje como si lo agregase a un pedido. Por ejemplo:\narmar_pedido(\"Dulce de leche\")\nAgregando 'Dulce de leche'\narmar_pedido(\"Dulce de leche\", \"Sambay√≥n\", \"Frutos del bosque\")\nAgregando 'Dulce de leche'\nAgregando 'Sambay√≥n'\nAgregando 'Frutos del bosque'\nUna posible implementaci√≥n para tal funci√≥n es:\ndef armar_pedido(gusto_1=None, gusto_2=None, gusto_3=None):\n    if gusto_1 is not None:\n        print(f\"Agregando '{gusto_1}'\")\n    if gusto_2 is not None:\n        print(f\"Agregando '{gusto_2}'\")\n    if gusto_3 is not None:\n        print(f\"Agregando '{gusto_3}'\")\nAunque funciona, esta soluci√≥n est√° lejos de ser ideal. Requiere definir un argumento separado para cada gusto, asignarle un valor por defecto y luego verificar si es distinto de None antes de agregarlo al pedido.\nAdem√°s, el c√≥digo resulta repetitivo y restrictivo: solo permite un m√°ximo de tres gustos.\nAfortunadamente, en Python es posible crear funciones que acepten una cantidad arbitraria de argumentos posicionales de una manera sencilla.\nPara ello se utiliza un argumento especial precedido por un asterisco (*), lo que le permite recibir una cantidad arbitraria de valores no nombrados.\n\ndef armar_pedido(*args):\n    for gusto in args:\n        print(f\"Agregando '{gusto}'\")\n\n\narmar_pedido(\"Dulce de leche\", \"Sambay√≥n\", \"Frutos del bosque\", \"Menta granizada\")\n\nAgregando 'Dulce de leche'\nAgregando 'Sambay√≥n'\nAgregando 'Frutos del bosque'\nAgregando 'Menta granizada'\n\n\n\narmar_pedido(\"gusto 1\", \"gusto 2\", \"gusto 3\", \"gusto 4\", \"gusto 5\", \"gusto 6\", \"gusto 7\")\n\nAgregando 'gusto 1'\nAgregando 'gusto 2'\nAgregando 'gusto 3'\nAgregando 'gusto 4'\nAgregando 'gusto 5'\nAgregando 'gusto 6'\nAgregando 'gusto 7'\n\n\nPor convenci√≥n, este argumento suele escribirse como *args, aunque en realidad el nombre del argumento puede ser cualquiera que resulte apropiado. En nuestro caso, resulta m√°s intuitivo usar *gustos, y la funci√≥n quedar√≠a as√≠:\n\ndef armar_pedido(*gustos):\n    for gusto in gustos:\n        print(f\"Agregando '{gusto}'\")\n\n\narmar_pedido(\"gusto 1\", \"gusto 2\", \"gusto 3\", \"gusto 4\", \"gusto 5\", \"gusto 6\", \"gusto 7\")\n\nAgregando 'gusto 1'\nAgregando 'gusto 2'\nAgregando 'gusto 3'\nAgregando 'gusto 4'\nAgregando 'gusto 5'\nAgregando 'gusto 6'\nAgregando 'gusto 7'\n\n\n\n\n\n\n\n\nQu√© hay debajo de *args üîç\n\n\n\nCuando se utilizan valores con el argumento especial *args, Python los re√∫ne autom√°ticamente en una tupla. Esto permite acceder a todos los argumentos como miembros de una colecci√≥n inmutable.\ndef fun(*args):\n    print(len(args))\n    print(args)\n    print(type(args))\n\nfun(\"que\", \"es\", \"esto\", True, None)\n5\n('que', 'es', 'esto', True, None)\n&lt;class 'tuple'&gt;\n\n\n\n\nCantidad variable de argumentos nombrados **kwargs\nAs√≠ como recibimos una cantidad arbitraria de argumentos posicionales, tambi√©n podemos recibir una cantidad arbitraria de argumentos nombrados.\nEn este caso, se utilizan dos aster√≠scos (**) en vez de uno (*).\nLa convenci√≥n es usar el nombre **kwargs, pero tambi√©n es v√°lido usar cualquier otro nombre que sea adecuado en nuestro contexto.\nComencemos por un ejemplo elemental, que solo imprime el objeto kwrargs y su tipo:\n\ndef ejemplo(**kwargs):\n    print(kwargs)\n    print(type(kwargs))\n\nejemplo(nombre=\"Mariano\", apellido=\"P√©rez\")\n\n{'nombre': 'Mariano', 'apellido': 'P√©rez'}\n&lt;class 'dict'&gt;\n\n\nCuando usamos una cantidad variable de argumentos nombrados, Python los agrupa en un diccionario, ya que esta estructura permite asociar cada nombre con su valor de forma natural.\nDentro de la funci√≥n, se puede manipular al diccionario kwargs como a cualquier otro diccionario de Python.\nImaginemos, por ejemplo, una funci√≥n que registra informaci√≥n de distintos departamentos. En este caso, no sabemos de antemano qu√© atributos se van a proporcionar, pero s√≠ sabemos que ciertos atributos deben contar con un valor por defecto si no se especifican.\n\ndef registrar_propiedad(**kwargs):\n    print(\"Diccionario original:\")\n    print(kwargs)\n\n    # Si no se especifica la cantidad de cocheras, se pone 0 por defecto\n    if \"cochera\" not in kwargs:\n        kwargs[\"cochera\"] = 0\n\n    # Si no se especifica la ciudad, se pone 'Desconocido' por defecto\n    if \"ciudad\" not in kwargs:\n        kwargs[\"ciudad\"] = \"Desconocido\"\n\n    return kwargs\n\nCuando no se especifician la cantidad de cocheras, la funci√≥n nos devuelve un diccionario donde la cantidad de cocheras es 0.\n\ndatos = registrar_propiedad(ambientes=2, ciudad=\"Rosario\")\n\nprint(\"\\nDiccionario sanitizado\")\nprint(datos)\n\nDiccionario original:\n{'ambientes': 2, 'ciudad': 'Rosario'}\n\nDiccionario sanitizado\n{'ambientes': 2, 'ciudad': 'Rosario', 'cochera': 0}\n\n\nSi los atributos requeridos son especificados, se devuelve el diccionario sin cambios.\n\ndatos = registrar_propiedad(ambientes=2, ciudad=\"Santa Fe\", cochera=2)\n\nprint(\"\\nDiccionario sanitizado\")\nprint(datos)\n\nDiccionario original:\n{'ambientes': 2, 'ciudad': 'Santa Fe', 'cochera': 2}\n\nDiccionario sanitizado\n{'ambientes': 2, 'ciudad': 'Santa Fe', 'cochera': 2}\n\n\nY si se pasan atributos inesperados, tambi√©n se incluyen en la salida.\n\ndatos = registrar_propiedad(ambientes=4, dormitorios=2)\n\nprint(\"\\nDiccionario sanitizado\")\nprint(datos)\n\nDiccionario original:\n{'ambientes': 4, 'dormitorios': 2}\n\nDiccionario sanitizado\n{'ambientes': 4, 'dormitorios': 2, 'cochera': 0, 'ciudad': 'Desconocido'}\n\n\n\n\nCombinando *args y **kwargs\nLas funciones en Python pueden recibir simult√°neamente una cantidad variable de argumentos posicionales y nombrados. Para lograrlo, se combinan *args y **kwargs. Es importante recordar que, al definir la funci√≥n, *args debe colocarse antes que **kwargs, ya que los argumentos posicionales siempre se pasan antes que los nombrados.\n\ndef superfuncion(*args, **kwargs):\n    for arg in args:\n        print(f\"Me pasaron el argumento posicional '{arg}'\")\n\n    for key, value in kwargs.items():\n        print(f\"Me pasaron el argumento con nombre '{key}' y valor '{value}'\")\n\nsuperfuncion(True, 64, nombre=\"Elsa\", apellido=\"Pato\")\n\nMe pasaron el argumento posicional 'True'\nMe pasaron el argumento posicional '64'\nMe pasaron el argumento con nombre 'nombre' y valor 'Elsa'\nMe pasaron el argumento con nombre 'apellido' y valor 'Pato'\n\n\nSi se intenta pasar un argumento posicional (sin nombre) despu√©s de un argumento nombrado, obtendr√≠amos un error:\nsuperfuncion(True, nombre=\"Elsa\", apellido=\"Pato\", 64)\n    superfuncion(True, nombre=\"Elsa\", apellido=\"Pato\", 64)\n                                                         ^\nSyntaxError: positional argument follows keyword argument\n\n\n\n\n\n\n¬øY para qu√© me sirven? ü§î\n\n\n\nA primera vista, los ejemplos de *args y **kwargs pueden dar la impresi√≥n de que estas herramientas solo complican la escritura del c√≥digo. Sin embargo, su verdadero valor aparece al trabajar en programas m√°s complejos, donde se vuelven fundamentales para simplificar la l√≥gica y aportar flexibilidad en la resoluci√≥n de una gran variedad de problemas.\nYa llegaremos‚Ä¶\n\n\n\n\n\n\n\n\nEs solo una convenci√≥n ü§ù\n\n\n\nPara reforzar que los nombres *args y **kwargs son solamente una convenci√≥n, podr√≠amos escribir la funci√≥n superfuncion como:\ndef superfuncion(*posicionales, **nombrados):\n    for arg in posicionales:\n        print(f\"Me pasaron el argumento posicional '{arg}'\")\n\n    for key, value in nombrados.items():\n        print(f\"Me pasaron el argumento con nombre '{key}' y valor '{value}'\")\ny funcionar√≠a de igual modo.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "1 - El paradigma funcional"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/01_paradigma.html#closures",
    "href": "teoria/02_programacion_funcional/01_paradigma.html#closures",
    "title": "1 - El paradigma funcional",
    "section": "Closures",
    "text": "Closures\nEn la Secci√≥n¬†3.1 vimos el siguiente ejemplo:\ndef crear_multiplicador(x):\n    def interna(y):\n        return y * x\n    return interna\n\nduplicar = crear_multiplicador(2)\ntriplicar = crear_multiplicador(3)\n\nprint(duplicar(5))\nprint(triplicar(5))\n10\n15\nLa funci√≥n crear_multiplicador es una f√°brica de funciones que devuelve otra funci√≥n que se encarga de realizar la multiplicaci√≥n. Lo interesante de esta implementaci√≥n es que la funci√≥n interna solo recibe uno de los dos valores necesarios para la multiplicaci√≥n; el otro queda que fijado cuando se ejecuta la funci√≥n externa crear_multiplicador.\nPara que duplicar y triplicar funcionen correctamente, ambas funciones internas deben conservar acceso al entorno en el que est√° definido el valor de x. Ese mecanismo, que permite a una tener acceso a las variables de su contexto incluso despu√©s de que la ejecuci√≥n de la funci√≥n externa haya conclu√≠do, es precisamente lo que se conoce como un closure.\n\ndef crear_multiplicador(x):\n    def interna(y):\n        return y * x\n    return interna\n\nduplicar = crear_multiplicador(2)\ntriplicar = crear_multiplicador(3)\n\nprint(duplicar(5))\nprint(triplicar(5))\n\n10\n15\n\n\nEl siguiente ejemplo hace a√∫n m√°s evidente el funcionamiento de este mecanismo.\nDentro del cuerpo de la function factory externa, se define valor con el n√∫mero 256. Luego, la funci√≥n interna hace uso de esta variable valor dentro de print.\n\ndef externa():\n    valor = 256\n    def closure():\n        print(f\"¬°El valor es: {valor}!\")\n    return closure\n\nrevelar_numero = externa()\nrevelar_numero()\n\n¬°El valor es: 256!\n\n\nAunque desde fuera no podemos acceder directamente a valor:\nvalor\nNameError: name 'valor' is not defined\nla funci√≥n interna s√≠ puede hacerlo tantas veces como sea necesario:\n\nrevelar_numero()\nrevelar_numero()\nrevelar_numero()\n\n¬°El valor es: 256!\n¬°El valor es: 256!\n¬°El valor es: 256!\n\n\nPara finalizar, veamos un ejemplo similar al anterior, pero donde el valor de la variable numero es desconocido para nosotros. Dicho valor se genera de manera aleatoria cuando se crea ejecuta la f√°brica de funciones crear_funcion.\n\nimport random\n\ndef crear_funcion():\n    numero = random.randint(1, 1000)\n    def closure():\n        print(\"El valor es...\", numero)\n    return closure\n\nreveladora = crear_funcion()\n\nLuego, sin importar cu√°ntas veces llamemos a reveladora, el mensaje ser√° siempre el mismo, ya que el valor de numero se defini√≥ una sola vez en el momento de crear la funci√≥n.\n\nreveladora()\n\nEl valor es... 393\n\n\n\nreveladora()\n\nEl valor es... 393\n\n\n\n\n\n\n\n\nUna dosis de precisi√≥n üéØüò±\n\n\n\nA menudo se dice que un closure es una funci√≥n. As√≠, en el siguiente ejemplo, duplicar ser√≠a considerado un closure:\ndef crear_multiplicador(x):\n    def interna(y):\n        return y * x\n    return interna\n\nduplicar = crear_multiplicador(2)\nSin embargo, esa definici√≥n es un tanto imprecisa. Un closure no es simplemente una funci√≥n, sino el mecanismo que permite a las funciones acceder a las variables del entorno en el que fueron definidas, incluso cuando ese entorno ya dej√≥ de existir (por ejemplo, despu√©s de que termina la ejecuci√≥n de la funci√≥n externa que las cre√≥).\nUf‚Ä¶ ¬°qu√© complicado!\n\n\n\n\n\n\n\n\nobject of type 'closure' is not subsettable üòµ\n\n\n\nSi en R intentamos seleccionar filas o columnas de data sin haberle asignado un objeto previamente, obtendremos el siguiente error:\nError in data[1] : object of type 'closure' is not subsettable\nEsto ocurre porque data es en realidad una funci√≥n en R. En este lenguaje, el tipo de los objetos funci√≥n se denomina closure, haciendo referencia la capacidad que tienen las funciones de acceder a valores del ambiente donde fueron definidas.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "1 - El paradigma funcional"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html",
    "href": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html",
    "title": "4 - Estrategias de evaluaci√≥n üß©",
    "section": "",
    "text": "En este breve cap√≠tulo vamos a explorar las diferentes estrategias de evaluaci√≥n que utiliza Python. En programaci√≥n, una estrategia de evaluaci√≥n es el conjunto de reglas que define c√≥mo y cu√°ndo se calculan las expresiones.\nAnalizaremos la evaluaci√≥n inmediata (eager) y la evaluaci√≥n perezosa (lazy), as√≠ como la diferencia entre evaluaci√≥n estricta y no estricta.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "4 - Estrategias de evaluaci√≥n üß©"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#introducci√≥n",
    "href": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#introducci√≥n",
    "title": "4 - Estrategias de evaluaci√≥n üß©",
    "section": "",
    "text": "En este breve cap√≠tulo vamos a explorar las diferentes estrategias de evaluaci√≥n que utiliza Python. En programaci√≥n, una estrategia de evaluaci√≥n es el conjunto de reglas que define c√≥mo y cu√°ndo se calculan las expresiones.\nAnalizaremos la evaluaci√≥n inmediata (eager) y la evaluaci√≥n perezosa (lazy), as√≠ como la diferencia entre evaluaci√≥n estricta y no estricta.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "4 - Estrategias de evaluaci√≥n üß©"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluaci√≥n-estricta",
    "href": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluaci√≥n-estricta",
    "title": "4 - Estrategias de evaluaci√≥n üß©",
    "section": "Evaluaci√≥n estricta",
    "text": "Evaluaci√≥n estricta\nSupongamos una funci√≥n a la que le pasamos dos n√∫meros a y b y nos devuelve una lista con todos los enteros entre a y b.\n\ndef intervalo(a, b):\n    return list(range(a, b + 1))\n\nintervalo(5, 12)\n\n[5, 6, 7, 8, 9, 10, 11, 12]\n\n\nPara cumplir su objetivo, esta funci√≥n solo necesita los valores a y b. Pero, ¬øqu√© pasar√≠a si por error le agregamos otro par√°metro y despu√©s la llamamos sin darle ning√∫n valor para ese par√°metro?\n\ndef intervalo(a, b, c):\n    return list(range(a, b + 1))\n\nintervalo(5, 12)\n    intervalo(5, 12)\n    ~~~~~~~~~^^^^^^^\nTypeError: intervalo() missing 1 required positional argument: 'c'\nPython devuelve un error indicando que la funci√≥n intervalo no puede ejecutarse porque falta un valor para el par√°metro c. Aunque sepamos que dicho par√°metro no se utiliza dentro de la funci√≥n, Python igualmente exige que se le pase un valor.\nEsta exigencia se debe a que las funciones de Python se eval√∫an bajo las reglas de la evaluaci√≥n estricta. Bajo este enfoque, una funci√≥n no puede producir un resultado si alguno de sus par√°metros no est√° definido. Por eso, aun cuando el valor de c nunca se use en el cuerpo de la funci√≥n, la ausencia de un argumento para √©l provoca un error.\nPara que la funci√≥n se ejecute correctamente, basta con pasarle cualquier valor:\n\nintervalo(5, 12, None)\n\n[5, 6, 7, 8, 9, 10, 11, 12]\n\n\nEn Python, todas las llamadas a funciones siguen la estrategia de evaluaci√≥n estricta, y esto no es algo que podamos modificar: forma parte del dise√±o del lenguaje. De todas formas, como veremos m√°s adelante, existen ciertas construcciones del propio lenguaje que aplican una estrategia de evaluaci√≥n no estricta.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "4 - Estrategias de evaluaci√≥n üß©"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluaci√≥n-inmediata",
    "href": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluaci√≥n-inmediata",
    "title": "4 - Estrategias de evaluaci√≥n üß©",
    "section": "Evaluaci√≥n inmediata",
    "text": "Evaluaci√≥n inmediata\nOtro aspecto interesante al trabajar con funciones es el momento en que se eval√∫an los argumentos que se pasan en las llamadas.\nTomemos de nuevo nuestra funci√≥n original:\ndef intervalo(a, b):\n    return list(range(a, b + 1))\ny la siguiente llamada:\nintervalo(1 + 3, 5 + 12)\nLa pregunta es: ¬øqu√© pasa primero? ¬øSe ejecuta la funci√≥n intervalo y reci√©n ah√≠ se resuelven las expresiones 1 + 3 y 5 + 12, o esas expresiones se calculan antes y luego se pasan sus resultados a la funci√≥n?\nPara aclarar esta duda, en lugar de usar una suma directa podemos probar con una funci√≥n que sume pero que, adem√°s, imprima los argumentos que recibe. Del mismo modo, podemos modificar la funci√≥n intervalo para que muestre un mensaje cuando sea llamada y as√≠ ver con m√°s claridad el orden en que ocurren las cosas.\n\ndef suma(x, y):\n    print(f\"suma(x={x}, y={y})\")\n    return x + y\n\n\ndef intervalo(a, b):\n    print(f\"intervalo(a={a}, b={b})\")\n    return list(range(a, b + 1))\n\nintervalo(suma(1, 3), suma(5, 12))\n\nsuma(x=1, y=3)\nsuma(x=5, y=12)\nintervalo(a=4, b=17)\n\n\n[4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]\n\n\nPor el orden en que aparecen los mensajes impresos, vemos que Python primero ejecut√≥ la llamada suma(1, 3), luego suma(5, 12) y reci√©n despu√©s invoc√≥ a la funci√≥n intervalo, ya recibiendo los valores resultantes de las llamadas a suma.\nEn otras palabras, antes de llamar a intervalo, Python evalu√≥ las expresiones que se pasaron como argumentos.\nA esta estrategia de evaluaci√≥n, donde los argumentos se resuelven antes de ejecutar la funci√≥n, se la conoce como evaluaci√≥n inmediata, o por su nombre en ingl√©s, eager evaluation.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "4 - Estrategias de evaluaci√≥n üß©"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluaci√≥n-no-estricta",
    "href": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluaci√≥n-no-estricta",
    "title": "4 - Estrategias de evaluaci√≥n üß©",
    "section": "Evaluaci√≥n no estricta",
    "text": "Evaluaci√≥n no estricta\nEn contraste con la evaluaci√≥n estricta, la evaluaci√≥n no estricta es una estrategia en la que se puede determinar el resultado de una expresi√≥n sin necesidad de evaluar todos sus argumentos u operandos.\nEn Python, solo tres tipos de expresiones siguen esta estrategia: and, or y las expresiones condicionales.\nEn los siguientes ejemplos, vamos a utilizar una funci√≥n que imprime el valor ingresado y lo devuelve:\n\ndef f(x):\n    print(f\"el valor es {x}\")\n    return x\n\n\nExpresi√≥n and\nUna expresi√≥n and devuelve True √∫nicamente cuando todos sus argumentos son verdaderos. Por eso, en el siguiente ejemplo, se imprime el valor es True antes de obtener el resultado de la operaci√≥n and, ya que fue necesario evaluar la funci√≥n f.\n\nTrue and f(True)\n\nel valor es True\n\n\nTrue\n\n\nEn cambio, cuando el primero de sus argumentos es False, se puede anticipar que el resultado de la operaci√≥n and ser√° False, sin necesidad de evaluar el segundo argumento. Por este motivo, la funci√≥n f no se ejecuta en ninguno de los siguientes casos, al punto de que podemos pasarle argumentos absurdos:\n\nFalse and f(True)\n\nFalse\n\n\n\nFalse and f(1 / 0)\n\nFalse\n\n\nEn Python, este mecanismo tambi√©n se conoce como cortocircuito. Al detectar que el resultado de la operaci√≥n ya est√° decidido con el primer argumento, el int√©rprete ‚Äúcorta camino‚Äù y no sigue evaluando el resto.\n\n\nExpresi√≥n or\nEl mecanismo de cortocircuito tambi√©n funciona para el operador or:\n\n# El primer argumento es True, el resultado es True\nTrue or f(True)\n\nTrue\n\n\n\n# El primer arugmento es False, hay que evaluar el segundo para determinar el resultado\nFalse or f(True)\n\nel valor es True\n\n\nTrue\n\n\nLas mismas reglas de evaluaci√≥n se mantienen en expresiones m√°s complejas. En el siguiente ejemplo, es necesario ejecutar f(True) para poder resolver el primer or, pero no hace falta evaluar 1 + [2, 3], que provocar√≠a un error, porque el valor True ya alcanza para determinar el resultado de toda la operaci√≥n.\n\nFalse or f(True) or (1 + [2, 3])\n\nel valor es True\n\n\nTrue\n\n\n\n\nExpresiones condicionales\nFinalmente, esta estrategia de evaluaci√≥n no estricta (o cortocircuito) tambi√©n se aplica en las expresiones condicionales.\nEn el siguiente ejemplo, la expresi√≥n devuelve 10 porque la condici√≥n es verdadera, sin necesidad de ejecutar f(20).\n\n10 if True else f(20)\n\n10\n\n\nEn cambio, esta segunda expresi√≥n s√≠ requiere que se ejecute la llamada en la parte else de la expresi√≥n.\n\n10 if False else f(20)\n\nel valor es 20\n\n\n20",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "4 - Estrategias de evaluaci√≥n üß©"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluaci√≥n-perezosa",
    "href": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluaci√≥n-perezosa",
    "title": "4 - Estrategias de evaluaci√≥n üß©",
    "section": "Evaluaci√≥n perezosa",
    "text": "Evaluaci√≥n perezosa\nPara terminar, veamos una √∫ltima estrategia de evaluaci√≥n: la evaluaci√≥n perezosa (en ingl√©s, lazy evaluation).\nPartimos de una funci√≥n que recibe un valor, imprime un mensaje con √©l y lo devuelve:\ndef identidad(x):\n    print(\"Devuelvo\", x)\n    return x\nSi usamos map para aplicar la funci√≥n identidad a los n√∫meros 0, 1, 2 y 3:\nmap_obj = map(identidad, range(4))\nmap_obj\n&lt;map at 0x7fedb41f3cd0&gt;\nvemos que se crea un objeto map, pero no aparece ning√∫n mensaje de la funci√≥n identidad. Esto pasa porque map no ejecuta la funci√≥n sobre los elementos hasta que realmente hace falta.\nPor ejemplo, si convertimos el objeto map en una lista, reci√©n ah√≠ se produce la evaluaci√≥n:\nlista = list(map_obj)\nDevuelvo 0\nDevuelvo 1\nDevuelvo 2\nDevuelvo 3\nlista\n[0, 1, 2, 3]\nA esta estrategia, en la que se retrasa la evaluaci√≥n de las expresiones hasta el √∫ltimo momento posible, se la llama evaluaci√≥n perezosa o lazy evaluation.\nDe manera similar, filter tambi√©n utiliza una estrategia de evaluaci√≥n perezosa. Reci√©n cuando queremos materializar los elementos se aplica la funci√≥n de filtro.\n\ndef es_multiplo_5(x):\n    print(f\"x={x}\")\n    return x % 5  ==0\n\nfilter_obj = filter(es_multiplo_5, [12, 10, 8, 5, 125, 55, 11, 9])\n\n\nfor x in filter_obj:\n    print(f\"El numero {x} es m√∫ltiplo de 5\")\n\nx=12\nx=10\nEl numero 10 es m√∫ltiplo de 5\nx=8\nx=5\nEl numero 5 es m√∫ltiplo de 5\nx=125\nEl numero 125 es m√∫ltiplo de 5\nx=55\nEl numero 55 es m√∫ltiplo de 5\nx=11\nx=9\n\n\nComo se puede ver, la funci√≥n es_multiplo_5 se ejecut√≥ para cada valor de la lista num√©rica, pero filter √∫nicamente devolvi√≥ aquellos que efectivamente son m√∫ltiplos de 5.\nEn el pr√≥ximo y √∫ltimo cap√≠tulo vamos a explorar los generadores, un tipo especial de iterador que implementa una estrategia de evaluaci√≥n perezosa y nos permite recorrer secuencias incluso potencialmente infinitas.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "4 - Estrategias de evaluaci√≥n üß©"
    ]
  },
  {
    "objectID": "informacion/programa.html",
    "href": "informacion/programa.html",
    "title": "Programa",
    "section": "",
    "text": "Los profesionales en Estad√≠stica y Ciencia de Datos necesitan contar con habilidades avanzadas de programaci√≥n, que les permitan abordar problemas complejos y desarrollar soluciones eficientes y robustas.\nLa asignatura Programaci√≥n 2 introduce a los estudiantes a conceptos y pr√°cticas avanzadas de la programaci√≥n, incorporando herramientas y paradigmas que resultan fundamentales para el desarrollo profesional en Estad√≠stica y Ciencia de Datos.\nLa asignatura profundiza en enfoques como la programaci√≥n funcional y la programaci√≥n orientada a objetos, promoviendo el desarrollo de soluciones estructuradas, reutilizables, robustas y escalables. Adem√°s, se abordan conceptos fundamentales de estructuras de datos y algoritmos, relevantes para el dise√±o y an√°lisis de programas eficientes, as√≠ como para la comprensi√≥n de la complejidad computacional. Se focaliza en el lenguaje Python, ampliamente utilizado en la industria y la academia por su versatilidad, su ecosistema de librer√≠as y su capacidad para integrarse con diversas tecnolog√≠as.\nDictada en el segundo cuatrimestre del primer a√±o, Programaci√≥n 2 completa los contenidos del √°rea de Fundamentos Computacionales en el Ciclo de Formaci√≥n T√©cnica en Estad√≠stica y Ciencia de Datos, iniciada en el primer cuatrimestre con Programaci√≥n 1. De este modo, consolida las competencias inform√°ticas de los estudiantes y los prepara para afrontar asignaturas m√°s avanzadas y desaf√≠os profesionales que requieren un dominio s√≥lido de la programaci√≥n. Asimismo, fomenta buenas pr√°cticas de desarrollo de c√≥digo, el uso eficiente de los recursos computacionales y el pensamiento cr√≠tico en la resoluci√≥n de problemas.",
    "crumbs": [
      "Informaci√≥n",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/programa.html#fundamentaci√≥n",
    "href": "informacion/programa.html#fundamentaci√≥n",
    "title": "Programa",
    "section": "",
    "text": "Los profesionales en Estad√≠stica y Ciencia de Datos necesitan contar con habilidades avanzadas de programaci√≥n, que les permitan abordar problemas complejos y desarrollar soluciones eficientes y robustas.\nLa asignatura Programaci√≥n 2 introduce a los estudiantes a conceptos y pr√°cticas avanzadas de la programaci√≥n, incorporando herramientas y paradigmas que resultan fundamentales para el desarrollo profesional en Estad√≠stica y Ciencia de Datos.\nLa asignatura profundiza en enfoques como la programaci√≥n funcional y la programaci√≥n orientada a objetos, promoviendo el desarrollo de soluciones estructuradas, reutilizables, robustas y escalables. Adem√°s, se abordan conceptos fundamentales de estructuras de datos y algoritmos, relevantes para el dise√±o y an√°lisis de programas eficientes, as√≠ como para la comprensi√≥n de la complejidad computacional. Se focaliza en el lenguaje Python, ampliamente utilizado en la industria y la academia por su versatilidad, su ecosistema de librer√≠as y su capacidad para integrarse con diversas tecnolog√≠as.\nDictada en el segundo cuatrimestre del primer a√±o, Programaci√≥n 2 completa los contenidos del √°rea de Fundamentos Computacionales en el Ciclo de Formaci√≥n T√©cnica en Estad√≠stica y Ciencia de Datos, iniciada en el primer cuatrimestre con Programaci√≥n 1. De este modo, consolida las competencias inform√°ticas de los estudiantes y los prepara para afrontar asignaturas m√°s avanzadas y desaf√≠os profesionales que requieren un dominio s√≥lido de la programaci√≥n. Asimismo, fomenta buenas pr√°cticas de desarrollo de c√≥digo, el uso eficiente de los recursos computacionales y el pensamiento cr√≠tico en la resoluci√≥n de problemas.",
    "crumbs": [
      "Informaci√≥n",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/programa.html#objetivos",
    "href": "informacion/programa.html#objetivos",
    "title": "Programa",
    "section": "Objetivos",
    "text": "Objetivos\nQue los estudiantes logren:\n\nanalizar problemas computacionales y formular soluciones algor√≠tmicas adecuadas;\nimplementar esas soluciones mediante el desarrollo de programas en Python, seleccionando estructuras de datos apropiadas y evaluando la eficiencia de los algoritmos involucrados;\nidentificar y aplicar los paradigmas funcional y orientado a objetos cuando resulte pertinente, desarrollando programas que integren estos enfoques; y\nutilizar e integrar m√≥dulos y librer√≠as que permitan extender, organizar y mejorar las funcionalidades de sus programas.",
    "crumbs": [
      "Informaci√≥n",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/programa.html#contenidos",
    "href": "informacion/programa.html#contenidos",
    "title": "Programa",
    "section": "Contenidos",
    "text": "Contenidos\n\nUnidad 1: Introducci√≥n a Python\n\nLenguaje Python y su ecosistema. Uso de la interfaz Positron. Sintaxis de Python. Expresiones. Variables y asignaciones. Tipos de datos elementales. Operadores num√©ricos, de comparaci√≥n y l√≥gicos. Funciones. Ejecuci√≥n condicional de c√≥digo. Bucles definidos y no definidos. Listas, tuplas y diccionarios. Uso de c√≥digo externo. M√≥dulos y librer√≠as. Librer√≠a est√°ndar de Python. Instalaci√≥n y gesti√≥n de librer√≠as. Scripting. Lectura y escritura de archivos de texto plano. Modularizaci√≥n de programas.\n\nUnidad 2: Programaci√≥n funcional\n\nPrincipios fundamentales. Funciones como ciudadanos de primera clase. Funciones puras. Funciones an√≥nimas. Closures. Recursi√≥n. Funciones de orden superior: map, filter, reduce. Evaluaci√≥n estricta y no estricta. Evaluaci√≥n perezosa (lazy) e inmediata (eager). Generadores. Aplicaci√≥n parcial de funciones. Decoradores.\n\nUnidad 3: Programaci√≥n orientada a objetos\n\nPrincipios fundamentales. Objetos, clases e instancias. Atributos y m√©todos. Propiedades p√∫blicas y privadas. M√©todos de clase y m√©todos de instancia. Encapsulamiento. Herencia simple y m√∫ltiple. Polimorfismo. M√©todos especiales (dunder methods). Decoradores aplicados a m√©todos. Sobrecarga de operadores.\n\nUnidad 4: Estructuras de datos\n\nConcepto y clasificaci√≥n. Estructuras lineales: listas, listas enlazadas, pilas y colas. Operaciones b√°sicas: agregar, quitar y recorrer. Estructuras no lineales: √°rboles y grafos. Recorridos de √°rboles y grafos. Uso de colecciones de Python (list, deque, dict, set). Arreglos multidimensionales de NumPy.\n\nUnidad 5: Algoritmos de b√∫squeda y ordenamiento\n\nConcepto de algoritmo y complejidad. Notaci√≥n Big O. B√∫squeda lineal y binaria. Algoritmos de ordenamiento: bubble sort, insertion sort, selection sort, quick sort y merge sort. Comparaci√≥n de eficiencia. Funciones de b√∫squeda y ordenamiento en Python (sorted, sort, heapq).",
    "crumbs": [
      "Informaci√≥n",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/aprobacion.html",
    "href": "informacion/aprobacion.html",
    "title": "Condiciones de aprobaci√≥n",
    "section": "",
    "text": "üìù Examen parcial: individual y escrito. Hay un recuperatorio, de similares caracter√≠sticas, que reemplaza la nota del parcial.\nü§ù Trabajo pr√°ctico grupal: se hace fuera de clase, en grupos de entre dos y tres integrantes.\nüßë‚Äçüíª Trabajo pr√°ctico individual: opcional para promoci√≥n, con presentaci√≥n y defensa oral.\nTodas las instancias se califican en una escala de 0 a 10 y se aprueban con 6.",
    "crumbs": [
      "Informaci√≥n",
      "Condiciones de aprobaci√≥n"
    ]
  },
  {
    "objectID": "informacion/aprobacion.html#instancias-de-evaluaci√≥n",
    "href": "informacion/aprobacion.html#instancias-de-evaluaci√≥n",
    "title": "Condiciones de aprobaci√≥n",
    "section": "",
    "text": "üìù Examen parcial: individual y escrito. Hay un recuperatorio, de similares caracter√≠sticas, que reemplaza la nota del parcial.\nü§ù Trabajo pr√°ctico grupal: se hace fuera de clase, en grupos de entre dos y tres integrantes.\nüßë‚Äçüíª Trabajo pr√°ctico individual: opcional para promoci√≥n, con presentaci√≥n y defensa oral.\nTodas las instancias se califican en una escala de 0 a 10 y se aprueban con 6.",
    "crumbs": [
      "Informaci√≥n",
      "Condiciones de aprobaci√≥n"
    ]
  },
  {
    "objectID": "informacion/aprobacion.html#condiciones-de-aprobaci√≥n",
    "href": "informacion/aprobacion.html#condiciones-de-aprobaci√≥n",
    "title": "Condiciones de aprobaci√≥n",
    "section": "Condiciones de aprobaci√≥n",
    "text": "Condiciones de aprobaci√≥n\n\nPromoci√≥n\n\nQuienes aprueben el parcial individual (con nota \\(\\text{P}\\)), el trabajo pr√°ctico grupal (con nota \\(\\text{T}\\)) y el trabajo pr√°ctico individual con defensa oral (con nota \\(\\text{O}\\)), adquieren la condici√≥n de estudiante promovido y su nota final se calcula como \\(0.5 \\times \\text{P} + 0.2 \\times \\text{T} + 0.3 \\times \\text{O}\\).\n\nRegularidad\n\nQuienes aprueben el parcial individual (o su recuperatorio) y el trabajo pr√°ctico grupal, pero no accedan o no aprueben el trabajo pr√°ctico individual, adquieren la condici√≥n de estudiante regular.\n\nLibres\n\nQuienes no aprueben el parcial individual (ni su recuperatorio) o el trabajo pr√°ctico grupal, adquieren la condici√≥n de estudiante libre.",
    "crumbs": [
      "Informaci√≥n",
      "Condiciones de aprobaci√≥n"
    ]
  },
  {
    "objectID": "trabajos_practicos/descripcion.html",
    "href": "trabajos_practicos/descripcion.html",
    "title": "Descripci√≥n",
    "section": "",
    "text": "Ac√° explicamos las pautas para los TP.",
    "crumbs": [
      "Trabajos Pr√°cticos",
      "Descripci√≥n"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html",
    "href": "trabajos_practicos/trabajo_grupal.html",
    "title": "Trabajo Pr√°ctico",
    "section": "",
    "text": "Trabajo Pr√°ctico",
    "crumbs": [
      "Trabajos Pr√°cticos",
      "Trabajo Pr√°ctico"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_individual.html",
    "href": "trabajos_practicos/trabajo_individual.html",
    "title": "Trabajo Pr√°ctico Final",
    "section": "",
    "text": "Trabajo Pr√°ctico Final",
    "crumbs": [
      "Trabajos Pr√°cticos",
      "Trabajo Pr√°ctico Final"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programaci√≥n II",
    "section": "",
    "text": "Programaci√≥n II\n\n\n ¬† Ciclo de Formaci√≥n T√©cnica - Estad√≠stica y Ciencia de Datos\n ¬† Facultad de Ciencias Econ√≥micas y Estad√≠stica (UNR)\n ¬† 2¬∞ Cuatrimestre 2025"
  },
  {
    "objectID": "index.html#docentes",
    "href": "index.html#docentes",
    "title": "Programaci√≥n II",
    "section": "Docentes",
    "text": "Docentes\n\n\nTom√°s Capretto\n\n ¬† tomas.capretto@fcecon.unr.edu.ar \n\n\n\nLuciano Anselmino\n\n ¬† luciano.anselmino@fcecon.unr.edu.ar \n\n\n\nJoaqu√≠n Bermejo\n\n ¬† joaquin.bermejo@fcecon.unr.edu.ar \n\n\n\nDolores Sollberger\n\n ¬† dolores.sollberger@fcecon.unr.edu.ar"
  },
  {
    "objectID": "informacion/bibliografia.html",
    "href": "informacion/bibliografia.html",
    "title": "Bibliograf√≠a",
    "section": "",
    "text": "Principal\n\nCormen et¬†al. (2022) Downey (2024) Kalb (2022) Kubica (2022) Lott y Phillips (2021) Lott (2022) Mertz (2015) Miller, Ranum, y Yasinovskyy (2023) Sedgewick y Wayne (2011) Sedgewick, Wayne, y Dondero (2015) Sweigart (2020) Tuckfield (2021)\n\n\n\nCormen, Thomas H., Charles E. Leiserson, Ronald L. Rivest, y Clifford Stein. 2022. Introduction to Algorithms. 4th ed. MIT.\n\n\nDowney, Allen B. 2024. Think Python. 3.¬™ ed. O‚ÄôReilly Media. https://allendowney.github.io/ThinkPython/.\n\n\nKalb, Irv. 2022. Object-Oriented Python. No Starch Press.\n\n\nKubica, Jacek. 2022. Data Structures the Fun Way. 1st ed. No Starch Press.\n\n\nLott, Steven F. 2022. Functional Python Programming. 3rd ed. Packt Publishing.\n\n\nLott, Steven F., y Dusty Phillips. 2021. Python Object-Oriented Programming. 4th ed. Packt Publishing.\n\n\nMertz, David. 2015. Functional Programming in Python. O‚ÄôReilly Media.\n\n\nMiller, Bradley, David Ranum, y Jan Yasinovskyy. 2023. Problem Solving with Algorithms and Data Structures Using Python. 3rd ed. Franklin, Beedle & Associates.\n\n\nSedgewick, Robert, y Kevin Wayne. 2011. Algorithms. 4th ed. Addison-Wesley Professional.\n\n\nSedgewick, Robert, Kevin Wayne, y Robert Dondero. 2015. Introduction to Programming in Python. Addison-Wesley Professional.\n\n\nSweigart, Al. 2020. Beyond the Basic Stuff with Python. No Starch Press. https://inventwithpython.com/beyond/.\n\n\nTuckfield, Bradford. 2021. Dive Into Algorithms. No Starch Press.\n\n\n\n\nComplementaria\n\nHetland (2014) Mailund (2023) Sweigart (2021) Vaughan (2019) Wickham (2019)\n\n\n\n\n\nHetland, Magnus Lie. 2014. Python Algorithms. 2.¬™ ed. Apress.\n\n\nMailund, Thomas. 2023. Functional Programming in R 4. 2.¬™ ed. Apress.\n\n\nSweigart, Al. 2021. The Big Book of Small Python Projects. No Starch Press. https://inventwithpython.com/bigbookpython/.\n\n\nVaughan, Lee. 2019. Impractical Python Projects. No Starch Press.\n\n\nWickham, Hadley. 2019. Advanced R. 2.¬™ ed. Chapman & Hall/CRC. https://adv-r.hadley.nz/.",
    "crumbs": [
      "Informaci√≥n",
      "Bibliograf√≠a"
    ]
  },
  {
    "objectID": "informacion/calendario.html",
    "href": "informacion/calendario.html",
    "title": "Calendario",
    "section": "",
    "text": "Semana\nFecha\nTemas\nOtras actividades\n\n\n\n\n1\n4 de agosto\n‚Ä¢ Lenguaje Python y su ecosistema.‚Ä¢ Uso de Python en la terminal.‚Ä¢ Uso de Positron.‚Ä¢ Python en Positron.‚Ä¢ Python: expresiones; variables y asignaciones; tipos de datos elementales; operadores num√©ricos, de comparaci√≥n y l√≥gicos.‚Ä¢ Jupyter Notebooks.‚Ä¢ Definici√≥n de funciones.‚Ä¢ Ejecuci√≥n condicional de c√≥digo.\n\n\n\n2\n11 de agosto\n‚Ä¢ Colecciones de datos en Python: list, tuple, dict y set.‚Ä¢ Secuencias.‚Ä¢ Las secuencias str y range.‚Ä¢ Bucles definidos (for) y no definidos (while).‚Ä¢ Sentencias break y continue.\n\n\n\n3\n17 de agosto\n‚Ä¢ Uso de c√≥digo externo (propio y de terceros).‚Ä¢ M√≥dulos y librer√≠as.‚Ä¢ Librer√≠a est√°ndar de Python.‚Ä¢ Instalaci√≥n y gesti√≥n de librer√≠as.‚Ä¢ Scripting.‚Ä¢ Modularizaci√≥n de programas.‚Ä¢ Lectura y escritura de archivos de texto plano.\n\n\n\n4\n25 de agosto\n‚Ä¢ Funciones como ciudadanos de primera clase.‚Ä¢ Funciones puras.‚Ä¢ Funciones an√≥nimas.‚Ä¢ Closures.‚Ä¢ Recursi√≥n.\n\n\n\n5\n1 de septiembre\n‚Ä¢ Funciones de orden superior: map, filter, reduce.‚Ä¢ Evaluaci√≥n estricta y no estricta.‚Ä¢ Evaluaci√≥n perezosa (lazy) e inmediata (eager).‚Ä¢ Generadores.‚Ä¢ Aplicaci√≥n parcial de funciones.‚Ä¢ Decoradores.\n\n\n\n6\n15 de septiembre\n‚Ä¢ Objetos, clases e instancias.‚Ä¢ Atributos y m√©todos.‚Ä¢ Propiedades p√∫blicas y privadas.‚Ä¢ M√©todos de clase y m√©todos de instancia.\n\n\n\n7\n22 de septiembre\n‚Ä¢ Encapsulamiento.‚Ä¢ Herencia simple y m√∫ltiple.‚Ä¢ Polimorfismo.‚Ä¢ Abstracci√≥n.\n\n\n\n8\n29 de septiembre\n‚Ä¢ M√©todos especiales (dunder methods).‚Ä¢ Decoradores aplicados a m√©todos.‚Ä¢ Sobrecarga de operadores.\nParcial\n\n\n9\n6 de octubre\n‚Ä¢ Concepto y clasificaci√≥n.‚Ä¢ Estructuras lineales y no lineales.‚Ä¢ Listas y listas enlazadas.‚Ä¢ Operaciones b√°sicas: agregar, quitar y recorrer.\nPresentaci√≥n TP Grupal\n\n\n10\n13 de octubre\n‚Ä¢ Hashing.‚Ä¢ Diccionarios y conjuntos como estructuras asociativas.‚Ä¢ √Årboles y grafos.\nRecuperatorio\n\n\n11\n20 de octubre\n‚Ä¢ Arreglos multidimensionales de NumPy.\n\n\n\n12\n27 de octubre\n‚Ä¢ Concepto de algoritmo y complejidad.‚Ä¢ Algoritmos de b√∫squeda.‚Ä¢ B√∫squeda lineal y binaria.‚Ä¢ Notaci√≥n Big O.\n\n\n\n13\n3 de noviembre\n‚Ä¢ Algoritmos de ordenamiento.‚Ä¢ bubble sort, insert sort, select sort, quick sort y merge sort.‚Ä¢ Comparaci√≥n de algoritmos de ordenamiento.\nEntrega TP GrupalPresentaci√≥n TP Individual\n\n\n14\n10 de noviembre\n‚Ä¢ Funciones de b√∫squeda y ordenamiento en Python.\n\n\n\n15\n17 de noviembre\n\n\n\n\n16\n24 de noviembre\n\nEntrega y defensa TP Individual",
    "crumbs": [
      "Informaci√≥n",
      "Calendario"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/05_generadores.html",
    "href": "teoria/02_programacion_funcional/05_generadores.html",
    "title": "5 - Generadores üß©",
    "section": "",
    "text": "En este cap√≠tulo vamos a introducirnos en los generadores, tanto en las funciones como en las expresiones generadoras. A diferencia de las funciones regulares, que devuelven un resultado con return, los generadores no devuelven un √∫nico resultado, sino que van entregando valores de a uno a medida que se lo solicita. Cada vez que se entrega un valor, la ejecuci√≥n queda en pausa y se conserva el estado de las variables, de modo que puede reanudarse m√°s adelante. De este modo, los generadores resultan ideales para definir iteradores y trabajar con grandes vol√∫menes de datos sin necesidad de almacenarlos al mismo tiempo en memoria.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "5 - Generadores üß©"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/05_generadores.html#introducci√≥n",
    "href": "teoria/02_programacion_funcional/05_generadores.html#introducci√≥n",
    "title": "5 - Generadores üß©",
    "section": "",
    "text": "En este cap√≠tulo vamos a introducirnos en los generadores, tanto en las funciones como en las expresiones generadoras. A diferencia de las funciones regulares, que devuelven un resultado con return, los generadores no devuelven un √∫nico resultado, sino que van entregando valores de a uno a medida que se lo solicita. Cada vez que se entrega un valor, la ejecuci√≥n queda en pausa y se conserva el estado de las variables, de modo que puede reanudarse m√°s adelante. De este modo, los generadores resultan ideales para definir iteradores y trabajar con grandes vol√∫menes de datos sin necesidad de almacenarlos al mismo tiempo en memoria.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "5 - Generadores üß©"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/05_generadores.html#funciones-generadoras",
    "href": "teoria/02_programacion_funcional/05_generadores.html#funciones-generadoras",
    "title": "5 - Generadores üß©",
    "section": "Funciones generadoras",
    "text": "Funciones generadoras\nUna funci√≥n generadora se define igual que una funci√≥n com√∫n con def, pero en lugar de devolver un valor con return, lo hace con yield.\nCuando se ejecuta una funci√≥n generadora, no se ejecuta el c√≥digo en su cuerpo de manera inmediata ni se obtiene un resultado. En cambio, se obtiene un generador que luego puede entregar valores.\n\ndef gen():\n    yield \"¬°Resultado!\"\n\ng = gen()\ng\n\n&lt;generator object gen at 0x7f90c8738ca0&gt;\n\n\nComo los generadores son iteradores (ver Iterables e iteradores), se puede usar next para obtener el siguiente valor de manera manual:\n\nnext(g)\n\n'¬°Resultado!'\n\n\nEste primer ejemplo es demasiado simple para apreciar la verdadera utilidad de los generadores. Si solo necesit√°ramos devolver un √∫nico valor, bastar√≠a con usar una funci√≥n com√∫n.\nLa ventaja de los generadores est√° en que pueden entregar varios valores de a uno, a medida que se los solicita, mientras conservan el estado de las variables.\nVeamos ahora una segunda funci√≥n generadora, esta vez con dos instrucciones yield en lugar de una. En la primera llamada a next, obtenemos \"Primer resultado\".\n\ndef gen():\n    yield \"Primer resultado\"\n    yield \"Segundo resultado\"\n\ng = gen()\nnext(g)\n\n'Primer resultado'\n\n\nY en la segunda llamada a next el generador entrega el segundo valor: \"Segundo resultado\".\n\nnext(g)\n\n'Segundo resultado'\n\n\nEn la primera llamada a next, la funci√≥n se ejecuta hasta llegar a la primera instrucci√≥n yield. All√≠ el generador devuelve un valor y suspende su ejecuci√≥n. Con la segunda llamada, la ejecuci√≥n se reanuda desde ese punto y contin√∫a hasta encontrar el siguiente yield, entregando otro valor.\nAhora bien, ¬øqu√© ocurre si llamamos a next cuando el generador ya entreg√≥ todos los valores disponibles?\nnext(g)\n    next(g)\n    ~~~~^^^\nStopIteration\nUna vez que un generador se agota, cualquier llamada adicional a next elevar√° la excepci√≥n StopIteration, que se√±ala que ya no quedan valores por producir.\nPara observar con m√°s detalle c√≥mo funciona la ejecuci√≥n y suspensi√≥n en los generadores, vamos a implementar una funci√≥n que mantiene el estado de una variable num√©rica e imprime un mensaje justo antes de cada yield.\n\ndef generador(x):\n    print(\"Recib√≠ el valor\", x)\n\n    x = x + 18\n    print(\"Entrego el valor\", x)\n    yield x\n\n    x = x - 5\n    print(\"Esto una entrega siguiente, devuelvo el valor\", x)\n    yield x\n\n    print(\"Este mensaje est√° bien al final\")\n\ng = generador(7)\n\nComo se puede observar, la ejecuci√≥n de la funci√≥n generadora no imprimi√≥ ning√∫n mensaje, ya que esto no ejecuta el cuerpo de la funci√≥n. Reci√©n al pedir el primer valor se ejecutan los dos print previos al primer yield. Adem√°s, el valor inicial 7 se incrementa en 18 y luego es devuelto.\n\nnext(g)\n\nRecib√≠ el valor 7\nEntrego el valor 25\n\n\n25\n\n\nEn la segunda llamada a next(g) se imprime un mensaje y se entrega el valor 25 - 5 = 20. Esto muestra que el generador conserva el estado de las variables: en lugar de usar el valor original de x, utiliza el valor actualizado en la entrega anterior.\n\nnext(g)\n\nEsto una entrega siguiente, devuelvo el valor 20\n\n\n20\n\n\nSin embargo, el print al final, debajo del √∫ltimo yield, a√∫n no se ejecut√≥. Para eso, usamos next(g) nuevamente.\nnext(g)\nEste mensaje est√° bien al final\n\n    next(g)\n    ~~~~^^^\nStopIteration\nComo no hay ning√∫n otro valor por entregar, se imprime el mensaje y luego se obtiene la excepci√≥n StopIteration.\n\nEjemplo 1: Secuencia de n√∫meros naturales\nLos generadores tambi√©n permiten crear secuencias infinitas. Para ello basta con escribir un bucle infinito dentro de la funci√≥n generadora. Esto no representa un problema, ya que el generador produce un valor a la vez, √∫nicamente cuando se le solicita.\n\ndef numeros_naturales():\n    n = 0\n    while True:\n        yield n\n        n = n + 1\n\nsecuencia = numeros_naturales()\n\nLuego, pedimos los valores de a uno:\n\nprint(next(secuencia))\nprint(next(secuencia))\nprint(next(secuencia))\nprint(next(secuencia))\nprint(next(secuencia))\n\n0\n1\n2\n3\n4\n\n\nVale la pena notar que un generador no tiene longitud, ya que podr√≠a ser infinito, ni permite acceder a sus elementos por √≠ndice. Solo sabe c√≥mo producir el pr√≥ximo valor, sin conocer de antemano cu√°ntos quedan por generar.\nlen(secuencia)\n    len(secuencia)\n    ~~~^^^^^^^^^^\nTypeError: object of type 'generator' has no len()\nsecuencia[0]\n    secuencia[0]\n    ~~~~~~~~~^^^\nTypeError: 'generator' object is not subscriptable\nComo los generadores son iteradores, podemos recorrerlos con un bucle for. En el caso de secuencias infinitas, es necesario usar un break para evitar que el bucle nunca termine.\n\ni = 0\nfor n in secuencia:\n    print(n)\n    i += 1\n    if i &gt;= 5:\n        break\n\n5\n6\n7\n8\n9\n\n\nSi nuestro √∫nico objetivo es recorrer los elementos del generador, podemos inicializarlo directamente en el bucle for.\n\nfor n in numeros_naturales():\n    print(n)\n    if n &gt;= 7:\n        break\n\n0\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\nEjemplo 2: Secuencia de Fibonacci\nLas secuencias infinitas no se limitan a los n√∫meros naturales. Como los generadores conservan el estado de las variables dentro de la funci√≥n, tambi√©n pueden usarse para producir otras secuencias, como la de Fibonacci.\n\\[\nF_n =\n\\begin{cases}\n0 & \\text{si } n = 0 \\\\\n1 & \\text{si } n = 1 \\\\\nF_{n-1} + F_{n - 2} & \\text{si } n \\ge 2 \\\\\n\\end{cases}\n\\]\n\ndef fibonacci():\n    a = 0\n    b = 1\n    while True:\n        yield a\n        a, b = b, a + b\n\nSi queremos los primeros 10 n√∫meros de la secuencia, podemos utilizar un bucle for que ejecuta next(g) 10 veces seguidas.\n\ng = fibonacci()\nfor _ in range(10):\n    print(next(g))\n\n0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n\n\nAl volver a pedir un nuevo valor a nuestro generador, este contin√∫a avanzando en la secuencia de Fibonacci.\n\nnext(g)\n\n55\n\n\n\nnext(g)\n\n89\n\n\n\n\nEjemplo 3: Promedio acumulado\nEn este ejemplo se muestra un generador que procesa una secuencia num√©rica y va devolviendo el promedio acumulado a medida que avanza.\nComo los valores se producen bajo demanda, en memoria solo se conserva la secuencia original y el √∫ltimo promedio calculado.\n\ndef promedio_acumulado(numeros):\n    numerador = 0\n    for i, numero in enumerate(numeros):\n        numerador += numero\n        yield numerador / (i + 1)\n\nvalores = [2, 4, 9, 1, 7, 11] # Supongamos una lista muy grande de n√∫meros\n\nfor m in promedio_acumulado(valores):\n    print(f\"Promedio acumulado: {m:.2f}\")\n\nPromedio acumulado: 2.00\nPromedio acumulado: 3.00\nPromedio acumulado: 5.00\nPromedio acumulado: 4.00\nPromedio acumulado: 4.60\nPromedio acumulado: 5.67",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "5 - Generadores üß©"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/05_generadores.html#expresiones-generadoras",
    "href": "teoria/02_programacion_funcional/05_generadores.html#expresiones-generadoras",
    "title": "5 - Generadores üß©",
    "section": "Expresiones generadoras",
    "text": "Expresiones generadoras\nLas expresiones generadoras, del ingl√©s generator expressions, proveen una manera concisa para construir generadores. Se parecen a las list comprehensions, pero usan par√©ntesis en vez de corchetes.\nSupongamos una lista de n√∫meros cualquiera y que usamos una list comprehension para obtener el triple de cada n√∫mero.\n\nnumeros = [3, 14, 2, 7, 1, 28]\ntriples = [n * 3 for n in numeros]\n\nprint(numeros)\nprint(triples)\n\n[3, 14, 2, 7, 1, 28]\n[9, 42, 6, 21, 3, 84]\n\n\nLa expresi√≥n generadora equivalente es la siguiente:\n\ntriples = (n * 3 for n in numeros)\ntriples\n\n&lt;generator object &lt;genexpr&gt; at 0x7f90c87702b0&gt;\n\n\nComo todo generador, implementa la estrategia de evaluaci√≥n perezosa. Esto quiere decir que el triple de cada n√∫mero se calcula justo en el momento en que se solicita, no antes.\nAs√≠, podemos obtener los valores mediante un bucle:\n\nfor n in triples:\n    print(n)\n\n9\n42\n6\n21\n3\n84\n\n\nUn generador creado con una expresi√≥n generadora es equivalente a uno definido con una funci√≥n generadora. En ambos casos, si se intenta obtener un valor de un generador ya agotado, se producir√° un error.\nnext(triples)\n    next(triples)\n    ~~~~^^^^^^^^^\nStopIteration\nY al intentar obtener una lista a partir de un generador agotado, obtendremos una lista vac√≠a.\n\nlist(triples)\n\n[]\n\n\nAdem√°s de ser perezosos, los generadores son de √∫nico uso. Sus valores se generan a medida que se solicitan y no se guardan en memoria, de modo que, una vez consumidos, no es posible volver a iterarlos.\nEsta aparente limitaci√≥n es en realidad una ventaja. A diferencia de una lista, que construye y guarda todos sus elementos en memoria, un generador solo define una receta para producirlos cuando se necesiten. En el siguiente ejemplo se muestra c√≥mo esto impacta en el consumo de memoria frente a una lista.\n\nimport sys\n\n# Enteros divisibles por 3 o 5 entre 1 y 10,000,000\nlista = [n for n in range(1, 10_000_001) if n % 3 == 0 or n % 5 == 0]\ngenexpr = (n for n in range(1, 10_000_001) if n % 3 == 0 or n % 5 == 0)\n\nprint(sys.getsizeof(lista))   # bytes\nprint(sys.getsizeof(genexpr)) # bytes\n\n39064728\n200\n\n\nY a partir de ambos objetos se puede computar, por ejemplo, la suma.\n\nsum(lista), sum(genexpr)\n\n(23333341666668, 23333341666668)\n\n\nEn resumen, mientras que una lista es una colecci√≥n de valores, un generador es una receta para producir valores.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "5 - Generadores üß©"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/05_generadores.html#sec-iteradores",
    "href": "teoria/02_programacion_funcional/05_generadores.html#sec-iteradores",
    "title": "5 - Generadores üß©",
    "section": "Iterables e iteradores",
    "text": "Iterables e iteradores\nA lo largo de este cap√≠tulo dijimos varias veces que los generadores son iteradores, aunque todav√≠a no definimos con precisi√≥n qu√© significa eso.\nLo que s√≠ sabemos es que un objeto es iterable cuando puede recorrerse con un bucle for. En Python, las listas, las cadenas y los diccionarios son ejemplos de objetos iterables, por lo que los siguientes bloques de c√≥digo funcionan sin problemas:\nfor i in [10, 55, 2]:\n    print(i + 5)\n\nfor c in \"palabras\":\n    print(c.upper())\n\nfor k in {\"nombre\": \"Juan\", \"apellido\": \"P√©rez\"}:\n    print(k)\nComo ya vimos que una lista se puede recorrer con un bucle, podr√≠amos preguntarnos si tambi√©n es posible usar la funci√≥n next para obtener su siguiente elemento.\n\nnums = [-10, 0, 10]\n\nnext(nums)\n    next(nums)\n    ~~~~^^^^^^\nTypeError: 'list' object is not an iterator\nSin embargo, al hacerlo obtenemos un TypeError que indica que la lista no es un iterador. Lo mismo ocurre si intentamos usar next directamente con una cadena o un diccionario.\nnext(\"palabra\")\n    next(\"palabra\")\n    ~~~~^^^^^^^^^^^\nTypeError: 'str' object is not an iterator\nnext({\"nombre\": \"Juan\", \"apellido\": \"P√©rez\"})\n    next({\"nombre\": \"Juan\", \"apellido\": \"P√©rez\"})\n    ~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: 'dict' object is not an iterator\nEl error que aparece al usar next sobre una lista, una cadena o un diccionario muestra que no basta con que un objeto sea iterable para poder aplicarle next directamente.\nLo que sucede, es que, en realidad, nuestra definici√≥n inicial de iterable era incompleta: un objeto es iterable cuando puede generar un iterador a partir de √©l.\nLuego, es el iterador que conoce c√≥mo producir los valores uno a uno y, por eso, es sobre el iterador (y no sobre el iterable) que Python puede aplicar next para avanzar en la secuencia.\nPara crear un iterador a partir de un iterable usamos iter.\n\niterador = iter(nums)\niterador\n\n&lt;list_iterator at 0x7f90c87337f0&gt;\n\n\nY ahora s√≠ es posible avanzar a trav√©s de los elementos de la lista original:\n\nnext(iterador)\n\n-10\n\n\n\nnext(iterador)\n\n0\n\n\n\nnext(iterador)\n\n10\n\n\nnext(iterador)\n    next(iterador)\n    ~~~~^^^^^^^^^^\nStopIteration\nPor √∫ltimo, vale la pena se√±alar que los iteradores solo pueden construirse a partir de objetos iterables. Por ejemplo, un n√∫mero entero no es iterable, por lo que no es posible obtener un iterador a partir de √©l.\niter(10)\n    iter(10)\n    ~~~~^^^^\nTypeError: 'int' object is not iterable\nEn resumen, en Python solo se puede iterar sobre iteradores. Un objeto es iterable cuando puede generar un iterador a partir de √©l, y es este √∫ltimo el que sabe c√≥mo devolver los elementos uno a uno mediante la funci√≥n next. Cuando ya no quedan m√°s valores por producir, el iterador eleva la excepci√≥n StopIteration.\nLos generadores son un caso particular de iteradores: producen sus valores bajo demanda y mantienen el estado entre llamadas.\nFinalmente, al usar un bucle for con un iterable, todo este mecanismo ocurre de forma autom√°tica: Python crea el iterador por nosotros y se encarga de avanzar en la secuencia hasta agotarla.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "5 - Generadores üß©"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html",
    "href": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html",
    "title": "3 - Funciones de orden superior",
    "section": "",
    "text": "Las funciones de orden superior son una herramienta muy importante en la programaci√≥n funcional. A lo largo de esta unidad, trabajaremos con las siguientes variedades de funciones de orden superior:\n\nFunciones que aceptan funciones como argumentos.\nFunciones que devuelven una funci√≥n como resultado.\nFunciones que aceptan funciones como argumentos y devuelven una funci√≥n como resultado.\n\nEn este cap√≠tulo comenzamos enfoc√°ndonos en las funciones de orden superior m√°s elementales: map, filter y reduce; todas ellas reciben funciones como argumentos. Luego, aprenderemos sobre las comprehensions, que constituyen la alternativa moderna y Pythonica a las funciones mencionadas anteriormente. Finalmente, trabajaremos con funciones que devuelven funciones cuando exploremos evaluaci√≥n parcial de funciones y el uso de decoradores.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "3 - Funciones de orden superior"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#introducci√≥n",
    "href": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#introducci√≥n",
    "title": "3 - Funciones de orden superior",
    "section": "",
    "text": "Las funciones de orden superior son una herramienta muy importante en la programaci√≥n funcional. A lo largo de esta unidad, trabajaremos con las siguientes variedades de funciones de orden superior:\n\nFunciones que aceptan funciones como argumentos.\nFunciones que devuelven una funci√≥n como resultado.\nFunciones que aceptan funciones como argumentos y devuelven una funci√≥n como resultado.\n\nEn este cap√≠tulo comenzamos enfoc√°ndonos en las funciones de orden superior m√°s elementales: map, filter y reduce; todas ellas reciben funciones como argumentos. Luego, aprenderemos sobre las comprehensions, que constituyen la alternativa moderna y Pythonica a las funciones mencionadas anteriormente. Finalmente, trabajaremos con funciones que devuelven funciones cuando exploremos evaluaci√≥n parcial de funciones y el uso de decoradores.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "3 - Funciones de orden superior"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#map-filter-y-reduce",
    "href": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#map-filter-y-reduce",
    "title": "3 - Funciones de orden superior",
    "section": "Map, Filter y Reduce",
    "text": "Map, Filter y Reduce\nLas funciones map, filter y reduce son funciones de orden superior fundamentales en la programaci√≥n funcional. Act√∫an como primitivas b√°sicas para procesar y transformar secuencias, y muchas otras operaciones funcionales pueden construirse a partir de ellas o expresarse en t√©rminos de estas.\nLas primeras dos, map y filter, est√°n disponibles por defecto en nuestra sesi√≥n de Python (ya que son funciones built-in), mientras que a reduce la tenemos que importar desde el m√≥dulo est√°ndar functools.\n\nMap\nSupongamos que tenemos una secuencia de palabras y queremos invertir el orden de los caracteres de cada una. Para ello, vamos a rebanadar cada cadena desde el principio al final usando un paso de -1. Por ejemplo:\n\n\"cosa\"[::-1]\n\n'asoc'\n\n\nSi quisi√©ramos obtener una lista con las palabras invertidas, podr√≠amos crear una nueva lista, recorrer la original con un bucle for, invertir cada palabra y guardarla en la lista nueva.\n\npalabras = [\"hola\", \"mate\", \"somos\",\" libro\", \"conocer\", \"anilina\", \"programa\"]\npalabras_invertidas = []\n\nfor palabra in palabras:\n    palabras_invertidas.append(palabra[::-1])\n\nprint(\"Palabras originales:\", palabras, \"\\n\", sep=\"\\n\")\nprint(\"Palabras invertidas:\", palabras_invertidas, sep=\"\\n\")\n\nPalabras originales:\n['hola', 'mate', 'somos', ' libro', 'conocer', 'anilina', 'programa']\n\n\nPalabras invertidas:\n['aloh', 'etam', 'somos', 'orbil ', 'reconoc', 'anilina', 'amargorp']\n\n\nLa alternativa funcional consiste en utilizar map para aplicar una funci√≥n a cada palabra de la secuencia. En este caso, aplicamos la funci√≥n invertir, que invierte los caracteres de una palabra, a cada elemento de la lista palabras.\n\ndef invertir(x):\n    return x[::-1]\n\nlist(map(invertir, palabras))\n\n['aloh', 'etam', 'somos', 'orbil ', 'reconoc', 'anilina', 'amargorp']\n\n\nAs√≠, se obtiene una nueva lista con las palabras invertidas, sin necesidad de iterar manualmente con un bucle for.\nSi quisi√©ramos que el programa fuese a√∫n m√°s conciso, podr√≠amos usar una funci√≥n an√≥nima en vez de una funci√≥n regular:\n\nlist(map(lambda x: x[::-1], palabras))\n\n['aloh', 'etam', 'somos', 'orbil ', 'reconoc', 'anilina', 'amargorp']\n\n\n\n\n\n\n\n\nEl objeto map üîç\n\n\n\nEn el ejemplo anterior usamos list para convertir el resultado de map en una lista. Este paso, que puede parecer innecesario, es fundamental si queremos obtener una lista como resultado final. De lo contrario, la llamada a map devuelve un objeto de tipo map.\nmap(lambda x: x[::-1], palabras)\n&lt;map object at 0x7fd2fc1ad360&gt;\nEste objeto, perezoso e iterable, puede recorrerse o convertirse en otras colecciones como listas, tuplas o conjuntos:\nlist(map(lambda x: x[::-1], palabras))\n['aloh', 'etam', 'somos', 'orbil ', 'reconoc', 'anilina', 'amargorp']\n\n\n\nmap con datos complejos\nEn el ejemplo anterior se us√≥ map sobre una secuencia simple de cadenas de texto. Sin embargo, eso no implica que su uso se limite a casos sencillos.\nSupongamos ahora que tenemos una lista anidada de n√∫meros, es decir, una lista que contiene otras listas con valores num√©ricos:\n\nventas = [\n    [22.5, 9.3, 11.0],\n    [5.4, 22.5],\n    [3.0, 3.0, 12.9, 7.5],\n]\n\nSi queremos calcular el total de cada sublista, podemos combinar map con la funci√≥n sum. Esto aplica sum a cada elemento de la lista ventas, generando como resultado una nueva lista con los totales de cada sublista.\n\nlist(map(sum, ventas))\n\n[42.8, 27.9, 26.4]\n\n\nDe manera similar, se puede obtener el m√≠nimo, el m√°ximo, la media u otra medida de inter√©s aplicando la funci√≥n correspondiente a cada sublista.\nUsando una combinaci√≥n m√°s compleja de maps y expresiones lambda, se puede determinar cu√°les sublistas de ventas contienen al menos un valor mayor a 20.\n\nlist(\n    map(\n        lambda sublista: any(map(lambda x: x &gt; 20,  sublista)),\n        ventas\n    )\n)\n\n[True, True, False]\n\n\nComo puede observarse, un programa que utiliza map junto con expresiones lambda puede volverse dif√≠cil de leer y comprender r√°pidamente, especialmente a medida que la l√≥gica se vuelve m√°s compleja.\nPara finalizar este listado de ejemplos, observemos uno donde se crea un diccionario a partir del map, en vez de una lista.\nSe cuenta con una lista de diccionarios. Cada diccionario contiene el nombre y las calificaciones de una persona. Nuestro objetivo es obtener un nuevo diccionario que tenga por claves al nombre de la persona, y por valor a la nota promedio.\n\nnotas = [\n    {\n        \"nombre\": \"Mariano\",\n        \"notas\": [6, 9, 9, 8]\n    },\n    {\n        \"nombre\": \"Daniela\",\n        \"notas\": [6, 7, 7, 8]\n    },\n    {\n        \"nombre\": \"Sof√≠a\",\n        \"notas\": [8, 6, 9, 8]\n    },\n]\n\nSin utilizar un enfoque funcional, una soluci√≥n posible es la siguiente:\n\ndef media(x):\n    return sum(x) / len(x)\n\npromedios = {}\n\nfor datum in notas:\n    promedios[datum[\"nombre\"]] = media(datum[\"notas\"])\n\npromedios\n\n{'Mariano': 8.0, 'Daniela': 7.0, 'Sof√≠a': 7.75}\n\n\nEn cambio, utilizando map:\n\ndict(map(lambda datum: (datum[\"nombre\"], media(datum[\"notas\"])), notas))\n\n{'Mariano': 8.0, 'Daniela': 7.0, 'Sof√≠a': 7.75}\n\n\nLa clave est√° en notar que la expresi√≥n lambda devuelve una tupla de dos elementos, donde el primero es el nombre y el segundo, la nota promedio. A partir de estos pares (str, float), se puede construir directamente un diccionario.\n\n\nmap con m√∫ltiples iterabes\nHasta ahora hemos utilizado map con funciones que se aplican sobre los elementos de un √∫nico iterable. Sin embargo, map tambi√©n acepta m√∫ltiples iterables y los recorre en paralelo, lo que la convierte en una funci√≥n vari√°dica. Esto permite aplicar funciones que toman m√°s de un argumento, una vez por cada grupo de elementos correspondientes.\nSupongamos que queremos redondear un listado de n√∫meros utilizando diferentes niveles de precisi√≥n. Para redondear un √∫nico n√∫mero podemos usar directamente round:\n\nround(29.12951138, 4)\n\n29.1295\n\n\nSi quisi√©ramos redonear m√∫ltiples n√∫meros en una lista, usando el mismo nivel de precisi√≥n, podemos usar map y round:\n\nnumeros = [\n    30.60726375,\n    78.12297368,\n    61.94972186,\n    68.78842783,\n    55.60016942,\n    94.9760221,\n    90.41151716,\n    38.72727347,\n    21.30193307,\n    66.39407577\n]\nlist(map(lambda x: round(x, 3), numeros))\n\n[30.607, 78.123, 61.95, 68.788, 55.6, 94.976, 90.412, 38.727, 21.302, 66.394]\n\n\n¬øY si quisi√©ramos aplicar diferentes niveles de precisi√≥n a cada n√∫mero? Para ello, tambi√©n podemos usar map. Definimos una funci√≥n que reciba dos argumentos y luego iteramos en paralelo sobre dos iterables: uno con los n√∫meros y otro con las precisiones correspondientes.\n\nprecisiones = [2, 2, 3, 3, 4, 4, 5, 5, 2, 2]\nlist(map(lambda x, y: round(x, y), numeros, precisiones))\n\n[30.61, 78.12, 61.95, 68.788, 55.6002, 94.976, 90.41152, 38.72727, 21.3, 66.39]\n\n\n\n\n\n\n\n\n¬øQu√© pasa si un iterable es m√°s corto que el otro? ü§î\n\n\n\nCuando se recorren m√∫ltiples iterables con map, la iteraci√≥n se detiene tan pronto como se agota el iterable m√°s corto. Por ejemplo, si tenemos 10 n√∫meros pero solo 5 precisiones, map aplicar√° la funci√≥n √∫nicamente a los primeros 5 pares de elementos:\nprecisiones = [1, 2, 3, 4, 5]\nlist(map(lambda x, y: round(x, y), numeros, precisiones))\n[30.6, 78.12, 61.95, 68.7884, 55.60017]\n\n\n\n\n\nFilter\nfilter se utiliza para seleccionar ‚Äîo, m√°s precisamente, filtrar‚Äî elementos de un iterable seg√∫n el resultado de aplicar una funci√≥n. A diferencia de map, la funci√≥n usada por filter se aplica sobre los elementos de un solo iterable y debe devolver un valor booleano. El resultado es un nuevo iterable que contiene √∫nicamente los elementos para los que la funci√≥n retorna True.\nComo ejemplo del uso de filter, vamos a seleccionar las notas menores a 6 a partir de una lista de calificaciones.\n\nnotas = [6, 9, 6, 5, 7, 4, 5, 8, 3, 10, 9, 4, 7, 8]\nlist(filter(lambda x: x &lt; 6, notas))\n\n[5, 4, 5, 3, 4]\n\n\nDe este modo, resulta sencillo calcular el promedio de las notas de aquellos que no aprobaron:\n\nmedia(list(filter(lambda x: x &lt; 6, notas)))\n\n4.2\n\n\nRetomando el ejemplo del listado de palabras que se quer√≠an revertir, se podr√≠a usar filter para seleccionar solo aquellas palabras que sean pal√≠ndromos, es decir, capic√∫a.\n\npalabras = [\"hola\", \"mate\", \"somos\",\" libro\", \"conocer\", \"anilina\", \"programa\"]\ncapicuas = list(filter(lambda p: p[::-1] == p, palabras))\ncapicuas\n\n['somos', 'anilina']\n\n\nNaturalmente, filter tambi√©n puede utilizarse para filtrar objetos m√°s complejos. Por ejemplo, si tenemos una lista de diccionarios con informaci√≥n de estudiantes (nombre, ciudad de origen, edad y fecha de inscripci√≥n), podemos usar filter para seleccionar aquellos que cumplan una o m√°s condiciones. En ese caso, el valor booleano que devuelve la funci√≥n se construye combinando condiciones mediante operadores l√≥gicos como and.\n\ndatos = [\n    {\"nombre\": \"Agustina\", \"ciudad\": \"Casilda\", \"edad\": 18, \"inscripcion\": 2025},\n    {\"nombre\": \"Emiliano\", \"ciudad\": \"Rosario\", \"edad\": 21, \"inscripcion\": 2024},\n    {\"nombre\": \"David\", \"ciudad\": \"Pergamino\", \"edad\": 19, \"inscripcion\": 2024},\n    {\"nombre\": \"Julieta\", \"ciudad\": \"Rosario\", \"edad\": 19, \"inscripcion\": 2025},\n    {\"nombre\": \"Victoria\", \"ciudad\": \"Cha√±ar Ladeado\", \"edad\": 18, \"inscripcion\": 2025},\n    {\"nombre\": \"Fernando\", \"ciudad\": \"Rosario\", \"edad\": 20, \"inscripcion\": 2024},\n    {\"nombre\": \"Mateo\", \"ciudad\": \"P√©rez\", \"edad\": 23, \"inscripcion\": 2025},\n    {\"nombre\": \"Luc√≠a\", \"ciudad\": \"Rosario\", \"edad\": 22, \"inscripcion\": 2022},\n    {\"nombre\": \"Joaqu√≠n\", \"ciudad\": \"Casilda\", \"edad\": 19, \"inscripcion\": 2025},\n    {\"nombre\": \"Micaela\", \"ciudad\": \"Rosario\", \"edad\": 18, \"inscripcion\": 2024},\n]\n\nlist(filter(lambda x: x[\"ciudad\"] == \"Rosario\" and x[\"inscripcion\"] == 2025, datos))\n\n[{'nombre': 'Julieta', 'ciudad': 'Rosario', 'edad': 19, 'inscripcion': 2025}]\n\n\n\n\nReduce\nLa funci√≥n reduce permite reducir una secuencia a un √∫nico valor aplicando de forma sucesiva una funci√≥n de dos argumentos sobre sus elementos.\nPara utilizarla, es necesario importarla desde el m√≥dulo est√°ndar functools:\n\nfrom functools import reduce\n\nreduce aplica la funci√≥n acumulando resultados de a pares, desde el primer elemento hasta el √∫ltimo. Por ejemplo:\nreduce(lambda x, y: x + y, [1, 2, 3, 4, 5])\nequivale a:\n((((1 + 2) + 3) + 4) + 5)\nEn este caso, es simplemente una forma m√°s rebuscada de escribir sum([1, 2, 3, 4, 5]) en Python.\nPara entender c√≥mo funciona el proceso de acumulaci√≥n en reduce, podemos definir una funci√≥n que imprima los valores de sus argumentos en cada paso:\n\ndef sumar(x, y):\n    print(f\"x={x}, y={y}\")\n    return x + y\n\nreduce(sumar, [1, 2, 3, 4, 5])\n\nx=1, y=2\nx=3, y=3\nx=6, y=4\nx=10, y=5\n\n\n15\n\n\nEn la primera llamada, x e y son los dos primeros elementos de la secuencia. En la segunda, x es el resultado de la llamada anterior, e y es el siguiente elemento de la secuencia. Este proceso contin√∫a hasta que se recorre toda la lista.\nEn resumen:\n\nx representa el valor acumulado hasta el momento.\ny es el nuevo elemento a combinar.\n\nAs√≠, reduce va aplicando la funci√≥n paso a paso, acumulando resultados hasta obtener un √∫nico valor final.\nMuchas operaciones comunes, como sumas, productos, m√≠nimos o m√°ximos, pueden expresarse mediante reducciones. Por ejemplo, es posible calcular el factorial de un n√∫mero utilizando una reduce:\n\ndef factorial(n):\n    return reduce(lambda x, y: x * y, range(1, n + 1))\n\nfactorial(5)\n\n120\n\n\nLa reducci√≥n mediante la multiplicaci√≥n de dos n√∫meros, aplicada a la secuencia del 1 al n, da como resultado el factorial de n.\nFinalmente, podemos ver que combinando una funci√≥n que devuelve el mayor de dos n√∫meros y una reducci√≥n, es posible obtener el m√°ximo de una secuencia.\n\ndef mayor(x, y):\n    if x &gt; y:\n        return x\n    return y\n\nreduce(mayor, [23, 49, 6, 32, 101, 9])\n\n101\n\n\nVale la pena mencionar que reduce acepta un tercer argumento opcional, que especifica el valor inicial de la reducci√≥n. Este valor se utiliza como punto de partida antes de procesar los elementos del iterable.\n\ndef sumar(x, y):\n    print(f\"x={x}, y={y}\")\n    return x + y\n\nreduce(sumar, [1, 2, 3, 4, 5], 20)\n\nx=20, y=1\nx=21, y=2\nx=23, y=3\nx=26, y=4\nx=30, y=5\n\n\n35\n\n\n\n\n\n\n\n\nExpresiones condicionales üîÄüò±\n\n\n\nLa reducci√≥n anterior puede expresarse de forma m√°s concisa utilizando expresiones condicionales:\nreduce(lambda x, y: x if x &gt; y else y, [23, 49, 6, 32, 101, 9])\nEstas expresiones permiten simplificar asignaciones condicionales. Por ejemplo, el siguiente bloque:\nif x &gt; y:\n    valor = x\nelse:\n    valor = y\npuede escribirse de manera m√°s compacta as√≠:\nvalor = x if x &gt; y else y\nEn t√©rminos generales, la sintaxis es:\n&lt;valor_si_verdadero&gt; if &lt;condici√≥n&gt; else &lt;valor_si_falso&gt;\n\n\n\n\nResumen de Map, Filter y Reduce\nEl siguiente bloque de c√≥digo resume el funcionamiento de map, filter y reduce.\n\nnumeros = [1, 2, 3, 4, 5]\n\n# Map: Aplicar una funci√≥n a cada elemento de un iterable\ncuadrados = list(map(lambda x: x**2, numeros))\nprint(\"Map [cuadrados]:\", cuadrados)\n\n# Filter: Devuelve el subconjunto de elementos para los que la funci√≥n devuelve True\npares = list(filter(lambda x: x % 2 == 0, numeros))\nprint(\"Filter [pares]:\", pares)\n\n# Reduce: Aplica una funci√≥n de dos argumentos de manera acumulativa a los elementos de una secuencia\nproducto = reduce(lambda x, y: x * y, numeros)\nprint(\"Reduce [producto]:\", producto)\n\nMap [cuadrados]: [1, 4, 9, 16, 25]\nFilter [pares]: [2, 4]\nReduce [producto]: 120\n\n\n\nMap y Filter como casos particulares de Reduce üò±\nPor otro lado, algo menos evidente es que tanto map como filter pueden verse como casos particulares de reduce.\nEsta aplicaci√≥n de map:\n\nlist(map(lambda x: x * 2, range(10)))\n\n[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n\n\nPuede ser reproducida con el siguiente uso de reduce:\n\ndef dup(x):\n    return x * 2\n\nreduce(lambda seq, x: seq + [dup(x)], range(10), [])\n\n[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n\n\nY el siguiente uso de filter\n\nlist(filter(lambda x: x % 2 == 1, range(10)))\n\n[1, 3, 5, 7, 9]\n\n\n\ndef es_impar(x):\n    return x % 2 == 1\n\nreduce(lambda seq, x: seq + [x] if es_impar(x) else seq, range(10), [])\n\n[1, 3, 5, 7, 9]\n\n\nEstas expresiones con reduce() son complejas, pero ilustran claramente el poder de la funci√≥n: cualquier operaci√≥n que pueda definirse a partir de una combinaci√≥n sucesiva de elementos puede, al menos en principio, expresarse como una reducci√≥n, aunque no siempre sea la forma m√°s clara o recomendada de hacerlo.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "3 - Funciones de orden superior"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#comprehensions",
    "href": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#comprehensions",
    "title": "3 - Funciones de orden superior",
    "section": "Comprehensions",
    "text": "Comprehensions\nCuando usamos map y filter obtenemos objetos especiales: map devuelve un objeto de tipo map, y filter devuelve un objeto de tipo filter. Estos objetos son iterables y perezosos, lo que significa que no realizan ninguna operaci√≥n hasta que se los recorre o convierte en una colecci√≥n, como una lista. Por eso, si queremos ver directamente el resultado de una transformaci√≥n o filtrado, necesitamos envolverlos con list():\nnumeros = [1, 2, 3]\nlist(map(lambda x: x * 2, numeros))          # ‚Üí [2, 4, 6]\nlist(filter(lambda x: x % 2 == 0, numeros))  # ‚Üí [2]\nAunque map y filter siguen siendo completamente v√°lidos y √∫tiles, hoy en d√≠a se consideran formas algo anticuadas o menos idiom√°ticas de construir listas transformadas o filtradas en Python.\nLa alternativa moderna y, en general preferida, son las comprensiones de listas (del ingl√©s, list comprehensions), que permiten expresar las mismas ideas de forma m√°s clara y legible:\n\nnumeros = list(range(11))\n[x * 2 for x in numeros] # Reemplaza a list(map())\n\n[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n\n\n\n[x for x in numeros if x % 2 == 0] # Reemplaza a list(filter())\n\n[0, 2, 4, 6, 8, 10]\n\n\n\nComprehension como reemplazo de Map\nSupongamos que tenemos una lista de n√∫meros y queremos restarles su media.\nUna forma de hacerlo utilizando un bucle for ser√≠a:\n\nvector = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]\n\nmedia = media(vector)\nvector_centrado = []\nfor x in vector:\n    vector_centrado.append(x - media)\n\nvector_centrado\n\n[-4.5, -3.5, -2.5, -1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5]\n\n\nSi, en cambio, decidimos usar map, podemos hacer:\n\nlist(map(lambda x: x - media, vector))\n\n[-4.5, -3.5, -2.5, -1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5]\n\n\nFinalmente, se puede obtener el mismo resultado usando una list comprehension:\n\n[x - media for x in vector]\n\n[-4.5, -3.5, -2.5, -1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5]\n\n\nLa sintaxis general de una list comprehension que aplica una transformaci√≥n sobre los elementos de un iterable es:\n[&lt;expresi√≥n&gt; for elemento in iterable]\nComo se observa en el ejemplo anterior, lo que aparece en la parte izquierda como &lt;expresi√≥n&gt; no tiene por qu√© ser una llamada a una funci√≥n; puede ser cualquier expresi√≥n v√°lida que produzca un resultado. Es decir, una operaci√≥n matem√°tica, un formateo de texto, la construcci√≥n de una estructura de datos, una llamada a una funci√≥n, etc.\n\n\nComprehension como reemplazo de Filter\nAhora veamos con mayor detalle c√≥mo funciona una list comprehension que reemplaza al uso de filter. Para eso, retomemos el ejemplo de las palabras capic√∫a.\n\npalabras = [\"hola\", \"mate\", \"somos\",\" libro\", \"conocer\", \"anilina\", \"programa\"]\n\nInicialmente, podemos construir un listado de palabras capic√∫a usando un bucle for.\n\ncapicuas = []\nfor palabra in palabras:\n    if palabra == palabra[::-1]:\n        capicuas.append(palabra)\ncapicuas\n\n['somos', 'anilina']\n\n\nLuego, podemos construir el listado de palabras capic√∫a usando la funci√≥n de orden superior filter.\n\nlist(filter(lambda x: x == x[::-1], palabras))\n\n['somos', 'anilina']\n\n\nY finalmente, se puede obtener exactamente el mismo resultado mediante una list comprehension.\n\n[palabra for palabra in palabras if palabra == palabra[::-1]]\n\n['somos', 'anilina']\n\n\nLa sintaxis general de una list comprehension que filtra los elementos de un iterable es:\n[elemento for elemento in iterable if &lt;expresi√≥n_l√≥gica&gt;]\nAl igual que en la list comprehension que aplica funciones a todos los ementos, &lt;expresi√≥n_l√≥gica&gt; puede ser cualquier expresi√≥n de Python que devuelva un valor True o False, o que pueda interpretarse como tal.\n\n\n\n\n\n\nComprehensions con expresiones condicionales üò±\n\n\n\nLa estructura general:\n[elemento for elemento in iterable if &lt;expresi√≥n_l√≥gica&gt;]\npuede modificarse cuando se desea evaluar una expresi√≥n en caso de que se cumpla una condici√≥n y otra distinta si no se cumple. Para ello, se usa una expresi√≥n condicional directamente en la parte izquierda de la comprensi√≥n:\n[&lt;expresi√≥n_si_verdadero&gt; if &lt;condici√≥n&gt; else &lt;expresi√≥n_si_falso&gt; for elemento in iterable]\nPor ejemplo:\nnumeros = [1, 2, 3, 4, 5]\n[f\"{x} es par\" if x % 2 == 0 else f\"{x} es impar\" for x in numeros]\n['1 es impar', '2 es par', '3 es impar', '4 es par', '5 es impar']\n\n\n\n\n\n\n\n\nDictionary comprehensions üò±üò±\n\n\n\nLas comprensiones en Python no est√°n limitadas a listas. Este patr√≥n tambi√©n puede utilizarse para construir otras estructuras de datos como diccionarios, conjuntos e incluso generadores (estructura que veremos m√°s adelante).\nPor ejemplo, una comprensi√≥n de diccionario permite crear un dict a partir de una secuencia de pares clave-valor:\ndef media(x):\n    return sum(x) / len(x)\n\ndatos = [\n    (\"Marcos\", (4, 8, 9, 9)),\n    (\"Joaqu√≠n\", (10, 8, 8, 7)),\n    (\"Luj√°n\", (10, 9, 9, 10)),\n]\n\n{nombre: media(notas) for nombre, notas in datos}\n{'Marcos': 7.5, 'Joaqu√≠n': 8.25, 'Luj√°n': 9.5}",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "3 - Funciones de orden superior"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#evaluaci√≥n-parcial-de-funciones",
    "href": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#evaluaci√≥n-parcial-de-funciones",
    "title": "3 - Funciones de orden superior",
    "section": "Evaluaci√≥n parcial de funciones",
    "text": "Evaluaci√≥n parcial de funciones\nEn el El paradigma funcional comenzamos a trabajar con function factories, es decir, con funciones que fabrican y devuelven funciones. El ejemplo que vimos consist√≠a en una funci√≥n crear_multiplicador que recib√≠a un m√∫ltiplo y devolv√≠a una funci√≥n de un argumento que al llamarla realizaba la multiplcaci√≥n. As√≠, era posible crear funciones para duplicar, triplicar, cuadruplicar, etc.\n\ndef crear_multiplicador(x):\n    def interna(y):\n        return y * x\n    return interna\n\nduplicar = crear_multiplicador(2)\ntriplicar = crear_multiplicador(3)\n\nprint(duplicar(10), triplicar(22))\n\n20 66\n\n\nAhora bien, esta no es la √∫nica forma de crear funciones que multipliquen dos numeros dejando uno de sus argumentos fijo.\nUna alternativa consiste en crear una funci√≥n general de multiplicaci√≥n y usar partial del m√≥dulo functools para obtener una versi√≥n de la misma con alguno de sus argumentos fijados.\n\ndef multiplicar(x, y):\n    return x * y\n\nmultiplicar(7, 8)\n\n56\n\n\n\nfrom functools import partial\n\ncuadruplicar = partial(multiplicar, 8)\ncuadruplicar(2)\n\n16\n\n\nEn esencia, partial toma una funci√≥n y fija algunos de sus par√°metros, devolviendo una nueva funci√≥n con argumentos ya establecidos. Dicho de otro modo, partial produce una funci√≥n parcialmente evaluada, de ah√≠ su nombre.\nDe un modo similar, se podr√≠an crear funciones de potencia a partir de una funci√≥n gen√©rica.\n\ndef potencia(x, n):\n    return x ** n\n\ncuadrado = partial(potencia, n=2)\ncubo = partial(potencia, n=3)\n\nprint(cuadrado(5), cubo(9))\n\n25 729\n\n\nMediante un ejemplo podemos ver que partial tambi√©n permite fijar m√°s de un par√°metro. Supongamos que tenemos una lista de n√∫meros que queremos estandarizar; es decir, restarles la media y dividir cada valor por el desv√≠o.\n\nnums = [\n    4.74346239e-01, -2.90877176e-01, -1.44377789e+00, -4.48680759e+01,\n    -1.21249801e+00, -3.32729317e-01,  2.21676912e-01,  1.05599711e+00,\n    -3.62372053e+00, -2.96441579e-01, -4.28304222e+00,  1.55908820e+02,\n    9.00858234e-01, -1.09384173e+00, -1.51083571e+00, -5.38491167e-01,\n    -3.84153084e-02,  1.20393395e+00,  1.82651406e-01,  2.05179405e+00\n]\n\ndef media(x):\n    return sum(x) / len(x)\n\ndef varianza(x):\n    numerador = 0\n    x_media = media(x)\n    for x_i in x:\n        numerador += (x_i - x_media) ** 2\n    return numerador / len(x)\n\nestandarizar = partial(\n1    lambda x, media, desvio: (x - media) / desvio,\n2    media=media(nums),\n    desvio=varianza(nums) ** 0.5\n)\n\n\n1\n\nDefinimos una funci√≥n lambda que implementa la estandarizaci√≥n. Esta funci√≥n recibe el valor a estandarizar, la media y el desv√≠o correspondientes.\n\n2\n\nCalculamos la media y el desv√≠o de la lista, y luego los pasamos a partial como par√°metros a fijar.\n\n\n\n\nDe esta manera, obtenemos la funci√≥n estandarizar, que al recibir un n√∫mero le resta la media y lo divide por el desv√≠o calculado a partir de nums.\n\nestandarizar(numeros[0])\n\n-0.1425284124988861\n\n\nY, si queremos estandarizar toda la secuencia, podemos usar una list comprehension.\n\n[estandarizar(num) for num in nums]\n\n[-0.12933243764138067,\n -0.1506204085674334,\n -0.18269328610772323,\n -1.390726359064761,\n -0.17625924440864513,\n -0.15178470535100874,\n -0.13636151853677025,\n -0.1131513242720763,\n -0.24333773925841856,\n -0.1507752062996549,\n -0.2616795995472022,\n 4.1947440261328905,\n -0.11746717741646615,\n -0.1729583111265218,\n -0.1845587869464874,\n -0.1575088536123251,\n -0.1435970990449382,\n -0.10903582664474336,\n -0.13744718034588063,\n -0.08544896194045284]\n\n\n\n\n\n\n\n\nArgumentos posicionales y nombrados üî¢üè∑Ô∏è\n\n\n\npartial puede utilizarse para fijar tanto argumentos posicionales como nombrados. Cuando recibe argumentos posicionales, estos se transmiten a la funci√≥n original en el mismo orden; mientras que, si se le pasan argumentos nombrados, se reenv√≠an como tales.\nPor ejemplo, las siguientes llamadas a partial generan funciones equivalentes:\ndef prod(x, y):\n    return x * y\n\npartial(prod, 5)     # 5 * y\npartial(prod, x=5)   # 5 * y\npartial(prod, y=5)   # x * 5",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "3 - Funciones de orden superior"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#decoradores",
    "href": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#decoradores",
    "title": "3 - Funciones de orden superior",
    "section": "Decoradores",
    "text": "Decoradores\nEn Ciudadanos de primera clase aprendimos que las funciones son un objeto como cualquier otro. Por eso, ya no nos sorprende que puedan pasarse como argumento a otra funci√≥n o devolverse como resultado de otra funci√≥n.\nAhora vamos a explorar un tipo de funciones que son muy √∫tiles en Python: los decoradores.\nLos decoradores son funciones que ‚Äúenvuelven‚Äù o ‚Äúencapsulan‚Äù funciones y modifican su comportamiento.\nEmpecemos con un ejemplo: la funci√≥n decorador recibe una funci√≥n fun, define una funci√≥n envoltura que contiene una llamada a fun y la devuelve.\n\ndef decorador(fun):\n\n    def envoltura():\n        print(\"Antes de llamar a la funci√≥n...\")\n        fun()\n        print(\"Listo, ya se llam√≥ a la funci√≥n.\")\n\n    return envoltura\n\nPara mostrar el funcionamiento del decorador, definamos una funci√≥n muy sencilla, que simplemente imprime un saludo.\n\ndef decir_hola():\n    print(\"¬°Hola hola!\")\n\ndecir_hola()\n\n¬°Hola hola!\n\n\nAhora, invocamos a decorador pasandole la funci√≥n decir_hola y obtenemos una nueva una funci√≥n.\nPodemos ver que esta nueva funci√≥n es la funci√≥n envoltura definida dentro del decorador.\n\nnueva = decorador(decir_hola)\nnueva\n\n&lt;function __main__.decorador.&lt;locals&gt;.envoltura()&gt;\n\n\nAntes de ejecutar la funci√≥n nueva, intentemos anticipar qu√© va a ocurrir cuando la llamemos.\nAl invocar nueva, se ejecutar√°n las siguientes tres l√≠neas de c√≥digo:\n1print(\"Antes de llamar a la funci√≥n...\")\n2fun()\n3print(\"Listo, ya se llam√≥ a la funci√≥n.\")\n\n1\n\nLa primera l√≠nea contiene directamente un print, por lo que podemos anticipar que lo primero que vamos a ver es un mensaje que dice \"Antes de llamar a la funci√≥n...\".\n\n2\n\nLa segunda l√≠nea contiene una llamada a la funci√≥n fun. Esta es la funci√≥n que le pasamos a decorador al momento de crear nueva, es decir, es la funci√≥n decir_hola.\nPor lo tanto, habr√° un segundo mensaje que dice \"¬°Hola hola!\".\n\n3\n\nFinalmente, se ejecuta la tercera l√≠nea, y como vemos que es un print, sabemos que vamos a ver un mensaje que dice \"Listo, ya se llam√≥ a la funci√≥n.\".\n\n\n\nnueva()\n\nAntes de llamar a la funci√≥n...\n¬°Hola hola!\nListo, ya se llam√≥ a la funci√≥n.\n\n\nEn este ejemplo vemos que el decorador ‚Äúenvuelve‚Äù o ‚Äúencapsula‚Äù a la funci√≥n decir_hola. Gracias a esto, la funci√≥n decoorada ya no se ejecuta como antes, sino que ahora tambi√©n imprime mensajes antes y despu√©s de realizar la tarea en su definici√≥n original.\n\nDecoradores que reciben argumentos\nSi intentamos pasarle argumentos a la funci√≥n nueva, obtendremos un error. Este error no se debe a que la funci√≥n decorada, decir_hola, no acepte par√°metros, sino a que la funci√≥n que devuelve el decorador, envoltura, no est√° preparada para recibirlos.\nAhora bien, si queremos que nuestra funci√≥n de envoltura pueda transmitir argumentos a la funci√≥n decorada, necesitamos un mecanismo flexible. No podemos conocer de antemano qu√© par√°metros recibir√° la funci√≥n a decorar, justamente porque no sabemos cu√°l ser√° esa funci√≥n.\nLa soluci√≥n es definir envoltura de manera que acepte una cantidad arbitraria de argumentos posicionales y nombrados. De esta forma, podemos propagar todos esos argumentos a la funci√≥n decorada sin importar cu√°les sean.\n\ndef decorador(fun):\n\n    def envoltura(*args, **kwargs):\n        if args:\n            print(\"Argumentos posicionales:\", args)\n        if kwargs:\n            print(\"Argumentos nombrados:\", kwargs)\n        fun(*args, **kwargs)\n\n    return envoltura\n\ndef potencia(x, n):\n    return x ** n\n\npotencia = decorador(potencia)\n\n\npotencia(5, 3)\n\nArgumentos posicionales: (5, 3)\n\n\n\npotencia(5, n=3)\n\nArgumentos posicionales: (5,)\nArgumentos nombrados: {'n': 3}\n\n\n\npotencia(x=5, n=3)\n\nArgumentos nombrados: {'x': 5, 'n': 3}\n\n\nEl ejemplo muestra que el decorador imprime los argumentos de la funci√≥n original, tanto posicionales como nombrados, siempre que se le haya pasado alguno.\n\n\nDecoradores que devuelven valores\nSi bien el decorador anterior funcionaba correctamente con funciones que reciben tanto argumentos posicionales como nombrados, no vemos que la funci√≥n decorada devuelva la potencia calculada. Para que eso ocurra, la envoltura no solo tiene que llamar a fun, sino tambi√©n retornar lo que esta retorne.\n\ndef decorador(fun):\n\n    def envoltura(*args, **kwargs):\n        if args:\n            print(\"Argumentos posicionales:\", args)\n        if kwargs:\n            print(\"Argumentos nombrados:\", kwargs)\n1        return fun(*args, **kwargs)\n\n    return envoltura\n\ndef potencia(x, n):\n    return x ** n\n\n\n1\n\nGracias a esta l√≠nea, la funci√≥n envoltura ahora retorna que fun retorne.\n\n\n\n\n\npotencia = decorador(potencia)\npotencia(x=5, n=3)\n\nArgumentos nombrados: {'x': 5, 'n': 3}\n\n\n125\n\n\n\n\nAz√∫car sint√°ctico\nDado que los decoradores cumplen un rol muy importante en la programaci√≥n con Python, el lenguaje ofrece una sintaxis especial para aplicarlos directamente al momento de definir una funci√≥n.\nPara ello, basta con escribir @&lt;nombre_decorador&gt; en la l√≠nea anterior a la definici√≥n de la funci√≥n. Por ejemplo:\n\n@decorador\ndef producto(x, y):\n    return x * y\n\nproducto(3, 7)\n\nArgumentos posicionales: (3, 7)\n\n\n21\n\n\n\nproducto(x=3, y=7)\n\nArgumentos nombrados: {'x': 3, 'y': 7}\n\n\n21\n\n\nDe esta manera, no es necesario incluir l√≠neas adicionales del estilo:\ndef funcion(...):\n    ...\n    return ...\n\nfuncion = decorador(funcion)\nA este tipo de atajos sint√°cticos que brinda el lenguaje se los conoce como az√∫car sint√°ctico (del ingl√©s, syntax sugar).\n\n\nEjemplo: medir tiempo de ejecuci√≥n\nHasta ahora, los ejemplos que vimos fueron un tanto artificiales, pensados √∫nicamente para mostrar qu√© son los decoradores y c√≥mo se utilizan. A continuaci√≥n, presentamos un ejemplo m√°s cercano a un uso pr√°ctico:\nEl decorador timer imprime el tiempo de ejecuci√≥n que le toma a una funci√≥n. Luego, lo aplicamos para comparar los tiempos entre la funci√≥n built-in max y otra implementaci√≥n que obtiene el m√°ximo mediante una reducci√≥n.\n\nimport time\n\ndef timer(fun):\n    def envoltura(*args, **kwargs):\n        inicio = time.time()\n        resultado = fun(*args, **kwargs)\n        fin = time.time()\n        print(f\"{fun.__name__} demor√≥ {fin - inicio:6f} segundos\")\n        return resultado\n    return envoltura\n\n\ndef mayor(x, y):\n    if x &gt; y:\n        return x\n    return y\n\n@timer\ndef maximo_reduce(x):\n    return reduce(mayor, x)\n\n@timer\ndef maximo_builtin(x):\n    return max(x)\n\n\nlista = list(range(1_000_000))\n\nmaximo_reduce(lista)\n\nmaximo_reduce demor√≥ 0.040458 segundos\n\n\n999999\n\n\n\nmaximo_builtin(lista)\n\nmaximo_builtin demor√≥ 0.006502 segundos\n\n\n999999",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "3 - Funciones de orden superior"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html",
    "title": "3 - Ejecuci√≥n condicional",
    "section": "",
    "text": "Las computadoras son muy buenas para much√≠simas cosas. En particular:\n\nDeterminar autom√°ticamente que secciones de un programa se debe ejecutar.\nRealizar tareas repetitivas.\n\nEl primer punto se refiere a la ejecuci√≥n condicional de c√≥digo y el segundo a la ejecuci√≥n repetitiva de c√≥digo.\nEstos dos puntos pueden ser vistos de manera general como control de flujo del c√≥digo.\nEn este apunte hablamos de la ejecuci√≥n condicional de c√≥digo.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "3 - Ejecuci√≥n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#introducci√≥n",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#introducci√≥n",
    "title": "3 - Ejecuci√≥n condicional",
    "section": "",
    "text": "Las computadoras son muy buenas para much√≠simas cosas. En particular:\n\nDeterminar autom√°ticamente que secciones de un programa se debe ejecutar.\nRealizar tareas repetitivas.\n\nEl primer punto se refiere a la ejecuci√≥n condicional de c√≥digo y el segundo a la ejecuci√≥n repetitiva de c√≥digo.\nEstos dos puntos pueden ser vistos de manera general como control de flujo del c√≥digo.\nEn este apunte hablamos de la ejecuci√≥n condicional de c√≥digo.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "3 - Ejecuci√≥n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if",
    "title": "3 - Ejecuci√≥n condicional",
    "section": "Bloques if",
    "text": "Bloques if\nLos bloques if utilizan la keyword if para evaluar una condici√≥n y ejecutar una secci√≥n de c√≥digo en base al resultado de esta evaluaci√≥n.\n\n\n\n\n\nVeamos un ejemplo.\n\ncondicion = True\nif condicion:\n    print(\"Se ejecuta el bloque if\")\n\nSe ejecuta el bloque if\n\n\n\ncondicion = False\nif condicion:\n    print(\"Se ejecuta el bloque if\")\n\nDe manera mas general, un bloque if es de la siguiente forma:\n\n\n\n\n\nTiene los siguientes componentes:\n\nLa palabra clave if.\nLa condici√≥n a evaluar, que tiene que ser True o False. Esta va seguida de los dos puntos : que indican el fin de la condici√≥n a evaluar y que lo siguiente es el bloque de c√≥digo a ejecutar condicionalmente.\nEl bloque de c√≥digo a evaluar si condici√≥n es verdadera.\n\nVeamos otro ejemplo.\n\ncondicion = True\nif condicion:\n    print(\"Se ejecuta el bloque if\")\n\nprint(\"Esto se imprime siempre\")\n\nSe ejecuta el bloque if\nEsto se imprime siempre\n\n\nEl segundo print() se imprime siempre porque est√° por fuera del bloque de ejecuci√≥n condicional.\n¬øC√≥mo nos damos cuenta que no est√° dentro del bloque condicional?\nSimplemente la indentaci√≥n vuelve a ser normal. El fin de la indentaci√≥n indica el fin del bloque de c√≥digo.\n\nvalor = 12\nif valor &gt; 10:\n    print(\"Se ejecuta el bloque if\")\n\nSe ejecuta el bloque if",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "3 - Ejecuci√≥n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if---else",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if---else",
    "title": "3 - Ejecuci√≥n condicional",
    "section": "Bloques if - else",
    "text": "Bloques if - else\nVimos que el bloque if nos permite ejecutar un bloque de c√≥digo de manera condicional, y que luego el programa sigue su ejecuci√≥n normal.\nTambi√©n es posible que necesitemos ejecutar un bloque de c√≥digo cuando las condiciones resulten en True y un bloque distinto en el caso contrario.\nPara eso, utilizamos el bloque if-else.\nUn bloque if-else es muy similar a un bloque if.\nLa diferencia es que nos permite definir otro bloque de c√≥digo que se ejecuta cuando la prueba condicional es False.\n\n\n\n\n\n\nedad = 21\nif edad &gt;= 16:\n    print(\"Ten√©s la edad suficiente para votar\")\nelse:\n    print(\"Lo siento, a√∫n sos demasiado j√≥ven para votar\")\n\nTen√©s la edad suficiente para votar\n\n\n\n\n\n\n\nAl igual que con el bloque if, cualquier parte del c√≥digo que se escriba luego del bloque if-else es ejecutada sin importar el valor de las condiciones.\nVeamos otro ejemplo donde evaluamos si un n√∫mero es par o impar.\n\nvalor = 10\nprint(valor)\n\nif valor % 2 == 0:\n    mensaje = \"Es par\"\nelse:\n    mensaje = \"Es impar\"\n\nprint(mensaje)\n\n10\nEs par\n\n\nEn este caso, print(mensaje) se ejecuta siempre.\nLo que var√≠a es el valor de la variable mensaje, que depende de si el n√∫mero es par o impar.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "3 - Ejecuci√≥n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if-elif-else",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if-elif-else",
    "title": "3 - Ejecuci√≥n condicional",
    "section": "Bloques if-elif-else",
    "text": "Bloques if-elif-else\nEs muy probable que tengamos situaciones donde necesitemos considerar m√°s de dos escenarios posibles.\nPara esto, Python ofrece los bloques if-elif-else.\nEste tipo de programa considera varias condiciones y las eval√∫a de a una a la vez hasta que alguna es verdadera. Luego se ejecuta solamente el bloque de c√≥digo que corresponde a la primer condici√≥n verdadera.\n\n\n\n\n\nSupongamos que viene un parque de diversiones a Rosario y tiene los siguientes precios para la entrada:\n\nMenores de 4 a√±os, gratis.\nPersonas entre 4 y 18 a√±os, $400.\nPersonas de 18 o mas a√±os, $600.\n\n\nedad = 3\n\nif edad &lt; 4:\n    print(\"El costo de entrada para vos es de $0.\")\nelif edad &lt; 18:\n    print(\"El costo de entrada para vos es de $400.\")\nelse:\n    print(\"El costo de entrada para vos es de $600.\")\n\nEl costo de entrada para vos es de $0.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "3 - Ejecuci√≥n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#m√∫ltiples-bloques-elif",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#m√∫ltiples-bloques-elif",
    "title": "3 - Ejecuci√≥n condicional",
    "section": "M√∫ltiples bloques elif",
    "text": "M√∫ltiples bloques elif\nHasta ahora utilizamos un √∫nico bloque elif, pero podemos usar tantos como sea necesario.\nPor ejemplo, si el parque de diversiones decide realizar un descuento para adultos mayores, dejando el precio en $350, podriamos agregar otro bloque elif que represente la evaluaci√≥n de esta condici√≥n.\n\nedad = 68\n\nif edad &lt; 4:\n    precio = 0\nelif edad &lt; 18:\n    precio = 400\nelif edad &lt; 65:\n    precio = 600\nelse:\n    precio = 350\n\nprint(f\"El precio de entrada para vos es de ${precio}.\")\n\nEl precio de entrada para vos es de $350.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "3 - Ejecuci√≥n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#omitir-el-bloque-else",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#omitir-el-bloque-else",
    "title": "3 - Ejecuci√≥n condicional",
    "section": "Omitir el bloque else",
    "text": "Omitir el bloque else\nNo hay ninguna regla que nos obligue a terminar un bloque de if-elif con un bloque else.\nUtilizar el bloque else a veces es lo correcto, pero otras veces puede ser mejor poner una condici√≥n expl√≠cita en un √∫ltimo elif que contemple solamente la condici√≥n que realmente nos interesa.\n\nedad = 10\n\nif edad &lt; 4:\n    precio = 0\nelif edad &lt; 18:\n    precio = 400\nelif edad &lt; 65:\n    precio = 600\nelif edad &gt;= 65:\n    precio = 350\n\nprint(f\"El precio de entrada para vos es de ${precio}.\")\n\nEl precio de entrada para vos es de $400.\n\n\nEl bloque elif que agregamos indica que el precio ser√° de $350 cuando la edad de la persona sea mayor o igual a 65 a√±os.\nEsta condici√≥n es m√°s expl√≠cita y f√°cil de entender que el bloque else que us√°bamos antes.\nSin embargo, todav√≠a hay un problema: el programa sigue funcionando incluso si se ingresan edades fuera de un rango razonable. A continuaci√≥n se muestra una versi√≥n m√°s completa:\n\nedad = 125\n\nif edad &lt; 0:\n    print(\"¬°Error!\")\n    precio = None\nelif edad &lt; 4:\n    precio = 0\nelif edad &lt; 18:\n    precio = 400\nelif edad &lt; 65:\n    precio = 600\nelif edad &gt;= 65 and edad &lt;= 120:\n    precio = 350\nelse:\n    print(\"¬°Error!\")\n    precio = None\n\nprint(f\"El precio de entrada para vos es ${precio}.\")\n\n¬°Error!\nEl precio de entrada para vos es $None.\n\n\nEl diagrama y el c√≥digo para el caso solo con elif se ven de la siguiente manera:",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "3 - Ejecuci√≥n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html",
    "href": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html",
    "title": "6 - Uso de c√≥digo externo",
    "section": "",
    "text": "En la mayor√≠a de los proyectos de programaci√≥n no alcanza con el c√≥digo que escribimos nosotros mismos. Con frecuencia necesitamos utilizar c√≥digo externo y/o de terceros, ya sea para resolver problemas comunes de manera m√°s r√°pida o para aprovechar el trabajo de la comunidad.\nPython facilita este proceso a trav√©s de m√≥dulos y paquetes, que nos permiten organizar, compartir e integrar c√≥digo de forma sencilla. Gracias a ellos podemos sumar nuevas funcionalidades sin tener que programar todo desde cero, mantener el c√≥digo m√°s ordenado y evitar errores innecesarios.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "6 - Uso de c√≥digo externo"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#introducci√≥n",
    "href": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#introducci√≥n",
    "title": "6 - Uso de c√≥digo externo",
    "section": "",
    "text": "En la mayor√≠a de los proyectos de programaci√≥n no alcanza con el c√≥digo que escribimos nosotros mismos. Con frecuencia necesitamos utilizar c√≥digo externo y/o de terceros, ya sea para resolver problemas comunes de manera m√°s r√°pida o para aprovechar el trabajo de la comunidad.\nPython facilita este proceso a trav√©s de m√≥dulos y paquetes, que nos permiten organizar, compartir e integrar c√≥digo de forma sencilla. Gracias a ellos podemos sumar nuevas funcionalidades sin tener que programar todo desde cero, mantener el c√≥digo m√°s ordenado y evitar errores innecesarios.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "6 - Uso de c√≥digo externo"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#m√≥dulos-y-paquetes",
    "href": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#m√≥dulos-y-paquetes",
    "title": "6 - Uso de c√≥digo externo",
    "section": "M√≥dulos y paquetes",
    "text": "M√≥dulos y paquetes\nUn m√≥dulo es un archivo de Python (por ejemplo, modulo.py) que contiene c√≥digo que se puede reutilizar. En general, los m√≥dulos definen funciones, clases y objetos que representan datos de distinta complejidad. Estos pueden ir desde estructuras simples, como una constante num√©rica, hasta otras m√°s elaboradas, como una tabla de datos con columnas de diferentes tipos.\nUn paquete, por otro lado, es una colecci√≥n de m√≥dulos, generalmente interdependientes. En la pr√°ctica, un paquete es una carpeta que contiene varios m√≥dulos e, incluso, subpaquetes (carpetas con m√≥dulos). Por lo general, los paquetes ofrecen un conjunto de herramientas m√°s amplio que un m√≥dulo individual. Adem√°s, suelen distribuirse de forma que puedan ser instalados y utilizados por otros usuarios.\n\nPor qu√© existen\nAs√≠ como las funciones ayudan a reutilizar un programa sin repetir el c√≥digo y los bucles permiten repetir la misma acci√≥n muchas veces, los m√≥dulos y paquetes tambi√©n permiten la reutilizaci√≥n de c√≥digo.\nDe este modo se evita, por ejemplo, tener que crear una funci√≥n cada vez que la queremos usar. Simplemente la importamos o la ‚Äútraemos‚Äù de un m√≥dulo o paquete. Se ahorra tiempo, se reduce la probabilidad de errores y se mejora la mantenibilidad del c√≥digo.\nAdem√°s, los paquetes y m√≥dulos nos ayudan a mantener el c√≥digo organizado y modular. Al dividir el c√≥digo en ‚Äúpartes‚Äù m√°s peque√±as y manejables, facilitamos su comprensi√≥n y mantenimiento.\nPor √∫ltimo pero no menos importante, los m√≥dulos paquetes nos permiten aprovechar el trabajo de otros. De esta manera, podemos hacer mucho m√°s sin tener que programar todo desde cero.\n\n\n\n\n\n\nGlosario üéØ\n\n\n\nLa documentaci√≥n de Python 3 provee un glosario con definiciones precisas para t√©rminos relevantes en el universo de Python. Entre ellas, podemos destacar las de m√≥dulo y paquete:\n\nM√≥dulo: Un objeto que funciona como una unidad de organizaci√≥n de c√≥digo de Python. Los m√≥dulos tienen un espacio de nombres (namespace) que contiene objetos de Python arbitrarios. Los m√≥dulos se cargan en Python a trav√©s del proceso de importaci√≥n.\nPaquete: Un m√≥dulo de Python que puede contener subm√≥dulos o, de forma recursiva, subpaquetes. T√©cnicamente, un paquete es un m√≥dulo de Python con un atributo __path__.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "6 - Uso de c√≥digo externo"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#c√≥mo-importar-c√≥digo",
    "href": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#c√≥mo-importar-c√≥digo",
    "title": "6 - Uso de c√≥digo externo",
    "section": "C√≥mo importar c√≥digo",
    "text": "C√≥mo importar c√≥digo\n\nLa sentencia import\nPara importar un m√≥dulo usamos la sentencia import seguida del nombre del m√≥dulo a importar.\nimport nombre\nDe esta manera, podemos importar el m√≥dulo math que pertenece a la librer√≠a est√°ndar de Python.\n\nimport math\n\nLuego, podemos acceder a los objetos dentro del namespace math utilizando math.nombre_objeto. Por ejemplo, para usar la funci√≥n sqrt(), que calcula la ra√≠z cuadrada de un numero n, escribimos math.sqrt(n).\n\nmath.sqrt(16)\n\n4.0\n\n\nSi quisi√©ramos importar m√°s de una m√≥dulo, solo tenemos que agregar una nueva l√≠nea con el import correspondiente. As√≠, podemos tambi√©n importar el m√≥dulo random que provee herramientas para generar n√∫meros aleatorios.\n\nimport math\nimport random\n\n\nrandom.random() # n√∫mero aleatorio entre 0 y 1\n\n0.02007022378062895\n\n\n\n\n\n\n\n\nLibrer√≠a est√°ndar de Python üìö\n\n\n\nLa librer√≠a est√°ndar de Python es un conjunto de m√≥dulos y paquetes incluidos por defecto con cualquier instalaci√≥n oficial de Python, listos para usar sin necesidad de hacer instalaciones adicionales.\n\n\n\n\n\n\n\n\nDiferencias con R üé≠\n\n\n\nA diferencia de la carga de paquetes en R, que pone a disposici√≥n objetos del paquete en el ambiente global, el comando import math en Python no carga los objetos del m√≥dulo math directamente en el ambiente donde se ejecuta; solo carga el m√≥dulo en s√≠.\nPara acceder a las funciones de math, es necesario hacerlo mediante el nombre del m√≥dulo. Por este motivo, el siguiente bloque de c√≥digo produce un error:\nimport math\nsqrt(16)\nNameError: name 'sqrt' is not defined\n\n\n\n\nListar nombres disponibles\nPara obtener un listado con los nombres de los objetos disponibles dentro de un m√≥dulo, podemos usar la funci√≥n dir().\ndir(math)\n['__doc__',\n '__file__',\n '__loader__',\n '__name__',\n '__package__',\n '__spec__',\n 'acos',\n 'acosh',\n 'asin',\n 'asinh',\n...\n 'tan',\n 'tanh',\n 'tau',\n 'trunc',\n 'ulp']\nSin embargo, en la pr√°ctica, esta funci√≥n no suele usarse demasiado para explorar los nombres disponibles en un m√≥dulo.\nPor lo general, trabajamos en editores de c√≥digo que muestran autom√°ticamente la lista de variables disponibles en un m√≥dulo.\nEn Positron, si escribimos math seguido de un punto (math.), el editor desplegar√° un listado de los objetos disponibles en dicho m√≥dulo.\n\n\n\n\n\n\n\nImportar objetos de un m√≥dulo\nLa flexibilidad en la carga de m√≥dulos en Python permite importar uno o m√°s objetos de un m√≥dulo (o subm√≥dulo) sin necesidad de importar el m√≥dulo completo.\nLa sintaxis para traer un objeto de un m√≥dulo llamado cosas es:\nfrom cosas import objeto\nDe este modo, podemos cargar la constante pi del m√≥dulo math.\n\nfrom math import pi\n\nLuego, es posible acceder a la variable pi sin tener que pasar por el nombre del m√≥dulo donde se define.\n\npi\n\n3.141592653589793\n\n\nEn nuestro caso, como anteriormente tambi√©n importamos el m√≥dulo math, seguimos teniendo acceso a pi a trav√©s de math.\n\nprint(math.pi)\nprint(pi)\n\n3.141592653589793\n3.141592653589793\n\n\nPara importar varios objetos a la vez, se utiliza una sintaxis similar a la anterior, separando sus nombres con comas. A modo de ejemplo, importemos las funciones mean() y median() de otro m√≥dulo est√°ndar llamado statistics.\n\nfrom statistics import mean, median\n\n\nnumeros = [4, 5, 9, 30, 3, 8, 6]\n\nprint(\"La media es:\", mean(numeros))\nprint(\"La mediana es:\", median(numeros))\n\nLa media es: 9.285714285714286\nLa mediana es: 6\n\n\n\n\nImportar con alias\nPython no solo permite decidir que objetos importar de un m√≥dulo, si no que tambi√©n hace posible asignar un alias al objeto o m√≥dulo que se importa.\nPara un m√≥dulo:\nimport modulo as alias\nY para un objeto dentro de un m√≥dulo:\nfrom modulo import objeto as alias\nPodemos importar el m√≥dulo math usando el alias mates:\n\nimport math as mates\n\nprint(mates.cos(mates.pi)) # coseno(pi)\n\n-1.0\n\n\nO importar la funcion sqrt con el nombre raiz:\n\nfrom math import sqrt as raiz\n\nraiz(81)\n\n9.0\n\n\n\n\n\n\n\n\nEl problema de importar todo\n\n\n\nPython permite cargar todos los objetos definidos en un m√≥dulo o paquete directamente en el ambiente actual. La sintaxis es:\nfrom nombre import *\nEsta no es una pr√°ctica recomendable, ya que no sabemos cu√°ntos elementos se importar√°n ni qu√© conflictos podr√≠an surgir entre los nombres definidos en el m√≥dulo y los que ya tenemos en nuestro programa.\nEl uso de from nombre import * produce un efecto similar al de library(paquete) en R, pero en Python se desaconseja.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "6 - Uso de c√≥digo externo"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#m√≥dulos-propios",
    "href": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#m√≥dulos-propios",
    "title": "6 - Uso de c√≥digo externo",
    "section": "M√≥dulos propios",
    "text": "M√≥dulos propios\nLa sintaxis para importar un m√≥dulo propio, u objetos definidos en √©l, es la misma que la que se utiliza para importar cualquier otro m√≥dulo.\nSupongamos que tenemos un archivo llamado funciones.py con el siguiente contenido:\n\n\nfunciones.py\n\ndef es_par(n):\n    if n % 2 == 0:\n        return True\n    return False\n\n\ndef es_primo(n):\n    if n &lt;= 1:\n        return False\n\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n\n    return True\n\ny queremos usar las funciones es_par y es_primo en nuestro programa principal.\nUn aspecto fundamental a tener en cuenta para poder importar el m√≥dulo funciones desde nuestro programa principal es su ubicaci√≥n.\nSi el archivo funciones.py no se encuentra en alguno de los directorios que Python recorre al ejecutar la sentencia import, obtendremos un error.\nUno de los directorios en los que Python busca m√≥dulos al importar es el directorio actual, es decir, aquel desde donde se ejecuta nuestro programa principal.\nSupongamos una carpeta (es decir, un proyecto) con la siguiente estructura de archivos:\nproyecto/                  # Carpeta\n‚îú‚îÄ‚îÄ funciones.py           # M√≥dulo\n‚îî‚îÄ‚îÄ programa.py            # Programa principal\nAqu√≠, programa.py es nuestro programa principal y contiene el siguiente c√≥digo:\nimport funciones\n\nprint(funciones.es_par(12))\nprint(funciones.es_par(15))\n\nprint(funciones.es_primo(1))\nprint(funciones.es_primo(11))\nprint(funciones.es_primo(15))\nAl ejecutarlo, obtendremos la siguiente salida:\nTrue\nFalse\nFalse\nTrue\nFalse\nUn programa equivalente es el siguiente:\nfrom funciones import es_par, es_primo\n\nprint(es_par(12))\nprint(es_par(15))\n\nprint(es_primo(1))\nprint(es_primo(11))\nprint(es_primo(15))\nLa salida de este programa ser√° la misma que la del ejemplo anterior. La diferencia es que en este segundo programa se importan directamente las funciones es_par y es_primo desde el m√≥dulo funciones, en lugar de importar el m√≥dulo y luego acceder a las funciones a trav√©s de funciones.es_par y funciones.es_primo.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "6 - Uso de c√≥digo externo"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#paquetes-externos",
    "href": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#paquetes-externos",
    "title": "6 - Uso de c√≥digo externo",
    "section": "Paquetes externos",
    "text": "Paquetes externos\nLa instalaci√≥n de paquetes en Python se realiza mediante un sistema de gesti√≥n de paquetes que se encarga de instalar y administrar paquetes.\nEstos paquetes se encuentran alojados en repositorios p√∫blicos (o privados) a los que los gestores acceden para descargar y actualizar el software.\nEn el ecosistema de Python existe una gran variedad de sistemas de gesti√≥n de paquetes, cuya adopci√≥n depende de las necesidades de cada usuario o proyecto.\nEn cuanto a los repositorios, tambi√©n hay varias alternativas. Sin embargo, a diferencia de los gestores, el Python Package Index (PyPI) es el m√°s utilizado por la gran mayor√≠a de la comunidad.\n\n\n\n\n\n\nNota üìù\n\n\n\nSe puede considerar al Python Package Index (PyPI) como el equivalente del Comprehensive R Archive Network (CRAN) en el ecosistema de R.\n\n\n\nInstalaci√≥n de paquetes con pip\nLa instalaci√≥n oficial de Python incluye un administrador de paquetes est√°ndar llamado pip. Esta herramienta permite instalar y gestionar paquetes que no forman parte de la biblioteca est√°ndar de Python.\nEs importante resaltar que pip se utiliza desde la terminal, no desde el int√©rprete de Python.\nEn Windows, es posible usar el comando where pip para localizar la ubicaci√≥n del programa. Otra opci√≥n es ejecutar pip --version, que muestra la versi√≥n instalada de pip junto con la ruta de la instalaci√≥n de Python a la que est√° vinculado.\nAntes de instalar paquetes con pip, es posible consultar qu√© paquetes ya se encuentran instalados mediante esta herramienta con el comando list:\npip list\nEste comando muestra un listado con los paquetes instalados y sus respectivas versiones.\nC:\\Users\\tutoriales&gt;pip list\nPackage Version\n------- -------\npip     25.1.1\nComo a√∫n no hemos instalado ning√∫n paquete adicional a los que vienen con Python, solo se muestra pip.\nLa instalaci√≥n de paquetes se hace con el comando install. Luego, para instalar el paquete NumPy hacemos:\npip install numpy\nDebajo se incluye una captura de la terminal de Windows donde se muestra la ejecuci√≥n de los comandos antes mencionados y sus respectivas salidas:\n\n\n\n\n\n\n\n\n\n\n\nEjecutar pip como m√≥dulo de Python\n\n\n\nLa herramienta pip es simplemente un m√≥dulo de Python. Si tenemos m√∫ltiples instalaciones de Python y/o pip, es posible que la versi√≥n de pip a la que se accede en nuestra terminal no sea la que est√° asociada a la versi√≥n de Python que queremos utilizar. Para evitar este tipo de problemas, se puede ejecutar el programa pip como un m√≥dulo de Python. De este modo, la instalaci√≥n de NumPy se ver√≠a de la siguiente manera:\npython -m pip install numpy\nLa opci√≥n -m le indica a Python que ejecute un m√≥dulo como si fuera un programa dentro del int√©rprete de Python.\n\n\n\n\n\n\n\n\n¬øEn qu√© momento seleccionamos a PyPI? ü§î\n\n\n\nNo es necesario que manualmente selccionemos a PyPI como repositorio de c√≥digo. Por defecto, pip ya instala los paquetes desde PyPI.\n\n\n\n\nCreaci√≥n de ambientes con venv\nCuando instalamos paquetes con la versi√≥n de pip que se incluye por defecto en Python, estos se instalan de forma global. Esto no siempre representa un problema, pero suele complicarse cuando trabajamos en varios proyectos distintos.\nCada proyecto puede depender de diferentes paquetes, e incluso de diferentes versiones de Python. Si todos comparten una misma instalaci√≥n global, es muy probable que aparezcan conflictos: algunos programas podr√≠an dejar de funcionar o comportarse de manera incorrecta.\nUna soluci√≥n ser√≠a reinstalar todas las dependencias desde cero cada vez, pero esto implica una p√©rdida de tiempo innecesaria y, adem√°s, no garantiza el correcto funcionamiento. La soluci√≥n m√°s aceptada por la comunidad es usar ambientes virtuales.\nUn ambiente virtual en Python permite aislar dependencias y paquetes para evitar conflictos entre proyectos.\nExisten distintas herramientas para crear y administrar ambientes virtuales; la que se incluye en la instalaci√≥n oficial de Python es venv.\nPara crear un ambiente virtual con venv, primero debemos ubicarnos en la carpeta de nuestro proyecto y ejecutar en la terminal:\npython -m venv .venv\nEl nombre .venv es una convenci√≥n adoptada por la comunidad, aunque puede usarse cualquier nombre v√°lido de directorio.\nEste comando genera una carpeta con la siguiente estructura:\n.venv\n‚îú‚îÄ‚îÄ Include\n‚îú‚îÄ‚îÄ Lib\n‚îÇ   ‚îî‚îÄ‚îÄ site-packages\n‚îÇ       ‚îú‚îÄ‚îÄ pip\n‚îÇ       ‚îî‚îÄ‚îÄ pip-25.1.1.dist-info\n‚îú‚îÄ‚îÄ Scripts\n‚îÇ   ‚îú‚îÄ‚îÄ Activate.ps1\n‚îÇ   ‚îú‚îÄ‚îÄ activate\n‚îÇ   ‚îú‚îÄ‚îÄ activate.bat\n‚îÇ   ‚îú‚îÄ‚îÄ activate.fish\n‚îÇ   ‚îú‚îÄ‚îÄ deactivate.bat\n‚îÇ   ‚îú‚îÄ‚îÄ pip.exe\n‚îÇ   ‚îú‚îÄ‚îÄ pip3.13.exe\n‚îÇ   ‚îú‚îÄ‚îÄ pip3.exe\n‚îÇ   ‚îú‚îÄ‚îÄ python.exe\n‚îÇ   ‚îî‚îÄ‚îÄ pythonw.exe\n‚îî‚îÄ‚îÄ pyvenv.cfg\nDentro de .venv/Lib/site-packages se almacenan los paquetes instalados en el ambiente, y en .venv/Scripts se encuentra el ejecutable de Python (python.exe) junto con otros scripts de utilidad.\nPara usar el int√©rprete de Python del ambiente e instalar paquetes en √©l, es necesario activarlo con el comando:\n.venv\\Scripts\\activate\nAl hacerlo, se mostrar√° (.venv) al inicio de la l√≠nea de la terminal.\nFinalmente, para desactivar el ambiente, basta con ejecutar:\ndeactivate\n\n\nEjemplo: NumPy\nNumPy es una paquete de Python especializado en el c√°lculo num√©rico y el an√°lisis de datos.\nProvee un nuevo tipo de objeto llamado array que permite representar colecciones de datos de un mismo tipo en varias dimensiones y funciones muy eficientes para su manipulaci√≥n.\n\n\n\n\n\nPara crear un proyecto, un ambiente con venv e instalar NumPy, seguimos los siguientes pasos:\nmkdir proyecto          # Crear directorio\ncd proyecto             # Mover la terminal al directorio del proyecto\npython -m venv .venv    # Crear ambiente virtual llamado .venv\n.venv\\Scripts\\activate  # Activar ambiente\npip install numpy       # Instalar numpy en el ambiente del proyecto\npython                  # Iniciar el int√©rprete interactivo de Python\nEl siguiente video muestra los pasos realizados en la terminal de Windows:\n\n\n\n\n\nLos paquetes de Python suelen importarse utilizando un alias. En el caso de los m√°s populares, como NumPy, la mayor√≠a de la comunidad usa el alias np.\n\nimport numpy as np\n\narray = np.array([1, 2, 3, 4])\narray\n\narray([1, 2, 3, 4])\n\n\n\ntype(array)\n\nnumpy.ndarray\n\n\nLa propiedad .ndim nos devuelve el n√∫mero de dimensiones del array.\n\narray.ndim\n\n1\n\n\nY .shape nos devuelve la ‚Äúforma‚Äù del array. Es decir, la cantidad de elementos por cada dimensi√≥n. Se puede notar que el .shape de un array es una tupla.\n\narray.shape\n\n(4,)\n\n\nEn este caso creamos un array a partir de una lista, pero tambi√©n es posible crear arrays a partir de otros objetos.\nSi continuamos utilizando listas, el n√∫mero de dimensiones del array va a depender del anidamiento que tengamos en las listas que utilizamos.\nA modo de ejemplo, podemos crear un array de dos dimensiones de la siguiente manera:\n\narray_2d = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])\narray_2d\n\narray([[1, 2, 3, 4],\n       [5, 6, 7, 8]])\n\n\n\nprint(array_2d.ndim)\nprint(array_2d.shape)\n\nUna de las caracter√≠sticas m√°s atractivas de NumPy es que las operaciones matem√°ticas con arrays est√°n vectorizadas, es decir, se realizan al nivel del arreglo.\n\nprint(array * 10)\nprint(array - 5)\nprint(array / 10)\nprint(array ** 2.4)\n\n[10 20 30 40]\n[-4 -3 -2 -1]\n[0.1 0.2 0.3 0.4]\n[ 1.          5.27803164 13.96661017 27.85761803]\n\n\nNumPy tambi√©n provee much√≠simas funciones para hacer c√°lculos com√∫nmente realizados con los arrays.\n\nprint(np.mean(array))\nprint(np.median(array))\nprint(np.std(array))\nprint(np.exp(array))\n\n2.5\n2.5\n1.118033988749895\n[ 2.71828183  7.3890561  20.08553692 54.59815003]",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "6 - Uso de c√≥digo externo"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#ap√©ndice",
    "href": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#ap√©ndice",
    "title": "6 - Uso de c√≥digo externo",
    "section": "Ap√©ndice",
    "text": "Ap√©ndice\n\nAlgunos comandos de pip\n\n\n\n\n\n\n\nComando\nDescripci√≥n\n\n\n\n\npip install pkg1 pkg2\nInstala uno o varios paquetes.\n\n\npip install pkg==1.2.3pip install pkg&gt;=1.0,&lt;=2.0\nInstala una versi√≥n espec√≠fica o un rango de versiones de un paquete.\n\n\npip install pkg --upgrade\nActualiza un paquete a la √∫ltima versi√≥n disponible.\n\n\npip freeze\nMuestra todos los paquetes instalados y sus versiones en formato compatible con requirements.txt.\n\n\npip uninstall pkg\nDesinstala un paquete instalado.\n\n\npip show pkg\nMuestra informaci√≥n detallada sobre un paquete (versi√≥n, ubicaci√≥n, dependencias).\n\n\npip help\nMuestra la ayuda general de pip o de un subcomando espec√≠fico.\n\n\npip install -r dependencias.txt\nInstala todas las dependencias listadas en un archivo.\n\n\n\n\nEjemplos\npip install requests flask        # Instala varios paquetes\npip install numpy==1.25.0         # Instala una versi√≥n exacta\npip install pandas&gt;=1.0,&lt;2.0      # Instala dentro de un rango de versiones\npip install requests --upgrade    # Actualiza un paquete\npip freeze                        # Lista paquetes instalados y versiones\npip uninstall flask               # Desinstala un paquete\npip show numpy                    # Muestra informaci√≥n de un paquete\npip help install                  # Muestra ayuda sobre 'install'\npip install -r requirements.txt   # Instala dependencias desde un archivo",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "6 - Uso de c√≥digo externo"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html",
    "title": "5 - Ejecuci√≥n repetitiva",
    "section": "",
    "text": "Anteriormente aprendimos a crear objetos que contienen otros objetos (listas, tuplas y diccionarios).\nCuando quer√≠amos realizar una acci√≥n con cada uno de los objetos que estos conten√≠an, ten√≠amos que escribir el mismo c√≥digo para acceder a cada uno de ellos de a uno.\nPor ejemplo, supongamos que tenemos un listado con nombres de nuestros amigos y queremos ponerlos a todos en may√∫sculas:\n\nnombres = [\"julieta\", \"facundo\", \"emiliano\", \"lorenzo\", \"victoria\"]\nprint(\"Nombres originales:\")\nprint(nombres)\n\nnombres[0] = nombres[0].upper()\nnombres[1] = nombres[1].upper()\nnombres[2] = nombres[2].upper()\nnombres[3] = nombres[3].upper()\nnombres[4] = nombres[4].upper()\n\nprint(\"\\nNombres modificados:\")\nprint(nombres)\n\nNombres originales:\n['julieta', 'facundo', 'emiliano', 'lorenzo', 'victoria']\n\nNombres modificados:\n['JULIETA', 'FACUNDO', 'EMILIANO', 'LORENZO', 'VICTORIA']\n\n\nVemos que realizamos exactamente la misma acci√≥n con cada nombre en la lista‚Ä¶ ¬øNo estar√≠a bueno poder automatizarlo?\nY para eso, en esta secci√≥n vamos a aprender sobre bucles.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "5 - Ejecuci√≥n repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#introducci√≥n",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#introducci√≥n",
    "title": "5 - Ejecuci√≥n repetitiva",
    "section": "",
    "text": "Anteriormente aprendimos a crear objetos que contienen otros objetos (listas, tuplas y diccionarios).\nCuando quer√≠amos realizar una acci√≥n con cada uno de los objetos que estos conten√≠an, ten√≠amos que escribir el mismo c√≥digo para acceder a cada uno de ellos de a uno.\nPor ejemplo, supongamos que tenemos un listado con nombres de nuestros amigos y queremos ponerlos a todos en may√∫sculas:\n\nnombres = [\"julieta\", \"facundo\", \"emiliano\", \"lorenzo\", \"victoria\"]\nprint(\"Nombres originales:\")\nprint(nombres)\n\nnombres[0] = nombres[0].upper()\nnombres[1] = nombres[1].upper()\nnombres[2] = nombres[2].upper()\nnombres[3] = nombres[3].upper()\nnombres[4] = nombres[4].upper()\n\nprint(\"\\nNombres modificados:\")\nprint(nombres)\n\nNombres originales:\n['julieta', 'facundo', 'emiliano', 'lorenzo', 'victoria']\n\nNombres modificados:\n['JULIETA', 'FACUNDO', 'EMILIANO', 'LORENZO', 'VICTORIA']\n\n\nVemos que realizamos exactamente la misma acci√≥n con cada nombre en la lista‚Ä¶ ¬øNo estar√≠a bueno poder automatizarlo?\nY para eso, en esta secci√≥n vamos a aprender sobre bucles.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "5 - Ejecuci√≥n repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#qu√©-son-los-bucles",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#qu√©-son-los-bucles",
    "title": "5 - Ejecuci√≥n repetitiva",
    "section": "¬øQu√© son los bucles?",
    "text": "¬øQu√© son los bucles?\nLos bucles son una estrcutura de los lenguajes de programaci√≥n que nos permite repetir la ejecuci√≥n de c√≥digo de manera autom√°tica.\nEn otras palabras, los bucles hacen que sea muy f√°cil ejecutar el mismo bloque de c√≥digo una y otra vez.\nA la repetici√≥n del mismo bloque de c√≥digo una y otra vez le decimos iteraci√≥n. Entonces, los bucles nos ayudan a iterar.\nEn Python tenemos dos tipos de bucles:\n\nEl bucle for (for-loop).\nEl bucle while (while-loop).\n\nLa diferencia entre este tipo de bucles es que con el for conocemos la cantidad de iteraciones que vamos a realizar de antemano.\nEn cambio, con el while no conocemos la cantidad de iteraciones que vamos a realizar de antemano.\nVeamos el ejemplo anterior pero utilizando un bucle for. En este caso, generamos una nueva lista llamada nombres_modificados donde vamos a almacenar los nombres modificados.\n\nnombres = [\"julieta\", \"facundo\", \"emiliano\", \"mariana\", \"victoria\"]\nnombres_modificados = []\n\n# Bucle for\nfor nombre in nombres:\n    nombres_modificados.append(nombre.upper())\n\nprint(\"Nombres originales:\")\nprint(nombres)\n\nprint(\"\\nNombres modificados:\")\nprint(nombres_modificados)\n\nNombres originales:\n['julieta', 'facundo', 'emiliano', 'mariana', 'victoria']\n\nNombres modificados:\n['JULIETA', 'FACUNDO', 'EMILIANO', 'MARIANA', 'VICTORIA']",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "5 - Ejecuci√≥n repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#el-bucle-for",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#el-bucle-for",
    "title": "5 - Ejecuci√≥n repetitiva",
    "section": "El bucle for",
    "text": "El bucle for\n\nPresentaci√≥n\nEn un bucle for encontramos los siguientes componentes.\n\nLa palabra clave for\nEl nombre de una variable que se usa para iterar (variable de iteraci√≥n)\nLa palabra clave in\nEl objeto sobre el cual iteramos, seguido por :\nEn la siguiente linea y con indentaci√≥n, el bloque de c√≥digo a ejecutar\n\n\n\n\n\n\nEn Python, al igual que en las sentencias if, else y otras estructuras de control, los dos puntos (:) se utilizan para indicar el comienzo de un bloque de c√≥digo, y la indentaci√≥n define el contenido de ese bloque. Nunca se emplean llaves {} como en otros lenguajes.\nEn el caso de un bucle for, se declara una variable que va tomando, en cada iteraci√≥n, uno de los valores del iterable que se est√° recorriendo. Por ejemplo, si el iterable contiene 10 objetos, el bucle ejecutar√° 10 iteraciones y la variable de iteraci√≥n (por convenci√≥n llamada i, aunque puede tener cualquier nombre) ir√° adoptando esos valores, uno por uno.\n\n\nEjemplos\nDado que a iterar se aprende iterando, veamos algunos ejemplos:\n\nfor i in [3, 1, 2]:\n    print(f\"El n√∫mero es {i}.\")\n\nEl n√∫mero es 3.\nEl n√∫mero es 1.\nEl n√∫mero es 2.\n\n\nTambi√©n podemos ordenar los valores de la lista sobre la que iteramos:\n\nfor i in sorted([3, 1, 2]):\n    print(f\"El n√∫mero es {i}.\")\n\nEl n√∫mero es 1.\nEl n√∫mero es 2.\nEl n√∫mero es 3.\n\n\nPero no es necesario iterar sobre listas. De hecho, podemos iterar sobre cualquier secuencia, por ejemplo, una tupla:\n\nfor i in (3, 1, 2):\n    print(f\"El n√∫mero es {i}.\")\n\nEl n√∫mero es 3.\nEl n√∫mero es 1.\nEl n√∫mero es 2.\n\n\n\nfor i in sorted((3, 1, 2)):\n    print(f\"El n√∫mero es {i}.\")\n\nEl n√∫mero es 1.\nEl n√∫mero es 2.\nEl n√∫mero es 3.\n\n\nE incluso una cadena de caracteres:\n\nfor c in \"Hola Curso\":\n    print(c)\n\nH\no\nl\na\n \nC\nu\nr\ns\no\n\n\n\n\n\n\n\n\nVariable de iteraci√≥n\n\n\n\nEl nombre de la variable que se usa para iterar es arbitrario. Sin embargo, es recomendable no utilizar el mismo nombre que el de otra variable en nuestro programa. Por ejemplo:\ni = 1\nfor i in [1, 2, 3]:\n    print(i)\nprint(i)\n1\n2\n3\n3\nLa variable de iteraci√≥n i va pisando su valor y cualquier valor que esta pudo haber tenido antes.\nAs√≠, luego de la finalizar el bucle, el valor de i es 3.\n\n\nLos bucles permiten generar nuevos objetos de forma autom√°tica.\nEn el siguiente ejemplo, partimos de una lista con cadenas que pueden contener n√∫meros o letras. Mediante un for, crearemos tres listas: una con los n√∫meros, otra con el texto y una tercera con los elementos que no sean ninguno de los dos.\n\nlista_original = [\"1\", \"@\", \"x\", \"y\", \"?\", \"3\", \"4\", \"7\", \"f\", \"l\", \"9\", \"10\", \"!\"]\n\n\n# Crear tres listas vac√≠as (que contienen los diferentes tipos de datos)\nnumeros = []\ntexto = []\notros = []\n\n# Iterar a traves de los valores de la lista original\nfor valor in lista_original:\n    # Si es num√©rico, lo agregamos en la lista 'numeros'\n    if valor.isnumeric():\n        numeros.append(valor)\n    # Sino es num√©rico, pregunto si es alfab√©tico (o una letra del abecedario)\n    elif valor.isalpha():\n        texto.append(valor)\n    # Caso contrario, lo metemos en la lista de otros\n    else:\n        print(f\"La cadena '{valor}' no es ni num√©rica ni alfab√©tica.\")\n        otros.append(valor)\n\nprint(lista_original)\nprint(numeros)\nprint(texto)\nprint(otros)\n\nLa cadena '@' no es ni num√©rica ni alfab√©tica.\nLa cadena '?' no es ni num√©rica ni alfab√©tica.\nLa cadena '!' no es ni num√©rica ni alfab√©tica.\n['1', '@', 'x', 'y', '?', '3', '4', '7', 'f', 'l', '9', '10', '!']\n['1', '3', '4', '7', '9', '10']\n['x', 'y', 'f', 'l']\n['@', '?', '!']\n\n\n\n\nCrear listas num√©ricas con range().\nPython provee una funci√≥n llamada range() que hace que sea muy f√°cil generar una secuencia de n√∫meros. Por ejemplo, podemos usar range() para imprimir una serie de n√∫meros.\n\nfor i in range(1, 5):\n    print(i)\n\n1\n2\n3\n4\n\n\nrange() funciona de manera similar a los slices, es decir, no incluye el l√≠mite superior. Adem√°s, si se usa con un solo argumento, es equivalente a range(0, numero).\n\nfor i in range(5):\n    print(i)\n\n0\n1\n2\n3\n4\n\n\nUna forma √∫til de entender range(n) es verlo como la creaci√≥n de una secuencia con los primeros n n√∫meros, comenzando desde 0.\n\nx = range(5)\nprint(x)\nprint(type(x))\n\nrange(0, 5)\n&lt;class 'range'&gt;\n\n\nPodemos obtener una lista a partir de un range usando la funci√≥n list().\n\nlist(x)\n\n[0, 1, 2, 3, 4]\n\n\nY, por qu√© no, una tupla tambi√©n.\n\ntuple(x)\n\n(0, 1, 2, 3, 4)\n\n\nrange() admite un tercer argumento opcional que especifica el paso entre valores. Por defecto es 1. Veamos algunos ejemplos:\nLista de n√∫meros entre 0 y 10 (no inclusivo), avanzando de a 2 en cada paso.\n\nlist(range(0, 10, 2))\n\n[0, 2, 4, 6, 8]\n\n\nIntento de lista de n√∫meros entre 10 y 0 (no inclusivo).\n\nlist(range(10, 0))\n\n[]\n\n\nVemos que el resultado no es el esperado. Esto se debe a que el paso es por defecto 1 y es imposible recorrer desde el 10 al 0 sumando de a 1. Si cambiamos el paso a -1, funciona correctamente:\n\nlist(range(10, 0, -1))\n\n[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n\n\n\n\n¬øSobre qu√© cosas podemos iterar en un bucle for?\nRecordemos el diagrama que vimos anteriormente‚Ä¶\n\n\n\n\n\nEn naranja tenemos resaltado iterable. Pero, ¬øqu√© significa que un objeto sea iterable?\n\nQue podemos iterar a trav√©s de el.\nQue podemos recorrerlo elemento por elemento.\nQue puede devolver sus elementos de a uno a la vez.\n\nDe manera similar a las secuencias, el t√©rmino iterable describe una categor√≠a de tipos de datos. De hecho, todas las secuencias son iterables (por eso podemos recorrer listas, tuplas y cadenas), pero no es requisito ser una secuencia para ser iterable. Por ejemplo, los diccionarios no son secuencias y, sin embargo, pueden recorrerse porque implementan un m√©todo para entregar sus elementos de uno en uno.\n\nfor i in {\"a\": 1, \"b\": 2}:\n    print(i)\n\na\nb",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "5 - Ejecuci√≥n repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#el-bucle-while",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#el-bucle-while",
    "title": "5 - Ejecuci√≥n repetitiva",
    "section": "El bucle while",
    "text": "El bucle while\nEn un bucle while encontramos los siguientes componentes.\n\nLa palabra clave while.\nUna condici√≥n, es decir, una expresi√≥n que se eval√∫a a True o False, seguido por los dos puntos :.\nEn la siguiente linea y con indentaci√≥n, el bloque de c√≥digo a ejecutar.\n\n\n\n\n\n\n\nnumero = 0\nwhile numero &lt; 5:\n    numero += 1 # Abreviaci√≥n de x = x + 1\n    print(f\"El numero es {numero}\")\n\nEl numero es 1\nEl numero es 2\nEl numero es 3\nEl numero es 4\nEl numero es 5\n\n\n\n\n\n\n\nAnalicemos el diagrama:\n\nMientras numero &lt; 5 sea True, Python ejecutar√° el cuerpo del bucle completo.\nEn la primera iteraci√≥n, numero es 0.\n\nComo 0 es menor a 5, Python imprime el n√∫mero y luego le agrega 1, haciendo que el n√∫mero sea 1.\n\nEn la segunda iteraci√≥n, numero es 1.\n\nComo 1 es menor a 5, Python imprime el n√∫mero y luego le agrega 1, haciendo que el n√∫mero sea 2.\n\n\nEl proceso contin√∫a hasta que numero deja de ser menor que 5, momento en el que el bucle se detiene.\n\n\n\n\n\n\nBucles infinitos ‚ôæÔ∏è\n\n\n\nVeamos el siguiente ejemplo:\nx = 0\nwhile x &lt; 5:\n    print(x)\nSi ejecutamos este c√≥digo, Python nunca detendr√° su ejecuci√≥n. Esto sucede porque el valor de x nunca cambia, por lo que la condici√≥n x &lt; 5 es siempre verdadera. Este es un caso t√≠pico de bucle infinito, algo que puede ocurrir con cualquier while, y en particular con while True si no incluimos una forma de salir del bucle (por ejemplo, con break).\nSi entramos en un bucle infinito, la √∫nica forma de detenerlo es interrumpir la ejecuci√≥n manualmente:\n\nEn la terminal: CTRL + C\nEn un editor de c√≥digo: usar el bot√≥n de interrupci√≥n\n\n\n\n\nLa sentencia break\nPython provee la sentencia break que sirve para terminar un bucle (for o while) de manera anticipada.\nVeamos algunos ejemplos de uso.\n\nwhile True:\n    print(\"¬°Hola!\")\n    break\n\n¬°Hola!\n\n\nEn el ejemplo anterior, la condici√≥n del bucle era True, lo que implicar√≠a una ejecuci√≥n infinita. Sin embargo, al final de la primera iteraci√≥n encontramos un break, que fuerza la salida del bucle. De forma similar, podemos reescribir el primer while utilizando esta estructura alternativa.\n\nnumero = 0\nwhile True:\n    if numero &gt;= 5:\n        break\n    numero += 1\n    print(f\"El numero es {numero}\")\n\nEl numero es 1\nEl numero es 2\nEl numero es 3\nEl numero es 4\nEl numero es 5\n\n\n\nnumero = 0\nwhile True:\n    numero += 1\n    print(f\"El numero es {numero}\")\n    if numero &gt;= 5:\n        break\n\nEl numero es 1\nEl numero es 2\nEl numero es 3\nEl numero es 4\nEl numero es 5\n\n\nSupongamos que queremos sumar los valores de una lista hasta que se cumpla cierta condici√≥n, por ejemplo, que el total sea mayor o igual a 20.\nSi partimos de una lista de n√∫meros cualquiera, no sabemos de antemano cu√°ntos elementos ser√° necesario sumar. Sin embargo, esto no ser√° un problema si utilizamos la estructura while en combinaci√≥n con la sentencia break.\n\nsuma = 0\numbral = 20\nvalores = [3, 5, 4, 4, 5, 5, 3, 5, 2, 7]\n\nwhile valores:\n    suma += valores.pop(0)\n    print(suma)\n    if suma &gt;= umbral:\n        break\n\n3\n8\n12\n16\n21\n\n\n\nvalores # valores que no se sumaron\n\n[5, 3, 5, 2, 7]\n\n\nEn el bloque de c√≥digo anterior puede llamar la atenci√≥n el uso de\nwhile valores:\nEl bucle while valores: se ejecuta mientras la lista tenga elementos. En cada iteraci√≥n, .pop(0) extrae el primer elemento, se suma a suma y se imprime el total acumulado. Si en alg√∫n momento suma alcanza o supera el umbral, se ejecuta break para detener el bucle aunque a√∫n queden elementos en la lista. Si la lista se vac√≠a antes de llegar al umbral, el bucle tambi√©n finaliza autom√°ticamente gracias a la condici√≥n while valores:.\nUn ejemplo m√°s conciso es el siguiente:\n\nif [1, 2, 3]:\n    print(\"Bloque 'if'\")\nelse:\n    print(\"Bloque 'else'\")\n\nBloque 'if'\n\n\n\nif []:\n    print(\"Bloque 'if'\")\nelse:\n    print(\"Bloque 'else'\")\n\nBloque 'else'\n\n\nAhora supongamos que tenemos una lista de n√∫meros aleatorios que representan alg√∫n conteo.\nEstamos interesados en la cantidad de extracciones que se necesitaron hasta que el conteo supere cierto umbral, por ejemplo, 30.\n\nnumeros_aleatorios = [\n    5, 7, 6, 4, 2, 2, 5, 3, 6, 4, 4, 6, 3, 6, 1,\n    3, 3, 1, 9, 5, 5, 6, 5, 1, 7, 3, 3, 1, 3, 4\n]\n\numbral = 30\n\n# Inicializamos suma y cantidad de iteraciones en 0\nsuma = 0\niteraciones = 0\n\n# Mientras la lista no est√© vac√≠a\nwhile numeros_aleatorios:\n    # Agregamos 1 al conteo de iteraciones realizadas\n    iteraciones += 1\n\n    # Extraemos el primer n√∫mero de la lista y lo sumamos a la suma\n    suma += numeros_aleatorios.pop(0)\n\n    # Si la suma es mayor o igual al umbral, dejamos de iterar\n    if suma &gt;= umbral:\n        break\n\nif suma &gt;= umbral:\n    print(f\"Se super√≥ el umbral de {umbral} en la iteraci√≥n {iteraciones}, sumando {suma}.\")\nelse:\n    print(f\"La suma de los elementos de la lista no llega a superar {umbral}\")\n\nSe super√≥ el umbral de 30 en la iteraci√≥n 7, sumando 31.\n\n\n\nSolicitar valores de entrada al usuario\nPython provee una funci√≥n llamada input() que sirve para solicitar al usuario que ingrese un valor.\n\nEl argumento es el mensaje que se mostrar√° en pantalla.\nEl tipo de dato que se devuelve es str.\n\n\nnombre = input(\"Ingresa tu nombre: \")\nprint(f\"El nombre ingresado es '{nombre}'\")\n\nEl nombre ingresado es 'Tomi'\n\n\nEsta funcion combinada con el bucle while nos permite generar programas interactivos que solicitan entrada al usuario hasta que se cumple una condici√≥n. Por ejemplo, supongamos que queremos solicitar una contrase√±a que tenga 8 caracteres o m√°s.\n\nwhile True:\n    pwd = input(\"Ingrese su contrase√±a: \")\n    if len(pwd) &gt;= 8:\n        print(\"¬°Muchas gracias!\")\n        break\n    else:\n        print(f\"La contrase√±a '{pwd}' es corta\")\nprint(f\"La contrase√±a ingresada es '{pwd}'\")\n\nLa contrase√±a '' es corta\nLa contrase√±a 'prueba' es corta\n¬°Muchas gracias!\nLa contrase√±a ingresada es 'prueba 2'\n\n\n\n\n\nLa sentencia continue\nAs√≠ como tenemos la sentencia break que le dice a Python que interrumpa la ejecuci√≥n de un bucle, tenemos la sentencia continue que le dice que pase a la siguiente iteraci√≥n sin ejecutar el c√≥digo a continuaci√≥n de la misma.\nCuando un programa se encuentra con continue se procede a la siguiente iteraci√≥n del bucle, re-evaluando la condici√≥n del while de ser necesario.\nEn el siguiente ejemplo tenemos una lista con n√∫meros del 1 al 10 y queremos sumar solamente los n√∫meros pares.\n\n# Crear lista del 1 al 10\nnumeros = list(range(1, 11))\nprint(numeros)\n\nsuma = 0\nwhile numeros:\n    numero = numeros.pop(0)\n    if numero % 2 != 0:\n        continue\n    suma += numero\n    print(\"Sumando el numero\", numero)\n\nprint(\"La suma es\", suma)\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nSumando el numero 2\nSumando el numero 4\nSumando el numero 6\nSumando el numero 8\nSumando el numero 10\nLa suma es 30\n\n\nEn este programa, si numero % 2 != 0, el continue le indica a Python que debe pasar a la siguiente iteraci√≥n sin evaluar lo que hay debajo. Por lo tanto, cuando el n√∫mero es impar, no se ejecuta ni la suma ni el print.\nEste problema se puede resolver tambi√©n utilizando un bucle for en vez de un bucle while.\n\nnumeros = list(range(1, 11))\nsuma = 0\nfor numero in numeros:\n    if numero % 2 != 0:\n        continue\n    suma += numero\n    print(\"Sumando el numero\", numero)\nprint(\"La suma es\", suma)\n\nSumando el numero 2\nSumando el numero 4\nSumando el numero 6\nSumando el numero 8\nSumando el numero 10\nLa suma es 30",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "5 - Ejecuci√≥n repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#conclusi√≥n",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#conclusi√≥n",
    "title": "5 - Ejecuci√≥n repetitiva",
    "section": "Conclusi√≥n",
    "text": "Conclusi√≥n\nCu√°ndo usar un bucle for.\n\nSabemos exactamente, y de antemano, cuantas veces queremos iterar.\nQueremos iterar a trav√©s de todos los elementos de un objeto determinado.\n\nCu√°ndo usar un bucle while.\n\nNo sabemos exactamente cuantas veces queremos iterar.\nQueremos iterar hasta que se cumpla (o se deje de cumplir) una condici√≥n determinada.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "5 - Ejecuci√≥n repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html",
    "href": "teoria/01_programacion_en_python/01_introduccion.html",
    "title": "1 - Introducci√≥n",
    "section": "",
    "text": "Python es un lenguaje de programaci√≥n interpretado, de prop√≥sito general y de alto nivel. Fue creado por Guido Van Rossum y su primera versi√≥n p√∫blica fue en el a√±o 1991.\n\nInterpretado: no requiere que realicemos un paso expl√≠cito de compilaci√≥n a lenguaje de m√°quina antes de ejecutarlo. Adem√°s, se puede ejecutar l√≠nea por l√≠nea.\nProp√≥sito general: no se limita a un tipo de aplicaci√≥n espec√≠fica, es decir, se puede usar para implementar programas en diferentes dominios:\n\nVox populi: No es el mejor en casi nada, pero suficientemente bueno para casi todo.\nAlgunos dominios:\n\nAn√°lisis estad√≠stico y ciencia de datos.\nInteligencia artificial.\nDesarrollo web.\nDesarrollo de videojuegos.\nScripting.\n\n\nAlto nivel: se parece m√°s al lenguaje humano que al lenguaje de las m√°quinas.\n\nAdem√°s‚Ä¶\n\nEs gratis: no requiere pagar licencias para usarlo, tanto a nivel personal como comercial.\nEs de c√≥digo abierto: su c√≥digo fuente est√° disponible p√∫blicamente y puede ser modificado por cualquiera.\nPosee un ecosistema de librer√≠as complet√≠simo: existen miles de paquetes para todo tipo de tareas.\nComunidad: millones de personas lo usan, contribuyen, resuelven dudas y crean contenido, lo que facilita aprender y encontrar ayuda.\n\nPara utilizar Python es necesario instalar un int√©rprete de Python. La versi√≥n oficial puede ser descargada desde python.org. Una vez instalado el int√©rprete, es posible ejecutar scripts de Python y programar en Python de manera interactiva desde la terminal.\nEn esta materia se utiliza un editor de c√≥digo para ciencia de datos llamado Positron. Este editor es desarrollado por Posit, los mismos creadores de RStudio, y permite trabajar tanto con Python como con R.\nLas instrucciones para instalar Python y Positron pueden ser encontradas en Instalaci√≥n de Python y Positron en Windows.\n\n\n\nEmpecemos utilizando a Python como si fuese una calculadora. Para eso vamos a crear un bloque de c√≥digo en la notebook y escribimos algunas cuentas tal como lo hacemos en cualquier calculadora.\n\n2 * 3\n\n6\n\n\nNo tenemos la necesidad de pisar el c√≥digo todo el tiempo. Podemos escribir nuevas celdas de c√≥digo, y as√≠ podemos ir mostrando diferentes c√≥mputos y sus resultados.\n\n100 / 3.5\n\n28.571428571428573\n\n\n\n20 + 5\n\n25\n\n\n\n13 - 3\n\n10\n\n\n\n10 * 5.5\n\n55.0",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "1 - Introducci√≥n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#qu√©-es-python",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#qu√©-es-python",
    "title": "1 - Introducci√≥n",
    "section": "",
    "text": "Python es un lenguaje de programaci√≥n interpretado, de prop√≥sito general y de alto nivel. Fue creado por Guido Van Rossum y su primera versi√≥n p√∫blica fue en el a√±o 1991.\n\nInterpretado: no requiere que realicemos un paso expl√≠cito de compilaci√≥n a lenguaje de m√°quina antes de ejecutarlo. Adem√°s, se puede ejecutar l√≠nea por l√≠nea.\nProp√≥sito general: no se limita a un tipo de aplicaci√≥n espec√≠fica, es decir, se puede usar para implementar programas en diferentes dominios:\n\nVox populi: No es el mejor en casi nada, pero suficientemente bueno para casi todo.\nAlgunos dominios:\n\nAn√°lisis estad√≠stico y ciencia de datos.\nInteligencia artificial.\nDesarrollo web.\nDesarrollo de videojuegos.\nScripting.\n\n\nAlto nivel: se parece m√°s al lenguaje humano que al lenguaje de las m√°quinas.\n\nAdem√°s‚Ä¶\n\nEs gratis: no requiere pagar licencias para usarlo, tanto a nivel personal como comercial.\nEs de c√≥digo abierto: su c√≥digo fuente est√° disponible p√∫blicamente y puede ser modificado por cualquiera.\nPosee un ecosistema de librer√≠as complet√≠simo: existen miles de paquetes para todo tipo de tareas.\nComunidad: millones de personas lo usan, contribuyen, resuelven dudas y crean contenido, lo que facilita aprender y encontrar ayuda.\n\nPara utilizar Python es necesario instalar un int√©rprete de Python. La versi√≥n oficial puede ser descargada desde python.org. Una vez instalado el int√©rprete, es posible ejecutar scripts de Python y programar en Python de manera interactiva desde la terminal.\nEn esta materia se utiliza un editor de c√≥digo para ciencia de datos llamado Positron. Este editor es desarrollado por Posit, los mismos creadores de RStudio, y permite trabajar tanto con Python como con R.\nLas instrucciones para instalar Python y Positron pueden ser encontradas en Instalaci√≥n de Python y Positron en Windows.\n\n\n\nEmpecemos utilizando a Python como si fuese una calculadora. Para eso vamos a crear un bloque de c√≥digo en la notebook y escribimos algunas cuentas tal como lo hacemos en cualquier calculadora.\n\n2 * 3\n\n6\n\n\nNo tenemos la necesidad de pisar el c√≥digo todo el tiempo. Podemos escribir nuevas celdas de c√≥digo, y as√≠ podemos ir mostrando diferentes c√≥mputos y sus resultados.\n\n100 / 3.5\n\n28.571428571428573\n\n\n\n20 + 5\n\n25\n\n\n\n13 - 3\n\n10\n\n\n\n10 * 5.5\n\n55.0",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "1 - Introducci√≥n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#tipos-de-datos",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#tipos-de-datos",
    "title": "1 - Introducci√≥n",
    "section": "Tipos de datos",
    "text": "Tipos de datos\nComo cualquier lenguaje de programaci√≥n, Python ofrece diferentes tipos de datos.\nCada tipo de dato nos ayuda a resolver una tarea distinta. Por ejemplo, si quiero hacer operaciones matem√°ticas voy a necesitar de n√∫meros, pero si quiero escribir un correo electr√≥nico voy a necesitar de texto.\nA continuaci√≥n vamos a introducir los tipos de datos m√°s b√°sicos que Python nos ofrece.\nM√°s adelante tambi√©n veremos otros tipos de datos m√°s complejos que nos van a permitir resolver problemas (much√≠simo) m√°s interesantes.\n\nN√∫meros\nAcabamos de hacer cuentas matem√°ticas somo si tuvieramos una calculadora. Para eso usamos n√∫meros, los conocidos de toda la vida.\nSin notarlo, utilizamos dos tipos de n√∫meros distintos: los n√∫meros de tipo entero (int) y los n√∫meros de tipo flotante (float).\nLo siguiente es un n√∫mero entero:\n\n50\n\n50\n\n\nY el siguiente es un ejemplo de un n√∫mero flotante:\n\n36.8\n\n36.8\n\n\nUtilizando la funci√≥n type() Python nos devuelve el tipo del objeto.\n\ntype(10)\n\nint\n\n\n\ntype(10.5)\n\nfloat\n\n\n\ntype(10.0)\n\nfloat\n\n\n\ntype(10.)\n\nfloat\n\n\n\n\n\n\n\n\nObservaci√≥n üëÄ\n\n\n\nA diferencia de R, Python no es un lenguaje vectorizado. Por lo tanto, los tipos int y float representan valores escalares, no vectores de longitud 1 como ocurre en R.\nEsta observaci√≥n aplica a todos los tipos de datos elementales que vienen a continuaci√≥n.\n\n\n\n\nCadenas de texto\nPara ser una lenguaje de programaci√≥n tan afamado, Python tiene que ser capaz de trabajar con objetos m√°s complejos que los n√∫meros.\nUn ejemplo de esto es el texto, que se representa con un objeto llamado cadena de texto y se construyen utilizando comillas.\nComo en la mayor√≠a de los lenguajes de programaci√≥n, las comillas se ponen al principio y al final del texto e indican el principio y el final de la cadena; estas pueden pueden ser dobles \" o simples '.\n\n\"Programando en Python\"\n\n'Programando en Python'\n\n\n\n'Con comillas simples, tambi√©n.'\n\n'Con comillas simples, tambi√©n.'\n\n\nEn Python no hay diferencia entre usar comillas simples ' o dobles \", pero es importante que el tipo de comilla que se usa para abrir la cadena sea el mismo que se usa para cerrarla.\nCuando imprimimos una cadena, las comillas no se muestran en la salida. Para imprimir cualquier objeto de Python utilizamos la funci√≥n print().\n\nprint('Con comillas simples, ¬°tambi√©n!')\n\nCon comillas simples, ¬°tambi√©n!\n\n\nUna forma un poco m√°s ex√≥tica, pero muy √∫til, de crear cadenas es utilizando comillas triples. Con esta sintaxis, se repiten tres comillas seguidas, lo que permite definir cadenas de texto que ocupan varias l√≠neas.\n\nprint(\"\"\"Se puede escribir texto\nen varias lineas.\n¬°Est√° muy bueno!\"\"\")\n\nSe puede escribir texto\nen varias lineas.\n¬°Est√° muy bueno!\n\n\nOtra manera de escribir texto que abarca m√∫ltiples l√≠neas es usando el car√°cter especial \\n, que representa un salto de l√≠nea.\n\nprint(\"Primera l√≠nea\\nsegunda l√≠nea\\ntercera l√≠nea.\")\n\nPrimera l√≠nea\nsegunda l√≠nea\ntercera l√≠nea.\n\n\nEn cambio, si mostramos una representaci√≥n del texto (sin usar print()), los \\n s√≠ se visualizan.\n\n\"Primera l√≠nea\\nsegunda l√≠nea\\ntercera l√≠nea.\"\n\n'Primera l√≠nea\\nsegunda l√≠nea\\ntercera l√≠nea.'\n\n\n\n\n\n\n\n\n¬°Atenci√≥n! ü§ì\n\n\n\n¬øCu√°l es la diferencia entre usar print() y no usarlo?\n\nCuando usamos print() se imprime el objeto de una manera humanamente legible.\nCuando no lo usamos, se muestra una representaci√≥n del objeto. Esta representaci√≥n tiene que ser lo menos ambigua posible.\n\nPor este motivo es que se muestran las comillas a la hora de representar una cadena.\n\n\n\n\nOtra situaci√≥n en la que usar print() genera una diferencia es cuando se quieren mostrar varios objetos en una notebook. Por ejemplo, comparemos el resultado de los siguientes bloques:\n\n\"mensaje 1\"\n10\n\"mensaje 2\"\n\n'mensaje 2'\n\n\n\nprint(\"mensaje 1\")\nprint(10)\nprint(\"mensaje 2\")\n\nmensaje 1\n10\nmensaje 2\n\n\n\n\nL√≥gicos (o Booleanos)\nComo veremos m√°s adelante, nuestros programas suelen tener que decidir entre diferentes acciones a tomar seg√∫n se cumpla o no cierta condici√≥n.\nPara representar esta situaci√≥n utilizamos un tipo especial de dato conocido como l√≥gico o booleano, que puede tomar √∫nicamente dos valores: True o False.\nSi la condici√≥n se cumple, el resultado ser√° True; de lo contrario, ser√° False.\n\nTrue\n\nTrue\n\n\n\nFalse\n\nFalse\n\n\n\ntype(True)\n\nbool\n\n\n\ntype(False)\n\nbool\n\n\n\n\n\n\n\n\nRese√±a hist√≥rica üìú\n\n\n\nEste tipo de datos se llama Booleano en honor al matem√°tico George Boole.\n\n\n\n\nNulo\nEl valor nulo, llamado None en Python, representa la ausencia de valor o el vac√≠o. Se utiliza habitualmente para indicar que algo no tiene un valor asignado. Si intentamos mostrar el valor de None, veremos que no aparece nada.\n\nNone\n\nEn cambio, si imprimimos el objeto None, vemos el mensaje None.\n\nprint(None)\n\nNone\n\n\n¬øY cu√°l es su tipo?\n\ntype(None)\n\nNoneType\n\n\nSolamente los objetos None son del tipo NoneType.\n\n\n\n\n\n\n¬øPor qu√© existe el valor nulo? ü§î\n\n\n\nMuchas veces nuestro programa, o alguna parte del mismo, realiza una tarea que no devuelve ning√∫n resultado.\nPodr√≠amos ponernos de acuerdo en representar ‚Äúning√∫n resultado‚Äù usando un n√∫mero (e.g., 0), una cadena vac√≠a (\"\"), o algo similar. Pero estos valores representan algo espec√≠fico, no la ausencia total de valor.\nPara expresar claramente que no hay ning√∫n resultado, Python incluye un valor especial llamado None.\n\n\nEjemplos\n\nUn usuario completa un formulario con datos personales, pero algunos campos no son obligatorios y quedan sin completar.\nUna funci√≥n busca un elemento en una lista; cuando no encuentra lo buscado, devuelve un valor especial indicando que el resultado est√° ausente.\n\nEn general, cuando se quiera representar la ausencia de informaci√≥n se utilizar√° None.\n\n\n\n\n\n\nObservaci√≥n üëÄ\n\n\n\nEn R existen dos tipos de datos para representar valores faltantes: NULL y NA. El None de Python equivale a NULL en R, ya que ambos indican ausencia de valor.\nPor otro lado, NA en R representa un valor existente pero desconocido, por ejemplo, porque se ha perdido. Python no ofrece un tipo de dato equivalente de forma nativa, aunque algunas librer√≠as s√≠ lo implementan.\n\n\n\n\nConversi√≥n entre tipos de datos\nQue existan distintos tipos de datos no significa que un objeto de un tipo no pueda ‚Äúconvertirse‚Äù a otro.\nEn muchos casos es posible convertir entre tipos de datos. Por ejemplo, un n√∫mero siempre se puede convertir a una cadena de caracteres, pero no cualquier cadena puede convertirse a un n√∫mero.\nPara convertir un objeto a otro tipo utilizamos funciones con el nombre del tipo al que queremos convertir, como str(), int() o bool(). Estas funciones reciben como argumento el objeto a convertir.\nVeamos algunos ejemplos:\n\nstr(256)\n\n'256'\n\n\n\nstr(None)\n\n'None'\n\n\n\nint(165.5)\n\n165\n\n\n\nint(165.8)\n\n165\n\n\n\nint(\"165\")\n\n165\n\n\n\nfloat(\"165.0\")\n\n165.0\n\n\n\n\nResumen\n\nPython tiene distintos tipos de datos.\nCada tipo de dato es √∫til para resolver diferentes problemas.\n\nA lo largo de la materia veremos much√≠simos ejemplos.\n\nAl principio, tener varios tipos de datos puede parecer complejo.\n\nSin embargo, nos resultar√°n muy naturales a medida que los usemos para resolver problemas concretos.\n\n\n\n\n\n\n\n\n\nTipo de dato\nEjemplos\n\n\n\n\nN√∫meros enteros (int)\n-2, -1, 0, 10, 200\n\n\nN√∫meros de punto flotante (float)\n-200.789, -1.0, 0.0, 17.8\n\n\nCadenas de texto (str)\n\"a\", \"abc\", \"Rosario, Santa Fe\"\n\n\nBooleanos (bool)\nTrue, False\n\n\nValor nulo (NoneType)\nNone",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "1 - Introducci√≥n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#variables",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#variables",
    "title": "1 - Introducci√≥n",
    "section": "Variables",
    "text": "Variables\n¬øEs necesario escribir expl√≠citamente los valores con los que trabajamos cada vez que los usamos? Afortunadamente, la respuesta es no.\nLos lenguajes de programaci√≥n m√°s populares permiten usar variables.\nPodemos pensar las variables como etiquetas o nombres que asignamos a los objetos en nuestro programa.\nUna vez creada una variable con cierto valor, podemos usar directamente su nombre en lugar de volver a escribir el valor completo.\n\nmensaje = \"¬°Hola, curso!\"\nprint(mensaje)\n\n¬°Hola, curso!\n\n\n\nprint(\"¬°Hola, curso!\")\n\n¬°Hola, curso!\n\n\nPara crear una variable se necesita:\n\nEl nombre.\nEl operador de asignaci√≥n.\nEl valor que queremos asignar a la variable.\n\nEn nuestro caso, el nombre de la variable es mensaje y el valor es \"¬°Hola, curso!\".\nLuego, cuando accedemos a la variable mensaje dentro de la funci√≥n print(), Python nos devuelve el valor de la variable, es decir, ¬°Hola, curso!\".\nVeamos otros ejemplos‚Ä¶\n\npi = 3.14159\nfruta_favorita = \"manzana\"\npython_bueno = True\n\nEn el siguiente diagrama se muestra c√≥mo las variables que creamos funcionan simplemente como etiquetas para los valores asignados.\nCada vez que utilizamos una de estas etiquetas, accedemos directamente al valor que representa.\n\n\n\n\n\n\nprint(pi * 10)\n\n31.4159\n\n\n\nfruta_favorita\n\n'manzana'\n\n\n\npython_bueno\n\nTrue\n\n\nLas variables no solo evitan que escribamos repetidamente los mismos valores en nuestro programa, sino que tambi√©n permiten:\n\nGeneralizar el programa\n\nAl cambiar el valor de una variable, todas las partes del programa que la usan se actualizan autom√°ticamente.\n\nMejorar la legibilidad del c√≥digo\n\nSi elegimos nombres claros y descriptivos, el programa ser√° mucho m√°s f√°cil de leer y entender.\n\n\nPor ejemplo, los siguientes bloques de c√≥digo producen el mismo resultado, pero el segundo es mucho m√°s informativo:\n\n1500 * 8\n\n12000\n\n\n\nprecio = 1500\ncantidad = 8\nprecio * cantidad\n\n12000\n\n\n\nNombres permitidos\nNo todos los nombres que imaginemos se pueden utilizar como variables en Python.\nTenemos que tener en cuenta las siguientes reglas. Los nombres de variables‚Ä¶\n\nSolo pueden contener letras, n√∫meros y guiones bajos (_).\nDeben comenzar con una letra o un gui√≥n bajo, pero no con un n√∫mero.\n\nPor ejemplo, mensaje_1 es v√°lido, pero 1_mensaje no lo es.\n\nNo pueden contener espacios.\n\nPor eso usamos fruta_favorita en lugar de fruta favorita.\n\nNo pueden ser palabras reservadas de Python.\n\nLas palabras reservadas se encuentran al final de este apunte.\n\n\nAdem√°s, tambi√©n vale la pena tener presente estos consejos:\n\nUs√° nombres breves pero descriptivos.\n\nnombre es preferible a n.\nfruta_favorita es preferible a frut_fav.\n\nEvit√° utilizar tildes, la letra √± u otros caracteres espec√≠ficos del castellano.\n\n\n\nEliminar variables\nEs posible que, despu√©s de crear nuestras variables y realizar las operaciones necesarias, queramos eliminarlas.\nPara borrar una variable, Python ofrece la sentencia del (del ingl√©s delete, que significa eliminar o borrar).\n\ndel fruta_favorita\n\n\n\nAsignaci√≥n m√∫ltiple\nYa vimos que para asignar (o crear) una variable necesitamos hacer variable = &lt;valor&gt;.\nSi queremos crear varias variables, podemos hacerlo en l√≠neas separadas:\n\npi = 3.1416\ne = 2.7182\n\nprint(pi)\nprint(e)\n\n3.1416\n2.7182\n\n\nUna caracter√≠stica conveniente de Python es que permite asignar m√∫ltiples variables en una misma l√≠nea:\n\npi, e = 3.1416, 2.7182\n\nprint(pi)\nprint(e)\n\n3.1416\n2.7182\n\n\nOtra ventaja es que las variables no tienen que ser del mismo tipo:\n\na, b, c = 100 + 20, \"un mensaje cualquiera\", None\n\nprint(a)\nprint(b)\nprint(c)\n\n120\nun mensaje cualquiera\nNone\n\n\nEsta t√©cnica es √∫til para escribir c√≥digo m√°s conciso, pero no conviene abusar de ella porque puede resultar en c√≥digo poco legible.\n\n\n\n\n\n\nObservaci√≥n üëÄ\n\n\n\nLa vida es m√°s compleja de lo que parece, y los lenguajes de programaci√≥n no son una excepci√≥n.\nEn Python, lo que parece una asignaci√≥n m√∫ltiple de variables es en realidad el uso de una t√©cnica m√°s avanzada llamada unpacking.\nA no desesperarse, m√°s adelante vamos a aprender de qu√© se trata.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "1 - Introducci√≥n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#operadores",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#operadores",
    "title": "1 - Introducci√≥n",
    "section": "Operadores",
    "text": "Operadores\nLos operadores son s√≠mbolos que se utilizan para realizar operaciones o acciones sobre los objetos con los que estamos trabajando.\nHasta ahora, vimos que podemos tener n√∫meros, texto, y otras objetos un poco mas extra√±os como los booleanos e incluso algo que representa a la nada misma.\nA continuaci√≥n, comenzamos a ver algunas de las tareas que podemos hacer con ellos.\n\nOperadores aritm√©ticos\nPython incluye los mismos operadores aritm√©ticos que solemos utilizar en nuestro d√≠a a d√≠a para hacer operaciones matem√°ticas.\nEstos se parecen much√≠simo a los que usamos en una calculadora, por lo que podr√≠amos entenderlo incluso sin saber de Python.\nAlgunos operadores son los siguientes:\n\nSuma (+)\nResta (-)\nMultiplicaci√≥n (*)\nPotencia (**)\nDivisi√≥n (/)\nDivisi√≥n entera (//)\nM√≥dulo (%)\n\n\nSuma (+)\n\n10 + 25\n\n35\n\n\n\n10.0 + 25.0\n\n35.0\n\n\n\n-8 + 12.1\n\n4.1\n\n\nEl operador suma tambi√©n puede ser usado con un solo argumento:\n\n+ 8\n\n8\n\n\nEn este caso no modifica en nada al valor 8.\n\n\n\nResta (-)\n\n11 - 8\n\n3\n\n\n\n100 - 100.0\n\n0.0\n\n\n\n-35 - 28\n\n-63\n\n\nEl operador resta tambi√©n puede ser usado con un solo argumento:\n\n- 7\n\n-7\n\n\n\n\nMultiplicaci√≥n (*) y potencia (**)\n\n21 * 5\n\n105\n\n\n\n21 * 5.0\n\n105.0\n\n\n\n21.0 * 5.0\n\n105.0\n\n\n\n2 ** 3\n\n8\n\n\n\n2 ** 3.0\n\n8.0\n\n\n\n\n\n\n\n\nConclusiones\n\n\n\nPara las operaciones de suma, resta, multiplicaci√≥n y potencia se cumple:\n\nSi ambos valores son enteros, el resultado ser√° un entero.\nSi al menos uno de los valores es flotante, el resultado ser√° flotante.\n\n\n\n\n\nDivisi√≥n (/ y //)\nPython provee dos operadores distintos para calcular el cociente entre dos n√∫meros.\n\nEl operador / que calcula la divisi√≥n flotante.\nEl operador // que calcula la divisi√≥n entera.\n\nEl operador / es el que m√°s se utiliza y siempre devuelve un n√∫mero de tipo flotante.\n\n10 / 5\n\n2.0\n\n\n\n10 / 5.5\n\n1.8181818181818181\n\n\nLa divisi√≥n entera se suele utilizar cuando uno quiere el resultado entero de la divisi√≥n, sin importar si el resto es 0 o no.\n\n10 // 5\n\n2\n\n\n\n10 // 5.5\n\n1.0\n\n\nVeamos los siguientes ejemplos donde comparamos la divisi√≥n flotante con la divisi√≥n entera, utilizando los mismos argumentos.\n\n15 / 4\n\n3.75\n\n\n\n15.0 // 4.0\n\n3.0\n\n\nConclusi√≥n: La divisi√≥n entera no redondea el resultado de la divisi√≥n flotante. M√°s sobre esto debajo.\n\n\nM√≥dulo (%)\nOtro operador relacionado a la divisi√≥n entera es el operador m√≥dulo o resto (%).\nEsta operaci√≥n nos devuelve el resto que se obtiene al realizar la divisi√≥n entera entre dos n√∫meros.\n\n17 % 3\n\n2\n\n\nDebajo se puede ver la relaci√≥n entre la divisi√≥n entera y el m√≥dulo:\n\n\n\n\n\nAunque ahora pueda parecer dif√≠cil encontrar una aplicaci√≥n pr√°ctica para los operadores de divisi√≥n entera // y resto %, m√°s adelante veremos ejemplos donde haremos un uso intensivo de ellos.\n\n\n\n\n\n\nObservaci√≥n üëÄ\n\n\n\nProbablemente en R hayan utilizado principalmente el operador /, que tambi√©n corresponde a la divisi√≥n flotante.\nEn ese lenguaje, los operadores para divisi√≥n entera y resto son %/% y %%, respectivamente.\n\n\n\n\nPrioridad de los operadores\nHasta ahora vimos operaciones bastante sencillas.\nCuando presentamos la suma, realizamos simplemente una suma. Cuando presentamos la multiplicaci√≥n, hicimos solo una multiplicaci√≥n.\nPor supuesto, al momento de hacer c√°lculos podemos combinar los operadores que ya conocemos, de la misma forma en que lo hacemos al resolver cuentas a mano.\nUn punto importante a tener en cuenta es que, al igual que cuando hacemos cuentas a mano, algunas operaciones se resuelven antes que otras, sin importar el orden en que aparecen. Esto ocurre porque algunos operadores tienen mayor prioridad y, por lo tanto, se eval√∫an antes.\nEn el siguiente ejemplo, ¬øpor qu√© se obtienen resultados distintos?\n\n10 - 2 * 4\n\n2\n\n\n\n(10 - 2) * 4\n\n32\n\n\nIndependientemente de que el s√≠mbolo + aparezca antes que el s√≠mbolo * en una expresi√≥n, Python realiza primero la multiplicaci√≥n.\nAl igual que cuando hacemos cuentas a mano, la multiplicaci√≥n tiene mayor prioridad que la suma.\nSi queremos forzar a Python a realizar una operaci√≥n antes que otra, sin importar la prioridad de los operadores, debemos usar par√©ntesis.\nOtro ejemplo es el siguiente‚Ä¶\n\n7 + 8 / 2\n\n11.0\n\n\n\n(7 + 8) / 2\n\n7.5\n\n\nA continuaci√≥n se incluye una tabla con los operadores que vimos y la prioridad que tiene cada uno.\nLos operadores que aparecen m√°s arriba tienen mayor prioridad.\nLos operadores que aparecen en la misma fila tienen el mismo nivel de prioridad y se resuelven seg√∫n el orden en que aparecen en el c√≥digo (de izquierda a derecha).\n\n\n\n\n\n\n\nOperador\nSignificado\n\n\n\n\n()\nAgrupamiento\n\n\n**\nPotencia\n\n\n*, /, //, %\nMultiplicaci√≥n, Divisi√≥n, Divisi√≥n entera, M√≥dulo\n\n\n+, -\nSuma, Resta\n\n\n\nEsta lista es una versi√≥n m√°s sencilla y resumida de la tabla de prioridades de todos los operadores que hay en Python. Una versi√≥n m√°s completa se puede encontrar en Programiz.\n\n\n\nOperadores l√≥gicos\nLos operadores l√≥gicos en Python son tres: not, and y or. Se llaman as√≠ porque combinan expresiones l√≥gicas (o directamente valores l√≥gicos) y devuelven tambi√©n valores l√≥gicos, es decir, del tipo bool, que pueden ser True o False. Estos operadores se utilizan para combinar o invertir condiciones en expresiones l√≥gicas.\n\nNegaci√≥n (not)\nDevuelve el opuesto del valor que le pasamos.\n\nnot False\n\nTrue\n\n\n\nnot True\n\nFalse\n\n\n\n\nConjunci√≥n o intersecci√≥n (and)\nEsta operaci√≥n devuelve True solamente cuando los dos operadores que le pasamos son True.\n\nTrue and True\n\nTrue\n\n\n\nFalse and True\n\nFalse\n\n\n\n\nDisyunci√≥n o uni√≥n (or)\nEsta operaci√≥n devuelve True cuando cualquiera de sus argumentos es True.\n\nTrue or False\n\nTrue\n\n\nSolo devuelve False cuando sus dos argumentos son False.\n\nFalse or False\n\nFalse\n\n\n\n\n\nOperadores de comparaci√≥n\n\nComparaci√≥n por identidad\nPython ofrece dos operadores para verificar si dos objetos son o no el mismo en identidad (es decir, en memoria):\n\nis: devuelve True si ambos operandos son el mismo objeto.\nis not: devuelve True si los operandos no son el mismo objeto.\n\n\nFalse is False\n\nTrue\n\n\n\nFalse is True\n\nFalse\n\n\n\nNone is None\n\nTrue\n\n\nEste tipo de comparaci√≥n es posible porque cada objeto en Python existe en la memoria de la computadora y tiene una identificaci√≥n √∫nica (ID). Para conocer el ID de un objeto, se puede usar la funci√≥n id().\n\nid(False)\n\n94152411564800\n\n\n\nid(False)\n\n94152411564800\n\n\n\nid(None)\n\n94152411476128\n\n\n\n\nComparaci√≥n por valor\nPor otro lado, Python tambi√©n provee operadores para realizar comparaciones entre objetos en t√©rminos de sus valores.\nLos operadores que vemos a continuaci√≥n son los mismos que aprendimos en la secundaria.\n\n\n\n\n\n\n\nOperador\nDescripci√≥n\n\n\n\n\n==\nIgualdad: El resultado es True cuando los dos operandos son iguales.\n\n\n!=\nDesigualdad: El resultado es True si los operandos son distintos.\n\n\n&gt;\nMayor a: El resultado es True si el operando de la izquierda es mayor que el de la derecha.\n\n\n&gt;=\nMayor o igual a: El resultado es True si el operando de la izquierda es mayor o igual que el de la derecha.\n\n\n&lt;\nMenor a: El resultado es True si el operando de la izquierda es menor que el de la derecha.\n\n\n&lt;=\nMenor o igual a: El resultado es True si el operando de la izquierda es menor o igual que el de la derecha.\n\n\n\nAlgunos ejemplos‚Ä¶\n\n10 &gt; 5\n\nTrue\n\n\n\n10 &gt; 5 + 3\n\nTrue\n\n\n\n0 &lt; 0\n\nFalse\n\n\n\n1 &gt;= 1\n\nTrue\n\n\n\n10.0 != 10\n\nFalse\n\n\n\n10.0 == 10\n\nTrue\n\n\nA pesar de que 10.0 es de tipo flotante y 10 es de tipo entero, vemos que la comparaci√≥n de igualdad == dice que son iguales.\nNo siempre que comparemos objetos de distinto tipo va a suceder algo as√≠.\nLa comparaci√≥n de cadenas de texto distingue may√∫sculas de min√∫sculas\n\n\"UNR\" == \"unr\"\n\nFalse\n\n\nEs posible comparar objetos de distinto tipo, como lo vimos en el ejemplo anterior donde comparamos 10 y 10.0.\nSalvo casos particulares, como son los valores num√©ricos, estos objetos son considerados siempre distintos.\n\n\"10\" == 10\n\nFalse\n\n\n\n\"False\" == False\n\nFalse\n\n\nEs posible combinar mas de una comparaci√≥n en la misma l√≠nea.\n\n1 &lt; 2 and 2 &lt; 3\n\nTrue\n\n\nIncluso es posible omitir el operador and y tener una expresi√≥n m√°s clara\n\n1 &lt; 2 &lt; 3\n\nTrue\n\n\n\n-5 &lt; -4 &lt; -3\n\nTrue\n\n\nTambi√©n podemos mezclar not, and y or a gusto.\n\nFalse or not False\n\nTrue\n\n\nY es v√°lido utilizar par√©ntesis para agrupar operaciones.\n\n(False or True) and (True or False)\n\nTrue\n\n\nA continuaci√≥n se incluye una tabla con los operadores de comparaci√≥n y la prioridad que tiene cada uno.\nLos operadores que aparecen m√°s arriba tienen mayor prioridad.\nLos operadores que aparecen en la misma fila tienen el mismo nivel de prioridad y se resuelven seg√∫n el orden en que aparecen en el c√≥digo (de izquierda a derecha).\n\n\n\n\n\n\n\nOperadores\nSignificado\n\n\n\n\n==, !=, &gt;, &gt;=, &lt;, &lt;=, is, is not, in, not in\nComparaciones, identidad, pertenencia\n\n\nnot\nNegaci√≥n\n\n\nand\nConjunci√≥n o intersecci√≥n\n\n\nor\nDisyunci√≥n o uni√≥n\n\n\n\nTodos los operadores de comparaci√≥n tienen menor prioridad que los operadores aritm√©ticos que vimos arriba.\nEn otras palabras, si pegaramos ambas tablas, √©sta √∫ltima quedar√≠a por debajo.\nAnalicemos nuevamente uno de los ejemplos que ya vimos.\n\nnot True and not True\n\nFalse\n\n\nEl operador not tiene mayor prioridad que el operador and porque aparece primero en la tabla.\nEn consecuencia, en el c√≥digo anterior primero se resuelven los not True y luego el and. Esto es lo mismo que hacer\n\nFalse and False\n\nFalse\n\n\n\n\n\n\n\n\nResumen üìù\n\n\n\nExisten dos operadores para comparar igualdad entre dos objetos de Python:\n\n== ‚Üí compara el valor (contenido).\nis ‚Üí compara la identidad (ubicaci√≥n en memoria).",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "1 - Introducci√≥n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#operaciones-con-cadenas-de-caracteres",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#operaciones-con-cadenas-de-caracteres",
    "title": "1 - Introducci√≥n",
    "section": "Operaciones con cadenas de caracteres",
    "text": "Operaciones con cadenas de caracteres\n\nSuma y producto\nAunque al principio pueda parecer extra√±o, en Python es posible usar operadores matem√°ticos con objetos que no son num√©ricos.\nEsto no significa que se puedan aplicar a cualquier objeto, ni que est√©n disponibles todos los operadores en esos casos.\nSin embargo, vale la pena resaltar el uso del operador de suma (+) y producto (*) con las cadenas de caracteres.\nVeamos que pasa si ‚Äúsumamos‚Äù dos cadenas de caracteres:\n\n\"¬øFunciona\" + \"bien?\"\n\n'¬øFuncionabien?'\n\n\n\n\"¬øesto\" + \" tambi√©n \" + \"funciona?\"\n\n'¬øesto tambi√©n funciona?'\n\n\nComo se puede observar, el operador de suma (+) aplicado a cadenas de texto indica concatenaci√≥n: crea una nueva cadena uniendo el contenido de las cadenas originales, en el mismo orden.\nSi la suma tiene sentido para cadenas, entonces el producto tambi√©n deber√≠a tenerlo (al menos con n√∫meros enteros). Veamos un ejemplo:\n\n\"ja\" * 2\n\n'jaja'\n\n\n\n\"ja\" * 4\n\n'jajajaja'\n\n\nDe manera coherente con la definici√≥n de producto para enteros, multiplicar una cadena por un n√∫mero entero N equivale a concatenar esa cadena consigo misma N veces.\n\n\nCadenas formateadas (formatted strings)\nLas cadenas de texto formateadas son de gran utilidad para crear una cadena de texto a partir de otros objetos.\nEn Python se las conoce como f-strings (abreviaci√≥n de formatted-strings) y tienen este nombre porque tenemos que poner una f antes de las comillas.\nEl resultado de una f-string no se diferencia de una cadena de texto com√∫n y corriente.\n\nf\"Un texto cualquiera\"\n\n'Un texto cualquiera'\n\n\nSin embargo, las f-strings nos permiten interpolar cadenas de texto.\n¬øQu√© es interpolar texto?\nVeamos algunos ejemplos.\n\nlenguaje = \"Python\"\nprint(\"Programando en \" + lenguaje)\n\nProgramando en Python\n\n\n\nque = \"bayer\"\ncomo = \"bueno\"\nprint(\"Si es \" + que + \" es \" + como + \".\")\n\nSi es bayer es bueno.\n\n\nEl proceso se vuelve un poco engorroso. Hay que estar atentos a las sumas y los espacios para que el resultado quede formateado de una manera correcta.\nLas f-strings vienen a facilitar este proceso y hacerlo menos tedioso.\nLo que tenemos que hacer es pasar el nombre de la variable entre llaves ({}) en el contenido de la f-string.\n\nprint(f\"Programando en {lenguaje}\")\nprint(f\"Si es {que} es {como}.\")\n\nProgramando en Python\nSi es bayer es bueno.\n\n\nVeamos un ejemplo menos trivial, donde utilizar f-strings reduce la cantidad de c√≥digo y lo hace m√°s claro.\n\nnombre = \"Tom√°s\"\nedad = 29\nciudad = \"Rosario\"\n\nprint(\"Hola, soy \" + nombre + \", tengo \" + str(edad) + \" a√±os y vivo en \" + ciudad + \".\")\n\nHola, soy Tom√°s, tengo 29 a√±os y vivo en Rosario.\n\n\nUtilizando f-strings‚Ä¶\n\nprint(f\"Hola, soy {nombre}, tengo {edad} a√±os y vivo en {ciudad}.\")\n\nHola, soy Tom√°s, tengo 29 a√±os y vivo en Rosario.\n\n\nAdem√°s, no es necesario convertir la variable edad a al tipo str manualmente.\nNo solo podemos utilizar variables dentro de las f-strings, tambi√©n podemos incluir expresiones de Python.\n\nminutos_por_hora = 60\nhoras = 2.7\n\nprint(f\"En {horas} horas hay {horas * minutos_por_hora} minutos.\")\n\nEn 2.7 horas hay 162.0 minutos.\n\n\n\n\nCadenas de texto y sus met√≥dos\n\nnombre = \"Lionel Messi\"\n\nLas cadenas de texto, es decir, los objetos de tipo str, vienen con varias funciones (llamados ‚Äúm√©todos‚Äù) que nos facilitan much√≠simas tareas en la pr√°ctica.\nPor ejemplo, tenemos los m√©todos .upper() y .lower(), que ponen el texto en may√∫scula y en min√∫scula, respectivamente.\n\nprint(nombre.upper())\nprint(nombre.lower())\n\nLIONEL MESSI\nlionel messi\n\n\nTambi√©n tenemos .capitalize(), que pone la primer letra en may√∫scula y el resto en min√∫sculas.\nEstos m√©todos se pueden combinar dentro de una f-string, sin necesidad de modificar los valores de nombre o apellido.\n\nnombre = \"lionel\"\napellido = \"messi\"\nnombre_completo = f\"{nombre.capitalize()} {apellido.capitalize()}\"\nprint(nombre_completo)\n\nLionel Messi\n\n\nOtra opci√≥n es usar .title().\nEste m√©todo pone la primera letra de cada palabra en may√∫sculas y al resto en min√∫sculas.\n\nmensaje = \"mensaje de prueba\"\nprint(mensaje.capitalize())\nprint(mensaje.title())\n\nMensaje de prueba\nMensaje De Prueba\n\n\n\n\nEliminar espacios en blanco\nEs muy com√∫n que en nuestros programas tengamos que lidiar con texto que vienen con espacios en blanco que est√°n dem√°s.\nEl espacio puede estar tanto al principio como al final de una cadena de texto.\nAfortunadamente, Python tambi√©n provee algunos m√©todos que nos permiten eliminar estos espacios con muy poco trabajo.\n\nlenguaje_favorito = \"  python  \"\nlenguaje_favorito\n\n'  python  '\n\n\n.rstrip() elimina los espacios en blanco a la derecha del texto.\n\nlenguaje_favorito.rstrip()\n\n'  python'\n\n\n.lstrip() elimina los espacios en blanco a la izquierda del texto.\n\nlenguaje_favorito.lstrip()\n\n'python  '\n\n\ny .strip() elimina los espacios en blanco a la izquierda y a la derecha del texto.\n\nlenguaje_favorito.strip()\n\n'python'\n\n\n\n\nReemplazar y eliminar caracteres no deseados\nTambi√©n es frecuente que el texto contenga caracteres err√≥neos, o caracteres que simplemente no queremos conservar.\nPara estos casos podemos usar el m√©todo .replace().\nA diferencia de los m√©todos que vimos hasta ahora, .replace() requiere que le pasemos algunos argumentos.\nEl primer valor que le pasamos es el texto que queremos reemplazar y el segundo es el texto de reemplazo.\nPodemos reemplazar caracteres, palabras, o frases enteras.\n\nanimal = \"pato\"\nanimal.replace(\"p\", \"g\")\n\n'gato'\n\n\n\nsaludo = \"Hola Mundo\"\nsaludo.replace(\"Mundo\", \"Curso\")\n\n'Hola Curso'\n\n\nCuando utilizamos el m√©todo .replace() se nos devuelve una nueva cadena de texto.\nEsto nos permite ‚Äúpegar‚Äù o ‚Äúencadenar‚Äù mas de un .replace() a la vez, ya que cada nuevo .replace() se aplica sobre el resultado de la operaci√≥n anterior.\n\nsaludo.replace(\"Mundo\", \"Curso\").replace(\"Hola\", \"Chau\")\n\n'Chau Curso'\n\n\nsaludo.replace(\"Mundo\", \"Curso\") devuelve \"Hola Curso\", al que luego se le aplica .replace(\"Hola\", \"Chau\") y el resultado final es \"Chau Curso\".",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "1 - Introducci√≥n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#ap√©ndice",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#ap√©ndice",
    "title": "1 - Introducci√≥n",
    "section": "Ap√©ndice",
    "text": "Ap√©ndice\n\nPalabras claves y funciones predefinidas\nPython tiene un conjunto de palabras conocidas como keywords que sirven para realizar acciones especificas y que no podemos utilizar como nombres de variables.\nCuando intentemos utilizar una keyword como nombre de variable, obtendremos un error.\nPor otro lado, si intentamos utilizar el nombre de una funci√≥n (o clase) predefinida como nombre de una variable que nosotros creamos, no vamos a obtener un error pero no podremos usar la funci√≥n nuevamente porque la variable ahora representa otra cosa.\n\nPalabras claves\nFalse      await      else       import     pass\nNone       break      except     in         raise\nTrue       class      finally    is         return\nand        continue   for        lambda     try\nas         def        from       nonlocal   while\nassert     del        global     not        with\nasync      elif       if         or         yield\n\n\nFunciones y clases pre-definidas\nabs()          copyright()    getattr()      list()         range()        vars()\nall()          credits()      globals()      locals()       repr()         zip()\nany()          delattr()      hasattr()      map()          reversed()\nascii()        dict()         hash()         max()          round()\nbin()          dir()          help()         memoryview()   set()\nbool()         display()      hex()          min()          setattr()\nbreakpoint()   divmod()       id()           next()         slice()\nbytearray()    enumerate()    input()        object()       sorted()\nbytes()        eval()         int()          oct()          staticmethod()\ncallable()     exec()         isinstance()   open()         str()\nchr()          filter()       issubclass()   ord()          sum()\nclassmethod()  float()        iter()         pow()          super()\ncompile()      format()       len()          print()        tuple()\ncomplex()      frozenset()    license()      property()     type()\n\n\nM√©todos de las cadenas de texto\n\n\n\n\n\n\n\n\n\nM√©todo\nDescripci√≥n\nEjemplo\nResultado\n\n\n\n\n.endswith(sufijo)\nVerifica si termina con el sufijo\n\"file.txt\".endswith(\".txt\")\nTrue\n\n\n.find(x)\nLa posicion de la primera aparici√≥n de x en la cadena (o -1 si no est√°)\n\"Python\".find(\"t\")\n2\n\n\n.index(x)\nLa posicion de la primera aparici√≥n de x en la cadena (error si no est√°)\n\"Python\".index(\"n\")\n5\n\n\n.isalpha()\nVerifica si los caracteres son alfab√©ticos\n\"256\".isalpha()\nFalse\n\n\n.isdigit()\nVerifica si los caracteres son num√©ricos\n\"256\".isdigit()\nTrue\n\n\n.islower()\nVerifica si los caracteres son min√∫sculas\n\"Python\".islower()\nFalse\n\n\n.isupper()\nVerifica si los caracteres son may√∫sculas\n\"Python\".isupper()\nFalse\n\n\n.join(lista)\nUne una lista de cadenas usando la cadena como delimitador\n\" y \".join([\"esto\", \"aquello\"])\n\"esto y aquello\"\n\n\n.lower()\nConvertir a min√∫sculas\n\"Python\".lower()\n\"python\"\n\n\n.replace(viejo, nuevo)\nReemplaza texto\n\"maximo\".replace(\"ax\", \"in\")\n\"minimo\"\n\n\n.split(sep)\nParte la cadena en una lista de subcadenas\n\"esto y aquello\".split(\" y \")\n[\"esto\", \"aquello\"]\n\n\n.startswith(prefijo)\nVerifica si comienza con un prefijo\n\"file.txt\".endswith(\"a\")\nFalse\n\n\n.strip()\nElimina espacios en blanco al inicio o al final\n\" oh la la \".strip()\n\"oh la la\"\n\n\n.upper()\nConvierte a may√∫sculas\n\"Python\".upper()\n\"PYTHON\"",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "1 - Introducci√≥n"
    ]
  },
  {
    "objectID": "recursos/ejemplos/01_funciones_y_bucles.html",
    "href": "recursos/ejemplos/01_funciones_y_bucles.html",
    "title": "Funciones y bucles: Python vs R",
    "section": "",
    "text": "El siguiente bloque de c√≥digo define una funci√≥n en R:\n\n\nfuncion.R\n\nsumar &lt;- function(a, b) {\n  resultado &lt;- a + b\n  return(resultado)\n}\n\ny el siguiente define una funci√≥n an√°loga en Python:\n\n\nfuncion.py\n\ndef sumar(a, b):\n    resultado = a + b\n    return resultado",
    "crumbs": [
      "Recursos",
      "Ejemplos"
    ]
  },
  {
    "objectID": "recursos/ejemplos/01_funciones_y_bucles.html#funciones",
    "href": "recursos/ejemplos/01_funciones_y_bucles.html#funciones",
    "title": "Funciones y bucles: Python vs R",
    "section": "",
    "text": "El siguiente bloque de c√≥digo define una funci√≥n en R:\n\n\nfuncion.R\n\nsumar &lt;- function(a, b) {\n  resultado &lt;- a + b\n  return(resultado)\n}\n\ny el siguiente define una funci√≥n an√°loga en Python:\n\n\nfuncion.py\n\ndef sumar(a, b):\n    resultado = a + b\n    return resultado",
    "crumbs": [
      "Recursos",
      "Ejemplos"
    ]
  },
  {
    "objectID": "recursos/ejemplos/01_funciones_y_bucles.html#ejecuci√≥n-condicional",
    "href": "recursos/ejemplos/01_funciones_y_bucles.html#ejecuci√≥n-condicional",
    "title": "Funciones y bucles: Python vs R",
    "section": "Ejecuci√≥n condicional",
    "text": "Ejecuci√≥n condicional\nPor otro lado, el siguiente bloque muestra el uso de ejecuci√≥n condicional en R:\n\n\ncondicional.R\n\nx &lt;- 5\n\nif (x &gt; 0) {\n  mensaje &lt;- \"El n√∫mero es positivo\"\n} else {\n  mensaje &lt;- \"El n√∫mero no es positivo\"\n}\n\nprint(mensaje)\n\nY debajo se muestra la versi√≥n an√°loga en Python:\n\n\ncondicional.py\n\nx = 5\n\nif x &gt; 0:\n    mensaje = \"El n√∫mero es positivo\"\nelse:\n    mensaje = \"El n√∫mero no es positivo\"\n\nprint(mensaje)",
    "crumbs": [
      "Recursos",
      "Ejemplos"
    ]
  },
  {
    "objectID": "recursos/ejemplos/01_funciones_y_bucles.html#resumen-de-diferencias",
    "href": "recursos/ejemplos/01_funciones_y_bucles.html#resumen-de-diferencias",
    "title": "Funciones y bucles: Python vs R",
    "section": "Resumen de diferencias",
    "text": "Resumen de diferencias\n\nComunes\n\nUso de bloques:\n\nEn R los bloques de c√≥digo siempre se delimitan con llaves {}.\nEn Python los bloques se definen exclusivamente mediante indentaci√≥n (sin llaves).\n\nIndentaci√≥n:\n\nEn Python la indentaci√≥n es obligatoria y tiene significado sint√°ctico.\nEn R la indentaci√≥n es opcional; sirve √∫nicamente para mejorar la legibilidad.\n\nUso de los dos puntos (:):\n\nEn Python las definiciones de funciones y condiciones terminan con :.\nEn R no se utilizan los dos puntos al final de estas estructuras.\n\n\n\n\nFunciones\n\nForma de definir la funci√≥n:\n\nEn R: sumar &lt;- function(a, b). Se crea la funci√≥n y se asigna a una variable.\nEn Python: def sumar(a, b):. La creaci√≥n de la funci√≥n ya crea la variable.\n\nRetorno de valores:\n\nEn R, aunque es com√∫n usar return(), el resultado de la √∫ltima expresi√≥n se devuelve autom√°ticamente (puede omitirse return).\nEn Python es obligatorio usar return si se desea devolver un valor.\n\n\n\n\nEjecuci√≥n condicional\n\nUso de par√©ntesis en condiciones:\n\nEn R es obligatorio usar par√©ntesis alrededor de la condici√≥n (if (x &gt; 0)).\nEn Python no se usan par√©ntesis (if x &gt; 0:).",
    "crumbs": [
      "Recursos",
      "Ejemplos"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html",
    "href": "practica/02_programacion_funcional/ejercicios.html",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "",
    "text": "Debajo se muestra un listado de funciones impuras. Analice por qu√© son impuras e implemente alternativas puras (manteniendo su l√≥gica):\nFunci√≥n 1\ncontador = 0\ndef incrementar():\n1    global contador\n    contador += 1\n    return contador\n\n1\n\nLa palabra global es una keyword que indica que se pretende usar y modificar una variable definida fuera del √°mbito de ejecuci√≥n de la funci√≥n.\n\n\nFunci√≥n 2\ndef obtener_hora_actual():\n    import datetime\n    return datetime.datetime.now().hour\nFunci√≥n 3\ndef add_time(time, hours, minutes, seconds):\n1    increment_time(time, hours, minutes, seconds)\n    return time\n\n1\n\nAsuma que esta funci√≥n incrementa a time, que es un objeto datetime, en hours horas, minutes minutos y seconds segundos.\n\n\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nRepresente fechas y horas con el objeto objeto datetime del m√≥dulo est√°ndar datetime. Adem√°s, considere el objeto timedelta del mismo m√≥dulo para luego calcular diferencias. Por ejemplo:\nimport datetime\n\nahora = datetime.datetime.now() # Devuelve un objeto con la fecha y la hora actual\nprint(ahora)\n\nuna_hora_mas_tarde = datetime.timedelta(hours=1, minutes=0, seconds=0)\nprint(ahora + una_hora_mas_tarde)\n2025-08-31 09:48:58.327461\n2025-08-31 10:48:58.327461\n\n\n\nFunci√≥n 4\nhistorial_de_nombres = []\ndef registrar_nombre(nombre):\n    historial_de_nombres.append(nombre)\n    return f\"'{nombre}' ha sido registrado en el historial.\"\nFunci√≥n 5\nLIMITE_MAXIMO = 100\ndef verificar_limite(valor):\n    if valor &gt; LIMITE_MAXIMO:\n        return \"Excede el l√≠mite\"\n    return \"Dentro del l√≠mite\"",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#trasfromando-funciones",
    "href": "practica/02_programacion_funcional/ejercicios.html#trasfromando-funciones",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "",
    "text": "Debajo se muestra un listado de funciones impuras. Analice por qu√© son impuras e implemente alternativas puras (manteniendo su l√≥gica):\nFunci√≥n 1\ncontador = 0\ndef incrementar():\n1    global contador\n    contador += 1\n    return contador\n\n1\n\nLa palabra global es una keyword que indica que se pretende usar y modificar una variable definida fuera del √°mbito de ejecuci√≥n de la funci√≥n.\n\n\nFunci√≥n 2\ndef obtener_hora_actual():\n    import datetime\n    return datetime.datetime.now().hour\nFunci√≥n 3\ndef add_time(time, hours, minutes, seconds):\n1    increment_time(time, hours, minutes, seconds)\n    return time\n\n1\n\nAsuma que esta funci√≥n incrementa a time, que es un objeto datetime, en hours horas, minutes minutos y seconds segundos.\n\n\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nRepresente fechas y horas con el objeto objeto datetime del m√≥dulo est√°ndar datetime. Adem√°s, considere el objeto timedelta del mismo m√≥dulo para luego calcular diferencias. Por ejemplo:\nimport datetime\n\nahora = datetime.datetime.now() # Devuelve un objeto con la fecha y la hora actual\nprint(ahora)\n\nuna_hora_mas_tarde = datetime.timedelta(hours=1, minutes=0, seconds=0)\nprint(ahora + una_hora_mas_tarde)\n2025-08-31 09:48:58.327461\n2025-08-31 10:48:58.327461\n\n\n\nFunci√≥n 4\nhistorial_de_nombres = []\ndef registrar_nombre(nombre):\n    historial_de_nombres.append(nombre)\n    return f\"'{nombre}' ha sido registrado en el historial.\"\nFunci√≥n 5\nLIMITE_MAXIMO = 100\ndef verificar_limite(valor):\n    if valor &gt; LIMITE_MAXIMO:\n        return \"Excede el l√≠mite\"\n    return \"Dentro del l√≠mite\"",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#√°rea-de-aprendizaje",
    "href": "practica/02_programacion_funcional/ejercicios.html#√°rea-de-aprendizaje",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "2 √Årea de aprendizaje",
    "text": "2 √Årea de aprendizaje\nSe cuenta con una lista de tuplas de longitud 2, representando el ancho y alto de distintos rect√°ngulos.\nrectangulos = [\n    (5, 8),\n    (2, 2),\n    (9, 2),\n    (3, 3),\n    (3, 7),\n    (6, 3)\n]\nCree una nueva lista que ordene dichos rect√°ngulos en funci√≥n de su √°rea.",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#socios-ordenados",
    "href": "practica/02_programacion_funcional/ejercicios.html#socios-ordenados",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "3 Socios ordenados",
    "text": "3 Socios ordenados\nSe cuenta con la siguiente lista de diccionarios, la cual contiene datos personales sobre miembros de un club de atletismo:\ndatos_socios = [\n    {\"nombre\": \"Bautista Carrara\", \"edad\": 22, \"altura_cm\": 178, \"record_100m\": 13.4},\n    {\"nombre\": \"Valentina Lucci\",  \"edad\": 23, \"altura_cm\": 163, \"record_100m\": 14.2},\n    {\"nombre\": \"Ger√≥nimo Cuesta\",  \"edad\": 26, \"altura_cm\": 170, \"record_100m\": 14.0},\n    {\"nombre\": \"Lucio Borga\",      \"edad\": 28, \"altura_cm\": 186, \"record_100m\": 13.8},\n    {\"nombre\": \"Julia Spoglia\",    \"edad\": 21, \"altura_cm\": 163, \"record_100m\": 11.9},\n    {\"nombre\": \"Soledad Colombo\",  \"edad\": 22, \"altura_cm\": 170, \"record_100m\": 13.5}\n]\nOrdene la lista en base a los r√©cords en la carrera de 100 metros, en forma ascendente.\n\nPunto extra\nImplemente una funci√≥n que tome como argumento una clave de diccionario y devuelva una lista ordenada por los valores de dicha clave. Si el argumento toma el valor \"nombre\", ordene los elementos alfab√©ticamente en base a los apellidos.",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#f√°brica-de-promociones",
    "href": "practica/02_programacion_funcional/ejercicios.html#f√°brica-de-promociones",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "4 F√°brica de promociones",
    "text": "4 F√°brica de promociones\nConsidere el ejercicio Promociones de la Pr√°ctica 1. Utilizando el mismo sistema de descuentos cree la funci√≥n crear_promocion que reciba como argumento el medio de pago y devuelva una funci√≥n que al aplicarse sobre un n√∫mero aplique el descuento (o recargo) que le corresponde a ese medio de pago. Por ejemplo:\npromo_debito = crear_promocion(\"d√©bito\")\nprint(promo_debito(1000))\nprint(promo_debito(2700))\n900\n2430.0\nLuego, cree la funci√≥n crear_promocion_personalizada que recibe el medio de pago y, de manera opcional, el porcentaje de descuento a aplicar. Como resultado devuelve una funci√≥n que al aplicarse sobre un n√∫mero impacta el descuento o recargo correspondiente. Adem√°s, considere que:\n\nSi no se pasa el porcentaje a aplicar, se deben usar los descuentos y recargos detallados en el enunciado del ejercicio en la Pr√°ctica 1.\nCaso contrario, la funci√≥n devuelta debe aplicar ese porcentaje personalizado (e.g., crear_promocion_personalizada(\"d√©bito\", 15) para 15% de descuento).\n\nEjemplo de uso:\npromo_debito = crear_promocion_personalizada(\"d√©bito\", 15)\npromo_debito(1000)\n850",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#analistas-de-temperaturas",
    "href": "practica/02_programacion_funcional/ejercicios.html#analistas-de-temperaturas",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "5 Analistas de temperaturas",
    "text": "5 Analistas de temperaturas\nConsidere una lista de temperaturas en grados Celsius sobre la cual se deben aplicar distintas operaciones.\ntemperaturas_celsius = [\n    25.5, 28.0, 19.3, 31.5, 22.8, 17.0, 30.2, 35.6, 14.2,\n    32.4, 22.7, 10.1, 29.5, 33.9, 22.1, 38.9, 18.4, 16.3\n]\n\nConvierta las temperaturas a grados Fahrenheit utilizando map y almacene el resultado en una lista llamada temperaturas_f. Use la f√≥rmula de conversi√≥n: \\[\nF = C \\times \\frac{9}{5} + 32\n\\]\nUtilice filter para seleccionar de la lista anterior las temperaturas que sean mayores a 80¬∞F. Guarde el resultado en una nueva lista. ¬øSe le ocurre una alternativa que no utilice la lista creada en el primer punto?\nUtilice reduce para sumar las temperaturas filtradas en el paso anterior y calcular el promedio dividiendo la suma total entre la cantidad de elementos en la lista filtrada.\n\n\nPunto extra üò±\nCalcule el promedio de temperaturas sin materializar ninguna secuencia hasta el √∫ltimo instante. Para ello, deber√° utilizar enumrate, filter y reduce, sin convertir resultados a listas intermedias.",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#listado-de-rimas",
    "href": "practica/02_programacion_funcional/ejercicios.html#listado-de-rimas",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "6 Listado de rimas",
    "text": "6 Listado de rimas\nSe tiene la siguiente lista de palabras, la cual se quiere utilizar para formar rimas:\npalabras_a_rimar = [\n    \"actividad\",\n    \"bendici√≥n\",\n    \"cartelera\",\n    \"ciudad\",\n    \"escalera\",\n    \"estaci√≥n\",\n    \"felicidad\",\n    \"funci√≥n\",\n    \"reposera\"\n]\nOrdene la lista en base al orden alfab√©tico del reverso de cada palabra, de modo que las palabras que riman se encuentren juntas.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nSi la lista fuese [\"durazno\", \"kiwi\"], el resultado ser√≠a [\"kiwi\", \"durazno\"], porque \"iwik\" precede a \"onzarud\" en orden alfab√©tico.",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#el-tiempo-vuela",
    "href": "practica/02_programacion_funcional/ejercicios.html#el-tiempo-vuela",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "7 El tiempo vuela",
    "text": "7 El tiempo vuela\nSe quiere medir el tiempo que tarda la computadora en ejecutar distintos bloques de c√≥digo. Para eso, implemente una funci√≥n crear_cronometro que fabrique una funci√≥n cronometro, la cual devuelve el tiempo transcurrido entre su creaci√≥n y la llamada a la funci√≥n. Luego, utilice dos cron√≥metros en paralelo para evaluar el siguiente c√≥digo:\ncronometro1 = crear_cronometro()\n\nfor i in range(10**4):\n    i ** 2 # Calcula el cuadrado de un n√∫mero pero no lo devuelve\n\nprint(f\"El bloque entero tard√≥ {cronometro1()} segundos en ejecutarse.\")\n\ncronometro2 = crear_cronometro()\n\nfor j in range(10**6):\n    j // 2 # Calcula la divisi√≥n entera por 2 pero no la devuelve\n\nprint(f\"El segundo bucle tard√≥ {cronometro2()} segundos en ejecutarse.\")\n\nPunto extra\nModifique el funcionamiento del cron√≥metro para que en cada llamada devuelva el tiempo transcurrido entre la llamada actual y la inmediata anterior (excepto en la primera llamada, que devuelve el tiempo transcurrido desde su creaci√≥n).\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara medir el paso del tiempo en Python podemos usar la funci√≥n time del m√≥dulo hom√≥nimo.\nfrom time import time, sleep\n\ninicio = time()\nsleep(2) # Detiene la ejecuci√≥n por 2 segundos\nprint(time() - inicio) # ~ 2 (segundos)",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#sucesi√≥n-de-fibonacci",
    "href": "practica/02_programacion_funcional/ejercicios.html#sucesi√≥n-de-fibonacci",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "8 Sucesi√≥n de Fibonacci",
    "text": "8 Sucesi√≥n de Fibonacci\nConsidere la sucesi√≥n que comienza por los n√∫meros 0 y 1. Los siguientes n√∫meros se forman sumando los dos anteriores.\n\\[\n\\{\\;0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, \\cdots\\;\\}\n\\]\nEsta sucesi√≥n se conoce como sucesi√≥n de Fibonacci.\nImplemente una funci√≥n recursiva que tome un n√∫mero natural n como entrada y devuelva el n-√©simo n√∫mero en la sucesi√≥n.",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#subiendo-de-rango",
    "href": "practica/02_programacion_funcional/ejercicios.html#subiendo-de-rango",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "9 Subiendo de rango",
    "text": "9 Subiendo de rango\nLa funci√≥n range(start, stop, step) de Python devuelve un objeto que genera una secuencia de n√∫meros desde start (inclusive) hasta stop (exclusive) en incrementos de step unidades. El argumento step, sin embargo, s√≥lo puede ser un n√∫mero entero (excepto cero). Implemente una funci√≥n llamada frange que acepte los mismos argumentos, pudiendo step ser de tipo float. La funci√≥n debe retornar un generador de la secuencia correspondiente.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nUtilice el siguiente ejemplo a modo de control:\nfor i in frange(3, 4, 0.2):\n    print(f\"{i:.2f}\")\n3.00\n3.20\n3.40\n3.60\n3.80\nTenga en cuenta que la precisi√≥n finita de las computadoras puede afectar el comportamiento de su generador.",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#la-cajita-musical",
    "href": "practica/02_programacion_funcional/ejercicios.html#la-cajita-musical",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "10 La cajita musical",
    "text": "10 La cajita musical\nTenemos una caja musical que recita los siguientes versos:\nversos = [\n    \"Tengo que confesar que a veces no me gusta tu forma de ser\",\n    \"Luego te me desapareces y no entiendo muy bien por qu√©\",\n\n    \"No dices nada rom√°ntico cuando llega el atardecer\",\n    \"Te pones de un humor extra√±o con cada luna llena al mes\",\n\n    \"Pero a todo lo dem√°s le gana lo bueno que me das\",\n    \"S√≥lo tenerte cerca, siento que vuelvo a empezar\"\n]\nImplemente una funci√≥n para darle cuerda a la caja musical. En cada llamada debe devolver un verso distinto, hasta agotarlos todos.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nMediante el uso de yield se puede lograr que una funci√≥n se detenga en un punto intermedio y retome desde ese punto en la siguiente llamada.\ndef mostrar_fase():\n    print(\"Inicio\")\n    yield\n    print(\"Medio\")\n    yield\n    print(\"Desenlace\")\n    yield",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#el-mejor-precio",
    "href": "practica/02_programacion_funcional/ejercicios.html#el-mejor-precio",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "11 El mejor precio",
    "text": "11 El mejor precio\nUn supermercado ofrece m√∫ltiples promociones:\n\n15% de descuento los d√≠as lunes y mi√©rcoles.\n10% de descuento en compras con monto superior a $50.000.\n20% de descuento a clientes mayores de 65 a√±os.\n\nPara determinar la promoci√≥n a aplicar, el supermercado utiliza un programa con la siguiente estructura:\ndef promo_dia_semana(compra):\n    \"\"\"Aplica un 15% de descuento si la compra se realiza un lunes o mi√©rcoles.\"\"\"\n    return None # hay que implementar esta funci√≥n\n\ndef promo_monto_grande(compra):\n    \"\"\"Aplica un 10% de descuento si la compra tiene un monto superior a $50.000.\"\"\"\n    return None # hay que implementar esta funci√≥n\n\ndef promo_edad(compra):\n    \"\"\"Aplica un 20% de descuento si el cliente tiene 65 a√±os o m√°s.\"\"\"\n    return None # hay que implementar esta funci√≥n\n\npromos = [promo_dia_semana, promo_monto_grande, promo_edad]\n\ndef mejor_promo(compra):\n    \"\"\"Construye diccionario con el monto luego de aplicar la mejor promoci√≥n.\n\n    Esta funci√≥n devuelve un diccionario con el monto original, el monto final, y el descuento\n    aplicado.\n    \"\"\"\n    # Obtener el multiplicador del mayor descuento\n    multiplicador = sorted([promo(compra) for promo in promos])[0]\n\n    return {\n        \"monto_original\": compra[\"monto\"],\n        \"monto_final\": compra[\"monto\"] * multiplicador,\n        \"descuento\": f\"{round((1 - multiplicador) * 100)}%\"\n    }\n\nejemplo_compra = {\"dia\": \"mi√©rcoles\", \"edad_cliente\": 42, \"monto\": 66420}\nmejor_promo(ejemplo_compra)\n# {'monto_original': 66420, 'monto_final': 56457.0, 'descuento': '15%'}\nEl problema con esta implementaci√≥n es que, cada vez que se a√±ade o elimina una promoci√≥n, el cambio debe llevarse a cabo tanto en la funci√≥n de la promoci√≥n como en la lista de promociones. Para evitar el trabajo duplicado, implemente los siguientes cambios:\n\nDefina primero la lista promos, la cual comienza estando vac√≠a.\nDefina un decorador promo que a√±ade una funci√≥n a la lista promos antes de ejecutarla.\nImplemente las tres funciones de promoci√≥n y dec√≥relas con el decorador del paso anterior.",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#bromas-pesadas",
    "href": "practica/02_programacion_funcional/ejercicios.html#bromas-pesadas",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "12 Bromas pesadas üò±",
    "text": "12 Bromas pesadas üò±\nNuestro amigo programador est√° armando una p√°gina web, con una funci√≥n que saluda a los nuevos usuarios por su nombre cuando se registran. Nosotros queremos gastarle una broma a nuestro amigo, metiendo en su c√≥digo un decorador que haga que su funci√≥n corra normalmente excepto cada n-√©sima corrida, fallando silenciosamente (no imprime nada). El valor n es un n√∫mero entero de nuestra elecci√≥n.\n@romper_cada(3)\ndef saludar(nombre):\n  print(f\"¬°Hola, {nombre}!\")\n\nsaludar(\"Carlos\")     # \"¬°Hola, Carlos!\"\nsaludar(\"Mar√≠a Luz\")  # \"¬°Hola, Mar√≠a Luz!\"\nsaludar(\"Mirna\")      # Nada (la funci√≥n devuelve None)\nsaludar(\"Diego\")      # \"¬°Hola, Diego!\"\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara crear un decorador que reciba argumentos, podemos crear una f√°brica de decoradores:\ndef mi_decorador(n):\n    def decorar(funcion):\n        print(f\"Ejecutando decorador con argumento {n}\")\n        return funcion\n    return decorar\n\n@mi_decorador(7)\ndef imprimir(mensaje):\n    print(mensaje)\n\nimprimir(\"Hola mundo\")\n# &gt; Ejecutando decorador con argumento 7\n# &gt; Hola mundo",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#pipelines-de-procesamiento",
    "href": "practica/02_programacion_funcional/ejercicios.html#pipelines-de-procesamiento",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "13 Pipelines de procesamiento üò±",
    "text": "13 Pipelines de procesamiento üò±\nEste ejercicio tiene como objetivo implementar un sistema de preprocesamiento para una lista de diccionarios, donde cada diccionario representa una fila con sus columnas como pares clave‚Äìvalor. Un conjunto de datos de ejemplo es el siguiente:\ndatos = [\n    {\"edad\": 20, \"ingresos\": 2000},\n    {\"edad\": 30, \"ingresos\": 3000},\n    {\"edad\": None, \"ingresos\": 2500},\n    {\"edad\": 40, \"ingresos\": None},\n    {\"edad\": 25, \"ingresos\": 4000},\n]\nEl primer paso consiste en definir tres funciones:\n\neliminar_nulos: elimina las filas con al menos un valor None.\ncalcular_log: que calcula el logaritmo en base 10 para los valores de la variable indicada.\nfiltrar: recibe el listado, el nombre de una columna y una funci√≥n booleana que se aplica para determinar que registros se conservan.\n\nQue deben funcionar como se muestra en los ejemplos:\neliminar_nulos(datos)\n[\n    {\"edad\": 20, \"ingresos\": 2000},\n    {\"edad\": 30, \"ingresos\": 3000},\n    {\"edad\": 25, \"ingresos\": 4000},\n]\ncalcular_log(datos, \"ingresos\")\n[\n    {\"edad\": 20, \"ingresos\": 3.301},\n    {\"edad\": 30, \"ingresos\": 3.477},\n    {\"edad\": None, \"ingresos\": 3.397},\n    {\"edad\": 40, \"ingresos\": None},\n    {\"edad\": 25, \"ingresos\": 3.602},\n]\nfiltrar(datos, \"edad\", lambda e: e &gt; 25)\n[\n    {\"edad\": 30, \"ingresos\": 3000},\n    {\"edad\": 40, \"ingresos\": None},\n]\nEn el segundo paso, se debe implementar una funci√≥n crear_pipeline, que recibe una cantidad arbitraria de funciones de procesamiento, junto a sus argumentos, y debe devolver una funci√≥n que, al pasarle un listado de datos, los aplica de manera secuencial y devuelve un conjunto de datos procesado. Por ejemplo:\npipeline = crear_pipeline(\n    {\"fun\": eliminar_nulos, \"kwargs\": {}},\n    {\"fun\": calcular_log, \"kwargs\": {\"var_name\": \"ingresos\"}},\n    {\"fun\": filtrar, \"kwargs\": {\"var_name\": edad, \"key\": lambda e: e &gt; 25}}\n)\npipeline(datos)\n[{\"edad\": 30, \"ingresos\": 3.477}]",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#espacio-o-tiempo",
    "href": "practica/02_programacion_funcional/ejercicios.html#espacio-o-tiempo",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "14 ¬øEspacio o tiempo? ‚è≥",
    "text": "14 ¬øEspacio o tiempo? ‚è≥\nSuponga que trabaja en el equipo de an√°lisis de datos de un e-commerce y suponga que recibe un listado ventas del √∫ltimo mes. Deber√° extraer informaci√≥n clave de esos datos utilizando dos maneras distintas de resolver cada tarea.\n1. Preparaci√≥n de los datos\nPara empezar, use la siguiente funci√≥n que genera datos de ejemplo de ventas de distinto tama√±o:\nimport random\n\nCATEGORIAS = (\"electr√≥nica\", \"hogar\", \"accesorios\", \"deportes\")\n\ndef generar_ventas(n=100_000, seed=None):\n    \"\"\"Generar datos de ventas.\n\n    Parameters\n    ----------\n    n : int\n        Cantidad de ventas a simular.\n    seed : int, optional\n        Semilla para el generador de n√∫meros aleatorios. Por defecto, `None`.\n\n    Returns\n    -------\n    list[dict]\n        Listado de ventas.\n        Cada venta es un diccionario con claves `\"id\"`, `\"precio\"` y `\"categoria\"`.\n    \"\"\"\n    rng = random.Random(seed)\n    ventas = []\n    for i in range(1, n + 1):\n        ventas.append(\n            {\n                \"id\": f\"P{i+1:06d}\",\n                \"precio\": round(rng.uniform(5.0, 500.0), 2),\n                \"categoria\": CATEGORIAS[i % len(CATEGORIAS)],\n            }\n        )\n    return ventas\nGenere un conjunto de datos con 100,000 ventas:\nventas = generar_ventas(n=100_000, seed=1234)\n2. Implementaci√≥n de operaciones\nRealice dos operaciones sobre este conjunto de datos, cada una en dos variantes.\n\nCalcular precios con IVA (21%):\n\nVersi√≥n A. Use una list comprehension para crear una nueva lista llamada precios_con_iva_1 que contenga todos los precios con el 21 % de IVA ya calculado.\nVersi√≥n B. Use una expresi√≥n generadora para crear un objeto precios_con_iva_2 que represente la operaci√≥n, pero sin calcular ni almacenar los resultados todav√≠a.\n\nFiltrar ventas de ‚Äúelectr√≥nica‚Äù:\n\nVersi√≥n A. Use una list comprehension para crear una nueva lista llamada electronica_1 que contenga todas las ventas de la categor√≠a ‚Äúelectr√≥nica‚Äù.\nVersi√≥n B. Use una expresi√≥n generadora para crear un objeto electronica_2 que represente el filtro, sin materializar la lista.\n\n\n3. An√°lisis y comparaci√≥n\n\nCalcule el total de las ventas de electr√≥nica usando sum() en ambas variantes (electronica_1 y electronica_2).\nPara cada operaci√≥n, antes y despu√©s de aplicar sum(), mida el tiempo de ejecuci√≥n y el uso de memoria del objeto. Para el tiempo, podr√≠a usar time.time() del m√≥dulo time; para la memoria, sys.getsizeof() del m√≥dulo sys. Registre los resultados (si no observa diferencias claras, duplique n al generar el dataset).\n\n4. Reutilizaci√≥n del objeto\n\nIntente calcular el total de ventas de electr√≥nica una segunda vez para ambos objetos (electronica_1 y electronica_2).\nObserve qu√© sucede en cada caso. ¬øQu√© objeto puede volver a usarse y cu√°l no?\n\n5. Preguntas para reflexi√≥n\n\n¬øQu√© diferencias fundamentales encontr√≥ entre las dos maneras de procesar los datos? Considere cu√°ndo se realiza la operaci√≥n, el uso de memoria y el tiempo de ejecuci√≥n.\n¬øQu√© ocurri√≥ cuando intent√≥ recorrer o usar el mismo resultado dos veces?\n¬øSe comportaron de la misma manera la lista generada y el objeto generador? ¬øPor qu√© cree que sucede esto?\n¬øEn qu√© situaciones elegir√≠a un enfoque u otro? D√© un ejemplo de un escenario donde la ejecuci√≥n A sea mejor y otro donde la B resulte m√°s eficiente.",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html",
    "href": "practica/01_programacion_en_python/ejercicios.html",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "",
    "text": "Escriba una funci√≥n en Python que reciba el radio de un c√≠rculo y devuelva su √°rea. Luego, escriba otra funci√≥n que tambi√©n reciba el radio de un c√≠rculo, pero devuelva su per√≠metro. Finalmente, escriba una tercera funci√≥n que reciba el radio de un c√≠rculo y devuelva tanto el √°rea como el per√≠metro.\nUna vez que haya implementado todas las funciones, analice la diferencia entre:\narea, perimetro = calcular_area_y_perimetro(radio=5)\ny\nresultados = calcular_area_y_perimetro(radio=5)\nConsidere el tipo de las variables area, perimetro y resultados.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\n\\[\n\\begin{aligned}\nA &= \\pi \\cdot r^2 \\\\\nP &= 2 \\cdot \\pi \\cdot r\n\\end{aligned}\n\\]",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#√°rea-y-per√≠metro-de-un-c√≠rculo",
    "href": "practica/01_programacion_en_python/ejercicios.html#√°rea-y-per√≠metro-de-un-c√≠rculo",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "",
    "text": "Escriba una funci√≥n en Python que reciba el radio de un c√≠rculo y devuelva su √°rea. Luego, escriba otra funci√≥n que tambi√©n reciba el radio de un c√≠rculo, pero devuelva su per√≠metro. Finalmente, escriba una tercera funci√≥n que reciba el radio de un c√≠rculo y devuelva tanto el √°rea como el per√≠metro.\nUna vez que haya implementado todas las funciones, analice la diferencia entre:\narea, perimetro = calcular_area_y_perimetro(radio=5)\ny\nresultados = calcular_area_y_perimetro(radio=5)\nConsidere el tipo de las variables area, perimetro y resultados.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\n\\[\n\\begin{aligned}\nA &= \\pi \\cdot r^2 \\\\\nP &= 2 \\cdot \\pi \\cdot r\n\\end{aligned}\n\\]",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#promociones",
    "href": "practica/01_programacion_en_python/ejercicios.html#promociones",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "2 Promociones",
    "text": "2 Promociones\nEscriba una funci√≥n llamada calcular_precio que reciba dos argumentos: el monto total de una compra y el medio de pago utilizado.\nEl medio de pago puede ser \"efectivo\", \"d√©bito\" o \"cr√©dito\", y seg√∫n el caso se aplicar√° una modificaci√≥n sobre el monto:\n\nSi el medio de pago es \"efectivo\", el monto no se modifica.\nSi es \"d√©bito\", se aplica un descuento del 10% sobre el monto.\nSi es \"cr√©dito\", se aplica un recargo del 5% sobre el monto.\n\nLa funci√≥n debe retornar el monto final a pagar, con el descuento o recargo aplicado seg√∫n corresponda.\n\nPunto extra\nModifique la funci√≥n de modo tal que no sea necesario especificar el medio de pago. En tal caso, el medio de pago se asume \"efectivo\". Ayuda: asigne un valor por defecto al argumento medio. Considere una implementaci√≥n donde este sea \"efectivo\" y otra donde sea None.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#etapas-de-la-vida",
    "href": "practica/01_programacion_en_python/ejercicios.html#etapas-de-la-vida",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "3 Etapas de la vida",
    "text": "3 Etapas de la vida\nImplemente una funci√≥n que reciba una edad y devuelva un mensaje que indique la etapa de la vida correspondiente.\nUtilice una cadena de condicionales if-elif-else para clasificar la edad en alguno de los siguientes grupos:\n\nMenor a 2 a√±os: beb√©.\nEntre 2 (inclusive) y 4 a√±os: infante.\nEntre 4 (inclusive) y 13 a√±os: ni√±o/a.\nEntre 13 (inclusive) y 20 a√±os: adolescente.\nEntre 20 (inclusive) y 65 a√±os: adulto/a.\n65 a√±os o m√°s: persona mayor.\n\nLa funci√≥n debe imprimir un mensaje del tipo: \"La persona es un/a &lt;etapa&gt;\".",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres",
    "href": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "4 Conteo de caracteres",
    "text": "4 Conteo de caracteres\nEscriba una funci√≥n que reciba una cadena de texto y devuelva un diccionario que indique cu√°ntas veces aparece cada caracter en la cadena. La funci√≥n no debe diferenciar entre may√∫sculas y min√∫sculas y debe ignorar espacios. Utilice el siguiente ejemplo como validaci√≥n:\ncontar_caracteres(\"Ahora es mejor que nunca\")\n# {\"a\": 3, \"h\": 1, \"o\": 2, \"r\": 2, \"e\": 3, \"s\": 1, \"m\": 1, \"j\": 1, \"q\": 1, \"u\": 2, \"n\": 2, \"c\": 1}\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara saltear pasos de un bucle cuando se encuentra un espacio se puede utilizar la sentencia continue.\nfor i in ...:\n    # ... &lt;- Se ejecuta en todas las iteraciones\n    if condicion_de_salto:\n        continue\n    # ... &lt;- Se ejecuta en las iteraciones 'condicion_de_salto' es False",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#orden-de-m√©rito",
    "href": "practica/01_programacion_en_python/ejercicios.html#orden-de-m√©rito",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "5 Orden de m√©rito",
    "text": "5 Orden de m√©rito\nSe cuenta con una lista de tuplas que contienen las notas del examen final de Programaci√≥n 2 para un conjunto de alumnos:\nnotas = [\n    (\"Escalada\", 9),\n    (\"Alonso\", 7),\n    (\"P√©rez\", 8),\n    (\"Castro\", 8),\n    (\"Rossini\", 10),\n    (\"Mart√≠nez\", 9),\n    (\"P√©rez\", 6),\n    (\"Riquelme\", 5),\n]\n\nEscriba un programa que a partir de notas genere un diccionario donde las claves se corresponden con los apellidos y los valores con las notas del examen final.\nEscriba un programa que a partir de notas genere un diccionario donde las claves son las notas y el valor asociado sea una lista con los apellidos de quienes tuvieron esa nota.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#rendimento-acad√©mico",
    "href": "practica/01_programacion_en_python/ejercicios.html#rendimento-acad√©mico",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "6 Rendimento acad√©mico",
    "text": "6 Rendimento acad√©mico\nSe cuenta con el siguiente diccionario que asocia nombres de estudiantes con una lista de sus calificaciones:\nnotas = {\n    \"Ana\": [8, 9, 10],\n    \"Luis\": [6, 7, 8, 3, 9],\n    \"Carla\": [10, 9, 10],\n    \"Marcos\": [5, 6],\n    \"Sof√≠a\": [7, 7, 8],\n    \"Pedro\": [6, 4, 5, 6, 3, 8],\n    \"Luc√≠a\": [9, 8, 10, 9]\n}\nImplemente una funci√≥n que resuma el rendimiento acad√©mico de los estudiantes. La funci√≥n debe recibir el diccionario de notas y un argumento adicional llamado modo. Seg√∫n el valor de modo, se debe devolver un nuevo diccionario con la siguiente informaci√≥n:\n\nSi modo es \"promedio\", se debe devolver el promedio de notas por estudiante.\nSi modo es \"proporcion\", se debe devolver la proporci√≥n de ex√°menes aprobados por estudiante (se considera aprobado todo valor mayor o igual a 6).",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#√≠ndice-de-precios",
    "href": "practica/01_programacion_en_python/ejercicios.html#√≠ndice-de-precios",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "7 √çndice de precios",
    "text": "7 √çndice de precios\nSe cuenta con la serie mensual del √çndice de Precios al Consumidor (IPC) del a√±o 2024:\nipc_2024 = [20.6, 13.2, 11.0, 8.8, 4.2, 4.6, 4.0, 4.2, 3.5, 2.7, 2.4, 2.7]\nRealice los siguientes c√°lculos y an√°lisis:\n\nDetermine el menor y el mayor √≠ndice reportado durante el a√±o.\nCalcule el IPC promedio mensual del 2024.\nEncuentre la diferencia entre el IPC m√≠nimo y m√°ximo del a√±o.\n\n¬øEn qu√© mes se registr√≥ la inflaci√≥n m√°s alta?\n\nCalcule la inflaci√≥n mediana del 2024.\n¬øC√≥mo podr√≠a calcular el rango del IPC (diferencia entre el valor m√°ximo y m√≠nimo) sin usar las funciones min() ni max()?",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#res√∫menes-estad√≠sticos",
    "href": "practica/01_programacion_en_python/ejercicios.html#res√∫menes-estad√≠sticos",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "8 Res√∫menes estad√≠sticos",
    "text": "8 Res√∫menes estad√≠sticos\nCree funciones que, dada una lista de n√∫meros, calculen los siguientes res√∫menes estad√≠sticos:\n\nLa media \\[\n\\text{media}(X) = \\frac{1}{n}\\sum_{i=1}^n{x_i}\n\\]\nEl rango \\[\n\\text{rango}(X) = \\text{max}(X) - \\text{min}(X)\n\\]\nLa varianza \\[\n\\text{var}(X) = \\frac{1}{n}\\sum_{i=1}^n{(x_i - \\bar{x})^2}\n\\]\nEl desv√≠o est√°ndar \\[\n\\text{sd}(X) = \\sqrt{\\text{var}(X)}\n\\]\nLa mediana \\[\n\\begin{array}{lr}\n\\text{mediana}(X) = x_{(\\frac{n + 1}{2})} & \\text{Si } n \\text{ es impar} \\\\\n\\text{mediana}(X) = \\frac{x_{(\\frac{n}{2})} + x_{(\\frac{n}{2}+1)}}{2} & \\text{Si } n \\text{ es par}\n\\end{array}\n\\]\ndonde los \\(x_{(i)}\\) est√°n ordenados de manera ascendente.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#validaci√≥n-de-dni",
    "href": "practica/01_programacion_en_python/ejercicios.html#validaci√≥n-de-dni",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "9 Validaci√≥n de DNI",
    "text": "9 Validaci√≥n de DNI\nCrear una funci√≥n que dada una cadena de caracteres verifique si se corresponde con un DNI.\nSi es un DNI, devolver True. Caso contrario, devolver False.\nA tener en cuenta:\n\nAlgunos ejemplos de DNI v√°lidos\n\n40.094.127\n19053512\n6.392.780\n\nDNI no v√°lidos\n\n40,094,127\n19-053-512\n123456",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#la-f√≠sica-del-rebote",
    "href": "practica/01_programacion_en_python/ejercicios.html#la-f√≠sica-del-rebote",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "10 La f√≠sica del rebote",
    "text": "10 La f√≠sica del rebote\nUna pelota de goma es lanzada desde una altura inicial de 100 metros. Cada vez que toca el suelo, rebota alcanzando una altura equivalente a 3/5 de la altura desde la que cay√≥.\nEscriba un programa que imprima una tabla mostrando las alturas alcanzadas por la pelota en cada uno de sus primeros 10 rebotes.\nLuego, implemente este programa como una funci√≥n que reciba dos par√°metros:\n\nAltura inicial desde la que se lanza la pelota.\nCantidad de rebotes que se desea calcular.\n\nLa funci√≥n debe devolver una lista con las alturas alcanzadas en cada rebote.\n\nPunto extra\nModifique la funci√≥n para que considere un rebote como ‚Äúsignificativo‚Äù solo si la altura alcanzada es mayor o igual a un valor m√≠nimo especificado (por ejemplo, 1 cent√≠metro).\nSi la pelota no alcanza esta altura m√≠nima en alg√∫n rebote, se considera que ha completado su trayectoria y queda quieta. En este caso, la funci√≥n debe devolver √∫nicamente los valores correspondientes a los ‚Äúrebotes significativos‚Äù.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#un-mont√≥n-de-plata",
    "href": "practica/01_programacion_en_python/ejercicios.html#un-mont√≥n-de-plata",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "11 Un mont√≥n de plata",
    "text": "11 Un mont√≥n de plata\nUna ma√±ana pon√©s un billete en la vereda al lado del Monumento a la Bandera. A partir de ah√≠, cada d√≠a vas y duplic√°s la cantidad de billetes, apil√°ndolos prolijamente. ¬øCu√°nto tiempo pasa antes de que la pila de billetes sea m√°s alta que la del Monumento?\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nAlgunas constantes √∫tiles para resolver el problema:\nbillete_grosor = 0.11 * 0.001  # grosor de un billete en metros\naltura_monumento = 70          # altura en metros\nSugerencia: Usar un bucle while para realizar el c√°lculo.\n\n\n\n\nPunto extra\nEscribe una funci√≥n que permita determinar la cantidad de d√≠as necesarios para superar cualquier altura arbitraria.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#la-conjetura-de-collatz",
    "href": "practica/01_programacion_en_python/ejercicios.html#la-conjetura-de-collatz",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "12 La conjetura de Collatz",
    "text": "12 La conjetura de Collatz\nLa conjetura de Collatz dice:\n\nSi tomamos un n√∫mero natural cualquiera, su secuencia de Collatz termina llegando siempre al n√∫mero 1.\n\nSecuencia de Collatz:\n\nSi el n√∫mero es par, se divide entre 2.\nSi el n√∫mero es impar, se multiplica por 3 y se le suma 1.\n\n\\[\nf(n) =\n\\begin{cases}\n    \\displaystyle \\frac{n}{2} & \\text{si } n \\text{ es par,} \\\\ \\\\\n    3n + 1 & \\text{si } n \\text{ es impar.}\n\\end{cases}\n\\]\nEscribir una funci√≥n que calcule la secuencia de Collatz para un n√∫mero natural cualquiera.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\n\nUtilizar bucle while.\nEl bucle debe correr solo cuando el valor de la secuencia sigue siendo mayor a 1. Si es 1, hay que frenar.\nInsertar los elementos de la secuencia en una lista.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#adivina-el-n√∫mero",
    "href": "practica/01_programacion_en_python/ejercicios.html#adivina-el-n√∫mero",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "13 Adivina el n√∫mero",
    "text": "13 Adivina el n√∫mero\nEscriba un programa que implemente el cl√°sico juego ‚ÄúAdivina el n√∫mero‚Äù. El programa debe:\n\nTener un n√∫mero secreto (entero) que el usuario debe adivinar.\nSolicitar al usuario que ingrese un n√∫mero.\nSi el n√∫mero ingresado no coincide con el n√∫mero secreto:\n\nInformar si el n√∫mero ingresado es mayor o menor que el n√∫mero secreto.\nPedir al usuario que intente nuevamente.\n\nSi el usuario adivina el n√∫mero, el programa debe terminar mostrando un mensaje de felicitaciones.\n\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara generar n√∫meros aleatorios enteros en un rango dado puede utilizar randint() del m√≥dulo random:\nimport random\nrandom.randint(-100,¬†100)     # Genera un n√∫mero aleatorio entre -100 y 100\n\n\n\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nEl programa que resuelve este problema realiza una cantidad de iteraciones que se desconoce al momento de escribirlo. La soluci√≥n t√≠pica a este tipo de problema involucra el uso de while True junto a la sentencia break.\nwhile True:\n    # realizar alguna accion\n    if condicion_de_salida:\n        break\n\n\n\n\nPunto extra\nImplemente una versi√≥n de este programa donde el usuario cuenta con 10 intentos.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres-pythonico",
    "href": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres-pythonico",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "14 Conteo de caracteres Pythonico",
    "text": "14 Conteo de caracteres Pythonico\nLos diccionarios en Python cuentan con un m√©todo .get() que devuelve el valor asociado a una clave. Este m√©todo permite pasarle un segundo argumento con un valor que se devuelve cuando no se encuentra un elemento asociado a la clave que le pasamos. Por ejemplo:\nd = {\"a\": 1, \"b\": 20}\nd.get(\"b\", 0)\n20\nd.get(\"c\", 0)\n0\nModifique la funci√≥n contar_caracteres del ejercicio Conteo de caracteres utilizando el metodo .get() para obtener una implementaci√≥n m√°s sencilla. As√≠, deber√≠a poder eliminar el bloque if.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#validador-de-contrase√±as",
    "href": "practica/01_programacion_en_python/ejercicios.html#validador-de-contrase√±as",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "15 Validador de contrase√±as üò±",
    "text": "15 Validador de contrase√±as üò±\nEscriba un programa que solicite al usuario una contrase√±a y verifique que cumpla con las siguientes condiciones:\n\nDebe tener entre de 8 y 24 caracteres.\nDebe incluir letras, n√∫meros y caracteres especiales (@#$%^&*()).\n\nSi la contrase√±a no es v√°lida, el programa debe informar al usuario qu√© condici√≥n no se cumple y permitirle ingresar una nueva contrase√±a. El proceso se repite hasta que el usuario ingrese una contrase√±a v√°lida o decida no continuar.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres-ii",
    "href": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres-ii",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "16 Conteo de caracteres II üò±",
    "text": "16 Conteo de caracteres II üò±\nAgregue a la funci√≥n contar_frecuencias del ejercicio Conteo de caracteres un argumento llamado orden que admita los valores \"aparicion\", \"alfabetico\" y \"frecuencia\".\nEste argumento debe permitir ordenar las claves del diccionario resultante seg√∫n el siguiente criterio:\n\n\"aparicion\": mantiene el orden en que las palabras aparecen por primera vez en la lista original.\n\"alfabetico\": ordena las palabras alfab√©ticamente.\n\"frecuencia\": ordena las palabras por su frecuencia, de mayor a menor.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html",
    "href": "practica/01_programacion_en_python/autoevaluacion.html",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "",
    "text": "¬øQu√© valor contiene la variable contador luego de ejecutar el siguiente c√≥digo?\ncontador = 20\ncontador + 1\nComplete la siguiente tabla indicando si el nombre es v√°lido para una variable de Python.\n\n\n\nNombre\n¬øV√°lido?\nJustificaci√≥n\n\n\n\n\nbalance\n\n\n\n\nbalanceActual\n\n\n\n\nbalance-actual\n\n\n\n\nbalance actual\n\n\n\n\nbalance_actual\n\n\n\n\nmis.datos\n\n\n\n\n0cuenta\n\n\n\n\ncuenta0\n\n\n\n\n_cuenta\n\n\n\n\nSPAM\n\n\n\n\ncantidad$",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#variables",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#variables",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "",
    "text": "¬øQu√© valor contiene la variable contador luego de ejecutar el siguiente c√≥digo?\ncontador = 20\ncontador + 1\nComplete la siguiente tabla indicando si el nombre es v√°lido para una variable de Python.\n\n\n\nNombre\n¬øV√°lido?\nJustificaci√≥n\n\n\n\n\nbalance\n\n\n\n\nbalanceActual\n\n\n\n\nbalance-actual\n\n\n\n\nbalance actual\n\n\n\n\nbalance_actual\n\n\n\n\nmis.datos\n\n\n\n\n0cuenta\n\n\n\n\ncuenta0\n\n\n\n\n_cuenta\n\n\n\n\nSPAM\n\n\n\n\ncantidad$",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#n√∫meros",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#n√∫meros",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "2 N√∫meros",
    "text": "2 N√∫meros\n\n¬øCu√°l es el tipo de 10 / 2? ¬øPor qu√©?\n¬øCu√°l es el tipo de 5 * 2? ¬øPor qu√©?\n¬øPor qu√© 5 == 5.0 es True?",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#booleanos",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#booleanos",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "3 Booleanos",
    "text": "3 Booleanos\n\n¬øCu√°l es el resultado de las siguientes expresiones? ¬øPor qu√©?\nFalse or not False\nnot (True and True)\nnot True and True\n\"True\" != True\n10 &gt; 5 + 3\nNone is None\nFalse is False\nEjecute l√≠nea por l√≠nea los siguientes bloques y analice los resultados.\nint(True) * 50\nTrue * 50\n1 is True\nbool(1) is True\nid(True)\nid(bool(1))\nid(bool(1024))\n¬øCu√°les son los 3 operadores booleanos?",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#cadenas-de-caracteres",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#cadenas-de-caracteres",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "4 Cadenas de caracteres",
    "text": "4 Cadenas de caracteres\n\n¬øPor qu√© la siguiente comparaci√≥n resulta en True?\n\"spam\" + \"spamspam\" == \"spam\" * 3\n¬øPor qu√© la siguiente expresi√≥n resulta en un error? ¬øC√≥mo se puede arreglar?\n\"Me com√≠ \" + 6 + \" panchos.\"\n¬øEncuentra algo extra√±o en la siguiente expresi√≥n? ¬øC√≥mo la mejorar√≠a?\nmateria = \"Programaci√≥n 2\"\nprint(\"¬°Sean bienvenidos a la materia {materia}!\")\nExplique por qu√© es redundante utilizar str() en el siguiente bloque de c√≥digo:\nx, y = 10, 20\nprint(f\"La suma de {str(x)} y {str(y)} es: {str(x + y)}.\")\nConsidere el siguiente bloque de c√≥digo:\nmensaje = \"Hola, ¬øc√≥mo estes?\"\nmensaje[-3] = \"√°\"\n\n¬øCu√°l es la intenci√≥n detr√°s del programa?\n¬øPor qu√© no funciona?\n¬øC√≥mo podr√≠a arreglarlo? Alerta: la soluci√≥n no es muy elegante.\n\n¬øCu√°l es el resultado de list(\"abcdefgh\")? ¬øPor qu√©?\n¬øPor qu√© set(\"abcde\") es distinto de {\"abcde\"}?",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#funciones",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#funciones",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "5 Funciones",
    "text": "5 Funciones\n\n¬øCu√°l es la diferencia entre una funci√≥n y una llamada a funci√≥n?\n¬øCu√°l es el valor que devuelve una funci√≥n que no tiene return?\n¬øCu√°ndo se ejecuta el c√≥digo dentro de una funci√≥n: cuando la funci√≥n se define o cuando se la llama? Considere la siguiente funci√≥n:\ndef suma(x, y):\n    print(100 / 0)\n    return x + y\nLuego, ejecute el siguiente bloque:\nsuma(2, 4)",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#listas",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#listas",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "6 Listas",
    "text": "6 Listas\n\n¬øQu√© es []? ¬øCu√°l es el resultado de len([])?\n¬øPor qu√© la siguiente expresi√≥n resulta en False? Ayuda: use la funci√≥n id().\n[] is []\n¬øPor qu√© se obtiene un error en el siguiente bloque de c√≥digo?\nl = []\nl[0]\nSi [0][0] devuelve 0, ¬øpor qu√© [1][1] no devuelve [1]?\n¬øCu√°l es el valor de x en el siguiente bloque de c√≥digo? ¬øPor qu√©?\nl = [\"hola\", \"hola hola\", \"hasta luego\"]\nx = l.remove(\"hola\")\n¬øC√≥mo le asignar√≠a el valor \"hola\" como el tercer valor en una lista almacenada en una variable llamada cosas? Asuma que cosas contiene [2, 4, 6, 8, 10].\nAsuma que letras contiene la lista [\"a\", \"b\", \"c\", \"d\"]:\n\n¬øA qu√© eval√∫a letras[-1]?\n¬øA qu√© eval√∫a letras[:2]?\n¬øA qu√© eval√∫a letras[int(int('3' * 2) // 11)]? ¬øEs necesario usar dos veces int()?\n\nAsuma que bartulos contiene la lista [3.14, \"casa\", 11, \"casa\", True]:\n\n¬øA qu√© eval√∫a bartulos.index(\"casa\")? ¬øPor qu√©?\n¬øC√≥mo queda la lista en bartulos despu√©s de ejecutar bartulos.append(99)?\n¬øC√≥mo queda la lista en bartulos despu√©s de ejecutar bartulos.remove(\"casa\"') ?¬øPor qu√©?\n\n¬øCu√°les son los operadores para la concatenaci√≥n y la replicaci√≥n de listas?\n¬øCu√°l es la diferencia entre los m√©todos append() e insert() de las listas?\n¬øCu√°les son dos formas de eliminar valores de una lista?\nEl siguiente bloque de c√≥digo imprime ['a', 'b', True, 30]. ¬øPor qu√©?\ncosas = [\"a\", \"b\", True]\nbartulos = cosas\nbartulos.append(20 + 10)\nprint(cosas)\nConsidere el siguiente bloque de c√≥digo:\nmarcas = [\"Milka\", \"Cofler\", \"√Åguila\", \"Cadbury\", \"Lindt\", \"Toblerone\", \"After Eight\"]\nmarcas[2:5]\nque correctamente muestra [\"√Åguila\", \"Cadbury\", \"Lindt\"]. ¬øPor qu√© el siguiente bloque de c√≥digo no funciona?\nmarcas = [\"Milka\", \"Cofler\", \"√Åguila\", \"Cadbury\", \"Lindt\", \"Toblerone\", \"After Eight\"]\nindices = 2:5\nmarcas[indices]",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#tuplas",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#tuplas",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "7 Tuplas",
    "text": "7 Tuplas\n\n¬øPor qu√© la tupla no implementa un m√©todo similar al m√©todo .extend() de las listas?\nLas tuplas de Python son conocidas por ser inmutables. Por ejemplo, el siguiente bloque de c√≥digo resulta en un error:\ntupla = (1, 2, 3)\ntupla[1] = 10\nSin embargo, el siguiente bloque no arroja ning√∫n error y pareciera que se logra modificar la tupla exitosamente:\nbartulos = [\"Hola\", 10, None]\ntupla = (1, bartulos, 3)\n\ntupla[1].append(\"¬°Sorpesa!\")\n\nprint(tupla)\n¬øQu√© pas√≥?",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#diccionarios",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#diccionarios",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "8 Diccionarios",
    "text": "8 Diccionarios\n\n¬øC√≥mo se escribe en c√≥digo un diccionario vac√≠o?\n¬øC√≥mo se ve un diccionario que tiene la clave \"cosa\" y el valor 15?\n¬øCu√°l es la principal diferencia entre un diccionario y una lista?\n¬øQu√© ocurre si se intenta acceder a bartulos[\"cosa\"] cuando bartulos es {\"coso\": 100}?\nSi un diccionario est√° almacenado en bartulos, ¬øcu√°l es la diferencia entre las siguientes expresiones?\n\"cosa\" in bartulos\n\"cosa\" in bartulos.keys()\nSuponga el diccionario datos = {\"nombre\": \"Juan\"}. ¬øPor qu√© la siguiente expresi√≥n resulta en False?\n\"Juan\" in datos",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#control-de-flujo",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#control-de-flujo",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "9 Control de flujo",
    "text": "9 Control de flujo\n\n9.1 Condicionales\n\nExplique qu√© es una condici√≥n y en qu√© situaciones se utilizar√≠a.\nIdentifique los tres bloques de c√≥digo en el siguiente ejemplo:\ncodigo = 0\n\nif codigo == 10:\n    print(\"mensaje 1\")\n    if codigo &gt; 5:\n        print(\"mensaje 2\")\n    else:\n        print(\"mensaje alternativo\")\n    print(\"mensaje final\")\n\nprint(\"Fin del programa\")\n¬øTienen sentido las comparaciones utilizadas?\n¬øCu√°l es el problema con el siguiente programa? Proponga una soluci√≥n.\nnumero = 10\nif numero &lt; 0:\n    print(f\"El numero {numero} es negativo\")\nelif numero &lt; -5:\n    print(f\"El numero {numero} es menor a -5\")\nelif numero &gt; 0:\n    print(f\"El numero {numero} es positivo\")\nelse:\n    print(f\"El numero {numero} es 0\")\n\n\n\n9.2 Bucles\n\nConsidere el siguiente programa:\nfor i in range(10):\n    print(i)\nEscriba un programa que realice la misma tarea utilizando un bucle while.\n¬øCu√°l es la diferencia entre range(10), range(0, 10) y range(0, 10, 1) en un bucle for?\nSuponga que numeros es una lista que contiene numeros enteros, ¬øen qu√© se diferencian los siguientes bloques de c√≥digo?\nfor i in numeros:\n    if i % 2 == 0:\n        break\n    print(i)\nfor i in numeros:\n    if i % 2 == 0:\n        continue\n    print(i)\n¬øEs posible re-escribir el siguiente bloque de c√≥digo usando while True? ¬øQu√© modificaciones habr√≠a que hacer?\nsuma = 0\ni = 0\nwhile suma &lt;= limite:\n    suma += numeros[i]\n    i += 1",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  }
]