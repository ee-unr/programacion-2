[
  {
    "objectID": "informacion/programa.html",
    "href": "informacion/programa.html",
    "title": "Programa",
    "section": "",
    "text": "Los profesionales en Estadística y Ciencia de Datos necesitan contar con habilidades avanzadas de programación, que les permitan abordar problemas complejos y desarrollar soluciones eficientes y robustas.\nLa asignatura Programación 2 introduce a los estudiantes a conceptos y prácticas avanzadas de la programación, incorporando herramientas y paradigmas que resultan fundamentales para el desarrollo profesional en Estadística y Ciencia de Datos.\nLa asignatura profundiza en enfoques como la programación funcional y la programación orientada a objetos, promoviendo el desarrollo de soluciones estructuradas, reutilizables, robustas y escalables. Además, se abordan conceptos fundamentales de estructuras de datos y algoritmos, relevantes para el diseño y análisis de programas eficientes, así como para la comprensión de la complejidad computacional. Se focaliza en el lenguaje Python, ampliamente utilizado en la industria y la academia por su versatilidad, su ecosistema de librerías y su capacidad para integrarse con diversas tecnologías.\nDictada en el segundo cuatrimestre del primer año, Programación 2 completa los contenidos del área de Fundamentos Computacionales en el Ciclo de Formación Técnica en Estadística y Ciencia de Datos, iniciada en el primer cuatrimestre con Programación 1. De este modo, consolida las competencias informáticas de los estudiantes y los prepara para afrontar asignaturas más avanzadas y desafíos profesionales que requieren un dominio sólido de la programación. Asimismo, fomenta buenas prácticas de desarrollo de código, el uso eficiente de los recursos computacionales y el pensamiento crítico en la resolución de problemas.",
    "crumbs": [
      "Información",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/programa.html#fundamentación",
    "href": "informacion/programa.html#fundamentación",
    "title": "Programa",
    "section": "",
    "text": "Los profesionales en Estadística y Ciencia de Datos necesitan contar con habilidades avanzadas de programación, que les permitan abordar problemas complejos y desarrollar soluciones eficientes y robustas.\nLa asignatura Programación 2 introduce a los estudiantes a conceptos y prácticas avanzadas de la programación, incorporando herramientas y paradigmas que resultan fundamentales para el desarrollo profesional en Estadística y Ciencia de Datos.\nLa asignatura profundiza en enfoques como la programación funcional y la programación orientada a objetos, promoviendo el desarrollo de soluciones estructuradas, reutilizables, robustas y escalables. Además, se abordan conceptos fundamentales de estructuras de datos y algoritmos, relevantes para el diseño y análisis de programas eficientes, así como para la comprensión de la complejidad computacional. Se focaliza en el lenguaje Python, ampliamente utilizado en la industria y la academia por su versatilidad, su ecosistema de librerías y su capacidad para integrarse con diversas tecnologías.\nDictada en el segundo cuatrimestre del primer año, Programación 2 completa los contenidos del área de Fundamentos Computacionales en el Ciclo de Formación Técnica en Estadística y Ciencia de Datos, iniciada en el primer cuatrimestre con Programación 1. De este modo, consolida las competencias informáticas de los estudiantes y los prepara para afrontar asignaturas más avanzadas y desafíos profesionales que requieren un dominio sólido de la programación. Asimismo, fomenta buenas prácticas de desarrollo de código, el uso eficiente de los recursos computacionales y el pensamiento crítico en la resolución de problemas.",
    "crumbs": [
      "Información",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/programa.html#objetivos",
    "href": "informacion/programa.html#objetivos",
    "title": "Programa",
    "section": "Objetivos",
    "text": "Objetivos\nQue los estudiantes logren:\n\nanalizar problemas computacionales y formular soluciones algorítmicas adecuadas;\nimplementar esas soluciones mediante el desarrollo de programas en Python, seleccionando estructuras de datos apropiadas y evaluando la eficiencia de los algoritmos involucrados;\nidentificar y aplicar los paradigmas funcional y orientado a objetos cuando resulte pertinente, desarrollando programas que integren estos enfoques; y\nutilizar e integrar módulos y librerías que permitan extender, organizar y mejorar las funcionalidades de sus programas.",
    "crumbs": [
      "Información",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/programa.html#contenidos",
    "href": "informacion/programa.html#contenidos",
    "title": "Programa",
    "section": "Contenidos",
    "text": "Contenidos\n\nUnidad 1: Introducción a Python\n\nLenguaje Python y su ecosistema. Uso de la interfaz Positron. Sintaxis de Python. Expresiones. Variables y asignaciones. Tipos de datos elementales. Operadores numéricos, de comparación y lógicos. Funciones. Ejecución condicional de código. Bucles definidos y no definidos. Listas, tuplas y diccionarios. Uso de código externo. Módulos y librerías. Librería estándar de Python. Instalación y gestión de librerías. Scripting. Lectura y escritura de archivos de texto plano. Modularización de programas.\n\nUnidad 2: Programación funcional\n\nPrincipios fundamentales. Funciones como ciudadanos de primera clase. Funciones puras. Funciones anónimas. Closures. Recursión. Funciones de orden superior: map, filter, reduce. Evaluación estricta y no estricta. Evaluación perezosa (lazy) e inmediata (eager). Generadores. Aplicación parcial de funciones. Decoradores.\n\nUnidad 3: Programación orientada a objetos\n\nPrincipios fundamentales. Objetos, clases e instancias. Atributos y métodos. Propiedades públicas y privadas. Métodos de clase y métodos de instancia. Encapsulamiento. Herencia simple y múltiple. Polimorfismo. Métodos especiales (dunder methods). Decoradores aplicados a métodos. Sobrecarga de operadores.\n\nUnidad 4: Estructuras de datos\n\nConcepto y clasificación. Estructuras lineales: listas, listas enlazadas, pilas y colas. Operaciones básicas: agregar, quitar y recorrer. Estructuras no lineales: árboles y grafos. Recorridos de árboles y grafos. Uso de colecciones de Python (list, deque, dict, set). Arreglos multidimensionales de NumPy.\n\nUnidad 5: Algoritmos de búsqueda y ordenamiento\n\nConcepto de algoritmo y complejidad. Notación Big O. Búsqueda lineal y binaria. Algoritmos de ordenamiento: bubble sort, insertion sort, selection sort, quick sort y merge sort. Comparación de eficiencia. Funciones de búsqueda y ordenamiento en Python (sorted, sort, heapq).",
    "crumbs": [
      "Información",
      "Programa"
    ]
  },
  {
    "objectID": "practica/01_introduccion_a_python.html",
    "href": "practica/01_introduccion_a_python.html",
    "title": "P1 - Introducción a Python",
    "section": "",
    "text": "Práctica 1.",
    "crumbs": [
      "Práctica",
      "P1 - Introducción a Python"
    ]
  },
  {
    "objectID": "trabajos_practicos/descripcion.html",
    "href": "trabajos_practicos/descripcion.html",
    "title": "Descripción",
    "section": "",
    "text": "Acá explicamos las pautas para los TP.",
    "crumbs": [
      "Trabajos Prácticos",
      "Descripción"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html",
    "href": "trabajos_practicos/trabajo_grupal.html",
    "title": "Trabajo Práctico",
    "section": "",
    "text": "Trabajo Práctico",
    "crumbs": [
      "Trabajos Prácticos",
      "Trabajo Práctico"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_individual.html",
    "href": "trabajos_practicos/trabajo_individual.html",
    "title": "Trabajo Práctico Final",
    "section": "",
    "text": "Trabajo Práctico Final",
    "crumbs": [
      "Trabajos Prácticos",
      "Trabajo Práctico Final"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programación II",
    "section": "",
    "text": "Programación II\n\n\n   Ciclo de Formación Técnica - Estadística y Ciencia de Datos\n   Facultad de Ciencias Económicas y Estadística (UNR)\n   2° Cuatrimestre 2025"
  },
  {
    "objectID": "index.html#docentes",
    "href": "index.html#docentes",
    "title": "Programación II",
    "section": "Docentes",
    "text": "Docentes\n\n\nTomás Capretto\n\n   tomas.capretto@fcecon.unr.edu.ar\n   Consultas: TBD\n\n\n\nLuciano Anselmino\n\n   luciano.anselmino@fcecon.unr.edu.ar\n   Consultas: TBD\n\n\n\nJoaquín Bermejo\n\n   joaquin.bermejo@fcecon.unr.edu.ar\n   Consultas: TBD\n\n\n\nDolores Sollberger\n\n   dolores.sollberger@fcecon.unr.edu.ar\n   Consultas: TBD"
  },
  {
    "objectID": "informacion/calendario.html",
    "href": "informacion/calendario.html",
    "title": "Calendario",
    "section": "",
    "text": "Semana\nFecha\nTemas\nOtras actividades\n\n\n\n\n1\n4 de agosto\n• Lenguaje Python y su ecosistema.• Uso de Python en la terminal.• Uso de Positron.• Python en Positron.• Python: expresiones; variables y asignaciones; tipos de datos elementales; operadores numéricos, de comparación y lógicos.• Jupyter Notebooks.• Definición de funciones.• Ejecución condicional de código.\n\n\n\n2\n11 de agosto\n• Bucles definidos y no definidos: for, while, break, continue.• Estructuras de datos nativas de Python: list, tuple, set y dict.• Complemento: str, bytes, bytearray y range.\n\n\n\n3\n17 de agosto\n• Uso de código externo (propio y de terceros).• Módulos y librerías.• Librería estándar de Python.• Instalación y gestión de librerías.• Scripting.• Lectura y escritura de archivos de texto plano.• Modularización de programas.\n\n\n\n4\n25 de agosto\n• Funciones como ciudadanos de primera clase.• Funciones puras.• Funciones anónimas.• Closures.• Recursión.\n\n\n\n5\n1 de septiembre\n• Funciones de orden superior: map, filter, reduce.• Evaluación estricta y no estricta.• Evaluación perezosa (lazy) e inmediata (eager).• Generadores.• Aplicación parcial de funciones.• Decoradores.\n\n\n\n6\n15 de septiembre\n• Objetos, clases e instancias.• Atributos y métodos.• Propiedades públicas y privadas.• Métodos de clase y métodos de instancia.\n\n\n\n7\n22 de septiembre\n• Encapsulamiento.• Herencia simple y múltiple.• Polimorfismo.• Abstracción.\n\n\n\n8\n29 de septiembre\n• Métodos especiales (dunder methods).• Decoradores aplicados a métodos.• Sobrecarga de operadores.\nParcial\n\n\n9\n6 de octubre\n• Concepto y clasificación.• Estructuras lineales y no lineales.• Listas y listas enlazadas.• Operaciones básicas: agregar, quitar y recorrer.\nPresentación TP Grupal\n\n\n10\n13 de octubre\n• Hashing.• Diccionarios y conjuntos como estructuras asociativas.• Árboles y grafos.\nRecuperatorio\n\n\n11\n20 de octubre\n• Arreglos multidimensionales de NumPy.\n\n\n\n12\n27 de octubre\n• Concepto de algoritmo y complejidad.• Algoritmos de búsqueda.• Búsqueda lineal y binaria.• Notación Big O.\nEntrega TP Grupal\n\n\n13\n3 de noviembre\n• Algoritmos de ordenamiento.• bubble sort, insert sort, select sort, quick sort y merge sort.• Comparación de algoritmos de ordenamiento.\nPresentación TP Individual\n\n\n14\n10 de noviembre\n• Funciones de búsqueda y ordenamiento en Python.\n\n\n\n15\n17 de noviembre\n\n\n\n\n16\n24 de noviembre\n\nEntrega y defensa TP Individual",
    "crumbs": [
      "Información",
      "Calendario"
    ]
  },
  {
    "objectID": "informacion/bibliografia.html",
    "href": "informacion/bibliografia.html",
    "title": "Bibliografía",
    "section": "",
    "text": "Principal\n\nCormen et al. (2022) Downey (2024) Kalb (2022) Kubica (2022) Lott y Phillips (2021) Lott (2022) Mertz (2015) Miller, Ranum, y Yasinovskyy (2023) Sedgewick y Wayne (2011) Sedgewick, Wayne, y Dondero (2015) Sweigart (2020) Tuckfield (2021)\n\n\n\nCormen, Thomas H., Charles E. Leiserson, Ronald L. Rivest, y Clifford Stein. 2022. Introduction to Algorithms. 4th ed. MIT.\n\n\nDowney, Allen B. 2024. Think Python. 3.ª ed. O’Reilly Media. https://allendowney.github.io/ThinkPython/.\n\n\nKalb, Irv. 2022. Object-Oriented Python. No Starch Press.\n\n\nKubica, Jacek. 2022. Data Structures the Fun Way. 1st ed. No Starch Press.\n\n\nLott, Steven F. 2022. Functional Python Programming. 3rd ed. Packt Publishing.\n\n\nLott, Steven F., y Dusty Phillips. 2021. Python Object-Oriented Programming. 4th ed. Packt Publishing.\n\n\nMertz, David. 2015. Functional Programming in Python. O’Reilly Media.\n\n\nMiller, Bradley, David Ranum, y Jan Yasinovskyy. 2023. Problem Solving with Algorithms and Data Structures Using Python. 3rd ed. Franklin, Beedle & Associates.\n\n\nSedgewick, Robert, y Kevin Wayne. 2011. Algorithms. 4th ed. Addison-Wesley Professional.\n\n\nSedgewick, Robert, Kevin Wayne, y Robert Dondero. 2015. Introduction to Programming in Python. Addison-Wesley Professional.\n\n\nSweigart, Al. 2020. Beyond the Basic Stuff with Python. No Starch Press. https://inventwithpython.com/beyond/.\n\n\nTuckfield, Bradford. 2021. Dive Into Algorithms. No Starch Press.\n\n\n\n\nComplementaria\n\nHetland (2014) Mailund (2023) Sweigart (2021) Vaughan (2019) Wickham (2019)\n\n\n\n\n\nHetland, Magnus Lie. 2014. Python Algorithms. 2.ª ed. Apress.\n\n\nMailund, Thomas. 2023. Functional Programming in R 4. 2.ª ed. Apress.\n\n\nSweigart, Al. 2021. The Big Book of Small Python Projects. No Starch Press. https://inventwithpython.com/bigbookpython/.\n\n\nVaughan, Lee. 2019. Impractical Python Projects. No Starch Press.\n\n\nWickham, Hadley. 2019. Advanced R. 2.ª ed. Chapman & Hall/CRC. https://adv-r.hadley.nz/.",
    "crumbs": [
      "Información",
      "Bibliografía"
    ]
  },
  {
    "objectID": "informacion/aprobacion.html",
    "href": "informacion/aprobacion.html",
    "title": "Condiciones de aprobación",
    "section": "",
    "text": "📝 Examen parcial: individual y escrito. Hay un recuperatorio, de similares características, que reemplaza la nota del parcial.\n🤝 Trabajo práctico grupal: se hace fuera de clase, en grupos de entre dos y tres integrantes.\n🧑‍💻 Trabajo práctico individual: opcional para promoción, con presentación y defensa oral.\nTodas las instancias se califican en una escala de 0 a 10 y se aprueban con 6.",
    "crumbs": [
      "Información",
      "Condiciones de aprobación"
    ]
  },
  {
    "objectID": "informacion/aprobacion.html#instancias-de-evaluación",
    "href": "informacion/aprobacion.html#instancias-de-evaluación",
    "title": "Condiciones de aprobación",
    "section": "",
    "text": "📝 Examen parcial: individual y escrito. Hay un recuperatorio, de similares características, que reemplaza la nota del parcial.\n🤝 Trabajo práctico grupal: se hace fuera de clase, en grupos de entre dos y tres integrantes.\n🧑‍💻 Trabajo práctico individual: opcional para promoción, con presentación y defensa oral.\nTodas las instancias se califican en una escala de 0 a 10 y se aprueban con 6.",
    "crumbs": [
      "Información",
      "Condiciones de aprobación"
    ]
  },
  {
    "objectID": "informacion/aprobacion.html#condiciones-de-aprobación",
    "href": "informacion/aprobacion.html#condiciones-de-aprobación",
    "title": "Condiciones de aprobación",
    "section": "Condiciones de aprobación",
    "text": "Condiciones de aprobación\n\nPromoción\n\nQuienes aprueben el parcial individual (con nota \\(\\text{P}\\)), el trabajo práctico grupal (con nota \\(\\text{T}\\)) y el trabajo práctico individual con defensa oral (con nota \\(\\text{O}\\)), adquieren la condición de estudiante promovido y su nota final se calcula como \\(0.5 \\times \\text{P} + 0.2 \\times \\text{T} + 0.3 \\times \\text{O}\\).\n\nRegularidad\n\nQuienes aprueben el parcial individual (o su recuperatorio) y el trabajo práctico grupal, pero no accedan o no aprueben el trabajo práctico individual, adquieren la condición de estudiante regular.\n\nLibres\n\nQuienes no aprueben el parcial individual (ni su recuperatorio) o el trabajo práctico grupal, adquieren la condición de estudiante libre.",
    "crumbs": [
      "Información",
      "Condiciones de aprobación"
    ]
  },
  {
    "objectID": "teoria/01_introduccion_a_python/clase_1.html",
    "href": "teoria/01_introduccion_a_python/clase_1.html",
    "title": "Clase 1",
    "section": "",
    "text": "Python es un lenguaje de programación. Pero podemos pensarlo intuitivamente como una super-calculadora. Python nos ayuda a hacer lo mismo que una calculadora, y como vamos a ver, mucho más.\nEmpecemos utilizando a Python como si fuese una calculadora. Para eso vamos a crear un bloque de código en la notebook y escribimos algunas cuentas tal como lo hacemos en cualquier calculadora.\n\n2 * 3\n\n6\n\n\nNo tenemos la necesidad de pisar el código todo el tiempo. Podemos escribir nuevas celdas de código, y así podemos ir mostrando diferentes cómputos y sus resultados.\n\n100 / 3.5\n\n28.571428571428573\n\n\n\n20 + 5\n\n25\n\n\n\n13 - 3\n\n10\n\n\n\n10 * 5.5\n\n55.0",
    "crumbs": [
      "Teoría",
      "U1 - Introducción a Python",
      "Clase 1"
    ]
  },
  {
    "objectID": "teoria/01_introduccion_a_python/clase_1.html#una-super-calculadora",
    "href": "teoria/01_introduccion_a_python/clase_1.html#una-super-calculadora",
    "title": "Clase 1",
    "section": "",
    "text": "Python es un lenguaje de programación. Pero podemos pensarlo intuitivamente como una super-calculadora. Python nos ayuda a hacer lo mismo que una calculadora, y como vamos a ver, mucho más.\nEmpecemos utilizando a Python como si fuese una calculadora. Para eso vamos a crear un bloque de código en la notebook y escribimos algunas cuentas tal como lo hacemos en cualquier calculadora.\n\n2 * 3\n\n6\n\n\nNo tenemos la necesidad de pisar el código todo el tiempo. Podemos escribir nuevas celdas de código, y así podemos ir mostrando diferentes cómputos y sus resultados.\n\n100 / 3.5\n\n28.571428571428573\n\n\n\n20 + 5\n\n25\n\n\n\n13 - 3\n\n10\n\n\n\n10 * 5.5\n\n55.0",
    "crumbs": [
      "Teoría",
      "U1 - Introducción a Python",
      "Clase 1"
    ]
  },
  {
    "objectID": "teoria/01_introduccion_a_python/clase_1.html#tipos-de-datos",
    "href": "teoria/01_introduccion_a_python/clase_1.html#tipos-de-datos",
    "title": "Clase 1",
    "section": "Tipos de datos",
    "text": "Tipos de datos\nComo cualquier lenguaje de programación, Python ofrece diferentes tipos de datos. ¡Una super-calculadora no se puede rebajar a trabajar solo con números!\nCada tipo de dato nos ayuda a resolver una tarea distinta. Por ejemplo, si quiero hacer operaciones matemáticas voy a necesitar de números, pero si quiero escribir un correo electrónico voy a necesitar de texto.\nA continuación vamos a introducir los tipos de datos más básicos que Python nos ofrece.\nMás adelante también veremos otros tipos de datos más complejos que nos van a permitir resolver problemas más interesantes.\n\nNúmeros\nAcabamos de hacer cuentas matemáticas somo si tuvieramos una calculadora. Para eso usamos números, los conocidos de toda la vida.\nSin notarlo, utilizamos dos tipos de números distintos: los números de tipo entero (int) y los números de tipo flotante (float).\nLo siguiente es un número entero:\n\n50\n\n50\n\n\nY el siguiente es un ejemplo de un número flotante:\n\n36.8\n\n36.8\n\n\nUtilizando la función type() Python nos devuelve el tipo del objeto.\n\ntype(10)\n\nint\n\n\n\ntype(10.5)\n\nfloat\n\n\n\ntype(10.0)\n\nfloat\n\n\n\ntype(10.)\n\nfloat\n\n\n\n\nCadenas de texto\nPara ser una super-calculadora, Python tiene que ser capaz de trabajar con objetos más complejos que los números.\nUn ejemplo de esto es el texto. El texto se representa con un objeto llamado cadena de texto.\nPara construir una cadena de texto se utilizan comillas.\nEstas se ponen al principio y al final del texto e indican el principio y el final de la cadena. Las comillas pueden ser dobles \" o simples '.\n\n\"Programando en Python\"\n\n'Programando en Python'\n\n\n\n'Con comillas simples, también.'\n\n'Con comillas simples, también.'\n\n\nNo hay diferencia entre las comillas simples ' y las dobles \". Sin embargo, debemos tener presente que hay que usar el mismo tipo de comillas para abrir y para cerrar la cadena.\nAl imprimir la cadena de texto, desaparecen las comillas.\nPara imprimir un objeto de Python se utiliza la función print().\n\nprint('Con comillas simples, también!')\n\nCon comillas simples, también!\n\n\nTambién se pueden crear cadenas de texto usando tres veces las comillas (le decimos comillas triples).\nEsto nos permite crear cadenas que están escritas en múltiples líneas.\n\nprint(\"\"\"Se puede escribir texto\nen varias lineas.\n¡Está muy bueno!\"\"\")\n\nSe puede escribir texto\nen varias lineas.\n¡Está muy bueno!\n\n\nUna alternativa para escribir texto en múltiples líneas es utilizar el el caracter especial \\n que indica un salto de línea.\n\nprint(\"Primera línea\\nsegunda línea\\ntercera línea.\")\n\nPrimera línea\nsegunda línea\ntercera línea.\n\n\nPodemos ver que el caracter \\n no aparece ninguna vez en el texto.\nEn cambio, donde el texto contiene \\n, se introduce un salto de línea.\n\n\"Primera línea\\nsegunda línea\\ntercera línea.\"\n\n'Primera línea\\nsegunda línea\\ntercera línea.'\n\n\n\n\n\n\n\n\n¡Atencion! 🤓\n\n\n\n¿Cuál es la diferencia entre usar print() y no usarlo?\n\nCuando usamos print() se imprime el objeto de una manera humanamente legible.\nCuando no lo usamos, se muestra una representación del objeto. Esta representación tiene que ser lo menos ambigua posible.\n\nPor este motivo es que se muestran las comillas a la hora de representar una cadena.\n\n\n\n\nOtra situación en la que usar print() genera una diferencia es cuando se quieren mostrar varios objetos. Por ejemplo, comparemos el resultado de los siguientes bloques:\n\n\"mensaje 1\"\n10\n\"mensaje 2\"\n\n'mensaje 2'\n\n\n\nprint(\"mensaje 1\")\nprint(10)\nprint(\"mensaje 2\")\n\nmensaje 1\n10\nmensaje 2\n\n\n\n\nLógicos (o Booleanos)\nComo veremos más adelante, nuestros programas suelen tener que decidir entre diferentes acciones a tomar según se cumpla o no cierta condición.\nPara representar esta situación utilizamos un tipo especial de dato conocido como lógico o booleano, que puede tomar únicamente dos valores: True o False.\nSi la condición se cumple, el resultado será True; de lo contrario, será False.\n\nTrue\n\nTrue\n\n\n\nFalse\n\nFalse\n\n\n\ntype(True)\n\nbool\n\n\n\ntype(False)\n\nbool\n\n\n\n\n\n\n\n\nReseña histórica 📜\n\n\n\nEste tipo de datos se llama Booleano en honor al matemático George Boole.\n\n\n\n\nNulo\nEl valor nulo, llamado None en Python, representa la ausencia de valor o el vacío.\nSe utiliza habitualmente para indicar que algo no tiene un valor asignado.\nSi intentamos mostrar el valor de None, veremos que no aparece nada.\n\nNone\n\nEn cambio, si imprimimos el objeto None, vemos el mensaje None.\n\nprint(None)\n\nNone\n\n\n¿Y cuál es su tipo?\n\ntype(None)\n\nNoneType\n\n\nSolamente los objetos None son del tipo NoneType.\n\n\n\n\n\n\n¿Por qué existe el valor nulo? 🤔\n\n\n\nMuchas veces nuestro programa, o alguna parte del mismo, realiza una tarea que no devuelve ningún resultado.\nPodríamos ponernos de acuerdo en representar “ningún resultado” usando un número (0), una cadena vacía (\"\") o algo parecido. Pero estos valores representan algo específico, no la ausencia total de valor.\nPara expresar claramente que no hay ningún resultado, Python incluye un valor especial llamado None.\n\n\nEjemplos\n\nUn usuario completa un formulario con datos personales, pero algunos campos no son obligatorios y quedan sin completar.\nUna función busca un elemento en una lista; cuando no encuentra lo buscado, devuelve un valor especial indicando que el resultado está ausente.\n\nEn general, cuando se quiera representar la ausencia de información se utilizará None.\n\n\nConversión entre tipos de datos\nQue existan distintos tipos de datos no significa que un objeto de un tipo no pueda “convertirse” a otro.\nEn muchos casos es posible convertir entre tipos de datos. Por ejemplo, un número siempre se puede convertir a una cadena de caracteres, pero no cualquier cadena puede convertirse a un número.\nPara convertir un objeto a otro tipo utilizamos funciones con el nombre del tipo al que queremos convertir, como str(), int() o bool(). Estas funciones reciben como argumento el objeto a convertir.\nVeamos algunos ejemplos:\n\nstr(256)\n\n'256'\n\n\n\nstr(None)\n\n'None'\n\n\n\nint(165.5)\n\n165\n\n\n\nint(165.8)\n\n165\n\n\n\nint(\"165\")\n\n165\n\n\n\nfloat(\"165.0\")\n\n165.0\n\n\n\n\nResumen\n\nPython tiene distintos tipos de datos.\nCada tipo de dato es útil para resolver diferentes problemas.\n\nA lo largo del curso veremos muchísimos ejemplos.\n\nAl principio, tener varios tipos de datos puede parecer complejo.\n\nSin embargo, nos resultarán muy naturales a medida que los usemos para resolver problemas concretos.\n\n\n\n\n\n\n\n\n\nTipo de dato\nEjemplos\n\n\n\n\nNúmeros enteros (int)\n-2, -1, 0, 10, 200\n\n\nNúmeros de punto flotante (float)\n-200.789, -1.0, 0.0, 17.8\n\n\nCadenas de texto (str)\n\"a\", \"abc\", \"Rosario, Santa Fe\"\n\n\nBooleanos (bool)\nTrue, False\n\n\nValor nulo (NoneType)\nNone",
    "crumbs": [
      "Teoría",
      "U1 - Introducción a Python",
      "Clase 1"
    ]
  },
  {
    "objectID": "teoria/01_introduccion_a_python/clase_1.html#variables",
    "href": "teoria/01_introduccion_a_python/clase_1.html#variables",
    "title": "Clase 1",
    "section": "Variables",
    "text": "Variables\n¿Es necesario escribir explícitamente los valores con los que trabajamos cada vez que los usamos? Afortunadamente, la respuesta es no.\nLos lenguajes de programación más populares permiten usar variables.\nPodemos pensar las variables como etiquetas o nombres que asignamos a los objetos en nuestro programa.\nUna vez creada una variable con cierto valor, podemos usar directamente su nombre en lugar de volver a escribir el valor completo.\n\nmensaje = \"¡Hola, curso!\"\nprint(mensaje)\n\n¡Hola, curso!\n\n\n\nprint(\"¡Hola, curso!\")\n\n¡Hola, curso!\n\n\nPara crear una variable se necesita:\n\nEl nombre.\nEl operador de asignación.\nEl valor que queremos asignar a la variable.\n\nEn nuestro caso, el nombre de la variable es mensaje y el valor es \"¡Hola, curso!\".\nLuego, cuando accedemos a la variable mensaje dentro de la función print(), Python nos devuelve el valor de la variable, es decir, ¡Hola, curso!\".\nVeamos otros ejemplos…\n\npi = 3.14159\nfruta_favorita = \"manzana\"\npython_bueno = True\n\nEn el siguiente diagrama se muestra cómo las variables que creamos funcionan simplemente como etiquetas para los valores asignados.\nCada vez que utilizamos una de estas etiquetas, accedemos directamente al valor que representa.\n\n\n\n\n\n\nprint(pi * 10)\n\n31.4159\n\n\n\nfruta_favorita\n\n'manzana'\n\n\n\npython_bueno\n\nTrue\n\n\nLas variables no solo evitan que escribamos repetidamente los mismos valores en nuestro programa, sino que también permiten:\n\nGeneralizar el programa\n\nAl cambiar el valor de una variable, todas las partes del programa que la usan se actualizan automáticamente.\n\nMejorar la legibilidad del código\n\nSi elegimos nombres claros y descriptivos, el programa será mucho más fácil de leer y entender.\n\n\nPor ejemplo, los siguientes bloques de código producen el mismo resultado, pero el segundo es mucho más informativo:\n\n1500 * 8\n\n12000\n\n\n\nprecio = 1500\ncantidad = 8\nprecio * cantidad\n\n12000\n\n\n\nNombres permitidos\nNo todos los nombres que imaginemos se pueden utilizar como variables en Python.\nTenemos que tener en cuenta las siguientes reglas. Los nombres de variables…\n\nSolo pueden contener letras, números y guiones bajos (_).\nDeben comenzar con una letra o un guión bajo, pero no con un número.\n\nPor ejemplo, mensaje_1 es válido, pero 1_mensaje no lo es.\n\nNo pueden contener espacios.\n\nPor eso usamos fruta_favorita en lugar de fruta favorita.\n\nNo pueden ser palabras reservadas de Python.\n\nLas palabras reservadas se encuentran al final de este apunte.\n\n\nAdemás, también vale la pena tener presente estos consejos:\n\nUsá nombres breves pero descriptivos.\n\nnombre es preferible a n.\nfruta_favorita es preferible a frut_fav.\n\nEvitá utilizar tildes, la letra ñ u otros caracteres específicos del castellano.\n\n\n\nEliminar variables\nEs posible que, después de crear nuestras variables y realizar las operaciones necesarias, queramos eliminarlas.\nPara borrar una variable, Python ofrece la sentencia del (del inglés delete, que significa eliminar o borrar).\n\ndel fruta_favorita",
    "crumbs": [
      "Teoría",
      "U1 - Introducción a Python",
      "Clase 1"
    ]
  },
  {
    "objectID": "teoria/01_introduccion_a_python/clase_1.html#operadores",
    "href": "teoria/01_introduccion_a_python/clase_1.html#operadores",
    "title": "Clase 1",
    "section": "Operadores",
    "text": "Operadores\nLos operadores son símbolos que se utilizan para realizar operaciones o acciones sobre los objetos con los que estamos trabajando.\nHasta ahora, vimos que podemos tener números, texto, y otras objetos un poco mas extraños como los booleanos e incluso algo que representa a la nada misma.\nA continuación, comenzamos a ver algunas de las tareas que podemos hacer con ellos.\n\nOperadores aritméticos\nPython incluye los mismos operadores aritméticos que solemos utilizar en nuestro día a día para hacer operaciones matemáticas.\nEstos se parecen muchísimo a los que usamos en una calculadora, por lo que podríamos entenderlo incluso sin saber que es Python.\nAlgunos operadores son los siguientes:\n\nSuma (+)\nResta (-)\nMultiplicación (*)\nPotencia (**)\nDivisión (/)\nDivisión entera (//)\nMódulo (%)\n\n\nSuma (+)\n\n10 + 25\n\n35\n\n\n\n10.0 + 25.0\n\n35.0\n\n\n\n-8 + 12.1\n\n4.1\n\n\nEl operador suma también puede ser usado con un solo argumento:\nEn este caso no modifica en nada al valor 8.\n\n\n\nResta (-)\n\n11 - 8\n\n3\n\n\n\n100 - 100.0\n\n0.0\n\n\n\n-35 - 28\n\n-63\n\n\nEl operador resta también puede ser usado con un solo argumento:\n\n- 7\n\n-7\n\n\n\n\nMultiplicación (*) y potencia (**)\n\n21 * 5\n\n105\n\n\n\n21 * 5.0\n\n105.0\n\n\n\n21.0 * 5.0\n\n105.0\n\n\n\n2 ** 3\n\n8\n\n\n\n2 ** 3.0\n\n8.0\n\n\n\n\n\n\n\n\nConclusiones\n\n\n\n\nSi utilizamos valores enteros, el resultado es un valor entero.\nSi al menos uno de los dos argumentos es de tipo flotante, el resultado es de tipo flotante.\n\n\n\n\n\nDivisión (/ y //)\nPython provee dos operadores distintos para calcular el cociente entre dos números.\n\nEl operador / que calcula la división flotante.\nEl operador // que calcula la división entera.\n\nEl operador / es el que más se utiliza y siempre devuelve un número de tipo flotante.\n\n10 / 5\n\n2.0\n\n\n\n10 / 5.5\n\n1.8181818181818181\n\n\nLa división entera se suele utilizar cuando uno quiere el resultado entero de la división, sin importar si el resto es 0 o no.\n\n10 // 5\n\n2\n\n\n\n10 // 5.5\n\n1.0\n\n\nVeamos los siguientes ejemplos donde comparamos la división flotante con la división entera, utilizando los mismos argumentos.\n\n15 / 4\n\n3.75\n\n\n\n15.0 // 4.0\n\n3.0\n\n\n\n\nMódulo (%)\nOtro operador relacionado a la división entera es el operador módulo o resto (%).\nEsta operación nos devuelve el resto que se obtiene al realizar la división entera entre dos números.\n\n17 % 3\n\n2\n\n\nDebajo se puede ver la relación entre la división entera y el módulo:\n\n\n\n\n\nAunque ahora pueda parecer difícil encontrar una aplicación práctica para los operadores de división entera // y resto %, más adelante veremos ejemplos donde haremos un uso intensivo de ellos.\n\n\nPrioridad de los operadores\nHasta ahora vimos operaciones bastante sencillas.\nCuando presentamos la suma, realizamos simplemente una suma. Cuando presentamos la multiplicación, hicimos solo una multiplicación.\nPor supuesto, al momento de hacer cálculos podemos combinar los operadores que ya conocemos, de la misma forma en que lo hacemos al resolver cuentas a mano.\nUn punto importante a tener en cuenta es que, al igual que cuando hacemos cuentas a mano, algunas operaciones se resuelven antes que otras, sin importar el orden en que aparecen. Esto ocurre porque algunos operadores tienen mayor prioridad y, por lo tanto, se evalúan antes.\nEn el siguiente ejemplo, ¿por qué se obtienen resultados distintos?\n\n10 - 2 * 4\n\n2\n\n\n\n(10 - 2) * 4\n\n32\n\n\nIndependientemente de que el símbolo + aparezca antes que el símbolo * en una expresión, Python realiza primero la multiplicación.\nAl igual que cuando hacemos cuentas a mano, la multiplicación tiene mayor prioridad que la suma.\nSi queremos forzar a Python a realizar una operación antes que otra, sin importar la prioridad de los operadores, debemos usar paréntesis.\nOtro ejemplo es el siguiente…\n\n7 + 8 / 2\n\n11.0\n\n\n\n(7 + 8) / 2\n\n7.5\n\n\nA continuación se incluye una tabla con los operadores que vimos y la prioridad que tiene cada uno.\nLos operadores que aparecen más arriba tienen mayor prioridad.\nLos operadores que aparecen en la misma fila tienen el mismo nivel de prioridad y se resuelven según el orden en que aparecen en el código (de izquierda a derecha).\n\n\n\n\n\n\n\nOperador\nSignificado\n\n\n\n\n()\nAgrupamiento\n\n\n**\nPotencia\n\n\n*, /, //, %\nMultiplicación, División, División entera, Módulo\n\n\n+, -\nSuma, Resta\n\n\n\nEsta lista es una versión más sencilla y resumida de la tabla de prioridades de todos los operadores que hay en Python. Una versión más completa se puede encontrar en Programiz.\n\n\n\nOperadores lógicos\nLos operadores lógicos se llaman así porque el resultado que devuelven es de tipo lógico (bool).\nEn algunos casos se utilizan símbolos, en otros se utilizan palabras claves.\nA partir de ahora vamos a ver varias operaciones que puedan resultar familiares para quienes hicieron alguna materia relacionada a lógica.\n\nNegación (not)\nDevuelve el opuesto del valor que le pasamos.\n\nnot False\n\n\nnot True\n\n\n\nConjunción o intersección (and)\nEsta operación devuelve True solamente cuando los dos operadores que le pasamos son True.\n\nTrue and True\n\n\nFalse and True\n\n\n\nDisyunción o unión (or)\nEsta operación devuelve True cuando cualquiera de sus argumentos es True.\n\nTrue or False\n\nSolo devuelve False cuando sus dos argumentos son False.\n\nFalse or False\n\n\n\nIdentidad (is)\nExisten dos operadores para evaluar la identidad de los objetos.\n\nOperador is: es True cuando ambos operandos son el mismo objeto\nOperador is not: es True cuando los operandos no son el mismo objeto.\n\n\nFalse is False\n\n\nFalse is True\n\n\nNone is None\n\n\n\nComparación\nPython provee varios operadores para realizar comparaciones entre objetos.\nLos operadores que vemos a continuación son los mismos que aprendimos en la secundaria.\n\n\n\n\n\n\n\nOperador\nDescripción\n\n\n\n\n==\nIgualdad: El resultado es True cuando los dos operandos son iguales.\n\n\n!=\nDesigualdad: El resultado es True si los operandos son distintos.\n\n\n&gt;\nMayor a: El resultado es True si el operando de la izquierda es mayor que el de la derecha.\n\n\n&gt;=\nMayor o igual a: El resultado es True si el operando de la izquierda es mayor o igual que el de la derecha.\n\n\n&lt;\nMenor a: El resultado es True si el operando de la izquierda es menor que el de la derecha.\n\n\n&lt;=\nMenor o igual a: El resultado es True si el operando de la izquierda es menor o igual que el de la derecha.\n\n\n\nAlgunos ejemplos…\n\n10 &gt; 5\n\n\n10 &gt; 5 + 3\n\n\n0 &lt; 0\n\n\n1 &gt;= 1\n\n\n10.0 != 10\n\n\n10.0 == 10\n\nA pesar de que 10.0 es de tipo flotante y 10 es de tipo entero, vemos que la comparación de igualdad == dice que son iguales.\nNo siempre que comparemos objetos de distinto tipo va a suceder algo así.\nLa comparación de cadenas de texto distingue mayúsculas de minúsculas\n\n\"UNR\" == \"unr\"\n\nFalse\n\n\nEs posible comparar objetos de distinto tipo, como lo vimos en el ejemplo anterior donde comparamos 10 y 10.0.\nSalvo casos particulares, como son los valores numéricos, estos objetos son considerados siempre distintos.\n\n\"10\" == 10\n\nFalse\n\n\n\n\"False\" == False\n\nFalse\n\n\nEs posible combinar mas de una comparación en la misma línea.\n\n1 &lt; 2 and 2 &lt; 3\n\nTrue\n\n\nIncluso es posible omitir el operador and y tener una expresión más clara\n\n1 &lt; 2 &lt; 3\n\nTrue\n\n\n\n-5 &lt; -4 &lt; -3\n\nTrue\n\n\nTambién podemos mezclar not, and y or a gusto.\n\nFalse or not False\n\nY es válido utilizar paréntesis para agrupar operaciones.\n\n(False or True) and (True or False)\n\nA continuación se incluye una tabla con los operadores lógicos y la prioridad que tiene cada uno.\nLos operadores que aparecen más arriba tienen mayor prioridad.\nLos operadores que aparecen en la misma fila tienen el mismo nivel de prioridad y se resuelven según el orden en que aparecen en el código (de izquierda a derecha).\n\n\n\n\n\n\n\nOperadores\nSignificado\n\n\n\n\n==, !=, &gt;, &gt;=, &lt;, &lt;=, is, is not, in, not in\nComparaciones, identidad, pertenencia\n\n\nnot\nNegación\n\n\nand\nConjunción o intersección\n\n\nor\nDisyunción o unión\n\n\n\nTodos los operadores lógicos tienen menor prioridad que los operadores aritméticos que vimos arriba.\nEn otras palabras, si pegaramos ambas tablas, ésta última quedaría por debajo.\nAnalicemos nuevamente uno de los ejemplos que ya vimos.\n\nnot True and not True\n\nEl operador not tiene mayor prioridad que el operador and porque aparece primero en la tabla.\nEn consecuencia, en el código anterior primero se resuelven los not True y luego el and. Esto es lo mismo que hacer\n\nFalse and False",
    "crumbs": [
      "Teoría",
      "U1 - Introducción a Python",
      "Clase 1"
    ]
  },
  {
    "objectID": "teoria/01_introduccion_a_python/clase_1.html#apéndice",
    "href": "teoria/01_introduccion_a_python/clase_1.html#apéndice",
    "title": "Clase 1",
    "section": "Apéndice",
    "text": "Apéndice\n\nPalabras claves y funciones predefinidas\nPython tiene un conjunto de palabras conocidas como keywords que sirven para realizar acciones especificas y que no podemos utilizar como nombres de variables.\nCuando intentemos utilizar una keyword como nombre de variable, obtendremos un error.\nPor otro lado, si intentamos utilizar el nombre de una función (o clase) predefinida como nombre de una variable que nosotros creamos, no vamos a obtener un error pero no podremos usar la función nuevamente porque la variable ahora representa otra cosa.\n\nPalabras claves\nFalse      await      else       import     pass\nNone       break      except     in         raise\nTrue       class      finally    is         return\nand        continue   for        lambda     try\nas         def        from       nonlocal   while\nassert     del        global     not        with\nasync      elif       if         or         yield\n\n\nFunciones y clases pre-definidas\nabs()          copyright()    getattr()      list()         range()        vars()\nall()          credits()      globals()      locals()       repr()         zip()\nany()          delattr()      hasattr()      map()          reversed()\nascii()        dict()         hash()         max()          round()\nbin()          dir()          help()         memoryview()   set()\nbool()         display()      hex()          min()          setattr()\nbreakpoint()   divmod()       id()           next()         slice()\nbytearray()    enumerate()    input()        object()       sorted()\nbytes()        eval()         int()          oct()          staticmethod()\ncallable()     exec()         isinstance()   open()         str()\nchr()          filter()       issubclass()   ord()          sum()\nclassmethod()  float()        iter()         pow()          super()\ncompile()      format()       len()          print()        tuple()\ncomplex()      frozenset()    license()      property()     type()\n\n\n\nAsignaciones múltiples\nYa vimos que para asignar, o crear, una variable necesitamos hacer variable = &lt;valor&gt;.\nSi queremos crear multiples variables, podemos escribir las asignaciones en múltiples líneas.\nPor ejemplo\n\npi, e = 3.1416, 2.7182\nprint(pi)\nprint(e)\n\nUna característica conveniente de Python es que permite asignar múltiples variables en una misma línea.\nOtro ejemplo es el siguiente, donde se demuestra que los tipos de las variables no necesitan ser iguales.\n\na, b, c = 100 + 20, \"un mensaje cualquiera\", None\n\n\nprint(a)\nprint(b)\nprint(c)\n\nEsta característica es muy útil para escribir código más conciso, aunque tampoco debemos abusar de ella. En muchos casos puede resultar en código poco legible.",
    "crumbs": [
      "Teoría",
      "U1 - Introducción a Python",
      "Clase 1"
    ]
  }
]