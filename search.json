[
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html",
    "href": "teoria/01_programacion_en_python/01_introduccion.html",
    "title": "Introducci√≥n",
    "section": "",
    "text": "Python es un lenguaje de programaci√≥n interpretado, de prop√≥sito general y de alto nivel. Fue creado por Guido Van Rossum y su primera versi√≥n p√∫blica fue en el a√±o 1991.\n\nInterpretado: no requiere que realicemos un paso expl√≠cito de compilaci√≥n a lenguaje de m√°quina antes de ejecutarlo. Adem√°s, se puede ejecutar l√≠nea por l√≠nea.\nProp√≥sito general: no se limita a un tipo de aplicaci√≥n espec√≠fica, es decir, se puede usar para implementar programas en diferentes dominios:\n\nVox populi: No es el mejor en casi nada, pero suficientemente bueno para casi todo.\nAlgunos dominios:\n\nAn√°lisis estad√≠stico y ciencia de datos.\nInteligencia artificial.\nDesarrollo web.\nDesarrollo de videojuegos.\nScripting.\n\n\nAlto nivel: se parece m√°s al lenguaje humano que al lenguaje de las m√°quinas.\n\nAdem√°s‚Ä¶\n\nEs gratis: no requiere pagar licencias para usarlo, tanto a nivel personal como comercial.\nEs de c√≥digo abierto: su c√≥digo fuente est√° disponible p√∫blicamente y puede ser modificado por cualquiera.\nPosee un ecosistema de librer√≠as complet√≠simo: existen miles de paquetes para todo tipo de tareas.\nComunidad: millones de personas lo usan, contribuyen, resuelven dudas y crean contenido, lo que facilita aprender y encontrar ayuda.\n\nPara utilizar Python es necesario instalar un int√©rprete de Python. La versi√≥n oficial puede ser descargada desde python.org. Una vez instalado el int√©rprete, es posible ejecutar scripts de Python y programar en Python de manera interactiva desde la terminal.\nEn esta materia se utiliza un editor de c√≥digo para ciencia de datos llamado Positron. Este editor es desarrollado por Posit, los mismos creadores de RStudio, y permite trabajar tanto con Python como con R.\nLas instrucciones para instalar Python y Positron pueden ser encontradas en Instalaci√≥n de Python y Positron en Windows.\n\n\n\nEmpecemos utilizando a Python como si fuese una calculadora. Para eso vamos a crear un bloque de c√≥digo en la notebook y escribimos algunas cuentas tal como lo hacemos en cualquier calculadora.\n\n2 * 3\n\n6\n\n\nNo tenemos la necesidad de pisar el c√≥digo todo el tiempo. Podemos escribir nuevas celdas de c√≥digo, y as√≠ podemos ir mostrando diferentes c√≥mputos y sus resultados.\n\n100 / 3.5\n\n28.571428571428573\n\n\n\n20 + 5\n\n25\n\n\n\n13 - 3\n\n10\n\n\n\n10 * 5.5\n\n55.0",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "Introducci√≥n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#qu√©-es-python",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#qu√©-es-python",
    "title": "Introducci√≥n",
    "section": "",
    "text": "Python es un lenguaje de programaci√≥n interpretado, de prop√≥sito general y de alto nivel. Fue creado por Guido Van Rossum y su primera versi√≥n p√∫blica fue en el a√±o 1991.\n\nInterpretado: no requiere que realicemos un paso expl√≠cito de compilaci√≥n a lenguaje de m√°quina antes de ejecutarlo. Adem√°s, se puede ejecutar l√≠nea por l√≠nea.\nProp√≥sito general: no se limita a un tipo de aplicaci√≥n espec√≠fica, es decir, se puede usar para implementar programas en diferentes dominios:\n\nVox populi: No es el mejor en casi nada, pero suficientemente bueno para casi todo.\nAlgunos dominios:\n\nAn√°lisis estad√≠stico y ciencia de datos.\nInteligencia artificial.\nDesarrollo web.\nDesarrollo de videojuegos.\nScripting.\n\n\nAlto nivel: se parece m√°s al lenguaje humano que al lenguaje de las m√°quinas.\n\nAdem√°s‚Ä¶\n\nEs gratis: no requiere pagar licencias para usarlo, tanto a nivel personal como comercial.\nEs de c√≥digo abierto: su c√≥digo fuente est√° disponible p√∫blicamente y puede ser modificado por cualquiera.\nPosee un ecosistema de librer√≠as complet√≠simo: existen miles de paquetes para todo tipo de tareas.\nComunidad: millones de personas lo usan, contribuyen, resuelven dudas y crean contenido, lo que facilita aprender y encontrar ayuda.\n\nPara utilizar Python es necesario instalar un int√©rprete de Python. La versi√≥n oficial puede ser descargada desde python.org. Una vez instalado el int√©rprete, es posible ejecutar scripts de Python y programar en Python de manera interactiva desde la terminal.\nEn esta materia se utiliza un editor de c√≥digo para ciencia de datos llamado Positron. Este editor es desarrollado por Posit, los mismos creadores de RStudio, y permite trabajar tanto con Python como con R.\nLas instrucciones para instalar Python y Positron pueden ser encontradas en Instalaci√≥n de Python y Positron en Windows.\n\n\n\nEmpecemos utilizando a Python como si fuese una calculadora. Para eso vamos a crear un bloque de c√≥digo en la notebook y escribimos algunas cuentas tal como lo hacemos en cualquier calculadora.\n\n2 * 3\n\n6\n\n\nNo tenemos la necesidad de pisar el c√≥digo todo el tiempo. Podemos escribir nuevas celdas de c√≥digo, y as√≠ podemos ir mostrando diferentes c√≥mputos y sus resultados.\n\n100 / 3.5\n\n28.571428571428573\n\n\n\n20 + 5\n\n25\n\n\n\n13 - 3\n\n10\n\n\n\n10 * 5.5\n\n55.0",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "Introducci√≥n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#tipos-de-datos",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#tipos-de-datos",
    "title": "Introducci√≥n",
    "section": "Tipos de datos",
    "text": "Tipos de datos\nComo cualquier lenguaje de programaci√≥n, Python ofrece diferentes tipos de datos.\nCada tipo de dato nos ayuda a resolver una tarea distinta. Por ejemplo, si quiero hacer operaciones matem√°ticas voy a necesitar de n√∫meros, pero si quiero escribir un correo electr√≥nico voy a necesitar de texto.\nA continuaci√≥n vamos a introducir los tipos de datos m√°s b√°sicos que Python nos ofrece.\nM√°s adelante tambi√©n veremos otros tipos de datos m√°s complejos que nos van a permitir resolver problemas (much√≠simo) m√°s interesantes.\n\nN√∫meros\nAcabamos de hacer cuentas matem√°ticas somo si tuvieramos una calculadora. Para eso usamos n√∫meros, los conocidos de toda la vida.\nSin notarlo, utilizamos dos tipos de n√∫meros distintos: los n√∫meros de tipo entero (int) y los n√∫meros de tipo flotante (float).\nLo siguiente es un n√∫mero entero:\n\n50\n\n50\n\n\nY el siguiente es un ejemplo de un n√∫mero flotante:\n\n36.8\n\n36.8\n\n\nUtilizando la funci√≥n type() Python nos devuelve el tipo del objeto.\n\ntype(10)\n\nint\n\n\n\ntype(10.5)\n\nfloat\n\n\n\ntype(10.0)\n\nfloat\n\n\n\ntype(10.)\n\nfloat\n\n\n\n\n\n\n\n\nObservaci√≥n üëÄ\n\n\n\nA diferencia de R, Python no es un lenguaje vectorizado. Por lo tanto, los tipos int y float representan valores escalares, no vectores de longitud 1 como ocurre en R.\nEsta observaci√≥n aplica a todos los tipos de datos elementales que vienen a continuaci√≥n.\n\n\n\n\nCadenas de texto\nPara ser una lenguaje de programaci√≥n tan afamado, Python tiene que ser capaz de trabajar con objetos m√°s complejos que los n√∫meros.\nUn ejemplo de esto es el texto, que se representa con un objeto llamado cadena de texto y se construyen utilizando comillas.\nComo en la mayor√≠a de los lenguajes de programaci√≥n, las comillas se ponen al principio y al final del texto e indican el principio y el final de la cadena; estas pueden pueden ser dobles \" o simples '.\n\n\"Programando en Python\"\n\n'Programando en Python'\n\n\n\n'Con comillas simples, tambi√©n.'\n\n'Con comillas simples, tambi√©n.'\n\n\nEn Python no hay diferencia entre usar comillas simples ' o dobles \", pero es importante que el tipo de comilla que se usa para abrir la cadena sea el mismo que se usa para cerrarla.\nCuando imprimimos una cadena, las comillas no se muestran en la salida. Para imprimir cualquier objeto de Python utilizamos la funci√≥n print().\n\nprint('Con comillas simples, ¬°tambi√©n!')\n\nCon comillas simples, ¬°tambi√©n!\n\n\nUna forma un poco m√°s ex√≥tica, pero muy √∫til, de crear cadenas es utilizando comillas triples. Con esta sintaxis, se repiten tres comillas seguidas, lo que permite definir cadenas de texto que ocupan varias l√≠neas.\n\nprint(\"\"\"Se puede escribir texto\nen varias lineas.\n¬°Est√° muy bueno!\"\"\")\n\nSe puede escribir texto\nen varias lineas.\n¬°Est√° muy bueno!\n\n\nOtra manera de escribir texto que abarca m√∫ltiples l√≠neas es usando el car√°cter especial \\n, que representa un salto de l√≠nea.\n\nprint(\"Primera l√≠nea\\nsegunda l√≠nea\\ntercera l√≠nea.\")\n\nPrimera l√≠nea\nsegunda l√≠nea\ntercera l√≠nea.\n\n\nEn cambio, si mostramos una representaci√≥n del texto (sin usar print()), los \\n s√≠ se visualizan.\n\n\"Primera l√≠nea\\nsegunda l√≠nea\\ntercera l√≠nea.\"\n\n'Primera l√≠nea\\nsegunda l√≠nea\\ntercera l√≠nea.'\n\n\n\n\n\n\n\n\n¬°Atencion! ü§ì\n\n\n\n¬øCu√°l es la diferencia entre usar print() y no usarlo?\n\nCuando usamos print() se imprime el objeto de una manera humanamente legible.\nCuando no lo usamos, se muestra una representaci√≥n del objeto. Esta representaci√≥n tiene que ser lo menos ambigua posible.\n\nPor este motivo es que se muestran las comillas a la hora de representar una cadena.\n\n\n\n\nOtra situaci√≥n en la que usar print() genera una diferencia es cuando se quieren mostrar varios objetos en una notebook. Por ejemplo, comparemos el resultado de los siguientes bloques:\n\n\"mensaje 1\"\n10\n\"mensaje 2\"\n\n'mensaje 2'\n\n\n\nprint(\"mensaje 1\")\nprint(10)\nprint(\"mensaje 2\")\n\nmensaje 1\n10\nmensaje 2\n\n\n\n\nL√≥gicos (o Booleanos)\nComo veremos m√°s adelante, nuestros programas suelen tener que decidir entre diferentes acciones a tomar seg√∫n se cumpla o no cierta condici√≥n.\nPara representar esta situaci√≥n utilizamos un tipo especial de dato conocido como l√≥gico o booleano, que puede tomar √∫nicamente dos valores: True o False.\nSi la condici√≥n se cumple, el resultado ser√° True; de lo contrario, ser√° False.\n\nTrue\n\nTrue\n\n\n\nFalse\n\nFalse\n\n\n\ntype(True)\n\nbool\n\n\n\ntype(False)\n\nbool\n\n\n\n\n\n\n\n\nRese√±a hist√≥rica üìú\n\n\n\nEste tipo de datos se llama Booleano en honor al matem√°tico George Boole.\n\n\n\n\nNulo\nEl valor nulo, llamado None en Python, representa la ausencia de valor o el vac√≠o. Se utiliza habitualmente para indicar que algo no tiene un valor asignado. Si intentamos mostrar el valor de None, veremos que no aparece nada.\n\nNone\n\nEn cambio, si imprimimos el objeto None, vemos el mensaje None.\n\nprint(None)\n\nNone\n\n\n¬øY cu√°l es su tipo?\n\ntype(None)\n\nNoneType\n\n\nSolamente los objetos None son del tipo NoneType.\n\n\n\n\n\n\n¬øPor qu√© existe el valor nulo? ü§î\n\n\n\nMuchas veces nuestro programa, o alguna parte del mismo, realiza una tarea que no devuelve ning√∫n resultado.\nPodr√≠amos ponernos de acuerdo en representar ‚Äúning√∫n resultado‚Äù usando un n√∫mero (e.g., 0), una cadena vac√≠a (\"\"), o algo similar. Pero estos valores representan algo espec√≠fico, no la ausencia total de valor.\nPara expresar claramente que no hay ning√∫n resultado, Python incluye un valor especial llamado None.\n\n\nEjemplos\n\nUn usuario completa un formulario con datos personales, pero algunos campos no son obligatorios y quedan sin completar.\nUna funci√≥n busca un elemento en una lista; cuando no encuentra lo buscado, devuelve un valor especial indicando que el resultado est√° ausente.\n\nEn general, cuando se quiera representar la ausencia de informaci√≥n se utilizar√° None.\n\n\n\n\n\n\nObservaci√≥n üëÄ\n\n\n\nEn R existen dos tipos de datos para representar valores faltantes: NULL y NA. El None de Python equivale a NULL en R, ya que ambos indican ausencia de valor.\nPor otro lado, NA en R representa un valor existente pero desconocido, por ejemplo, porque se ha perdido. Python no ofrece un tipo de dato equivalente de forma nativa, aunque algunas librer√≠as s√≠ lo implementan.\n\n\n\n\nConversi√≥n entre tipos de datos\nQue existan distintos tipos de datos no significa que un objeto de un tipo no pueda ‚Äúconvertirse‚Äù a otro.\nEn muchos casos es posible convertir entre tipos de datos. Por ejemplo, un n√∫mero siempre se puede convertir a una cadena de caracteres, pero no cualquier cadena puede convertirse a un n√∫mero.\nPara convertir un objeto a otro tipo utilizamos funciones con el nombre del tipo al que queremos convertir, como str(), int() o bool(). Estas funciones reciben como argumento el objeto a convertir.\nVeamos algunos ejemplos:\n\nstr(256)\n\n'256'\n\n\n\nstr(None)\n\n'None'\n\n\n\nint(165.5)\n\n165\n\n\n\nint(165.8)\n\n165\n\n\n\nint(\"165\")\n\n165\n\n\n\nfloat(\"165.0\")\n\n165.0\n\n\n\n\nResumen\n\nPython tiene distintos tipos de datos.\nCada tipo de dato es √∫til para resolver diferentes problemas.\n\nA lo largo de la materia veremos much√≠simos ejemplos.\n\nAl principio, tener varios tipos de datos puede parecer complejo.\n\nSin embargo, nos resultar√°n muy naturales a medida que los usemos para resolver problemas concretos.\n\n\n\n\n\n\n\n\n\nTipo de dato\nEjemplos\n\n\n\n\nN√∫meros enteros (int)\n-2, -1, 0, 10, 200\n\n\nN√∫meros de punto flotante (float)\n-200.789, -1.0, 0.0, 17.8\n\n\nCadenas de texto (str)\n\"a\", \"abc\", \"Rosario, Santa Fe\"\n\n\nBooleanos (bool)\nTrue, False\n\n\nValor nulo (NoneType)\nNone",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "Introducci√≥n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#variables",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#variables",
    "title": "Introducci√≥n",
    "section": "Variables",
    "text": "Variables\n¬øEs necesario escribir expl√≠citamente los valores con los que trabajamos cada vez que los usamos? Afortunadamente, la respuesta es no.\nLos lenguajes de programaci√≥n m√°s populares permiten usar variables.\nPodemos pensar las variables como etiquetas o nombres que asignamos a los objetos en nuestro programa.\nUna vez creada una variable con cierto valor, podemos usar directamente su nombre en lugar de volver a escribir el valor completo.\n\nmensaje = \"¬°Hola, curso!\"\nprint(mensaje)\n\n¬°Hola, curso!\n\n\n\nprint(\"¬°Hola, curso!\")\n\n¬°Hola, curso!\n\n\nPara crear una variable se necesita:\n\nEl nombre.\nEl operador de asignaci√≥n.\nEl valor que queremos asignar a la variable.\n\nEn nuestro caso, el nombre de la variable es mensaje y el valor es \"¬°Hola, curso!\".\nLuego, cuando accedemos a la variable mensaje dentro de la funci√≥n print(), Python nos devuelve el valor de la variable, es decir, ¬°Hola, curso!\".\nVeamos otros ejemplos‚Ä¶\n\npi = 3.14159\nfruta_favorita = \"manzana\"\npython_bueno = True\n\nEn el siguiente diagrama se muestra c√≥mo las variables que creamos funcionan simplemente como etiquetas para los valores asignados.\nCada vez que utilizamos una de estas etiquetas, accedemos directamente al valor que representa.\n\n\n\n\n\n\nprint(pi * 10)\n\n31.4159\n\n\n\nfruta_favorita\n\n'manzana'\n\n\n\npython_bueno\n\nTrue\n\n\nLas variables no solo evitan que escribamos repetidamente los mismos valores en nuestro programa, sino que tambi√©n permiten:\n\nGeneralizar el programa\n\nAl cambiar el valor de una variable, todas las partes del programa que la usan se actualizan autom√°ticamente.\n\nMejorar la legibilidad del c√≥digo\n\nSi elegimos nombres claros y descriptivos, el programa ser√° mucho m√°s f√°cil de leer y entender.\n\n\nPor ejemplo, los siguientes bloques de c√≥digo producen el mismo resultado, pero el segundo es mucho m√°s informativo:\n\n1500 * 8\n\n12000\n\n\n\nprecio = 1500\ncantidad = 8\nprecio * cantidad\n\n12000\n\n\n\nNombres permitidos\nNo todos los nombres que imaginemos se pueden utilizar como variables en Python.\nTenemos que tener en cuenta las siguientes reglas. Los nombres de variables‚Ä¶\n\nSolo pueden contener letras, n√∫meros y guiones bajos (_).\nDeben comenzar con una letra o un gui√≥n bajo, pero no con un n√∫mero.\n\nPor ejemplo, mensaje_1 es v√°lido, pero 1_mensaje no lo es.\n\nNo pueden contener espacios.\n\nPor eso usamos fruta_favorita en lugar de fruta favorita.\n\nNo pueden ser palabras reservadas de Python.\n\nLas palabras reservadas se encuentran al final de este apunte.\n\n\nAdem√°s, tambi√©n vale la pena tener presente estos consejos:\n\nUs√° nombres breves pero descriptivos.\n\nnombre es preferible a n.\nfruta_favorita es preferible a frut_fav.\n\nEvit√° utilizar tildes, la letra √± u otros caracteres espec√≠ficos del castellano.\n\n\n\nEliminar variables\nEs posible que, despu√©s de crear nuestras variables y realizar las operaciones necesarias, queramos eliminarlas.\nPara borrar una variable, Python ofrece la sentencia del (del ingl√©s delete, que significa eliminar o borrar).\n\ndel fruta_favorita\n\n\n\nAsignaci√≥n m√∫ltiple\nYa vimos que para asignar (o crear) una variable necesitamos hacer variable = &lt;valor&gt;.\nSi queremos crear varias variables, podemos hacerlo en l√≠neas separadas:\n\npi = 3.1416\ne = 2.7182\n\nprint(pi)\nprint(e)\n\n3.1416\n2.7182\n\n\nUna caracter√≠stica conveniente de Python es que permite asignar m√∫ltiples variables en una misma l√≠nea:\n\npi, e = 3.1416, 2.7182\n\nprint(pi)\nprint(e)\n\n3.1416\n2.7182\n\n\nOtra ventaja es que las variables no tienen que ser del mismo tipo:\n\na, b, c = 100 + 20, \"un mensaje cualquiera\", None\n\nprint(a)\nprint(b)\nprint(c)\n\n120\nun mensaje cualquiera\nNone\n\n\nEsta t√©cnica es √∫til para escribir c√≥digo m√°s conciso, pero no conviene abusar de ella porque puede resultar en c√≥digo poco legible.\n\n\n\n\n\n\nObservaci√≥n üëÄ\n\n\n\nLa vida es m√°s compleja de lo que parece, y los lenguajes de programaci√≥n no son una excepci√≥n.\nEn Python, lo que parece una asignaci√≥n m√∫ltiple de variables es en realidad el uso de una t√©cnica m√°s avanzada llamada unpacking.\nA no desesperarse, m√°s adelante vamos a aprender de qu√© se trata.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "Introducci√≥n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#operadores",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#operadores",
    "title": "Introducci√≥n",
    "section": "Operadores",
    "text": "Operadores\nLos operadores son s√≠mbolos que se utilizan para realizar operaciones o acciones sobre los objetos con los que estamos trabajando.\nHasta ahora, vimos que podemos tener n√∫meros, texto, y otras objetos un poco mas extra√±os como los booleanos e incluso algo que representa a la nada misma.\nA continuaci√≥n, comenzamos a ver algunas de las tareas que podemos hacer con ellos.\n\nOperadores aritm√©ticos\nPython incluye los mismos operadores aritm√©ticos que solemos utilizar en nuestro d√≠a a d√≠a para hacer operaciones matem√°ticas.\nEstos se parecen much√≠simo a los que usamos en una calculadora, por lo que podr√≠amos entenderlo incluso sin saber de Python.\nAlgunos operadores son los siguientes:\n\nSuma (+)\nResta (-)\nMultiplicaci√≥n (*)\nPotencia (**)\nDivisi√≥n (/)\nDivisi√≥n entera (//)\nM√≥dulo (%)\n\n\nSuma (+)\n\n10 + 25\n\n35\n\n\n\n10.0 + 25.0\n\n35.0\n\n\n\n-8 + 12.1\n\n4.1\n\n\nEl operador suma tambi√©n puede ser usado con un solo argumento:\n\n+ 8\n\n8\n\n\nEn este caso no modifica en nada al valor 8.\n\n\n\nResta (-)\n\n11 - 8\n\n3\n\n\n\n100 - 100.0\n\n0.0\n\n\n\n-35 - 28\n\n-63\n\n\nEl operador resta tambi√©n puede ser usado con un solo argumento:\n\n- 7\n\n-7\n\n\n\n\nMultiplicaci√≥n (*) y potencia (**)\n\n21 * 5\n\n105\n\n\n\n21 * 5.0\n\n105.0\n\n\n\n21.0 * 5.0\n\n105.0\n\n\n\n2 ** 3\n\n8\n\n\n\n2 ** 3.0\n\n8.0\n\n\n\n\n\n\n\n\nConclusiones\n\n\n\nPara las operaciones de suma, resta, multiplicaci√≥n y potencia se cumple:\n\nSi ambos valores son enteros, el resultado ser√° un entero.\nSi al menos uno de los valores es flotante, el resultado ser√° flotante.\n\n\n\n\n\nDivisi√≥n (/ y //)\nPython provee dos operadores distintos para calcular el cociente entre dos n√∫meros.\n\nEl operador / que calcula la divisi√≥n flotante.\nEl operador // que calcula la divisi√≥n entera.\n\nEl operador / es el que m√°s se utiliza y siempre devuelve un n√∫mero de tipo flotante.\n\n10 / 5\n\n2.0\n\n\n\n10 / 5.5\n\n1.8181818181818181\n\n\nLa divisi√≥n entera se suele utilizar cuando uno quiere el resultado entero de la divisi√≥n, sin importar si el resto es 0 o no.\n\n10 // 5\n\n2\n\n\n\n10 // 5.5\n\n1.0\n\n\nVeamos los siguientes ejemplos donde comparamos la divisi√≥n flotante con la divisi√≥n entera, utilizando los mismos argumentos.\n\n15 / 4\n\n3.75\n\n\n\n15.0 // 4.0\n\n3.0\n\n\nConclusi√≥n: La divisi√≥n entera no redondea el resultado de la divisi√≥n flotante. M√°s sobre esto debajo.\n\n\nM√≥dulo (%)\nOtro operador relacionado a la divisi√≥n entera es el operador m√≥dulo o resto (%).\nEsta operaci√≥n nos devuelve el resto que se obtiene al realizar la divisi√≥n entera entre dos n√∫meros.\n\n17 % 3\n\n2\n\n\nDebajo se puede ver la relaci√≥n entre la divisi√≥n entera y el m√≥dulo:\n\n\n\n\n\nAunque ahora pueda parecer dif√≠cil encontrar una aplicaci√≥n pr√°ctica para los operadores de divisi√≥n entera // y resto %, m√°s adelante veremos ejemplos donde haremos un uso intensivo de ellos.\n\n\n\n\n\n\nObservaci√≥n üëÄ\n\n\n\nProbablemente en R hayan utilizado principalmente el operador /, que tambi√©n corresponde a la divisi√≥n flotante.\nEn ese lenguaje, los operadores para divisi√≥n entera y resto son %/% y %%, respectivamente.\n\n\n\n\nPrioridad de los operadores\nHasta ahora vimos operaciones bastante sencillas.\nCuando presentamos la suma, realizamos simplemente una suma. Cuando presentamos la multiplicaci√≥n, hicimos solo una multiplicaci√≥n.\nPor supuesto, al momento de hacer c√°lculos podemos combinar los operadores que ya conocemos, de la misma forma en que lo hacemos al resolver cuentas a mano.\nUn punto importante a tener en cuenta es que, al igual que cuando hacemos cuentas a mano, algunas operaciones se resuelven antes que otras, sin importar el orden en que aparecen. Esto ocurre porque algunos operadores tienen mayor prioridad y, por lo tanto, se eval√∫an antes.\nEn el siguiente ejemplo, ¬øpor qu√© se obtienen resultados distintos?\n\n10 - 2 * 4\n\n2\n\n\n\n(10 - 2) * 4\n\n32\n\n\nIndependientemente de que el s√≠mbolo + aparezca antes que el s√≠mbolo * en una expresi√≥n, Python realiza primero la multiplicaci√≥n.\nAl igual que cuando hacemos cuentas a mano, la multiplicaci√≥n tiene mayor prioridad que la suma.\nSi queremos forzar a Python a realizar una operaci√≥n antes que otra, sin importar la prioridad de los operadores, debemos usar par√©ntesis.\nOtro ejemplo es el siguiente‚Ä¶\n\n7 + 8 / 2\n\n11.0\n\n\n\n(7 + 8) / 2\n\n7.5\n\n\nA continuaci√≥n se incluye una tabla con los operadores que vimos y la prioridad que tiene cada uno.\nLos operadores que aparecen m√°s arriba tienen mayor prioridad.\nLos operadores que aparecen en la misma fila tienen el mismo nivel de prioridad y se resuelven seg√∫n el orden en que aparecen en el c√≥digo (de izquierda a derecha).\n\n\n\n\n\n\n\nOperador\nSignificado\n\n\n\n\n()\nAgrupamiento\n\n\n**\nPotencia\n\n\n*, /, //, %\nMultiplicaci√≥n, Divisi√≥n, Divisi√≥n entera, M√≥dulo\n\n\n+, -\nSuma, Resta\n\n\n\nEsta lista es una versi√≥n m√°s sencilla y resumida de la tabla de prioridades de todos los operadores que hay en Python. Una versi√≥n m√°s completa se puede encontrar en Programiz.\n\n\n\nOperadores l√≥gicos\nLos operadores l√≥gicos en Python son tres: not, and y or. Se llaman as√≠ porque combinan expresiones l√≥gicas (o directamente valores l√≥gicos) y devuelven tambi√©n valores l√≥gicos, es decir, del tipo bool, que pueden ser True o False. Estos operadores se utilizan para combinar o invertir condiciones en expresiones l√≥gicas.\n\nNegaci√≥n (not)\nDevuelve el opuesto del valor que le pasamos.\n\nnot False\n\nTrue\n\n\n\nnot True\n\nFalse\n\n\n\n\nConjunci√≥n o intersecci√≥n (and)\nEsta operaci√≥n devuelve True solamente cuando los dos operadores que le pasamos son True.\n\nTrue and True\n\nTrue\n\n\n\nFalse and True\n\nFalse\n\n\n\n\nDisyunci√≥n o uni√≥n (or)\nEsta operaci√≥n devuelve True cuando cualquiera de sus argumentos es True.\n\nTrue or False\n\nTrue\n\n\nSolo devuelve False cuando sus dos argumentos son False.\n\nFalse or False\n\nFalse\n\n\n\n\n\nOperadores de comparaci√≥n\n\nComparaci√≥n por identidad\nPython ofrece dos operadores para verificar si dos objetos son o no el mismo en identidad (es decir, en memoria):\n\nis: devuelve True si ambos operandos son el mismo objeto.\nis not: devuelve True si los operandos no son el mismo objeto.\n\n\nFalse is False\n\nTrue\n\n\n\nFalse is True\n\nFalse\n\n\n\nNone is None\n\nTrue\n\n\nEste tipo de comparaci√≥n es posible porque cada objeto en Python existe en la memoria de la computadora y tiene una identificaci√≥n √∫nica (ID). Para conocer el ID de un objeto, se puede usar la funci√≥n id().\n\nid(False)\n\n94152411564800\n\n\n\nid(False)\n\n94152411564800\n\n\n\nid(None)\n\n94152411476128\n\n\n\n\nComparaci√≥n por valor\nPor otro lado, Python tambi√©n provee operadores para realizar comparaciones entre objetos en t√©rminos de sus valores.\nLos operadores que vemos a continuaci√≥n son los mismos que aprendimos en la secundaria.\n\n\n\n\n\n\n\nOperador\nDescripci√≥n\n\n\n\n\n==\nIgualdad: El resultado es True cuando los dos operandos son iguales.\n\n\n!=\nDesigualdad: El resultado es True si los operandos son distintos.\n\n\n&gt;\nMayor a: El resultado es True si el operando de la izquierda es mayor que el de la derecha.\n\n\n&gt;=\nMayor o igual a: El resultado es True si el operando de la izquierda es mayor o igual que el de la derecha.\n\n\n&lt;\nMenor a: El resultado es True si el operando de la izquierda es menor que el de la derecha.\n\n\n&lt;=\nMenor o igual a: El resultado es True si el operando de la izquierda es menor o igual que el de la derecha.\n\n\n\nAlgunos ejemplos‚Ä¶\n\n10 &gt; 5\n\nTrue\n\n\n\n10 &gt; 5 + 3\n\nTrue\n\n\n\n0 &lt; 0\n\nFalse\n\n\n\n1 &gt;= 1\n\nTrue\n\n\n\n10.0 != 10\n\nFalse\n\n\n\n10.0 == 10\n\nTrue\n\n\nA pesar de que 10.0 es de tipo flotante y 10 es de tipo entero, vemos que la comparaci√≥n de igualdad == dice que son iguales.\nNo siempre que comparemos objetos de distinto tipo va a suceder algo as√≠.\nLa comparaci√≥n de cadenas de texto distingue may√∫sculas de min√∫sculas\n\n\"UNR\" == \"unr\"\n\nFalse\n\n\nEs posible comparar objetos de distinto tipo, como lo vimos en el ejemplo anterior donde comparamos 10 y 10.0.\nSalvo casos particulares, como son los valores num√©ricos, estos objetos son considerados siempre distintos.\n\n\"10\" == 10\n\nFalse\n\n\n\n\"False\" == False\n\nFalse\n\n\nEs posible combinar mas de una comparaci√≥n en la misma l√≠nea.\n\n1 &lt; 2 and 2 &lt; 3\n\nTrue\n\n\nIncluso es posible omitir el operador and y tener una expresi√≥n m√°s clara\n\n1 &lt; 2 &lt; 3\n\nTrue\n\n\n\n-5 &lt; -4 &lt; -3\n\nTrue\n\n\nTambi√©n podemos mezclar not, and y or a gusto.\n\nFalse or not False\n\nTrue\n\n\nY es v√°lido utilizar par√©ntesis para agrupar operaciones.\n\n(False or True) and (True or False)\n\nTrue\n\n\nA continuaci√≥n se incluye una tabla con los operadores de comparaci√≥n y la prioridad que tiene cada uno.\nLos operadores que aparecen m√°s arriba tienen mayor prioridad.\nLos operadores que aparecen en la misma fila tienen el mismo nivel de prioridad y se resuelven seg√∫n el orden en que aparecen en el c√≥digo (de izquierda a derecha).\n\n\n\n\n\n\n\nOperadores\nSignificado\n\n\n\n\n==, !=, &gt;, &gt;=, &lt;, &lt;=, is, is not, in, not in\nComparaciones, identidad, pertenencia\n\n\nnot\nNegaci√≥n\n\n\nand\nConjunci√≥n o intersecci√≥n\n\n\nor\nDisyunci√≥n o uni√≥n\n\n\n\nTodos los operadores de comparaci√≥n tienen menor prioridad que los operadores aritm√©ticos que vimos arriba.\nEn otras palabras, si pegaramos ambas tablas, √©sta √∫ltima quedar√≠a por debajo.\nAnalicemos nuevamente uno de los ejemplos que ya vimos.\n\nnot True and not True\n\nFalse\n\n\nEl operador not tiene mayor prioridad que el operador and porque aparece primero en la tabla.\nEn consecuencia, en el c√≥digo anterior primero se resuelven los not True y luego el and. Esto es lo mismo que hacer\n\nFalse and False\n\nFalse\n\n\n\n\n\n\n\n\nResumen üìù\n\n\n\nExisten dos operadores para comparar igualdad entre dos objetos de Python:\n\n== ‚Üí compara el valor (contenido).\nis ‚Üí compara la identidad (ubicaci√≥n en memoria).",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "Introducci√≥n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#operaciones-con-cadenas-de-caracteres",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#operaciones-con-cadenas-de-caracteres",
    "title": "Introducci√≥n",
    "section": "Operaciones con cadenas de caracteres",
    "text": "Operaciones con cadenas de caracteres\n\nSuma y producto\nAunque al principio pueda parecer extra√±o, en Python es posible usar operadores matem√°ticos con objetos que no son num√©ricos.\nEsto no significa que se puedan aplicar a cualquier objeto, ni que est√©n disponibles todos los operadores en esos casos.\nSin embargo, vale la pena resaltar el uso del operador de suma (+) y producto (*) con las cadenas de caracteres.\nVeamos que pasa si ‚Äúsumamos‚Äù dos cadenas de caracteres:\n\n\"¬øFunciona\" + \"bien?\"\n\n'¬øFuncionabien?'\n\n\n\n\"¬øesto\" + \" tambi√©n \" + \"funciona?\"\n\n'¬øesto tambi√©n funciona?'\n\n\nComo se puede observar, el operador de suma (+) aplicado a cadenas de texto indica concatenaci√≥n: crea una nueva cadena uniendo el contenido de las cadenas originales, en el mismo orden.\nSi la suma tiene sentido para cadenas, entonces el producto tambi√©n deber√≠a tenerlo (al menos con n√∫meros enteros). Veamos un ejemplo:\n\n\"ja\" * 2\n\n'jaja'\n\n\n\n\"ja\" * 4\n\n'jajajaja'\n\n\nDe manera coherente con la definici√≥n de producto para enteros, multiplicar una cadena por un n√∫mero entero N equivale a concatenar esa cadena consigo misma N veces.\n\n\nCadenas formateadas (formatted strings)\nLas cadenas de texto formateadas son de gran utilidad para crear una cadena de texto a partir de otros objetos.\nEn Python se las conoce como f-strings (abreviaci√≥n de formatted-strings) y tienen este nombre porque tenemos que poner una f antes de las comillas.\nEl resultado de una f-string no se diferencia de una cadena de texto com√∫n y corriente.\n\nf\"Un texto cualquiera\"\n\n'Un texto cualquiera'\n\n\nSin embargo, las f-strings nos permiten interpolar cadenas de texto.\n¬øQu√© es interpolar texto?\nVeamos algunos ejemplos.\n\nlenguaje = \"Python\"\nprint(\"Programando en \" + lenguaje)\n\nProgramando en Python\n\n\n\nque = \"bayer\"\ncomo = \"bueno\"\nprint(\"Si es \" + que + \" es \" + como + \".\")\n\nSi es bayer es bueno.\n\n\nEl proceso se vuelve un poco engorroso. Hay que estar atentos a las sumas y los espacios para que el resultado quede formateado de una manera correcta.\nLas f-strings vienen a facilitar este proceso y hacerlo menos tedioso.\nLo que tenemos que hacer es pasar el nombre de la variable entre llaves ({}) en el contenido de la f-string.\n\nprint(f\"Programando en {lenguaje}\")\nprint(f\"Si es {que} es {como}.\")\n\nProgramando en Python\nSi es bayer es bueno.\n\n\nVeamos un ejemplo menos trivial, donde utilizar f-strings reduce la cantidad de c√≥digo y lo hace m√°s claro.\n\nnombre = \"Tom√°s\"\nedad = 29\nciudad = \"Rosario\"\n\nprint(\"Hola, soy \" + nombre + \", tengo \" + str(edad) + \" a√±os y vivo en \" + ciudad + \".\")\n\nHola, soy Tom√°s, tengo 29 a√±os y vivo en Rosario.\n\n\nUtilizando f-strings‚Ä¶\n\nprint(f\"Hola, soy {nombre}, tengo {edad} a√±os y vivo en {ciudad}.\")\n\nHola, soy Tom√°s, tengo 29 a√±os y vivo en Rosario.\n\n\nAdem√°s, no es necesario convertir la variable edad a al tipo str manualmente.\nNo solo podemos utilizar variables dentro de las f-strings, tambi√©n podemos incluir expresiones de Python.\n\nminutos_por_hora = 60\nhoras = 2.7\n\nprint(f\"En {horas} horas hay {horas * minutos_por_hora} minutos.\")\n\nEn 2.7 horas hay 162.0 minutos.\n\n\n\n\nCadenas de texto y sus met√≥dos\n\nnombre = \"Lionel Messi\"\n\nLas cadenas de texto, es decir, los objetos de tipo str, vienen con varias funciones (llamados ‚Äúm√©todos‚Äù) que nos facilitan much√≠simas tareas en la pr√°ctica.\nPor ejemplo, tenemos los m√©todos .upper() y .lower(), que ponen el texto en may√∫scula y en min√∫scula, respectivamente.\n\nprint(nombre.upper())\nprint(nombre.lower())\n\nLIONEL MESSI\nlionel messi\n\n\nTambi√©n tenemos .capitalize(), que pone la primer letra en may√∫scula y el resto en min√∫sculas.\nEstos m√©todos se pueden combinar dentro de una f-string, sin necesidad de modificar los valores de nombre o apellido.\n\nnombre = \"lionel\"\napellido = \"messi\"\nnombre_completo = f\"{nombre.capitalize()} {apellido.capitalize()}\"\nprint(nombre_completo)\n\nLionel Messi\n\n\nOtra opci√≥n es usar .title().\nEste m√©todo pone la primera letra de cada palabra en may√∫sculas y al resto en min√∫sculas.\n\nmensaje = \"mensaje de prueba\"\nprint(mensaje.capitalize())\nprint(mensaje.title())\n\nMensaje de prueba\nMensaje De Prueba\n\n\n\n\nEliminar espacios en blanco\nEs muy com√∫n que en nuestros programas tengamos que lidiar con texto que vienen con espacios en blanco que est√°n dem√°s.\nEl espacio puede estar tanto al principio como al final de una cadena de texto.\nAfortunadamente, Python tambi√©n provee algunos m√©todos que nos permiten eliminar estos espacios con muy poco trabajo.\n\nlenguaje_favorito = \"  python  \"\nlenguaje_favorito\n\n'  python  '\n\n\n.rstrip() elimina los espacios en blanco a la derecha del texto.\n\nlenguaje_favorito.rstrip()\n\n'  python'\n\n\n.lstrip() elimina los espacios en blanco a la izquierda del texto.\n\nlenguaje_favorito.lstrip()\n\n'python  '\n\n\ny .strip() elimina los espacios en blanco a la izquierda y a la derecha del texto.\n\nlenguaje_favorito.strip()\n\n'python'\n\n\n\n\nReemplazar y eliminar caracteres no deseados\nTambi√©n es frecuente que el texto contenga caracteres err√≥neos, o caracteres que simplemente no queremos conservar.\nPara estos casos podemos usar el m√©todo .replace().\nA diferencia de los m√©todos que vimos hasta ahora, .replace() requiere que le pasemos algunos argumentos.\nEl primer valor que le pasamos es el texto que queremos reemplazar y el segundo es el texto de reemplazo.\nPodemos reemplazar caracteres, palabras, o frases enteras.\n\nanimal = \"pato\"\nanimal.replace(\"p\", \"g\")\n\n'gato'\n\n\n\nsaludo = \"Hola Mundo\"\nsaludo.replace(\"Mundo\", \"Curso\")\n\n'Hola Curso'\n\n\nCuando utilizamos el m√©todo .replace() se nos devuelve una nueva cadena de texto.\nEsto nos permite ‚Äúpegar‚Äù o ‚Äúencadenar‚Äù mas de un .replace() a la vez, ya que cada nuevo .replace() se aplica sobre el resultado de la operaci√≥n anterior.\n\nsaludo.replace(\"Mundo\", \"Curso\").replace(\"Hola\", \"Chau\")\n\n'Chau Curso'\n\n\nsaludo.replace(\"Mundo\", \"Curso\") devuelve \"Hola Curso\", al que luego se le aplica .replace(\"Hola\", \"Chau\") y el resultado final es \"Chau Curso\".",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "Introducci√≥n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#ap√©ndice",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#ap√©ndice",
    "title": "Introducci√≥n",
    "section": "Ap√©ndice",
    "text": "Ap√©ndice\n\nPalabras claves y funciones predefinidas\nPython tiene un conjunto de palabras conocidas como keywords que sirven para realizar acciones especificas y que no podemos utilizar como nombres de variables.\nCuando intentemos utilizar una keyword como nombre de variable, obtendremos un error.\nPor otro lado, si intentamos utilizar el nombre de una funci√≥n (o clase) predefinida como nombre de una variable que nosotros creamos, no vamos a obtener un error pero no podremos usar la funci√≥n nuevamente porque la variable ahora representa otra cosa.\n\nPalabras claves\nFalse      await      else       import     pass\nNone       break      except     in         raise\nTrue       class      finally    is         return\nand        continue   for        lambda     try\nas         def        from       nonlocal   while\nassert     del        global     not        with\nasync      elif       if         or         yield\n\n\nFunciones y clases pre-definidas\nabs()          copyright()    getattr()      list()         range()        vars()\nall()          credits()      globals()      locals()       repr()         zip()\nany()          delattr()      hasattr()      map()          reversed()\nascii()        dict()         hash()         max()          round()\nbin()          dir()          help()         memoryview()   set()\nbool()         display()      hex()          min()          setattr()\nbreakpoint()   divmod()       id()           next()         slice()\nbytearray()    enumerate()    input()        object()       sorted()\nbytes()        eval()         int()          oct()          staticmethod()\ncallable()     exec()         isinstance()   open()         str()\nchr()          filter()       issubclass()   ord()          sum()\nclassmethod()  float()        iter()         pow()          super()\ncompile()      format()       len()          print()        tuple()\ncomplex()      frozenset()    license()      property()     type()\n\n\nM√©todos de las cadenas de texto\n\n\n\n\n\n\n\n\n\nM√©todo\nDescripci√≥n\nEjemplo\nResultado\n\n\n\n\n.endswith(sufijo)\nVerifica si termina con el sufijo\n\"file.txt\".endswith(\".txt\")\nTrue\n\n\n.find(x)\nLa posicion de la primera aparici√≥n de x en la cadena (o -1 si no est√°)\n\"Python\".find(\"t\")\n2\n\n\n.index(x)\nLa posicion de la primera aparici√≥n de x en la cadena (error si no est√°)\n\"Python\".index(\"n\")\n5\n\n\n.isalpha()\nVerifica si los caracteres son alfab√©ticos\n\"256\".isalpha()\nFalse\n\n\n.isdigit()\nVerifica si los caracteres son num√©ricos\n\"256\".isdigit()\nTrue\n\n\n.islower()\nVerifica si los caracteres son min√∫sculas\n\"Python\".islower()\nFalse\n\n\n.isupper()\nVerifica si los caracteres son may√∫sculas\n\"Python\".isupper()\nFalse\n\n\n.join(lista)\nUne una lista de cadenas usando la cadena como delimitador\n\" y \".join([\"esto\", \"aquello\"])\n\"esto y aquello\"\n\n\n.lower()\nConvertir a min√∫sculas\n\"Python\".lower()\n\"python\"\n\n\n.replace(viejo, nuevo)\nReemplaza texto\n\"maximo\".replace(\"ax\", \"in\")\n\"minimo\"\n\n\n.split(sep)\nParte la cadena en una lista de subcadenas\n\"esto y aquello\".split(\" y \")\n[\"esto\", \"aquello\"]\n\n\n.startswith(prefijo)\nVerifica si comienza con un prefijo\n\"file.txt\".endswith(\"a\")\nFalse\n\n\n.strip()\nElimina espacios en blanco al inicio o al final\n\" oh la la \".strip()\n\"oh la la\"\n\n\n.upper()\nConvierte a may√∫sculas\n\"Python\".upper()\n\"PYTHON\"",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "Introducci√≥n"
    ]
  },
  {
    "objectID": "informacion/programa.html",
    "href": "informacion/programa.html",
    "title": "Programa",
    "section": "",
    "text": "Los profesionales en Estad√≠stica y Ciencia de Datos necesitan contar con habilidades avanzadas de programaci√≥n, que les permitan abordar problemas complejos y desarrollar soluciones eficientes y robustas.\nLa asignatura Programaci√≥n 2 introduce a los estudiantes a conceptos y pr√°cticas avanzadas de la programaci√≥n, incorporando herramientas y paradigmas que resultan fundamentales para el desarrollo profesional en Estad√≠stica y Ciencia de Datos.\nLa asignatura profundiza en enfoques como la programaci√≥n funcional y la programaci√≥n orientada a objetos, promoviendo el desarrollo de soluciones estructuradas, reutilizables, robustas y escalables. Adem√°s, se abordan conceptos fundamentales de estructuras de datos y algoritmos, relevantes para el dise√±o y an√°lisis de programas eficientes, as√≠ como para la comprensi√≥n de la complejidad computacional. Se focaliza en el lenguaje Python, ampliamente utilizado en la industria y la academia por su versatilidad, su ecosistema de librer√≠as y su capacidad para integrarse con diversas tecnolog√≠as.\nDictada en el segundo cuatrimestre del primer a√±o, Programaci√≥n 2 completa los contenidos del √°rea de Fundamentos Computacionales en el Ciclo de Formaci√≥n T√©cnica en Estad√≠stica y Ciencia de Datos, iniciada en el primer cuatrimestre con Programaci√≥n 1. De este modo, consolida las competencias inform√°ticas de los estudiantes y los prepara para afrontar asignaturas m√°s avanzadas y desaf√≠os profesionales que requieren un dominio s√≥lido de la programaci√≥n. Asimismo, fomenta buenas pr√°cticas de desarrollo de c√≥digo, el uso eficiente de los recursos computacionales y el pensamiento cr√≠tico en la resoluci√≥n de problemas.",
    "crumbs": [
      "Informaci√≥n",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/programa.html#fundamentaci√≥n",
    "href": "informacion/programa.html#fundamentaci√≥n",
    "title": "Programa",
    "section": "",
    "text": "Los profesionales en Estad√≠stica y Ciencia de Datos necesitan contar con habilidades avanzadas de programaci√≥n, que les permitan abordar problemas complejos y desarrollar soluciones eficientes y robustas.\nLa asignatura Programaci√≥n 2 introduce a los estudiantes a conceptos y pr√°cticas avanzadas de la programaci√≥n, incorporando herramientas y paradigmas que resultan fundamentales para el desarrollo profesional en Estad√≠stica y Ciencia de Datos.\nLa asignatura profundiza en enfoques como la programaci√≥n funcional y la programaci√≥n orientada a objetos, promoviendo el desarrollo de soluciones estructuradas, reutilizables, robustas y escalables. Adem√°s, se abordan conceptos fundamentales de estructuras de datos y algoritmos, relevantes para el dise√±o y an√°lisis de programas eficientes, as√≠ como para la comprensi√≥n de la complejidad computacional. Se focaliza en el lenguaje Python, ampliamente utilizado en la industria y la academia por su versatilidad, su ecosistema de librer√≠as y su capacidad para integrarse con diversas tecnolog√≠as.\nDictada en el segundo cuatrimestre del primer a√±o, Programaci√≥n 2 completa los contenidos del √°rea de Fundamentos Computacionales en el Ciclo de Formaci√≥n T√©cnica en Estad√≠stica y Ciencia de Datos, iniciada en el primer cuatrimestre con Programaci√≥n 1. De este modo, consolida las competencias inform√°ticas de los estudiantes y los prepara para afrontar asignaturas m√°s avanzadas y desaf√≠os profesionales que requieren un dominio s√≥lido de la programaci√≥n. Asimismo, fomenta buenas pr√°cticas de desarrollo de c√≥digo, el uso eficiente de los recursos computacionales y el pensamiento cr√≠tico en la resoluci√≥n de problemas.",
    "crumbs": [
      "Informaci√≥n",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/programa.html#objetivos",
    "href": "informacion/programa.html#objetivos",
    "title": "Programa",
    "section": "Objetivos",
    "text": "Objetivos\nQue los estudiantes logren:\n\nanalizar problemas computacionales y formular soluciones algor√≠tmicas adecuadas;\nimplementar esas soluciones mediante el desarrollo de programas en Python, seleccionando estructuras de datos apropiadas y evaluando la eficiencia de los algoritmos involucrados;\nidentificar y aplicar los paradigmas funcional y orientado a objetos cuando resulte pertinente, desarrollando programas que integren estos enfoques; y\nutilizar e integrar m√≥dulos y librer√≠as que permitan extender, organizar y mejorar las funcionalidades de sus programas.",
    "crumbs": [
      "Informaci√≥n",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/programa.html#contenidos",
    "href": "informacion/programa.html#contenidos",
    "title": "Programa",
    "section": "Contenidos",
    "text": "Contenidos\n\nUnidad 1: Introducci√≥n a Python\n\nLenguaje Python y su ecosistema. Uso de la interfaz Positron. Sintaxis de Python. Expresiones. Variables y asignaciones. Tipos de datos elementales. Operadores num√©ricos, de comparaci√≥n y l√≥gicos. Funciones. Ejecuci√≥n condicional de c√≥digo. Bucles definidos y no definidos. Listas, tuplas y diccionarios. Uso de c√≥digo externo. M√≥dulos y librer√≠as. Librer√≠a est√°ndar de Python. Instalaci√≥n y gesti√≥n de librer√≠as. Scripting. Lectura y escritura de archivos de texto plano. Modularizaci√≥n de programas.\n\nUnidad 2: Programaci√≥n funcional\n\nPrincipios fundamentales. Funciones como ciudadanos de primera clase. Funciones puras. Funciones an√≥nimas. Closures. Recursi√≥n. Funciones de orden superior: map, filter, reduce. Evaluaci√≥n estricta y no estricta. Evaluaci√≥n perezosa (lazy) e inmediata (eager). Generadores. Aplicaci√≥n parcial de funciones. Decoradores.\n\nUnidad 3: Programaci√≥n orientada a objetos\n\nPrincipios fundamentales. Objetos, clases e instancias. Atributos y m√©todos. Propiedades p√∫blicas y privadas. M√©todos de clase y m√©todos de instancia. Encapsulamiento. Herencia simple y m√∫ltiple. Polimorfismo. M√©todos especiales (dunder methods). Decoradores aplicados a m√©todos. Sobrecarga de operadores.\n\nUnidad 4: Estructuras de datos\n\nConcepto y clasificaci√≥n. Estructuras lineales: listas, listas enlazadas, pilas y colas. Operaciones b√°sicas: agregar, quitar y recorrer. Estructuras no lineales: √°rboles y grafos. Recorridos de √°rboles y grafos. Uso de colecciones de Python (list, deque, dict, set). Arreglos multidimensionales de NumPy.\n\nUnidad 5: Algoritmos de b√∫squeda y ordenamiento\n\nConcepto de algoritmo y complejidad. Notaci√≥n Big O. B√∫squeda lineal y binaria. Algoritmos de ordenamiento: bubble sort, insertion sort, selection sort, quick sort y merge sort. Comparaci√≥n de eficiencia. Funciones de b√∫squeda y ordenamiento en Python (sorted, sort, heapq).",
    "crumbs": [
      "Informaci√≥n",
      "Programa"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html",
    "href": "practica/01_programacion_en_python/autoevaluacion.html",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "",
    "text": "¬øQu√© valor contiene la variable contador luego de ejecutar el siguiente c√≥digo?\ncontador = 20\ncontador + 1\nComplete la siguiente tabla indicando si el nombre es v√°lido para una variable de Python.\n\n\n\nNombre\n¬øV√°lido?\nJustificaci√≥n\n\n\n\n\nbalance\n\n\n\n\nbalanceActual\n\n\n\n\nbalance-actual\n\n\n\n\nbalance actual\n\n\n\n\nbalance_actual\n\n\n\n\nmis.datos\n\n\n\n\n0cuenta\n\n\n\n\ncuenta0\n\n\n\n\n_cuenta\n\n\n\n\nSPAM\n\n\n\n\ncantidad$",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#variables",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#variables",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "",
    "text": "¬øQu√© valor contiene la variable contador luego de ejecutar el siguiente c√≥digo?\ncontador = 20\ncontador + 1\nComplete la siguiente tabla indicando si el nombre es v√°lido para una variable de Python.\n\n\n\nNombre\n¬øV√°lido?\nJustificaci√≥n\n\n\n\n\nbalance\n\n\n\n\nbalanceActual\n\n\n\n\nbalance-actual\n\n\n\n\nbalance actual\n\n\n\n\nbalance_actual\n\n\n\n\nmis.datos\n\n\n\n\n0cuenta\n\n\n\n\ncuenta0\n\n\n\n\n_cuenta\n\n\n\n\nSPAM\n\n\n\n\ncantidad$",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#n√∫meros",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#n√∫meros",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "2 N√∫meros",
    "text": "2 N√∫meros\n\n¬øCu√°l es el tipo de 10 / 2? ¬øPor qu√©?\n¬øCu√°l es el tipo de 5 * 2? ¬øPor qu√©?\n¬øPor qu√© 5 == 5.0 es True?",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#booleanos",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#booleanos",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "3 Booleanos",
    "text": "3 Booleanos\n\n¬øCu√°l es el resultado de las siguientes expresiones? ¬øPor qu√©?\nFalse or not False\nnot (True and True)\nnot True and True\n\"True\" != True\n10 &gt; 5 + 3\nNone is None\nFalse is False\nEjecute l√≠nea por l√≠nea los siguientes bloques y analice los resultados.\nint(True) * 50\nTrue * 50\n1 is True\nbool(1) is True\nid(True)\nid(bool(1))\nid(bool(1024))\n¬øCu√°les son los 3 operadores booleanos?",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#cadenas-de-caracteres",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#cadenas-de-caracteres",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "4 Cadenas de caracteres",
    "text": "4 Cadenas de caracteres\n\n¬øPor qu√© la siguiente comparaci√≥n resulta en True?\n\"spam\" + \"spamspam\" == \"spam\" * 3\n¬øPor qu√© la siguiente expresi√≥n resulta en un error? ¬øC√≥mo se puede arreglar?\n\"Me com√≠ \" + 6 + \" panchos.\"\n¬øEncuentra algo extra√±o en la siguiente expresi√≥n? ¬øC√≥mo la mejorar√≠a?\nmateria = \"Programaci√≥n 2\"\nprint(\"¬°Sean bienvenidos a la materia {materia}!\")\nExplique por qu√© es redundante utilizar str() en el siguiente bloque de c√≥digo:\nx, y = 10, 20\nprint(f\"La suma de {str(x)} y {str(y)} es: {str(x + y)}.\")\nConsidere el siguiente bloque de c√≥digo:\nmensaje = \"Hola, ¬øc√≥mo estes?\"\nmensaje[-3] = \"√°\"\n\n¬øCu√°l es la intenci√≥n detr√°s del programa?\n¬øPor qu√© no funciona?\n¬øC√≥mo podr√≠a arreglarlo? Alerta: la soluci√≥n no es muy elegante.\n\n¬øCu√°l es el resultado de list(\"abcdefgh\")? ¬øPor qu√©?\n¬øPor qu√© set(\"abcde\") es distinto de {\"abcde\"}?",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#funciones",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#funciones",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "5 Funciones",
    "text": "5 Funciones\n\n¬øCu√°l es la diferencia entre una funci√≥n y una llamada a funci√≥n?\n¬øCu√°l es el valor que devuelve una funci√≥n que no tiene return?\n¬øCu√°ndo se ejecuta el c√≥digo dentro de una funci√≥n: cuando la funci√≥n se define o cuando se la llama? Considere la siguiente funci√≥n:\ndef suma(x, y):\n    print(100 / 0)\n    return x + y\nLuego, ejecute el siguiente bloque:\nsuma(2, 4)",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#listas",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#listas",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "6 Listas",
    "text": "6 Listas\n\n¬øQu√© es []? ¬øCu√°l es el resultado de len([])?\n¬øPor qu√© la siguiente expresi√≥n resulta en False? Ayuda: use la funci√≥n id().\n[] is []\n¬øPor qu√© se obtiene un error en el siguiente bloque de c√≥digo?\nl = []\nl[0]\n¬øC√≥mo le asignar√≠a el valor \"hola\" como el tercer valor en una lista almacenada en una variable llamada cosas? Asuma que cosas contiene [2, 4, 6, 8, 10].\nAsuma que letras contiene la lista [\"a\", \"b\", \"c\", \"d\"]:\n\n¬øA qu√© eval√∫a letras[-1]?\n¬øA qu√© eval√∫a letras[:2]?\n¬øA qu√© eval√∫a letras[int(int('3' * 2) // 11)]? ¬øEs necesario usar dos veces int()?\n\nAsuma que bartulos contiene la lista [3.14, \"casa\", 11, \"casa\", True]:\n\n¬øA qu√© eval√∫a bartulos.index(\"casa\")? ¬øPor qu√©?\n¬øC√≥mo queda la lista en bartulos despu√©s de ejecutar bartulos.append(99)?\n¬øC√≥mo queda la lista en bartulos despu√©s de ejecutar bartulos.remove(\"casa\"') ?¬øPor qu√©?\n\n¬øCu√°les son los operadores para la concatenaci√≥n y la replicaci√≥n de listas?\n¬øCu√°l es la diferencia entre los m√©todos append() e insert() de las listas?\n¬øCu√°les son dos formas de eliminar valores de una lista?\nEl siguiente bloque de c√≥digo imprime ['a', 'b', True, 30]. ¬øPor qu√©?\ncosas = [\"a\", \"b\", True]\nbartulos = cosas\nbartulos.append(20 + 10)\nprint(cosas)\nConsidere el siguiente bloque de c√≥digo:\nmarcas = [\"Milka\", \"Cofler\", \"√Åguila\", \"Cadbury\", \"Lindt\", \"Toblerone\", \"After Eight\"]\nmarcas[2:5]\nque correctamente muestra [\"√Åguila\", \"Cadbury\", \"Lindt\"]. ¬øPor qu√© el siguiente bloque de c√≥digo no funciona?\nmarcas = [\"Milka\", \"Cofler\", \"√Åguila\", \"Cadbury\", \"Lindt\", \"Toblerone\", \"After Eight\"]\nindices = 2:5\nmarcas[indices]",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#tuplas",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#tuplas",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "7 Tuplas",
    "text": "7 Tuplas\n\n¬øPor qu√© la tupla no implementa un m√©todo similar al m√©todo .extend() de las listas?\nLas tuplas de Python son conocidas por ser inmutables. Por ejemplo, el siguiente bloque de c√≥digo resulta en un error:\ntupla = (1, 2, 3)\ntupla[1] = 10\nSin embargo, el siguiente bloque no arroja ning√∫n error y pareciera que se logra modificar la tupla exitosamente:\nbartulos = [\"Hola\", 10, None]\ntupla = (1, bartulos, 3)\n\ntupla[1].append(\"¬°Sorpesa!\")\n\nprint(tupla)\n¬øQu√© pas√≥?",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#diccionarios",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#diccionarios",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "8 Diccionarios",
    "text": "8 Diccionarios\n\n¬øC√≥mo se escribe en c√≥digo un diccionario vac√≠o?\n¬øC√≥mo se ve un diccionario que tiene la clave \"cosa\" y el valor 15?\n¬øCu√°l es la principal diferencia entre un diccionario y una lista?\n¬øQu√© ocurre si se intenta acceder a bartulos[\"cosa\"] cuando bartulos es {\"coso\": 100}?\nSi un diccionario est√° almacenado en bartulos, ¬øcu√°l es la diferencia entre las siguientes expresiones?\n\"cosa\" in bartulos\n\"cosa\" in bartulos.keys()\nSuponga el diccionario datos = {\"nombre\": \"Juan\"}. ¬øPor qu√© la siguiente expresi√≥n resulta en False?\n\"Juan\" in datos",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#control-de-flujo",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#control-de-flujo",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "9 Control de flujo",
    "text": "9 Control de flujo\n\n9.1 Condicionales\n\nExplique qu√© es una condici√≥n y en qu√© situaciones se utilizar√≠a.\nIdentifique los tres bloques de c√≥digo en el siguiente ejemplo:\ncodigo = 0\n\nif codigo == 10:\n    print(\"mensaje 1\")\n    if codigo &gt; 5:\n        print(\"mensaje 2\")\n    else:\n        print(\"mensaje alternativo\")\n    print(\"mensaje final\")\n\nprint(\"Fin del programa\")\n¬øTienen sentido las comparaciones utilizadas?\n¬øCu√°l es el problema con el siguiente programa? Proponga una soluci√≥n.\nnumero = 10\nif numero &lt; 0:\n    print(f\"El numero {numero} es negativo\")\nelif numero &lt; -5:\n    print(f\"El numero {numero} es menor a -5\")\nelif numero &gt; 0:\n    print(f\"El numero {numero} es positivo\")\nelse:\n    print(f\"El numero {numero} es 0\")\n\n\n\n9.2 Bucles\n\nConsidere el siguiente programa:\nfor i in range(10):\n    print(i)\nEscriba un programa que realice la misma tarea utilizando un bucle while.\n¬øCu√°l es la diferencia entre range(10), range(0, 10) y range(0, 10, 1) en un bucle for?\nSuponga que numeros es una lista que contiene numeros enteros, ¬øen qu√© se diferencian los siguientes bloques de c√≥digo?\nfor i in numeros:\n    if i % 2 == 0:\n        break\n    print(i)\nfor i in numeros:\n    if i % 2 == 0:\n        continue\n    print(i)\n¬øEs posible re-escribir el siguiente bloque de c√≥digo usando while True? ¬øQu√© modificaciones habr√≠a que hacer?\nsuma = 0\ni = 0\nwhile suma &lt;= limite:\n    suma += numeros[i]\n    i += 1",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html",
    "href": "practica/01_programacion_en_python/ejercicios.html",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "",
    "text": "Escriba una funci√≥n en Python que reciba el radio de un c√≠rculo y devuelva su √°rea. Luego, escriba otra funci√≥n que tambi√©n reciba el radio de un c√≠rculo, pero devuelva su per√≠metro. Finalmente, escriba una tercera funci√≥n que reciba el radio de un c√≠rculo y devuelva tanto el √°rea como el per√≠metro.\nUna vez que haya implementado todas las funciones, analice la diferencia entre:\narea, perimetro = calcular_area_y_perimetro(radio=5)\ny\nresultados = calcular_area_y_perimetro(radio=5)\nConsidere el tipo de las variables area, perimetro y resultados.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\n\\[\n\\begin{aligned}\nA &= \\pi \\cdot r^2 \\\\\nP &= 2 \\cdot \\pi \\cdot r\n\\end{aligned}\n\\]",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#√°rea-y-per√≠metro-de-un-c√≠rculo",
    "href": "practica/01_programacion_en_python/ejercicios.html#√°rea-y-per√≠metro-de-un-c√≠rculo",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "",
    "text": "Escriba una funci√≥n en Python que reciba el radio de un c√≠rculo y devuelva su √°rea. Luego, escriba otra funci√≥n que tambi√©n reciba el radio de un c√≠rculo, pero devuelva su per√≠metro. Finalmente, escriba una tercera funci√≥n que reciba el radio de un c√≠rculo y devuelva tanto el √°rea como el per√≠metro.\nUna vez que haya implementado todas las funciones, analice la diferencia entre:\narea, perimetro = calcular_area_y_perimetro(radio=5)\ny\nresultados = calcular_area_y_perimetro(radio=5)\nConsidere el tipo de las variables area, perimetro y resultados.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\n\\[\n\\begin{aligned}\nA &= \\pi \\cdot r^2 \\\\\nP &= 2 \\cdot \\pi \\cdot r\n\\end{aligned}\n\\]",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#promociones",
    "href": "practica/01_programacion_en_python/ejercicios.html#promociones",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "2 Promociones",
    "text": "2 Promociones\nEscriba una funci√≥n llamada calcular_precio que reciba dos argumentos: el monto total de una compra y el medio de pago utilizado.\nEl medio de pago puede ser \"efectivo\", \"d√©bito\" o \"cr√©dito\", y seg√∫n el caso se aplicar√° una modificaci√≥n sobre el monto:\n\nSi el medio de pago es \"efectivo\", el monto no se modifica.\nSi es \"d√©bito\", se aplica un descuento del 10% sobre el monto.\nSi es \"cr√©dito\", se aplica un recargo del 5% sobre el monto.\n\nLa funci√≥n debe retornar el monto final a pagar, con el descuento o recargo aplicado seg√∫n corresponda.\n\nPunto extra\nModifique la funci√≥n de modo tal que no sea necesario especificar el medio de pago. En tal caso, el medio de pago se asume \"efectivo\". Ayuda: asigne un valor por defecto al argumento medio. Considere una implementaci√≥n donde este sea \"efectivo\" y otra donde sea None.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#etapas-de-la-vida",
    "href": "practica/01_programacion_en_python/ejercicios.html#etapas-de-la-vida",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "3 Etapas de la vida",
    "text": "3 Etapas de la vida\nImplemente una funci√≥n que reciba una edad y devuelva un mensaje que indique la etapa de la vida correspondiente.\nUtilice una cadena de condicionales if-elif-else para clasificar la edad en alguno de los siguientes grupos:\n\nMenor a 2 a√±os: beb√©.\nEntre 2 (inclusive) y 4 a√±os: infante.\nEntre 4 (inclusive) y 13 a√±os: ni√±o/a.\nEntre 13 (inclusive) y 20 a√±os: adolescente.\nEntre 20 (inclusive) y 65 a√±os: adulto/a.\n65 a√±os o m√°s: persona mayor.\n\nLa funci√≥n debe imprimir un mensaje del tipo: \"La persona es un/a &lt;etapa&gt;\".",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres",
    "href": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "4 Conteo de caracteres",
    "text": "4 Conteo de caracteres\nEscriba una funci√≥n que reciba una cadena de texto y devuelva un diccionario que indique cu√°ntas veces aparece cada caracter en la cadena. La funci√≥n no debe diferenciar entre may√∫sculas y min√∫sculas y debe ignorar espacios. Utilice el siguiente ejemplo como validaci√≥n:\ncontar_caracteres(\"Ahora es mejor que nunca\")\n# {\"a\": 3, \"h\": 1, \"o\": 2, \"r\": 2, \"e\": 3, \"s\": 1, \"m\": 1, \"j\": 1, \"q\": 1, \"u\": 2, \"n\": 2, \"c\": 1}\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara saltear pasos de un bucle cuando se encuentra un espacio se puede utilizar la sentencia continue.\nfor i in ...:\n    # ... &lt;- Se ejecuta en todas las iteraciones\n    if condicion_de_salto:\n        continue\n    # ... &lt;- Se ejecuta en las iteraciones 'condicion_de_salto' es False",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#orden-de-m√©rito",
    "href": "practica/01_programacion_en_python/ejercicios.html#orden-de-m√©rito",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "5 Orden de m√©rito",
    "text": "5 Orden de m√©rito\nSe cuenta con una lista de tuplas que contienen las notas del examen final de Programaci√≥n 2 para un conjunto de alumnos:\nnotas = [\n    (\"Escalada\", 9),\n    (\"Alonso\", 7),\n    (\"P√©rez\", 8),\n    (\"Castro\", 8),\n    (\"Rossini\", 10),\n    (\"Mart√≠nez\", 9),\n    (\"P√©rez\", 6),\n    (\"Riquelme\", 5),\n]\n\nEscriba un programa que a partir de notas genere un diccionario donde las claves se corresponden con los apellidos y los valores con las notas del examen final.\nEscriba un programa que a partir de notas genere un diccionario donde las claves son las notas y el valor asociado sea una lista con los apellidos de quienes tuvieron esa nota.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#rendimento-acad√©mico",
    "href": "practica/01_programacion_en_python/ejercicios.html#rendimento-acad√©mico",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "6 Rendimento acad√©mico",
    "text": "6 Rendimento acad√©mico\nSe cuenta con el siguiente diccionario que asocia nombres de estudiantes con una lista de sus calificaciones:\nnotas = {\n    \"Ana\": [8, 9, 10],\n    \"Luis\": [6, 7, 8, 3, 9],\n    \"Carla\": [10, 9, 10],\n    \"Marcos\": [5, 6],\n    \"Sof√≠a\": [7, 7, 8],\n    \"Pedro\": [6, 4, 5, 6, 3, 8],\n    \"Luc√≠a\": [9, 8, 10, 9]\n}\nImplemente una funci√≥n que resuma el rendimiento acad√©mico de los estudiantes. La funci√≥n debe recibir el diccionario de notas y un argumento adicional llamado modo. Seg√∫n el valor de modo, se debe devolver un nuevo diccionario con la siguiente informaci√≥n:\n\nSi modo es \"promedio\", se debe devolver el promedio de notas por estudiante.\nSi modo es \"proporcion\", se debe devolver la proporci√≥n de ex√°menes aprobados por estudiante (se considera aprobado todo valor mayor o igual a 6).",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#√≠ndice-de-precios",
    "href": "practica/01_programacion_en_python/ejercicios.html#√≠ndice-de-precios",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "7 √çndice de precios",
    "text": "7 √çndice de precios\nSe cuenta con la serie mensual del √çndice de Precios al Consumidor (IPC) del a√±o 2024:\nipc_2024 = [20.6, 13.2, 11.0, 8.8, 4.2, 4.6, 4.0, 4.2, 3.5, 2.7, 2.4, 2.7]\nRealice los siguientes c√°lculos y an√°lisis:\n\nDetermine el menor y el mayor √≠ndice reportado durante el a√±o.\nCalcule el IPC promedio mensual del 2024.\nEncuentre la diferencia entre el IPC m√≠nimo y m√°ximo del a√±o.\n\n¬øEn qu√© mes se registr√≥ la inflaci√≥n m√°s alta?\n\nCalcule la inflaci√≥n mediana del 2024.\n¬øC√≥mo podr√≠a calcular el rango del IPC (diferencia entre el valor m√°ximo y m√≠nimo) sin usar las funciones min() ni max()?",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#res√∫menes-estad√≠sticos",
    "href": "practica/01_programacion_en_python/ejercicios.html#res√∫menes-estad√≠sticos",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "8 Res√∫menes estad√≠sticos",
    "text": "8 Res√∫menes estad√≠sticos\nCree funciones que, dada una lista de n√∫meros, calculen los siguientes res√∫menes estad√≠sticos:\n\nLa media \\[\n\\text{media}(X) = \\frac{1}{n}\\sum_{i=1}^n{x_i}\n\\]\nEl rango \\[\n\\text{rango}(X) = \\text{max}(X) - \\text{min}(X)\n\\]\nLa varianza \\[\n\\text{var}(X) = \\frac{1}{n}\\sum_{i=1}^n{(x_i - \\bar{x})^2}\n\\]\nEl desv√≠o est√°ndar \\[\n\\text{sd}(X) = \\sqrt{\\text{var}(X)}\n\\]\nLa mediana \\[\n\\begin{array}{lr}\n\\text{mediana}(X) = x_{(\\frac{n + 1}{2})} & \\text{Si } n \\text{ es impar} \\\\\n\\text{mediana}(X) = \\frac{x_{(\\frac{n}{2})} + x_{(\\frac{n}{2}+1)}}{2} & \\text{Si } n \\text{ es par}\n\\end{array}\n\\]\ndonde los \\(x_{(i)}\\) est√°n ordenados de manera ascendente.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#validaci√≥n-de-dni",
    "href": "practica/01_programacion_en_python/ejercicios.html#validaci√≥n-de-dni",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "9 Validaci√≥n de DNI",
    "text": "9 Validaci√≥n de DNI\nCrear una funci√≥n que dada una cadena de caracteres verifique si se corresponde con un DNI.\nSi es un DNI, devolver True. Caso contrario, devolver False.\nA tener en cuenta:\n\nAlgunos ejemplos de DNI v√°lidos\n\n40.094.127\n19053512\n6.392.780\n\nDNI no v√°lidos\n\n40,094,127\n19-053-512\n123456",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#la-f√≠sica-del-rebote",
    "href": "practica/01_programacion_en_python/ejercicios.html#la-f√≠sica-del-rebote",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "10 La f√≠sica del rebote",
    "text": "10 La f√≠sica del rebote\nUna pelota de goma es lanzada desde una altura inicial de 100 metros. Cada vez que toca el suelo, rebota alcanzando una altura equivalente a 3/5 de la altura desde la que cay√≥.\nEscriba un programa que imprima una tabla mostrando las alturas alcanzadas por la pelota en cada uno de sus primeros 10 rebotes.\nLuego, implemente este programa como una funci√≥n que reciba dos par√°metros:\n\nAltura inicial desde la que se lanza la pelota.\nCantidad de rebotes que se desea calcular.\n\nLa funci√≥n debe devolver una lista con las alturas alcanzadas en cada rebote.\n\nPunto extra\nModifique la funci√≥n para que considere un rebote como ‚Äúsignificativo‚Äù solo si la altura alcanzada es mayor o igual a un valor m√≠nimo especificado (por ejemplo, 1 cent√≠metro).\nSi la pelota no alcanza esta altura m√≠nima en alg√∫n rebote, se considera que ha completado su trayectoria y queda quieta. En este caso, la funci√≥n debe devolver √∫nicamente los valores correspondientes a los ‚Äúrebotes significativos‚Äù.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#un-mont√≥n-de-plata",
    "href": "practica/01_programacion_en_python/ejercicios.html#un-mont√≥n-de-plata",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "11 Un mont√≥n de plata",
    "text": "11 Un mont√≥n de plata\nUna ma√±ana pon√©s un billete en la vereda al lado del Monumento a la Bandera. A partir de ah√≠, cada d√≠a vas y duplic√°s la cantidad de billetes, apil√°ndolos prolijamente. ¬øCu√°nto tiempo pasa antes de que la pila de billetes sea m√°s alta que la del Monumento?\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nAlgunas constantes √∫tiles para resolver el problema:\nbillete_grosor = 0.11 * 0.001  # grosor de un billete en metros\naltura_monumento = 70          # altura en metros\nSugerencia: Usar un bucle while para realizar el c√°lculo.\n\n\n\n\nPunto extra\nEscribe una funci√≥n que permita determinar la cantidad de d√≠as necesarios para superar cualquier altura arbitraria.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#la-conjetura-de-collatz",
    "href": "practica/01_programacion_en_python/ejercicios.html#la-conjetura-de-collatz",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "12 La conjetura de Collatz",
    "text": "12 La conjetura de Collatz\nLa conjetura de Collatz dice:\n\nSi tomamos un n√∫mero natural cualquiera, su secuencia de Collatz termina llegando siempre al n√∫mero 1.\n\nSecuencia de Collatz:\n\nSi el n√∫mero es par, se divide entre 2.\nSi el n√∫mero es impar, se multiplica por 3 y se le suma 1.\n\n\\[\nf(n) =\n\\begin{cases}\n    \\displaystyle \\frac{n}{2} & \\text{si } n \\text{ es par,} \\\\ \\\\\n    3n + 1 & \\text{si } n \\text{ es impar.}\n\\end{cases}\n\\]\nEscribir una funci√≥n que calcule la secuencia de Collatz para un n√∫mero natural cualquiera.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\n\nUtilizar bucle while.\nEl bucle debe correr solo cuando el valor de la secuencia sigue siendo mayor a 1. Si es 1, hay que frenar.\nInsertar los elementos de la secuencia en una lista.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#adivina-el-n√∫mero",
    "href": "practica/01_programacion_en_python/ejercicios.html#adivina-el-n√∫mero",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "13 Adivina el n√∫mero",
    "text": "13 Adivina el n√∫mero\nEscriba un programa que implemente el cl√°sico juego ‚ÄúAdivina el n√∫mero‚Äù. El programa debe:\n\nTener un n√∫mero secreto (entero) que el usuario debe adivinar.\nSolicitar al usuario que ingrese un n√∫mero.\nSi el n√∫mero ingresado no coincide con el n√∫mero secreto:\n\nInformar si el n√∫mero ingresado es mayor o menor que el n√∫mero secreto.\nPedir al usuario que intente nuevamente.\n\nSi el usuario adivina el n√∫mero, el programa debe terminar mostrando un mensaje de felicitaciones.\n\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara generar n√∫meros aleatorios enteros en un rango dado puede utilizar randint() del m√≥dulo random:\nimport random\nrandom.randint(-100,¬†100)     # Genera un n√∫mero aleatorio entre -100 y 100\n\n\n\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nEl programa que resuelve este problema realiza una cantidad de iteraciones que se desconoce al momento de escribirlo. La soluci√≥n t√≠pica a este tipo de problema involucra el uso de while True junto a la sentencia break.\nwhile True:\n    # realizar alguna accion\n    if condicion_de_salida:\n        break\n\n\n\n\nPunto extra\nImplemente una versi√≥n de este programa donde el usuario cuenta con 10 intentos.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres-pythonico",
    "href": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres-pythonico",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "14 Conteo de caracteres Pythonico",
    "text": "14 Conteo de caracteres Pythonico\nLos diccionarios en Python cuentan con un m√©todo .get() que devuelve el valor asociado a una clave. Este m√©todo permite pasarle un segundo argumento con un valor que se devuelve cuando no se encuentra un elemento asociado a la clave que le pasamos. Por ejemplo:\nd = {\"a\": 1, \"b\": 20}\nd.get(\"b\", 0)\n20\nd.get(\"c\", 0)\n0\nModifique la funci√≥n contar_caracteres del ejercicio Conteo de caracteres utilizando el metodo .get() para obtener una implementaci√≥n m√°s sencilla. As√≠, deber√≠a poder eliminar el bloque if.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#validador-de-contrase√±as",
    "href": "practica/01_programacion_en_python/ejercicios.html#validador-de-contrase√±as",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "15 Validador de contrase√±as üò±",
    "text": "15 Validador de contrase√±as üò±\nEscriba un programa que solicite al usuario una contrase√±a y verifique que cumpla con las siguientes condiciones:\n\nDebe tener entre de 8 y 24 caracteres.\nDebe incluir letras, n√∫meros y caracteres especiales (@#$%^&*()).\n\nSi la contrase√±a no es v√°lida, el programa debe informar al usuario qu√© condici√≥n no se cumple y permitirle ingresar una nueva contrase√±a. El proceso se repite hasta que el usuario ingrese una contrase√±a v√°lida o decida no continuar.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres-ii",
    "href": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres-ii",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "16 Conteo de caracteres II üò±",
    "text": "16 Conteo de caracteres II üò±\nAgregue a la funci√≥n contar_frecuencias del ejercicio Conteo de caracteres un argumento llamado orden que admita los valores \"aparicion\", \"alfabetico\" y \"frecuencia\".\nEste argumento debe permitir ordenar las claves del diccionario resultante seg√∫n el siguiente criterio:\n\n\"aparicion\": mantiene el orden en que las palabras aparecen por primera vez en la lista original.\n\"alfabetico\": ordena las palabras alfab√©ticamente.\n\"frecuencia\": ordena las palabras por su frecuencia, de mayor a menor.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "trabajos_practicos/descripcion.html",
    "href": "trabajos_practicos/descripcion.html",
    "title": "Descripci√≥n",
    "section": "",
    "text": "Ac√° explicamos las pautas para los TP.",
    "crumbs": [
      "Trabajos Pr√°cticos",
      "Descripci√≥n"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html",
    "href": "trabajos_practicos/trabajo_grupal.html",
    "title": "Trabajo Pr√°ctico",
    "section": "",
    "text": "Trabajo Pr√°ctico",
    "crumbs": [
      "Trabajos Pr√°cticos",
      "Trabajo Pr√°ctico"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_individual.html",
    "href": "trabajos_practicos/trabajo_individual.html",
    "title": "Trabajo Pr√°ctico Final",
    "section": "",
    "text": "Trabajo Pr√°ctico Final",
    "crumbs": [
      "Trabajos Pr√°cticos",
      "Trabajo Pr√°ctico Final"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programaci√≥n II",
    "section": "",
    "text": "Programaci√≥n II\n\n\n ¬† Ciclo de Formaci√≥n T√©cnica - Estad√≠stica y Ciencia de Datos\n ¬† Facultad de Ciencias Econ√≥micas y Estad√≠stica (UNR)\n ¬† 2¬∞ Cuatrimestre 2025"
  },
  {
    "objectID": "index.html#docentes",
    "href": "index.html#docentes",
    "title": "Programaci√≥n II",
    "section": "Docentes",
    "text": "Docentes\n\n\nTom√°s Capretto\n\n ¬† tomas.capretto@fcecon.unr.edu.ar \n\n\n\nLuciano Anselmino\n\n ¬† luciano.anselmino@fcecon.unr.edu.ar \n\n\n\nJoaqu√≠n Bermejo\n\n ¬† joaquin.bermejo@fcecon.unr.edu.ar \n\n\n\nDolores Sollberger\n\n ¬† dolores.sollberger@fcecon.unr.edu.ar"
  },
  {
    "objectID": "practica/01_programacion_en_python/problemas.html",
    "href": "practica/01_programacion_en_python/problemas.html",
    "title": "üß© Problemas",
    "section": "",
    "text": "En criptograf√≠a, el cifrado C√©sar es una de las t√©cnicas de cifrado m√°s simples y m√°s usadas.\nEs un tipo de cifrado en el que una letra en el texto original es reemplazada por otra letra que se encuentra un n√∫mero fijo de posiciones m√°s adelante en el alfabeto.\nPor ejemplo, con un desplazamiento de 3, la A ser√≠a sustituida por la D (situada 3 lugares a la derecha de la A), la B ser√≠a reemplazada por la E, etc.\n\n\n\n\n\nEscriba una funci√≥n, y luego un script, que permita cifrar y descifrar cadenas usando el cifrado C√©sar con un n√∫mero arbitrario de posiciones.\nDos funciones incluidas con Python que pueden ser √∫tiles para esta tarea son ord(), que convierte caracteres num√©ricos a n√∫meros, y chr(), que realiza la operaci√≥n inversa.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara el cifrado de un √∫nico caracter:\n\nDefinir un desplazamiento, por ejemplo 3.\nConvertir el caracter a n√∫mero usando ord().\nSumarle desplazamiento.\nFinalmente, convertirlo a caracter nuevamente utilizando chr().\n\nY para el descifrado:\n\nConvertir el caracter a n√∫mero.\nRestarle desplazamiento.\nConvertirlo a caracter nuevamente utilizando chr().\n\nAs√≠, se deber√≠a recuperar el caracter definido al principio.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üß© Problemas"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/problemas.html#cifrado-c√©sar",
    "href": "practica/01_programacion_en_python/problemas.html#cifrado-c√©sar",
    "title": "üß© Problemas",
    "section": "",
    "text": "En criptograf√≠a, el cifrado C√©sar es una de las t√©cnicas de cifrado m√°s simples y m√°s usadas.\nEs un tipo de cifrado en el que una letra en el texto original es reemplazada por otra letra que se encuentra un n√∫mero fijo de posiciones m√°s adelante en el alfabeto.\nPor ejemplo, con un desplazamiento de 3, la A ser√≠a sustituida por la D (situada 3 lugares a la derecha de la A), la B ser√≠a reemplazada por la E, etc.\n\n\n\n\n\nEscriba una funci√≥n, y luego un script, que permita cifrar y descifrar cadenas usando el cifrado C√©sar con un n√∫mero arbitrario de posiciones.\nDos funciones incluidas con Python que pueden ser √∫tiles para esta tarea son ord(), que convierte caracteres num√©ricos a n√∫meros, y chr(), que realiza la operaci√≥n inversa.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara el cifrado de un √∫nico caracter:\n\nDefinir un desplazamiento, por ejemplo 3.\nConvertir el caracter a n√∫mero usando ord().\nSumarle desplazamiento.\nFinalmente, convertirlo a caracter nuevamente utilizando chr().\n\nY para el descifrado:\n\nConvertir el caracter a n√∫mero.\nRestarle desplazamiento.\nConvertirlo a caracter nuevamente utilizando chr().\n\nAs√≠, se deber√≠a recuperar el caracter definido al principio.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üß© Problemas"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/problemas.html#n√∫meros-aleatorios",
    "href": "practica/01_programacion_en_python/problemas.html#n√∫meros-aleatorios",
    "title": "üß© Problemas",
    "section": "2 N√∫meros aleatorios",
    "text": "2 N√∫meros aleatorios\nConstruya un programa en Python que genere una cantidad determinada de n√∫meros aleatorios uniformes dentro de un rango definido por el usuario. El programa debe:\n\nSolicitar al usuario la cantidad de n√∫meros a generar y los valores m√≠nimo y m√°ximo del rango.\nGenerar los n√∫meros aleatorios\nGuardar los n√∫meros en un archivo de texto, uno por l√≠nea.\nOfrecer la opci√≥n de mostrar un resumen estad√≠stico con m√≠nimo, m√°ximo, media y desv√≠o est√°ndar, solo si el usuario lo solicita.\n\nPara resolver este problema utilice el m√≥dulo random y las funciones desarrolladas en el ejercicio Res√∫menes estad√≠sticos guardadas en un m√≥dulo llamado estadistica.py.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üß© Problemas"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/problemas.html#mensaje-al-descubierto",
    "href": "practica/01_programacion_en_python/problemas.html#mensaje-al-descubierto",
    "title": "üß© Problemas",
    "section": "3 Mensaje al descubierto",
    "text": "3 Mensaje al descubierto\nResulta que Franco, un amigo que estudia Ciencias de la Computaci√≥n en la FCEIA, te env√≠a por WhatsApp un archivo de texto plano con mensajes ‚Äúencriptados‚Äù usando caracteres sobrantes y s√≠mbolos extra√±os:\n    !!!,.,  aY??/u/DAM**e,, se =m!!e\n&&M&&e v!o!?LV...I.O /L/*oC/*o\n        __?e_?l//+ T++**e/*Cl!?aD==*O**\nTiene sentido pensar que est√° experimentando con nuevos algoritmos de cifrado y, de paso, te lanza el reto de descifrarlo.\nTu misi√≥n es escribir un programa que:\n\nLea un archivo de texto plano cualquiera.\nMuestre en pantalla su contenido original (tal cual llega).\nAplique un proceso de limpieza basado en las siguientes reglas:\n\nEliminar todos los caracteres +, *, -, /, =, !, ?, & y _.\nReemplazar cualquier secuencia de espacios m√∫ltiples por un solo espacio.\nHomogeinizar la capitalizaci√≥n de los caracteres.\nConservar los saltos de l√≠nea tal cual aparecen en el archivo original.\n\nMuestre en pantalla la versi√≥n desencriptada del texto.\nGuarde la versi√≥n limpia en un nuevo archivo de texto.\n\nEl usuario debe poder especificar el nombre del archivo de salida.\nSi no lo hace, se generar√° uno con el sufijo _limpio antes de la extensi√≥n original (por ejemplo, secreto.txt ‚Üí secreto_limpio.txt).",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üß© Problemas"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/problemas.html#c√≥digo-morse",
    "href": "practica/01_programacion_en_python/problemas.html#c√≥digo-morse",
    "title": "üß© Problemas",
    "section": "4 C√≥digo Morse",
    "text": "4 C√≥digo Morse\nEl c√≥digo Morse es un sistema utilizado para representar letras mediante combinaciones espec√≠ficas de se√±ales cortas y largas, denominadas puntos (.) y rayas (-). A continuaci√≥n se muestra un diccionario con el mapeo de caracteres alfab√©ticos, d√≠gitos del 0 al 9 y algunos s√≠mbolos de puntuaci√≥n comunes:\nmapeo_morse = {\n    \"A\": \".-\",\n    \"B\": \"-...\",\n    \"C\": \"-.-.\",\n    \"D\": \"-..\",\n    \"E\": \".\",\n    \"F\": \"..-.\",\n    \"G\": \"--.\",\n    \"H\": \"....\",\n    \"I\": \"..\",\n    \"J\": \".---\",\n    \"K\": \"-.-\",\n    \"L\": \".-..\",\n    \"M\": \"--\",\n    \"N\": \"-.\",\n    \"O\": \"---\",\n    \"P\": \".--.\",\n    \"Q\": \"--.-\",\n    \"R\": \".-.\",\n    \"S\": \"...\",\n    \"T\": \"-\",\n    \"U\": \"..-\",\n    \"V\": \"...-\",\n    \"W\": \".--\",\n    \"X\": \"-..-\",\n    \"Y\": \"-.--\",\n    \"Z\": \"--..\",\n    \"1\": \".----\",\n    \"2\": \"..---\",\n    \"3\": \"...--\",\n    \"4\": \"....-\",\n    \"5\": \".....\",\n    \"6\": \"-....\",\n    \"7\": \"--...\",\n    \"8\": \"---..\",\n    \"9\": \"----.\",\n    \"0\": \"-----\",\n    \", \": \"--..--\",\n    \".\": \".-.-.-\",\n}\nEscriba una funci√≥n en Python que permita convertir cualquier palabra a c√≥digo Morse utilizando este diccionario. Luego, escriba otra funci√≥n que haga exactamente lo contrario: dada una secuencia en c√≥digo Morse, debe recuperar la palabra original. Finalmente, incorpore ambas funciones en un script principal que combine ambas funciones y permita encriptar o desencriptar texto desde un archivo de texto plano. El programa debe recibir:\n\nEl nombre del archivo de entrada.\nEl nombre del archivo de salida.\nLa operaci√≥n a realizar (encriptar o desencriptar).\n\nAyuda: Para indicar espacios en c√≥digo Morse utilice /.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üß© Problemas"
    ]
  },
  {
    "objectID": "informacion/calendario.html",
    "href": "informacion/calendario.html",
    "title": "Calendario",
    "section": "",
    "text": "Semana\nFecha\nTemas\nOtras actividades\n\n\n\n\n1\n4 de agosto\n‚Ä¢ Lenguaje Python y su ecosistema.‚Ä¢ Uso de Python en la terminal.‚Ä¢ Uso de Positron.‚Ä¢ Python en Positron.‚Ä¢ Python: expresiones; variables y asignaciones; tipos de datos elementales; operadores num√©ricos, de comparaci√≥n y l√≥gicos.‚Ä¢ Jupyter Notebooks.‚Ä¢ Definici√≥n de funciones.‚Ä¢ Ejecuci√≥n condicional de c√≥digo.\n\n\n\n2\n11 de agosto\n‚Ä¢ Bucles definidos y no definidos: for, while, break, continue.‚Ä¢ Estructuras de datos nativas de Python: list, tuple, set y dict.‚Ä¢ Complemento: str, bytes, bytearray y range.\n\n\n\n3\n17 de agosto\n‚Ä¢ Uso de c√≥digo externo (propio y de terceros).‚Ä¢ M√≥dulos y librer√≠as.‚Ä¢ Librer√≠a est√°ndar de Python.‚Ä¢ Instalaci√≥n y gesti√≥n de librer√≠as.‚Ä¢ Scripting.‚Ä¢ Lectura y escritura de archivos de texto plano.‚Ä¢ Modularizaci√≥n de programas.\n\n\n\n4\n25 de agosto\n‚Ä¢ Funciones como ciudadanos de primera clase.‚Ä¢ Funciones puras.‚Ä¢ Funciones an√≥nimas.‚Ä¢ Closures.‚Ä¢ Recursi√≥n.\n\n\n\n5\n1 de septiembre\n‚Ä¢ Funciones de orden superior: map, filter, reduce.‚Ä¢ Evaluaci√≥n estricta y no estricta.‚Ä¢ Evaluaci√≥n perezosa (lazy) e inmediata (eager).‚Ä¢ Generadores.‚Ä¢ Aplicaci√≥n parcial de funciones.‚Ä¢ Decoradores.\n\n\n\n6\n15 de septiembre\n‚Ä¢ Objetos, clases e instancias.‚Ä¢ Atributos y m√©todos.‚Ä¢ Propiedades p√∫blicas y privadas.‚Ä¢ M√©todos de clase y m√©todos de instancia.\n\n\n\n7\n22 de septiembre\n‚Ä¢ Encapsulamiento.‚Ä¢ Herencia simple y m√∫ltiple.‚Ä¢ Polimorfismo.‚Ä¢ Abstracci√≥n.\n\n\n\n8\n29 de septiembre\n‚Ä¢ M√©todos especiales (dunder methods).‚Ä¢ Decoradores aplicados a m√©todos.‚Ä¢ Sobrecarga de operadores.\nParcial\n\n\n9\n6 de octubre\n‚Ä¢ Concepto y clasificaci√≥n.‚Ä¢ Estructuras lineales y no lineales.‚Ä¢ Listas y listas enlazadas.‚Ä¢ Operaciones b√°sicas: agregar, quitar y recorrer.\nPresentaci√≥n TP Grupal\n\n\n10\n13 de octubre\n‚Ä¢ Hashing.‚Ä¢ Diccionarios y conjuntos como estructuras asociativas.‚Ä¢ √Årboles y grafos.\nRecuperatorio\n\n\n11\n20 de octubre\n‚Ä¢ Arreglos multidimensionales de NumPy.\n\n\n\n12\n27 de octubre\n‚Ä¢ Concepto de algoritmo y complejidad.‚Ä¢ Algoritmos de b√∫squeda.‚Ä¢ B√∫squeda lineal y binaria.‚Ä¢ Notaci√≥n Big O.\nEntrega TP Grupal\n\n\n13\n3 de noviembre\n‚Ä¢ Algoritmos de ordenamiento.‚Ä¢ bubble sort, insert sort, select sort, quick sort y merge sort.‚Ä¢ Comparaci√≥n de algoritmos de ordenamiento.\nPresentaci√≥n TP Individual\n\n\n14\n10 de noviembre\n‚Ä¢ Funciones de b√∫squeda y ordenamiento en Python.\n\n\n\n15\n17 de noviembre\n\n\n\n\n16\n24 de noviembre\n\nEntrega y defensa TP Individual",
    "crumbs": [
      "Informaci√≥n",
      "Calendario"
    ]
  },
  {
    "objectID": "informacion/bibliografia.html",
    "href": "informacion/bibliografia.html",
    "title": "Bibliograf√≠a",
    "section": "",
    "text": "Principal\n\nCormen et¬†al. (2022) Downey (2024) Kalb (2022) Kubica (2022) Lott y Phillips (2021) Lott (2022) Mertz (2015) Miller, Ranum, y Yasinovskyy (2023) Sedgewick y Wayne (2011) Sedgewick, Wayne, y Dondero (2015) Sweigart (2020) Tuckfield (2021)\n\n\n\nCormen, Thomas H., Charles E. Leiserson, Ronald L. Rivest, y Clifford Stein. 2022. Introduction to Algorithms. 4th ed. MIT.\n\n\nDowney, Allen B. 2024. Think Python. 3.¬™ ed. O‚ÄôReilly Media. https://allendowney.github.io/ThinkPython/.\n\n\nKalb, Irv. 2022. Object-Oriented Python. No Starch Press.\n\n\nKubica, Jacek. 2022. Data Structures the Fun Way. 1st ed. No Starch Press.\n\n\nLott, Steven F. 2022. Functional Python Programming. 3rd ed. Packt Publishing.\n\n\nLott, Steven F., y Dusty Phillips. 2021. Python Object-Oriented Programming. 4th ed. Packt Publishing.\n\n\nMertz, David. 2015. Functional Programming in Python. O‚ÄôReilly Media.\n\n\nMiller, Bradley, David Ranum, y Jan Yasinovskyy. 2023. Problem Solving with Algorithms and Data Structures Using Python. 3rd ed. Franklin, Beedle & Associates.\n\n\nSedgewick, Robert, y Kevin Wayne. 2011. Algorithms. 4th ed. Addison-Wesley Professional.\n\n\nSedgewick, Robert, Kevin Wayne, y Robert Dondero. 2015. Introduction to Programming in Python. Addison-Wesley Professional.\n\n\nSweigart, Al. 2020. Beyond the Basic Stuff with Python. No Starch Press. https://inventwithpython.com/beyond/.\n\n\nTuckfield, Bradford. 2021. Dive Into Algorithms. No Starch Press.\n\n\n\n\nComplementaria\n\nHetland (2014) Mailund (2023) Sweigart (2021) Vaughan (2019) Wickham (2019)\n\n\n\n\n\nHetland, Magnus Lie. 2014. Python Algorithms. 2.¬™ ed. Apress.\n\n\nMailund, Thomas. 2023. Functional Programming in R 4. 2.¬™ ed. Apress.\n\n\nSweigart, Al. 2021. The Big Book of Small Python Projects. No Starch Press. https://inventwithpython.com/bigbookpython/.\n\n\nVaughan, Lee. 2019. Impractical Python Projects. No Starch Press.\n\n\nWickham, Hadley. 2019. Advanced R. 2.¬™ ed. Chapman & Hall/CRC. https://adv-r.hadley.nz/.",
    "crumbs": [
      "Informaci√≥n",
      "Bibliograf√≠a"
    ]
  },
  {
    "objectID": "informacion/aprobacion.html",
    "href": "informacion/aprobacion.html",
    "title": "Condiciones de aprobaci√≥n",
    "section": "",
    "text": "üìù Examen parcial: individual y escrito. Hay un recuperatorio, de similares caracter√≠sticas, que reemplaza la nota del parcial.\nü§ù Trabajo pr√°ctico grupal: se hace fuera de clase, en grupos de entre dos y tres integrantes.\nüßë‚Äçüíª Trabajo pr√°ctico individual: opcional para promoci√≥n, con presentaci√≥n y defensa oral.\nTodas las instancias se califican en una escala de 0 a 10 y se aprueban con 6.",
    "crumbs": [
      "Informaci√≥n",
      "Condiciones de aprobaci√≥n"
    ]
  },
  {
    "objectID": "informacion/aprobacion.html#instancias-de-evaluaci√≥n",
    "href": "informacion/aprobacion.html#instancias-de-evaluaci√≥n",
    "title": "Condiciones de aprobaci√≥n",
    "section": "",
    "text": "üìù Examen parcial: individual y escrito. Hay un recuperatorio, de similares caracter√≠sticas, que reemplaza la nota del parcial.\nü§ù Trabajo pr√°ctico grupal: se hace fuera de clase, en grupos de entre dos y tres integrantes.\nüßë‚Äçüíª Trabajo pr√°ctico individual: opcional para promoci√≥n, con presentaci√≥n y defensa oral.\nTodas las instancias se califican en una escala de 0 a 10 y se aprueban con 6.",
    "crumbs": [
      "Informaci√≥n",
      "Condiciones de aprobaci√≥n"
    ]
  },
  {
    "objectID": "informacion/aprobacion.html#condiciones-de-aprobaci√≥n",
    "href": "informacion/aprobacion.html#condiciones-de-aprobaci√≥n",
    "title": "Condiciones de aprobaci√≥n",
    "section": "Condiciones de aprobaci√≥n",
    "text": "Condiciones de aprobaci√≥n\n\nPromoci√≥n\n\nQuienes aprueben el parcial individual (con nota \\(\\text{P}\\)), el trabajo pr√°ctico grupal (con nota \\(\\text{T}\\)) y el trabajo pr√°ctico individual con defensa oral (con nota \\(\\text{O}\\)), adquieren la condici√≥n de estudiante promovido y su nota final se calcula como \\(0.5 \\times \\text{P} + 0.2 \\times \\text{T} + 0.3 \\times \\text{O}\\).\n\nRegularidad\n\nQuienes aprueben el parcial individual (o su recuperatorio) y el trabajo pr√°ctico grupal, pero no accedan o no aprueben el trabajo pr√°ctico individual, adquieren la condici√≥n de estudiante regular.\n\nLibres\n\nQuienes no aprueben el parcial individual (ni su recuperatorio) o el trabajo pr√°ctico grupal, adquieren la condici√≥n de estudiante libre.",
    "crumbs": [
      "Informaci√≥n",
      "Condiciones de aprobaci√≥n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html",
    "href": "teoria/01_programacion_en_python/02_funciones.html",
    "title": "Funciones",
    "section": "",
    "text": "Una funci√≥n puede pensarse como un ‚Äúmini-programa‚Äù dentro de un programa m√°s grande. Su prop√≥sito es cumplir una tarea u objetivo espec√≠fico, de forma independiente del resto del c√≥digo.\nEl uso de funciones tiene varias ventajas:\n\nReutilizaci√≥n de c√≥digo: se define una sola vez y se ejecuta cuando sea necesario.\nMejor organizaci√≥n: dividen el programa en partes m√°s f√°ciles de leer y mantener.\nModularidad: permiten construir programas como bloques independientes que pueden combinarse entre s√≠ (¬°funciones dentro de funciones!).\n\nConsideremos el siguiente caso donde se busca calcuar el precio final de un producto, considerando impuestos y descuentos.\n\nprecio_base = 800   # Precio del producto ($800)\nimpuesto = 0.21     # Impuesto (21%)\ndescuento = 0.10    # Descuento (10%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n871.2\n\n\n¬øQu√© pasa si queremos calcular el precio final para otros productos con diferentes precios, impuestos o descuentos?\nUna opci√≥n es repetir el c√≥digo tantas veces como sea necesario‚Ä¶\n\nprecio_base = 500   # Precio del producto ($500)\nimpuesto = 0.105    # Impuesto (10.5%)\ndescuento = 0.0     # Descuento (0%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n552.5\n\n\n\nprecio_base = 2000  # Precio del producto ($2000)\nimpuesto = 0.21     # Impuesto (21%)\ndescuento = 0.20    # Descuento (20%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n1936.0\n\n\nOtra opci√≥n, mucho mas conveniente, es utilizar funciones.\n\ndef calcular_precio(precio_base, impuesto, descuento):\n    resultado = precio_base * (1 + impuesto) * (1 - descuento)\n    return resultado\n\nLuego, para utilizar la funci√≥n simplemente la llamamos (o invocamos).\n\ncalcular_precio(800, 0.21, 0.10)\n\n871.2\n\n\nTambi√©n es posible indicar los valores de los argumentos utilizando sus nombres.\n\ncalcular_precio(precio_base=2000, impuesto=0.21, descuento=0.20)\n\n1936.0",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#qu√©-es-una-funci√≥n",
    "href": "teoria/01_programacion_en_python/02_funciones.html#qu√©-es-una-funci√≥n",
    "title": "Funciones",
    "section": "",
    "text": "Una funci√≥n puede pensarse como un ‚Äúmini-programa‚Äù dentro de un programa m√°s grande. Su prop√≥sito es cumplir una tarea u objetivo espec√≠fico, de forma independiente del resto del c√≥digo.\nEl uso de funciones tiene varias ventajas:\n\nReutilizaci√≥n de c√≥digo: se define una sola vez y se ejecuta cuando sea necesario.\nMejor organizaci√≥n: dividen el programa en partes m√°s f√°ciles de leer y mantener.\nModularidad: permiten construir programas como bloques independientes que pueden combinarse entre s√≠ (¬°funciones dentro de funciones!).\n\nConsideremos el siguiente caso donde se busca calcuar el precio final de un producto, considerando impuestos y descuentos.\n\nprecio_base = 800   # Precio del producto ($800)\nimpuesto = 0.21     # Impuesto (21%)\ndescuento = 0.10    # Descuento (10%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n871.2\n\n\n¬øQu√© pasa si queremos calcular el precio final para otros productos con diferentes precios, impuestos o descuentos?\nUna opci√≥n es repetir el c√≥digo tantas veces como sea necesario‚Ä¶\n\nprecio_base = 500   # Precio del producto ($500)\nimpuesto = 0.105    # Impuesto (10.5%)\ndescuento = 0.0     # Descuento (0%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n552.5\n\n\n\nprecio_base = 2000  # Precio del producto ($2000)\nimpuesto = 0.21     # Impuesto (21%)\ndescuento = 0.20    # Descuento (20%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n1936.0\n\n\nOtra opci√≥n, mucho mas conveniente, es utilizar funciones.\n\ndef calcular_precio(precio_base, impuesto, descuento):\n    resultado = precio_base * (1 + impuesto) * (1 - descuento)\n    return resultado\n\nLuego, para utilizar la funci√≥n simplemente la llamamos (o invocamos).\n\ncalcular_precio(800, 0.21, 0.10)\n\n871.2\n\n\nTambi√©n es posible indicar los valores de los argumentos utilizando sus nombres.\n\ncalcular_precio(precio_base=2000, impuesto=0.21, descuento=0.20)\n\n1936.0",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#definici√≥n-de-funciones",
    "href": "teoria/01_programacion_en_python/02_funciones.html#definici√≥n-de-funciones",
    "title": "Funciones",
    "section": "Definici√≥n de funciones",
    "text": "Definici√≥n de funciones\nAnalicemos las diferentes partes que forman la definici√≥n de una funci√≥n en Python:\n\n\n\n\n\n\nLa palabra clave def:\n\nMarca el inicio de la definici√≥n de una funci√≥n.\nEs una palabra reservada (keyword).\n\nEl nombre de la funci√≥n:\n\nDebe seguir las mismas reglas que los nombres de las variables.\n\nLos argumentos de la funci√≥n, dentro de par√©ntesis:\n\nSe separan por comas y pueden ser 0 o m√°s.\n\nLos dos puntos (:):\n\nIndican el final de la l√≠nea de definici√≥n y el inicio del bloque de c√≥digo.\n\nEl bloque de c√≥digo, que es el cuerpo de la funci√≥n:\n\nEs el c√≥digo que se ejecuta cada vez que llamamos a la funci√≥n.\n\nLa sentencia return que indica el resultado que devuelve la funci√≥n.\n\nLuego del return viene el valor o nombre de la variable a devolver.\nEs opcional (ya vamos a ver ejemplos).\n\n\n\n\n\n\n\n\nObservaci√≥n üëÄ\n\n\n\nEn R se tiene que asignar de manera expl√≠cita una funci√≥n a una variable. Por ejemplo:\nsumar &lt;- function(x, y) {\n    return(x + y)\n}\nEn cambio, en Python, la sentencia def define la funci√≥n y le asigna un nombre en un mismo paso.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#ejemplos",
    "href": "teoria/01_programacion_en_python/02_funciones.html#ejemplos",
    "title": "Funciones",
    "section": "Ejemplos",
    "text": "Ejemplos\n\n1. Suma de n√∫meros\nComencemos con una funci√≥n super sencilla. La misma se llama sumar, recibe dos argumentos x e y, y devuelve la suma de ambos.\n\ndef sumar(x, y):\n    return x + y\n\n\nsumar(15, 21.9)\n\n36.9\n\n\n\ntype(sumar(15, 21.9))\n\nfloat\n\n\nEl valor que devuelve puede ser tratado como cualquier valor en Python. Por ejemplo, se lo puede asignar a una variable.\n\nresultado = sumar(10, 11)\nresultado\n\n21\n\n\nY el valor de esa variable puede ser luego pasado a una nueva llamada a sumar() (o a cualquier otra funci√≥n).\n\nsumar(resultado, 2.55)\n\n23.55\n\n\nIncluso es posible pasar expresiones y llamadas a funciones a la hora de pasar un argumento:\n\nsumar(sumar(1, 2), 3)\n\n6\n\n\nEn la l√≠nea sumar(sumar(1, 2), 3), Python comienza evaluando la funci√≥n sumar(). Pero para poder hacerlo, primero necesita conocer los valores de los argumentos. Al revisar el primer argumento, detecta que no es un valor directamente, sino otra llamada a la funci√≥n sumar(1, 2), por lo que la eval√∫a primero. El resultado de esa operaci√≥n es 3, que se toma como valor del primer argumento de la llamada externa. El segundo argumento ya est√° dado: tambi√©n es 3. Entonces, Python invoca la funci√≥n sumar() con los argumentos 3 y 3, cuyo resultado es 6. Finalmente, ese valor se muestra en pantalla.\n\n\n2. Saludo personalizado\nOtro ejemplo sencillo consiste en una funci√≥n que recibe un nombre e imprime un saludo en pantalla.\n\ndef saludar(nombre):\n    print(\"Hola\", nombre)\n\n\nsaludar(\"Pablo\")\n\nHola Pablo\n\n\nEsta funci√≥n no devuelve un resultado, sino que utiliza el argumento recibido para mostrar un mensaje en pantalla.\n\nsaludar(\"Juan\" + \" Manuel\")\n\nHola Juan Manuel\n\n\n\n\n3. Sin par√°metros\nY podemos tener funciones que no utilicen ning√∫n argumento.\n\ndef decir_hola():\n    print(\"¬°Hola!\")\n\n\ndecir_hola()\ndecir_hola()\ndecir_hola()\n\n¬°Hola!\n¬°Hola!\n¬°Hola!\n\n\n\n\n4. Devoluci√≥n de m√∫ltiples valores\nEn Python, las funciones pueden devolver m√∫ltiples valores separ√°ndolos por comas en la sentencia return. Por ejemplo:\n\ndef potencias(x):\n    cuadrado = x ** 2\n    cubo = x ** 3\n    return cuadrado, cubo\n\npotencias(2)\n\n(4, 8)\n\n\nEl resultado de este tipo de funciones puede ser asignado a m√∫ltiples variables. De esta forma, podemos obtener el cuadrado y el cubo de un n√∫mero con una sola llamada a una funci√≥n.\n\ncuadrado, cubo = potencias(8)\nprint(cuadrado)\nprint(cubo)\n\n64\n512\n\n\n\n\n\n\n\n\nObservaci√≥n üëÄ\n\n\n\nAl igual que en la asignaci√≥n m√∫ltiple de variables, lo que parece ser una funci√≥n que devuelve m√∫ltiples objetos es en realidad una funci√≥n que devuelve un √∫nico objeto llamado tupla (de tipo tuple) que permite la t√©cnica de unpacking.\nNo te preocupes, m√°s adelante vamos a ver bien c√≥mo funciona.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#diagrama-de-una-funci√≥n",
    "href": "teoria/01_programacion_en_python/02_funciones.html#diagrama-de-una-funci√≥n",
    "title": "Funciones",
    "section": "Diagrama de una funci√≥n",
    "text": "Diagrama de una funci√≥n\n\n\n\n\n\nAlgunos efectos colaterales pueden ser:\n\nImprimir un texto o un gr√°fico.\nCambiar el valor de una variable global.\nCrear, eliminar o modificar un archivo de la computadora.\n\n\n\n\n\n\n\n¬øPuedo devolver una salida y generar efectos colaterales a la vez? ü§î\n\n\n\nUna funci√≥n en Python puede realizar m√∫ltiples tareas, como devolver un valor e imprimir un mensaje en pantalla.\nPor ejemplo:\ndef producto(x, y):\n    resultado = x * y\n    print(\"El producto es\", resultado)\n    return resultado\nLa funci√≥n producto() no solo calcula y devuelve el resultado de multiplicar x por y, sino que adem√°s muestra un mensaje por pantalla.\nSin embargo, en general no es una buena pr√°ctica combinar tareas distintas dentro de una misma funci√≥n, especialmente si son de distinta naturaleza (como devolver un valor y causar un efecto colateral). Esto puede dificultar la reutilizaci√≥n y el mantenimiento del c√≥digo.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#argumentos-nombrados-y-posicionales",
    "href": "teoria/01_programacion_en_python/02_funciones.html#argumentos-nombrados-y-posicionales",
    "title": "Funciones",
    "section": "Argumentos nombrados y posicionales",
    "text": "Argumentos nombrados y posicionales\nAl definir una funci√≥n, debemos darle un nombre a cada uno de los argumentos que va a recibir.\nAl llamar a la funci√≥n, podemos pasar los valores de dos formas: por posici√≥n o por nombre.\nPor ejemplo, las siguientes llamadas a la funci√≥n sumar() son equivalentes:\n\nsumar(x = 10, y = 15)\n\n25\n\n\n\nsumar(10, 15)\n\n25\n\n\nSi utilizamos los nombres para pasar los argumentos no hace falta que est√©n en el mismo orden que en la definici√≥n de la funci√≥n.\n\nsumar(y = 15, x = 10)\n\n25\n\n\n¬°Que sea posible no significa que sea una buena pr√°ctica!",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#ausencia-de-return",
    "href": "teoria/01_programacion_en_python/02_funciones.html#ausencia-de-return",
    "title": "Funciones",
    "section": "Ausencia de return",
    "text": "Ausencia de return\nLa funci√≥n sumar() termina con la siguiente l√≠nea:\n    return x + y\nEs decir, utiliza la sentencia return para devolver un valor.\nPor otro lado, la funci√≥n saludar() termina con un print() y no tiene ning√∫n return.\n    print(\"Hola\", nombre)\n\nresultado = sumar(1, 2)\nresultado\n\n3\n\n\n\nsaludo = saludar(\"Juan\")\n\nHola Juan\n\n\n\n¬øCu√°l es el valor de la variable saludo?\n¬øPor qu√©?\n¬øTiene sentido?\n\n\nprint(saludo)\n\nNone\n\n\nEn Python no existe el concepto de return impl√≠cito.\nSi queremos que una funci√≥n devuelva un valor, es necesario usar la instrucci√≥n return de forma expl√≠cita.\nEn caso de no hacerlo, la funci√≥n devuelve autom√°ticamente None.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#argumentos-por-defecto",
    "href": "teoria/01_programacion_en_python/02_funciones.html#argumentos-por-defecto",
    "title": "Funciones",
    "section": "Argumentos por defecto",
    "text": "Argumentos por defecto\nCuando definimos una funci√≥n podemos determinar valores por defecto para uno o m√°s par√°metros.\nSi cuando llamamos a la funci√≥n le pasamos un valor a ese par√°metro, se utiliza el valor que pasamos. Sino, se usa el valor por defecto.\nEsta pr√°ctica es √∫til para simplificar las llamadas que realizamos a una funci√≥n.\nSupongamos la siguiente funci√≥n describir_mascota() que tiene los par√°metros nombre y tipo\n\ndef describir_mascota(nombre, tipo):\n    print(\"Tengo un\", tipo)\n    print(\"Y su nombre es\", nombre)\n\ndescribir_mascota(\"Bruno\", \"perro\")\n\nTengo un perro\nY su nombre es Bruno\n\n\nAhora, hacemos que el par√°metro nombre sea por defecto igual a \"perro\".\n\ndef describir_mascota(nombre, tipo=\"perro\"):\n    print(\"Tengo un\", tipo)\n    print(\"Y su nombre es\", nombre)\n\nDe este modo, es posible llamar a la funci√≥n solamente pasando valores para aquellos par√°metros sin valor por defecto:\n\ndescribir_mascota(\"Bruno\")\n\nTengo un perro\nY su nombre es Bruno\n\n\nComo es de esperar, tambi√©n es posible pasar valores distintos a los establecidos por defecto:\n\ndescribir_mascota(\"Nemo\", \"pez\")\n\nTengo un pez\nY su nombre es Nemo",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html",
    "title": "Ejecuci√≥n condicional",
    "section": "",
    "text": "Las computadoras son muy buenas para much√≠simas cosas. En particular:\n\nDeterminar autom√°ticamente que secciones de un programa se debe ejecutar.\nRealizar tareas repetitivas.\n\nEl primer punto se refiere a la ejecuci√≥n condicional de c√≥digo y el segundo a la ejecuci√≥n repetitiva de c√≥digo.\nEstos dos puntos pueden ser vistos de manera general como control de flujo del c√≥digo.\nEn este apunte hablamos de la ejecuci√≥n condicional de c√≥digo.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "Ejecuci√≥n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#introducci√≥n",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#introducci√≥n",
    "title": "Ejecuci√≥n condicional",
    "section": "",
    "text": "Las computadoras son muy buenas para much√≠simas cosas. En particular:\n\nDeterminar autom√°ticamente que secciones de un programa se debe ejecutar.\nRealizar tareas repetitivas.\n\nEl primer punto se refiere a la ejecuci√≥n condicional de c√≥digo y el segundo a la ejecuci√≥n repetitiva de c√≥digo.\nEstos dos puntos pueden ser vistos de manera general como control de flujo del c√≥digo.\nEn este apunte hablamos de la ejecuci√≥n condicional de c√≥digo.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "Ejecuci√≥n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if",
    "title": "Ejecuci√≥n condicional",
    "section": "Bloques if",
    "text": "Bloques if\nLos bloques if utilizan la keyword if para evaluar una condici√≥n y ejecutar una secci√≥n de c√≥digo en base al resultado de esta evaluaci√≥n.\n\n\n\n\n\nVeamos un ejemplo.\n\ncondicion = True\nif condicion:\n    print(\"Se ejecuta el bloque if\")\n\nSe ejecuta el bloque if\n\n\n\ncondicion = False\nif condicion:\n    print(\"Se ejecuta el bloque if\")\n\nDe manera mas general, un bloque if es de la siguiente forma:\n\n\n\n\n\nTiene los siguientes componentes:\n\nLa palabra clave if.\nLa condici√≥n a evaluar, que tiene que ser True o False. Esta va seguida de los dos puntos : que indican el fin de la condici√≥n a evaluar y que lo siguiente es el bloque de c√≥digo a ejecutar condicionalmente.\nEl bloque de c√≥digo a evaluar si condici√≥n es verdadera.\n\nVeamos otro ejemplo.\n\ncondicion = True\nif condicion:\n    print(\"Se ejecuta el bloque if\")\n\nprint(\"Esto se imprime siempre\")\n\nSe ejecuta el bloque if\nEsto se imprime siempre\n\n\nEl segundo print() se imprime siempre porque est√° por fuera del bloque de ejecuci√≥n condicional.\n¬øC√≥mo nos damos cuenta que no est√° dentro del bloque condicional?\nSimplemente la indentaci√≥n vuelve a ser normal. El fin de la indentaci√≥n indica el fin del bloque de c√≥digo.\n\nvalor = 12\nif valor &gt; 10:\n    print(\"Se ejecuta el bloque if\")\n\nSe ejecuta el bloque if",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "Ejecuci√≥n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if---else",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if---else",
    "title": "Ejecuci√≥n condicional",
    "section": "Bloques if - else",
    "text": "Bloques if - else\nVimos que el bloque if nos permite ejecutar un bloque de c√≥digo de manera condicional, y que luego el programa sigue su ejecuci√≥n normal.\nTambi√©n es posible que necesitemos ejecutar un bloque de c√≥digo cuando las condiciones resulten en True y un bloque distinto en el caso contrario.\nPara eso, utilizamos el bloque if-else.\nUn bloque if-else es muy similar a un bloque if.\nLa diferencia es que nos permite definir otro bloque de c√≥digo que se ejecuta cuando la prueba condicional es False.\n\n\n\n\n\n\nedad = 21\nif edad &gt;= 16:\n    print(\"Ten√©s la edad suficiente para votar\")\nelse:\n    print(\"Lo siento, a√∫n sos demasiado j√≥ven para votar\")\n\nTen√©s la edad suficiente para votar\n\n\n\n\n\n\n\nAl igual que con el bloque if, cualquier parte del c√≥digo que se escriba luego del bloque if-else es ejecutada sin importar el valor de las condiciones.\nVeamos otro ejemplo donde evaluamos si un n√∫mero es par o impar.\n\nvalor = 10\nprint(valor)\n\nif valor % 2 == 0:\n    mensaje = \"Es par\"\nelse:\n    mensaje = \"Es impar\"\n\nprint(mensaje)\n\n10\nEs par\n\n\nEn este caso, print(mensaje) se ejecuta siempre.\nLo que var√≠a es el valor de la variable mensaje, que depende de si el n√∫mero es par o impar.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "Ejecuci√≥n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if-elif-else",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if-elif-else",
    "title": "Ejecuci√≥n condicional",
    "section": "Bloques if-elif-else",
    "text": "Bloques if-elif-else\nEs muy probable que tengamos situaciones donde necesitemos considerar m√°s de dos escenarios posibles.\nPara esto, Python ofrece los bloques if-elif-else.\nEste tipo de programa considera varias condiciones y las eval√∫a de a una a la vez hasta que alguna es verdadera. Luego se ejecuta solamente el bloque de c√≥digo que corresponde a la primer condici√≥n verdadera.\n\n\n\n\n\nSupongamos que viene un parque de diversiones a Rosario y tiene los siguientes precios para la entrada:\n\nMenores de 4 a√±os, gratis.\nPersonas entre 4 y 18 a√±os, $400.\nPersonas de 18 o mas a√±os, $600.\n\n\nedad = 3\n\nif edad &lt; 4:\n    print(\"El costo de entrada para vos es de $0.\")\nelif edad &lt; 18:\n    print(\"El costo de entrada para vos es de $400.\")\nelse:\n    print(\"El costo de entrada para vos es de $600.\")\n\nEl costo de entrada para vos es de $0.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "Ejecuci√≥n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#m√∫ltiples-bloques-elif",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#m√∫ltiples-bloques-elif",
    "title": "Ejecuci√≥n condicional",
    "section": "M√∫ltiples bloques elif",
    "text": "M√∫ltiples bloques elif\nHasta ahora utilizamos un √∫nico bloque elif, pero podemos usar tantos como sea necesario.\nPor ejemplo, si el parque de diversiones decide realizar un descuento para adultos mayores, dejando el precio en $350, podriamos agregar otro bloque elif que represente la evaluaci√≥n de esta condici√≥n.\n\nedad = 68\n\nif edad &lt; 4:\n    precio = 0\nelif edad &lt; 18:\n    precio = 400\nelif edad &lt; 65:\n    precio = 600\nelse:\n    precio = 350\n\nprint(f\"El precio de entrada para vos es de ${precio}.\")\n\nEl precio de entrada para vos es de $350.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "Ejecuci√≥n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#omitir-el-bloque-else",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#omitir-el-bloque-else",
    "title": "Ejecuci√≥n condicional",
    "section": "Omitir el bloque else",
    "text": "Omitir el bloque else\nNo hay ninguna regla que nos obligue a terminar un bloque de if-elif con un bloque else.\nUtilizar el bloque else a veces es lo correcto, pero otras veces puede ser mejor poner una condici√≥n expl√≠cita en un √∫ltimo elif que contemple solamente la condici√≥n que realmente nos interesa.\n\nedad = 10\n\nif edad &lt; 4:\n    precio = 0\nelif edad &lt; 18:\n    precio = 400\nelif edad &lt; 65:\n    precio = 600\nelif edad &gt;= 65:\n    precio = 350\n\nprint(f\"El precio de entrada para vos es de ${precio}.\")\n\nEl precio de entrada para vos es de $400.\n\n\nEl bloque elif que agregamos indica que el precio ser√° de $350 cuando la edad de la persona sea mayor o igual a 65 a√±os.\nEsta condici√≥n es m√°s expl√≠cita y f√°cil de entender que el bloque else que us√°bamos antes.\nSin embargo, todav√≠a hay un problema: el programa sigue funcionando incluso si se ingresan edades fuera de un rango razonable. A continuaci√≥n se muestra una versi√≥n m√°s completa:\n\nedad = 125\n\nif edad &lt; 0:\n    print(\"¬°Error!\")\n    precio = None\nelif edad &lt; 4:\n    precio = 0\nelif edad &lt; 18:\n    precio = 400\nelif edad &lt; 65:\n    precio = 600\nelif edad &gt;= 65 and edad &lt;= 120:\n    precio = 350\nelse:\n    print(\"¬°Error!\")\n    precio = None\n\nprint(f\"El precio de entrada para vos es ${precio}.\")\n\n¬°Error!\nEl precio de entrada para vos es $None.\n\n\nEl diagrama y el c√≥digo para el caso solo con elif se ven de la siguiente manera:",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "Ejecuci√≥n condicional"
    ]
  }
]