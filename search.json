[
  {
    "objectID": "practica/01_programacion_en_python/problemas.html",
    "href": "practica/01_programacion_en_python/problemas.html",
    "title": "üß© Problemas",
    "section": "",
    "text": "En criptograf√≠a, el cifrado C√©sar es una de las t√©cnicas de cifrado m√°s simples y m√°s usadas.\nEs un tipo de cifrado en el que una letra en el texto original es reemplazada por otra letra que se encuentra un n√∫mero fijo de posiciones m√°s adelante en el alfabeto.\nPor ejemplo, con un desplazamiento de 3, la A ser√≠a sustituida por la D (situada 3 lugares a la derecha de la A), la B ser√≠a reemplazada por la E, etc.\n\n\n\n\n\nEscriba una funci√≥n, y luego un script, que permita cifrar y descifrar cadenas usando el cifrado C√©sar con un n√∫mero arbitrario de posiciones.\nDos funciones incluidas con Python que pueden ser √∫tiles para esta tarea son ord(), que convierte caracteres num√©ricos a n√∫meros, y chr(), que realiza la operaci√≥n inversa.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara el cifrado de un √∫nico caracter:\n\nDefinir un desplazamiento, por ejemplo 3.\nConvertir el caracter a n√∫mero usando ord().\nSumarle desplazamiento.\nFinalmente, convertirlo a caracter nuevamente utilizando chr().\n\nY para el descifrado:\n\nConvertir el caracter a n√∫mero.\nRestarle desplazamiento.\nConvertirlo a caracter nuevamente utilizando chr().\n\nAs√≠, se deber√≠a recuperar el caracter definido al principio.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üß© Problemas"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/problemas.html#cifrado-c√©sar",
    "href": "practica/01_programacion_en_python/problemas.html#cifrado-c√©sar",
    "title": "üß© Problemas",
    "section": "",
    "text": "En criptograf√≠a, el cifrado C√©sar es una de las t√©cnicas de cifrado m√°s simples y m√°s usadas.\nEs un tipo de cifrado en el que una letra en el texto original es reemplazada por otra letra que se encuentra un n√∫mero fijo de posiciones m√°s adelante en el alfabeto.\nPor ejemplo, con un desplazamiento de 3, la A ser√≠a sustituida por la D (situada 3 lugares a la derecha de la A), la B ser√≠a reemplazada por la E, etc.\n\n\n\n\n\nEscriba una funci√≥n, y luego un script, que permita cifrar y descifrar cadenas usando el cifrado C√©sar con un n√∫mero arbitrario de posiciones.\nDos funciones incluidas con Python que pueden ser √∫tiles para esta tarea son ord(), que convierte caracteres num√©ricos a n√∫meros, y chr(), que realiza la operaci√≥n inversa.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara el cifrado de un √∫nico caracter:\n\nDefinir un desplazamiento, por ejemplo 3.\nConvertir el caracter a n√∫mero usando ord().\nSumarle desplazamiento.\nFinalmente, convertirlo a caracter nuevamente utilizando chr().\n\nY para el descifrado:\n\nConvertir el caracter a n√∫mero.\nRestarle desplazamiento.\nConvertirlo a caracter nuevamente utilizando chr().\n\nAs√≠, se deber√≠a recuperar el caracter definido al principio.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üß© Problemas"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/problemas.html#n√∫meros-aleatorios",
    "href": "practica/01_programacion_en_python/problemas.html#n√∫meros-aleatorios",
    "title": "üß© Problemas",
    "section": "2 N√∫meros aleatorios",
    "text": "2 N√∫meros aleatorios\nConstruya un programa en Python que genere una cantidad determinada de n√∫meros aleatorios uniformes dentro de un rango definido por el usuario. El programa debe:\n\nSolicitar al usuario la cantidad de n√∫meros a generar y los valores m√≠nimo y m√°ximo del rango.\nGenerar los n√∫meros aleatorios\nGuardar los n√∫meros en un archivo de texto, uno por l√≠nea.\nOfrecer la opci√≥n de mostrar un resumen estad√≠stico con m√≠nimo, m√°ximo, media y desv√≠o est√°ndar, solo si el usuario lo solicita.\n\nPara resolver este problema utilice el m√≥dulo random y las funciones desarrolladas en el ejercicio Res√∫menes estad√≠sticos guardadas en un m√≥dulo llamado estadistica.py.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üß© Problemas"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/problemas.html#mensaje-al-descubierto",
    "href": "practica/01_programacion_en_python/problemas.html#mensaje-al-descubierto",
    "title": "üß© Problemas",
    "section": "3 Mensaje al descubierto",
    "text": "3 Mensaje al descubierto\nResulta que Franco, un amigo que estudia Ciencias de la Computaci√≥n en la FCEIA, te env√≠a por WhatsApp un archivo de texto plano con mensajes ‚Äúencriptados‚Äù usando caracteres sobrantes y s√≠mbolos extra√±os:\n    !!!,.,  aY??/u/DAM**e,, se =m!!e\n&&M&&e v!o!?LV...I.O /L/*oC/*o\n        __?e_?l//+ T++**e/*Cl!?aD==*O**\nTiene sentido pensar que est√° experimentando con nuevos algoritmos de cifrado y, de paso, te lanza el reto de descifrarlo.\nTu misi√≥n es escribir un programa que:\n\nLea un archivo de texto plano cualquiera.\nMuestre en pantalla su contenido original (tal cual llega).\nAplique un proceso de limpieza basado en las siguientes reglas:\n\nEliminar todos los caracteres +, *, -, /, =, !, ?, & y _.\nReemplazar cualquier secuencia de espacios m√∫ltiples por un solo espacio.\nHomogeinizar la capitalizaci√≥n de los caracteres.\nConservar los saltos de l√≠nea tal cual aparecen en el archivo original.\n\nMuestre en pantalla la versi√≥n desencriptada del texto.\nGuarde la versi√≥n limpia en un nuevo archivo de texto.\n\nEl usuario debe poder especificar el nombre del archivo de salida.\nSi no lo hace, se generar√° uno con el sufijo _limpio antes de la extensi√≥n original (por ejemplo, secreto.txt ‚Üí secreto_limpio.txt).",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üß© Problemas"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/problemas.html#c√≥digo-morse",
    "href": "practica/01_programacion_en_python/problemas.html#c√≥digo-morse",
    "title": "üß© Problemas",
    "section": "4 C√≥digo Morse",
    "text": "4 C√≥digo Morse\nEl c√≥digo Morse es un sistema utilizado para representar letras mediante combinaciones espec√≠ficas de se√±ales cortas y largas, denominadas puntos (.) y rayas (-). A continuaci√≥n se muestra un diccionario con el mapeo de caracteres alfab√©ticos, d√≠gitos del 0 al 9 y algunos s√≠mbolos de puntuaci√≥n comunes:\nmapeo_morse = {\n    \"A\": \".-\",\n    \"B\": \"-...\",\n    \"C\": \"-.-.\",\n    \"D\": \"-..\",\n    \"E\": \".\",\n    \"F\": \"..-.\",\n    \"G\": \"--.\",\n    \"H\": \"....\",\n    \"I\": \"..\",\n    \"J\": \".---\",\n    \"K\": \"-.-\",\n    \"L\": \".-..\",\n    \"M\": \"--\",\n    \"N\": \"-.\",\n    \"O\": \"---\",\n    \"P\": \".--.\",\n    \"Q\": \"--.-\",\n    \"R\": \".-.\",\n    \"S\": \"...\",\n    \"T\": \"-\",\n    \"U\": \"..-\",\n    \"V\": \"...-\",\n    \"W\": \".--\",\n    \"X\": \"-..-\",\n    \"Y\": \"-.--\",\n    \"Z\": \"--..\",\n    \"1\": \".----\",\n    \"2\": \"..---\",\n    \"3\": \"...--\",\n    \"4\": \"....-\",\n    \"5\": \".....\",\n    \"6\": \"-....\",\n    \"7\": \"--...\",\n    \"8\": \"---..\",\n    \"9\": \"----.\",\n    \"0\": \"-----\",\n    \", \": \"--..--\",\n    \".\": \".-.-.-\",\n}\nEscriba una funci√≥n en Python que permita convertir cualquier palabra a c√≥digo Morse utilizando este diccionario. Luego, escriba otra funci√≥n que haga exactamente lo contrario: dada una secuencia en c√≥digo Morse, debe recuperar la palabra original. Finalmente, incorpore ambas funciones en un script principal que combine ambas funciones y permita encriptar o desencriptar texto desde un archivo de texto plano. El programa debe recibir:\n\nEl nombre del archivo de entrada.\nEl nombre del archivo de salida.\nLa operaci√≥n a realizar (encriptar o desencriptar).\n\nAyuda: Para indicar espacios en c√≥digo Morse utilice /.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üß© Problemas"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html",
    "href": "practica/03_oop/ejercicios.html",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "",
    "text": "Defina una clase Contador que represente un contador num√©rico. Por defecto, las instancias comienzan con el valor 0, aunque debe permitirse inicializarlas con un valor distinto.\nImplemente los siguientes m√©todos:\n\nincrementar: aumenta el valor del contador en una cantidad arbitraria (por defecto, 1).\ndecrementar: disminuye el valor del contador en una cantidad arbitraria (por defecto, 1).\nreiniciar: restablece el contador a su valor inicial (¬°que puede ser distinto de 0!).\nvalor: devuelve el valor actual del contador.\n\nEjemplo de uso\ncontador = Contador()\ncontador.incrementar(5)    # El valor interno es 5\ncontador.decrementar(2)    # El valor interno es 3\nprint(contador.valor())    # Imprime 3\ncontador.reiniciar()\nprint(contador.valor())    # Imprime 0",
    "crumbs": [
      "Pr√°ctica",
      "U3 - Programaci√≥n orientada a objetos",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html#contador",
    "href": "practica/03_oop/ejercicios.html#contador",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "",
    "text": "Defina una clase Contador que represente un contador num√©rico. Por defecto, las instancias comienzan con el valor 0, aunque debe permitirse inicializarlas con un valor distinto.\nImplemente los siguientes m√©todos:\n\nincrementar: aumenta el valor del contador en una cantidad arbitraria (por defecto, 1).\ndecrementar: disminuye el valor del contador en una cantidad arbitraria (por defecto, 1).\nreiniciar: restablece el contador a su valor inicial (¬°que puede ser distinto de 0!).\nvalor: devuelve el valor actual del contador.\n\nEjemplo de uso\ncontador = Contador()\ncontador.incrementar(5)    # El valor interno es 5\ncontador.decrementar(2)    # El valor interno es 3\nprint(contador.valor())    # Imprime 3\ncontador.reiniciar()\nprint(contador.valor())    # Imprime 0",
    "crumbs": [
      "Pr√°ctica",
      "U3 - Programaci√≥n orientada a objetos",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html#magia-para-programadores",
    "href": "practica/03_oop/ejercicios.html#magia-para-programadores",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "2 Magia para programadores",
    "text": "2 Magia para programadores\nEsta es tu primera clase de Pociones en Hogwarts y el profesor te dio como tarea descubrir de qu√© color se volver√° una poci√≥n si se mezcla con otra. Todas las pociones tienen un color definido en formato RGB, desde [0, 0, 0] hasta [255, 255, 255].\nPara complicar un poco m√°s la tarea, el profesor realizar√° varias mezclas seguidas y luego te preguntar√° por el color final. Adem√°s del color, tambi√©n deber√°s calcular qu√© volumen tendr√° la poci√≥n despu√©s de la mezcla final.\nGracias a tu experiencia en programaci√≥n descubriste que al mezclar dos pociones, los colores se combinan como si se mezclaran dos colores en formato RGB. Por ejemplo, si mezclas una poci√≥n con color [255, 255, 0] y volumen 10 con otra de color [0, 254, 0] y volumen 5, obtendr√°s una nueva poci√≥n con:\n\ncolor [170, 255, 0]\nvolumen 15\n\nPor lo tanto, decid√≠s crear una clase Pocion que tenga:\n\ndos propiedades:\n\ncolor (una lista o tupla con 3 enteros)\nvolumen (un n√∫mero)\n\nun m√©todo mezclar que acepte otra Pocion y devuelva una nueva Pocion ya mezclada.\n\nEjemplo:\nfelix_felicis = Pocion([255, 255, 255],  7)\npocion_multijugos = Pocion([51, 102, 51], 12)\nnueva_pocion = felix_felicis.mezclar(pocion_multijugos)\n\nnueva_pocion.color # Devuelve [127, 159, 127]\nnueva_pocion.volumen # Devuelve 19\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nLos colores de las pociones deben representarse como tr√≠os de n√∫meros enteros en formato RGB. Al realizar una mezcla de colores, se debe redondear hacia arriba utilizando math.ceil.",
    "crumbs": [
      "Pr√°ctica",
      "U3 - Programaci√≥n orientada a objetos",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html#mensaje-secreto",
    "href": "practica/03_oop/ejercicios.html#mensaje-secreto",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "3 Mensaje secreto",
    "text": "3 Mensaje secreto\nUn cifrado por sustituci√≥n simple reemplaza cada car√°cter de un alfabeto con un car√°cter de un alfabeto alternativo. Cada posici√≥n en el alfabeto original se mapea a la posici√≥n correspondiente en el alfabeto alternativo, y esto sirve tanto para codificar como para decodificar.\nEl objetivo es crear una clase que, al inicializarse, reciba dos alfabetos (original y alternativo). La clase debe tener un m√©todo para encriptar mensajes y otro para revertir la encriptaci√≥n.\nEjemplo:\nalfabeto = \"abcdefghijklmnopqrstuvwxyz\"\nalfabeto_mezclado = \"etaoinshrdlucmfwypvbgkjqxz\"\n\nmi_cifrado = Cifrado(alfabeto, alfabeto_mezclado)\n\nmi_cifrado.codificar(\"abc\")    # =&gt; \"eta\"\nmi_cifrado.codificar(\"xyz\")    # =&gt; \"qxz\"\nmi_cifrado.codificar(\"aeiou\")  # =&gt; \"eirfg\"\n\nmi_cifrado.decodificar(\"eta\")    # =&gt; \"abc\"\nmi_cifrado.decodificar(\"qxz\")    # =&gt; \"xyz\"\nmi_cifrado.decodificar(\"eirfg\")  # =&gt; \"aeiou\"\n\nPunto extra\nVerifique en el m√©todo __init__ que la longitud de los alfabetos sea la misma. Caso contrario, levante una excepci√≥n ValueError indicando cu√°l es el problema.",
    "crumbs": [
      "Pr√°ctica",
      "U3 - Programaci√≥n orientada a objetos",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html#real-envido",
    "href": "practica/03_oop/ejercicios.html#real-envido",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "4 Real envido",
    "text": "4 Real envido\nConstruir una clase ManoDeTruco que, al inicializarse, reciba una lista o tupla de hasta tres n√∫meros enteros, correspondientes a los valores de las cartas en una mano de truco.\nLa clase debe incluir un m√©todo llamado comparar_con que recibe otra mano de truco y determine cu√°l de las dos suma m√°s puntos para el envido. En caso de empate, se considera ganadora la mano que invoc√≥ el m√©todo.\nEjemplo de uso\nmano1 = ManoDeTruco([7, 5, 6])\nmano2 = ManoDeTruco([4, 11, 2])\n\nganadora = mano1.comparar_con(mano2)\n\n\n\n\n\n\nConsideraciones\n\n\n\n\n\n\nAsuma que todas las cartas cargadas en la mano son del mismo palo.\nPara calcular los puntos del envido, solo se consideran dos de las tres cartas, no la suma de las tres.",
    "crumbs": [
      "Pr√°ctica",
      "U3 - Programaci√≥n orientada a objetos",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html#la-muestra-infinita",
    "href": "practica/03_oop/ejercicios.html#la-muestra-infinita",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "5 La muestra infinita",
    "text": "5 La muestra infinita\nDefina una clase Muestra que represente un conjunto de datos num√©ricos. La clase debe inicializarse a partir de un iterable de n√∫meros e implementar los siguientes m√©todos:\n\nagregar(x): agrega un n√∫mero a la muestra.\nn(): devuelve la cantidad de elementos.\nsuma(): devuelve la suma de los valores.\nmedia(): devuelve el promedio de los valores.\nvarianza(muestral=False): calcula la varianza.\n\nSi muestral=False, se usa el denominador n (varianza poblacional).\nSi muestral=True, se usa el denominador n-1 (varianza muestral).\n\n\nEjemplo de uso\nmuestra = Muestra([10, 12, 13, 15])\nmuestra.agregar(20)\nmuestra.n()                     # 5\nmuestra.suma()                  # 70\nmuestra.media()                 # 14.0\nmuestra.varianza()              # varianza poblacional\nmuestra.varianza(muestral=True) # varianza muestral\n\nPunto extra\nModifique la clase para que:\n\nGuarde los datos en un atributo ‚Äúprivado‚Äù llamado _datos.\nProvea una propiedad de solo lectura valores, que devuelva una copia inmutable de los datos (por ejemplo, una tupla).",
    "crumbs": [
      "Pr√°ctica",
      "U3 - Programaci√≥n orientada a objetos",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html#orden-en-el-laboratorio",
    "href": "practica/03_oop/ejercicios.html#orden-en-el-laboratorio",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "6 ¬°Orden en el laboratorio!",
    "text": "6 ¬°Orden en el laboratorio!\nEn un laboratorio se necesita llevar un registro ordenado de los experimentos realizados. Cada experimento debe contar con un n√∫mero identificador √∫nico, un nombre y, de manera opcional, el nombre de la persona responsable.\nEl objetivo de este ejercicio es construir una clase que facilite dicha organizaci√≥n.\nPara ello, implemente una clase llamada Experimento que se inicializa con el nombre del experimento y, opcionalmente, con el nombre del responsable. La clase debe asignar autom√°ticamente un n√∫mero identificador √∫nico a cada instancia. Para lograrlo, utilice un atributo de clase llamado total_creados, que comience en 0.\nCada instancia debe contar con:\n\nUn identificador num√©rico √∫nico (asignado autom√°ticamente de forma incremental por la clase).\nUn nombre.\nUn responsable, si se proporciona.\n\nEjemplo de uso\ne1 = Experimento(\"Piloto A\", responsable=\"Dolores\")\ne2 = Experimento(\"Piloto Z\")\nExperimento.total_creados  # Devuelve 2\n\nPuntos extra\nModifique la clase para que tambi√©n:\n\nSe puedan crear objetos utilizando un m√©todo de clase llamado desde_dict que reciba un diccionario de la forma {\"nombre\": ..., \"responsable\": ...} y devuelva una instancia de Experimento.\nImplemente el m√©todo m√°gico __repr__ que devuelva una cadena de texto con el siguiente formato: python     Experimento(id=1, nombre=\"A/B\", responsable=\"Sosa\")\n\nEjemplo de uso\ne = Experimento.desde_dict({\"nombre\": \"Piloto B\", \"responsable\": \"Ana\"})\nrepr(e)\n# Experimento(id=3, nombre=\"Piloto B\", responsable=\"Ana\")",
    "crumbs": [
      "Pr√°ctica",
      "U3 - Programaci√≥n orientada a objetos",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html#sensores-descalibrados",
    "href": "practica/03_oop/ejercicios.html#sensores-descalibrados",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "7 Sensores descalibrados",
    "text": "7 Sensores descalibrados\nEste ejercicio requiere dise√±ar una peque√±a jerarqu√≠a de clases para simular sensores utilizados en un laboratorio.\nEn la pr√°ctica, los sensores no siempre son completamente precisos: pueden registrar valores ligeramente superiores o inferiores al valor real. Para corregir ese desv√≠o, se aplica una calibraci√≥n, que consiste en ajustar las lecturas mediante un valor adicional o corrector llamado offset.\n\nJerarqu√≠a de clases\nClase base: Sensor\nLa clase Sensor debe incluir:\n\nUn atributo nombre para identificar al sensor.\nUn m√©todo leer que levante una excepci√≥n NotImplementedError, indicando que debe ser implementado por las subclases.\nUn m√©todo calibrar(offset) que permita almacenar un valor de ajuste (offset) que se aplicar√° a las lecturas.\n\nSubclases\nSe deben definir dos subclases: SensorTemperatura y SensorHumedad, ambas con su propia implementaci√≥n del m√©todo leer:\n\nSensorTemperatura: simula una medici√≥n utilizando random.uniform(18, 28).\nSensorHumedad: simula una medici√≥n utilizando random.uniform(30, 70).\n\nEn ambos casos, la medici√≥n debe ser ajustada por el offset correspondiente (si fue calibrado).\n\n\nFunci√≥n auxiliar\nAdem√°s, implemente una funci√≥n llamada promedio_lecturas que reciba dos argumentos: una secuencia de sensores y un n√∫mero entero n, que indica cu√°ntas lecturas realizar con cada sensor.\nLa funci√≥n debe realizar n lecturas para cada sensor utilizando su m√©todo leer, calcular el promedio de esas lecturas y devolver un diccionario que asocie el nombre de cada sensor con su promedio correspondiente.\nEjemplo de uso\nst = SensorTemperatura(\"T1\")\nsh = SensorHumedad(\"H1\")\nst.calibrar(0.5)\n\npromedios = promedio_lecturas([st, sh], n=3)\n# {'T1': ..., 'H1': ...}",
    "crumbs": [
      "Pr√°ctica",
      "U3 - Programaci√≥n orientada a objetos",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html#python-para-matem√°ticos",
    "href": "practica/03_oop/ejercicios.html#python-para-matem√°ticos",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "8 Python para matem√°ticos",
    "text": "8 Python para matem√°ticos\nConstruya una clase Fraccion que acepte dos argumentos: numerador y denominador. Se desea que esta clase:\n\nSea representable como cadena de texto.\nImplemente la suma entre fracciones.\nDevuelva siempre el resultado en la m√≠nima representaci√≥n posible (fracci√≥n irreducible).\n\nEjemplo:\nfraccion1 = Fraccion(4, 5)\nprint(fraccion1 + Fraccion(1, 8))\n#&gt; \"37/40\"\n\nPunto extra\nExtender la funcionalidad de la clase incluyendo las operaciones de resta, multiplicaci√≥n y divisi√≥n.",
    "crumbs": [
      "Pr√°ctica",
      "U3 - Programaci√≥n orientada a objetos",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html#tiempo-al-tiempo",
    "href": "practica/03_oop/ejercicios.html#tiempo-al-tiempo",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "9 Tiempo al tiempo ‚è≥",
    "text": "9 Tiempo al tiempo ‚è≥\nEl m√≥dulo est√°ndar datetime de Python incluye, entre otras cosas, la clase date para trabajar con fechas. El objetivo de este ejercicio es implementar, desde cero, una nueva clase Date que permita representar fechas y operar con ellas.\n\nPrimera implementaci√≥n\n\nConstruya la clase Date. El m√©todo __init__ debe tomar 3 par√°metros: year, month y day, y asignarlos como atributos de la instancia. Cree un objeto que represente el 6 de noviembre de 1995 y verifique que los atributos contengan los valores esperados.\nImplemente el m√©todo __str__, que debe devolver una cadena con el formato YYYY-MM-DD, donde YYYY representa el a√±o, MM el mes y DD el d√≠a. Ayuda: Puede utilizar el m√©todo .rjust de las cadenas de texto para agregar ceros a la izquierda cuando sea necesario. Por ejemplo, para el 6 de noviembre de 1995, str(fecha) debe devolver \"1995-11-06\".\nImplemente el m√©todo __repr__, que debe devolver una representaci√≥n similar a la utilizada para crear la instancia. Para la fecha 6 de noviembre de 1995, debe devolver la cadena \"Date(year=1995, month=11, day=6)\".\nImplemente un m√©todo de clase que permita crear una Date a partir de una cadena en formato YYYY-MM-DD. Por ejemplo, Date.from_str(\"2025-03-08\") debe devolver un objeto Date que representa al 8 de marzo de 2025. Ayuda: Puede utilizar el m√©todo .lstrip(\"0\") para eliminar ceros a la izquierda en una cadena.\nImplemente los m√©todos de comparaci√≥n entre objetos Date.\n\n__eq__: igualdad (==)\n__ne__: desigualdad (!=)\n__lt__: menor que (&lt;)\n__gt__: mayor que (&gt;)\n__le__: menor o igual que (&lt;=)\n__ge__: mayor o igual que (&gt;=)\n\nAyuda: Dos fechas se consideran iguales si sus atributos year, month, y day coinciden. Para las comparaciones, considere primero el a√±o, luego el mes y finalmente el d√≠a.\n\n\n\nA prueba de balas\nA esta altura, se cuenta con una implementaci√≥n razonablemente completa y funcional para representar objetos de tipo fecha. Sin embargo, la clase Date no garantiza la validez ni la robustez de las instancias que se crean. Es posible construir objetos Date que representen fechas inv√°lidas, como el 31 de abril o el 55.8 del mes 25.3, y operar con ellos sin que el programa emita ning√∫n tipo de advertencia.\n\nModifique la implementaci√≥n de los atributos year, month y day de modo que sean privados y que su asignaci√≥n incluya una verificaci√≥n de validez. Para ello, se propone lo siguiente:\n\nUtilice atributos privados llamados _year, _month y _day.\nDefina m√©todos year, month y day, decorados con @property, que expongan dichos atributos para su lectura. Estos m√©todos deben devolver el valor del atributo correspondiente.\nPara permitir la asignaci√≥n controlada, implemente un setter para cada atributo Para ello, decore el mismo m√©todo con @&lt;nombre&gt;.setter (por ejemplo, @year.setter) y defina all√≠ la l√≥gica de verificaci√≥n. Por el momento, verifique √∫nicamente que el valor asignado sea un n√∫mero entero y positivo. Eleve un ValueError en caso de que el valor por asignar no pase la verificaci√≥n.\n\n\nUtilice los siguientes ejemplos de verificaci√≥n\nd = Date(2022, 7, 1)\nrepr(d) # Date(year=2022, month=7, day=1)\nstr(d)  # \"2022-07-01\"\n(d.year, d.month, d.day) # (2022, 7, 1)\nDate(2022, 0, 1)       # Falla: el mes no es positivo\nDate(2022, 3, 5.5)     # Falla: el d√≠a no es un entero\nDate(\"11\", 3, 1)       # Falla: el a√±o es una cadena de texto\nd = Date(2022, 7, 1)\nd.day = 11             # Funciona: pasa la verificaci√≥n\nstr(d)                 # \"2022-07-11\"\n\nd.month = -1           # Falla\nd.year = -1            # Falla\n\nMejore ahora las verificaciones de los valores asignados para que sean m√°s robustas:\n\nEl a√±o debe ser entero y mayor o igual a 0.\nEl mes debe ser un n√∫mero entero entre 1 y 12 inclusive.\nEl d√≠a debe ser un n√∫mero entero mayor o igual a 1 y menor o igual a la cantidad de d√≠as del mes correspondiente.\n\n\nLa cantidad de d√≠as depende del mes. Para todos los meses excepto febrero, utilice el diccionario provisto en la ayuda debajo. Para el caso de febrero, implemente un m√©todo est√°tico que reciba un a√±o como argumento y devuelva un booleano indicando si ese a√±o es bisiesto.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nDiccionario de d√≠as por mes:\nDOM = {\n    1: 31,  # Enero\n    2: 28,  # Febrero (29 en a√±o bisiesto)\n    3: 31,  # Marzo\n    4: 30,  # Abril\n    5: 31,  # Mayo\n    6: 30,  # Junio\n    7: 31,  # Julio\n    8: 31,  # Agosto\n    9: 30,  # Septiembre\n    10: 31, # Octubre\n    11: 30, # Noviembre\n    12: 31, # Diciembre\n}\n\nDOM[5] # Devuelve 31, porque es mayo\nPor otro lado, un a√±o es bisiesto si:\n\nEs divisible por 4,\nexcepto que sea divisible por 100,\nsalvo que tambien sea divisibles por 400\n\nEn Python\n(year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)\n\n\n\nFinalmente, verifique que su clase Date funciona correctamente con los siguientes ejemplos:\n# Definici√≥n de fechas\nd1 = Date(1990, 5, 20)\nd2 = Date(1998, 9, 21)\nd3 = Date(1998, 9, 20)\nd4 = Date(2022, 12, 18)\n\nd1 &lt; d2\nd1 &gt; d2\nd1 != d3\nd4 &gt;= d3\n\nDate(2000, 2, 29) # Funciona, es bisiesto\nDate(2001, 2, 29) # Falla, no es bisiesto\n\n\nl = [d1, d2, d3, d4]\nsorted(l) # Funciona, ¬øpor qu√©?",
    "crumbs": [
      "Pr√°ctica",
      "U3 - Programaci√≥n orientada a objetos",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/problemas.html",
    "href": "practica/02_programacion_funcional/problemas.html",
    "title": "üß© Problemas",
    "section": "",
    "text": "En programaci√≥n, el logging es el proceso de registrar eventos durante la ejecuci√≥n de un programa. Estos registros, llamados logs, permiten mantener un historial de lo que ocurri√≥, incluyendo estados del sistema, acciones realizadas y posibles errores o advertencias.\nEn este problema se propone implementar un decorador llamado log que registre, en un archivo, los valores de entrada y salida de cada llamada a las funciones decoradas. El decorador debe recibir como argumento la ruta del archivo donde se guardar√°n los mensajes.\nPor ejemplo, el siguiente c√≥digo:\nimport time\n\n@log(\"registro.log\")\ndef f(x, y):\n    return x + y\n\n@log(\"registro.log\")\ndef g(a, b):\n    return a + b ** 2\n\nf(3, 9)\ntime.sleep(1)\nf(256, 256)\ntime.sleep(3)\ng(3, 2)\nf(7, 8)\nDeber√≠a generar un archivo registro.log con un contenido similar al siguiente:\n\n\nregistro.log\n\n2025-09-02 18:04:07 - | f(x=3, y=9) -&gt; 12\n2025-09-02 18:04:08 - | f(x=256, y=256) -&gt; 512\n2025-09-02 18:04:11 - | g(a=3, b=2) -&gt; 7\n2025-09-02 18:04:11 - | f(x=7, y=8) -&gt; 15\n\n\n\n\nSi el archivo no existe, debe crearse autom√°ticamente.\nSi el archivo ya existe, los nuevos registros deben agregarse al final, sin sobrescribir los anteriores.\n\n\n\n\n\nPara obtener el momento exacto de la llamada, puede usar datetime.now() del m√≥dulo datetime.\nPara formatear ese valor como texto, utilice el m√©todo .strftime.\n\nPor ejemplo:\ndatetime.datetime.now().strftime(\"%Y-%m-%d¬†%H:%M:%S\")\n2025-09-02 18:30:39",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üß© Problemas"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/problemas.html#registro-de-llamadas",
    "href": "practica/02_programacion_funcional/problemas.html#registro-de-llamadas",
    "title": "üß© Problemas",
    "section": "",
    "text": "En programaci√≥n, el logging es el proceso de registrar eventos durante la ejecuci√≥n de un programa. Estos registros, llamados logs, permiten mantener un historial de lo que ocurri√≥, incluyendo estados del sistema, acciones realizadas y posibles errores o advertencias.\nEn este problema se propone implementar un decorador llamado log que registre, en un archivo, los valores de entrada y salida de cada llamada a las funciones decoradas. El decorador debe recibir como argumento la ruta del archivo donde se guardar√°n los mensajes.\nPor ejemplo, el siguiente c√≥digo:\nimport time\n\n@log(\"registro.log\")\ndef f(x, y):\n    return x + y\n\n@log(\"registro.log\")\ndef g(a, b):\n    return a + b ** 2\n\nf(3, 9)\ntime.sleep(1)\nf(256, 256)\ntime.sleep(3)\ng(3, 2)\nf(7, 8)\nDeber√≠a generar un archivo registro.log con un contenido similar al siguiente:\n\n\nregistro.log\n\n2025-09-02 18:04:07 - | f(x=3, y=9) -&gt; 12\n2025-09-02 18:04:08 - | f(x=256, y=256) -&gt; 512\n2025-09-02 18:04:11 - | g(a=3, b=2) -&gt; 7\n2025-09-02 18:04:11 - | f(x=7, y=8) -&gt; 15\n\n\n\n\nSi el archivo no existe, debe crearse autom√°ticamente.\nSi el archivo ya existe, los nuevos registros deben agregarse al final, sin sobrescribir los anteriores.\n\n\n\n\n\nPara obtener el momento exacto de la llamada, puede usar datetime.now() del m√≥dulo datetime.\nPara formatear ese valor como texto, utilice el m√©todo .strftime.\n\nPor ejemplo:\ndatetime.datetime.now().strftime(\"%Y-%m-%d¬†%H:%M:%S\")\n2025-09-02 18:30:39",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üß© Problemas"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/problemas.html#fibonacci-el-memorioso",
    "href": "practica/02_programacion_funcional/problemas.html#fibonacci-el-memorioso",
    "title": "üß© Problemas",
    "section": "2 Fibonacci el memorioso",
    "text": "2 Fibonacci el memorioso\nLa implementaci√≥n recursiva m√°s directa de la secuencia de Fibonacci es tan concisa como ineficiente.\ndef fibonacci(n):\n    if n &lt;= 1:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)\nAl invocar fibonacci(7), se realizan llamadas a fibonacci(6) y fibonacci(5). Luego, fibonacci(6) vuelve a llamar a fibonacci(5) y fibonacci(4), y as√≠ sucesivamente. Muchas de estas llamadas se repiten: por ejemplo, fibonacci(5) se calcula m√°s de una vez.\nEste comportamiento muestra que los subproblemas se superponen: los mismos valores se recalculan de manera redundante.\nEl objetivo de este ejercicio es dise√±ar una funci√≥n capaz de recordar resultados ya obtenidos, evitando recomputarlos cada vez que aparecen. Para lograrlo, podemos construir una funci√≥n recursiva que memorice sus valores anteriores y, as√≠, avance en la secuencia sin rehacer todos los c√°lculos previos.\n\nAyuda\nConsidere una function factory que devuelva la funci√≥n recursiva. Dentro del √°mbito de la function factory puede existir una estructura de datos mutable que almacene los resultados ya calculados.",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üß© Problemas"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/07_scripting.html",
    "href": "teoria/01_programacion_en_python/07_scripting.html",
    "title": "7 - Scripting",
    "section": "",
    "text": "En programaci√≥n, un script es un archivo de texto que contiene una secuencia l√≥gica de pasos que se pueden ejecutar para realizar una tarea espec√≠fica, ya sea simple o compleja. Esta serie de pasos suele expresarse en un lenguaje de scripting, un lenguaje de programaci√≥n que permite manipular, personalizar y automatizar tareas.\nA diferencia de los programas compilados, los scripts suelen interpretarse en tiempo de ejecuci√≥n. Es decir, un int√©rprete se encarga de leer, procesar y ejecutar cada instrucci√≥n en orden.\nEn el caso de Python, un script es un archivo con extensi√≥n .py que puede automatizar procesos, analizar datos, crear aplicaciones o pr√°cticamente cualquier otra tarea que el lenguaje permita. El int√©rprete de Python ejecuta el c√≥digo l√≠nea por l√≠nea, lo que facilita probar, modificar y reutilizar el programa de manera √°gil\nDebido a su uso frecuente para desarrollar scripts, Python es conocido tambi√©n como un lenguaje de scripting, aunque en la pr√°ctica su uso sea mucho m√°s amplio.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "7 - _Scripting_"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/07_scripting.html#qu√©-es-un-script",
    "href": "teoria/01_programacion_en_python/07_scripting.html#qu√©-es-un-script",
    "title": "7 - Scripting",
    "section": "",
    "text": "En programaci√≥n, un script es un archivo de texto que contiene una secuencia l√≥gica de pasos que se pueden ejecutar para realizar una tarea espec√≠fica, ya sea simple o compleja. Esta serie de pasos suele expresarse en un lenguaje de scripting, un lenguaje de programaci√≥n que permite manipular, personalizar y automatizar tareas.\nA diferencia de los programas compilados, los scripts suelen interpretarse en tiempo de ejecuci√≥n. Es decir, un int√©rprete se encarga de leer, procesar y ejecutar cada instrucci√≥n en orden.\nEn el caso de Python, un script es un archivo con extensi√≥n .py que puede automatizar procesos, analizar datos, crear aplicaciones o pr√°cticamente cualquier otra tarea que el lenguaje permita. El int√©rprete de Python ejecuta el c√≥digo l√≠nea por l√≠nea, lo que facilita probar, modificar y reutilizar el programa de manera √°gil\nDebido a su uso frecuente para desarrollar scripts, Python es conocido tambi√©n como un lenguaje de scripting, aunque en la pr√°ctica su uso sea mucho m√°s amplio.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "7 - _Scripting_"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/07_scripting.html#script-vs-m√≥dulo",
    "href": "teoria/01_programacion_en_python/07_scripting.html#script-vs-m√≥dulo",
    "title": "7 - Scripting",
    "section": "Script vs m√≥dulo",
    "text": "Script vs m√≥dulo\nPython es un lenguaje de programaci√≥n interpretado, y por ello sus programas suelen denominarse scripts. Sin embargo, no siempre es correcto usar este t√©rmino. Si bien muchos programas en Python consisten en instrucciones destinadas a resolver tareas puntuales, otros programas tienen por objetivo principal implementar herramientas que luego van a ser utilizadas por otros programas.\nUn programa de Python puede denominarse script o m√≥dulo. El prop√≥sito del c√≥digo en un archivo de texto .py es lo que determina si lo llamamos de una manera o de la otra. Cuando un archivo contiene c√≥digo ejecutable cuyo fin es realizar una tarea espec√≠fica, se lo considera script. En cambio, cuando el archivo est√° dise√±ado para ser importado y utilizado desde otro programa de Python, se lo denomina m√≥dulo.\nEn s√≠ntesis, la principal diferencia entre un m√≥dulo y un script es que los m√≥dulos almacenan c√≥digo importable mientras que los scripts contienen c√≥digo ejecutable.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "7 - _Scripting_"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/07_scripting.html#script-y-m√≥dulo",
    "href": "teoria/01_programacion_en_python/07_scripting.html#script-y-m√≥dulo",
    "title": "7 - Scripting",
    "section": "Script y m√≥dulo",
    "text": "Script y m√≥dulo\nPython es un lenguaje tan flexible que un mismo programa puede funcionar como script y como m√≥dulo al mismo tiempo. Esto ocurre cuando el archivo define herramientas reutilizables (por ejemplo, funciones o clases) y, adem√°s, incluye c√≥digo que se ejecuta directamente al correrlo desde la l√≠nea de comandos.\nPara ilustrarlo, consideremos un peque√±o programa en Python que solicita una fecha al usuario y luego indica cu√°ntos d√≠as faltan para llegar a ella:\n\n\ncalcular_dias.py\n\nfrom datetime import datetime\n\ndef diferencia_dias(fecha_str):\n    fecha = datetime.strptime(fecha_str, \"%Y-%m-%d\").date()\n    hoy = datetime.today().date()\n    diferencia = (fecha - hoy).days\n    return diferencia\n\nfecha_str = input(\"Ingres√° una fecha (formato AAAA-MM-DD): \")\ndiferencia = diferencia_dias(fecha_str)\n\nif diferencia &gt; 0:\n    print(f\"Faltan {diferencia} d√≠as para el {fecha_str}.\")\nelif diferencia == 0:\n    print(\"¬°La fecha es hoy!\")\nelse:\n    print(f\"Esa fecha ya pas√≥ hace {-diferencia} d√≠as.\")\n\nDebajo se muestra una animaci√≥n de la ejecuci√≥n de este script en la terminal:\n\n\n\n\n\nAhora, supongamos que queremos importar la funci√≥n diferencia_dias en otro programa de Python.\n\n\n\n\n\nCuando importamos una funci√≥n del m√≥dulo calcular_dias, observamos que Python tambi√©n ejecuta la parte del programa que solicita una fecha y muestra cu√°ntos d√≠as faltan para alcanzarla.\nEsto ocurre porque, al importar un m√≥dulo (o cualquier objeto definido en √©l), Python ejecuta todo el c√≥digo del archivo de principio a fin, sin importar qu√© elementos en particular estemos importando.\nPara evitar este comportamiento no deseado, y permitir que un mismo archivo pueda funcionar tanto como m√≥dulo reutilizable como script ejecutable, se encapsula la parte que debe ejecutarse solo al correr el archivo directamente dentro del siguiente bloque:\nif __name__ == \"__main__\":\n    # c√≥digo ejecutable\nCon esta estructura, el c√≥digo dentro de ese bloque se ejecutar√° √∫nicamente cuando el archivo se ejecute directamente como programa, y no cuando se lo importe desde otro m√≥dulo.\nDe esta manera, nuestro programa actualizado quedar√≠a as√≠:\n\n\ncalcular_dias.py\n\nfrom datetime import datetime\n\ndef diferencia_dias(fecha_str):\n    fecha = datetime.strptime(fecha_str, \"%Y-%m-%d\").date()\n    hoy = datetime.today().date()\n    diferencia = (fecha - hoy).days\n    return diferencia\n\nif __name__ == \"__main__\":\n    fecha_str = input(\"Ingres√° una fecha (formato AAAA-MM-DD): \")\n    diferencia = diferencia_dias(fecha_str)\n\n    if diferencia &gt; 0:\n        print(f\"Faltan {diferencia} d√≠as para el {fecha_str}.\")\n    elif diferencia == 0:\n        print(\"¬°La fecha es hoy!\")\n    else:\n        print(f\"Esa fecha ya pas√≥ hace {-diferencia} d√≠as.\")\n\nAhora, cuando se importa cualquier objeto desde calcular_dias, Python no ejecuta la parte del programa que interact√∫a con el usuario.\n\n\n\n\n\n\n\n\n\n\n\nLa variable especial __name__ üè∑Ô∏è\n\n\n\nLa variable __name__ es una variable especial que indica el nombre del m√≥dulo actual. Cuando un archivo Python se ejecuta directamente, __name__ toma el valor \"__main__\", lo que indica que es el m√≥dulo principal. En cambio, si el archivo se importa como un m√≥dulo en otro script, __name__ contendr√° el nombre del archivo (sin la extensi√≥n .py).",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "7 - _Scripting_"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/07_scripting.html#clis-con-argparse",
    "href": "teoria/01_programacion_en_python/07_scripting.html#clis-con-argparse",
    "title": "7 - Scripting",
    "section": "CLIs con argparse",
    "text": "CLIs con argparse\nargparse es un m√≥dulo de la librer√≠a est√°ndar de Python que sirve para crear interfaces de l√≠nea de comandos (CLIs, por sus siglas en ingl√©s).\nCon este m√≥dulo se pueden definir qu√© argumentos y opciones acepta nuestra programa. Luego, Python se encargar√° de:\n\nLeerlos desde la terminal al ejecutar el script.\nConvertirlos al tipo de dato indicado (int, float, str, etc.).\nValidarlos seg√∫n las reglas definidas.\nGenerar un mensaje de ayuda (--help) sin que tengamos que hacer nada.\n\n\nEjemplo: saludos personalizados\nEl siguiente programa recibe el nombre de una persona como argumento obligatorio y, de manera opcional, la cantidad de veces que se la debe saludar.\nimport argparse\n\nparser = argparse.ArgumentParser(description=\"Saluda a una persona\")\nparser.add_argument(\"nombre\", help=\"El nombre de la persona\") # Argumento posicional\nparser.add_argument(\"--veces\", type=int, default=1, help=\"Cu√°ntas veces saludar\") # Argumento nombrado\n\nargs = parser.parse_args()\n\nfor _ in range(args.veces):\n    print(f\"¬°Hola, {args.nombre}!\")\nLuego, en la terminal:\npython hola.py Tom√°s\n¬°Hola, Tom√°s!\nY si usamos el argumento --veces:\npython hola.py Tom√°s --veces 3\n¬°Hola, Tom√°s!\n¬°Hola, Tom√°s!\n¬°Hola, Tom√°s!\nLa ayuda se puede ver de la siguiente manera:\npython hola.py --help\nusage: hola.py [-h] [--veces VECES] nombre\n\nSaluda a una persona\n\npositional arguments:\n  nombre         El nombre de la persona\n\noptions:\n  -h, --help     show this help message and exit\n  --veces VECES  Cu√°ntas veces saludar\nSi usamos un valor de tipo err√≥neo para --veces, obtenemos un error informativo de manera autom√°tica:\npython hola.py Tom√°s --veces 3.5\n\nusage: hola.py [-h] [--veces VECES] nombre\nhola.py: error: argument --veces: invalid int value: '3.5'\n\n\n\n\n\n\n\ninput() vs argparse\n\n\n\nTanto input() como ArgumentParser de argparse permiten pasar datos a nuestro script. La diferencia entre ellos es que input() se usa para pedir datos mientras corre el programa, mientras que el m√≥dulo argparse se usa apra pedir datos al momento de ejecutar el programa desde al terminal.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "7 - _Scripting_"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html",
    "href": "teoria/01_programacion_en_python/02_funciones.html",
    "title": "2 - Funciones",
    "section": "",
    "text": "Una funci√≥n puede pensarse como un ‚Äúmini-programa‚Äù dentro de un programa m√°s grande. Su prop√≥sito es cumplir una tarea u objetivo espec√≠fico, de forma independiente del resto del c√≥digo.\nEl uso de funciones tiene varias ventajas:\n\nReutilizaci√≥n de c√≥digo: se define una sola vez y se ejecuta cuando sea necesario.\nMejor organizaci√≥n: dividen el programa en partes m√°s f√°ciles de leer y mantener.\nModularidad: permiten construir programas como bloques independientes que pueden combinarse entre s√≠ (¬°funciones dentro de funciones!).\n\nConsideremos el siguiente caso donde se busca calcuar el precio final de un producto, considerando impuestos y descuentos.\n\nprecio_base = 800   # Precio del producto ($800)\nimpuesto = 0.21     # Impuesto (21%)\ndescuento = 0.10    # Descuento (10%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n871.2\n\n\n¬øQu√© pasa si queremos calcular el precio final para otros productos con diferentes precios, impuestos o descuentos?\nUna opci√≥n es repetir el c√≥digo tantas veces como sea necesario‚Ä¶\n\nprecio_base = 500   # Precio del producto ($500)\nimpuesto = 0.105    # Impuesto (10.5%)\ndescuento = 0.0     # Descuento (0%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n552.5\n\n\n\nprecio_base = 2000  # Precio del producto ($2000)\nimpuesto = 0.21     # Impuesto (21%)\ndescuento = 0.20    # Descuento (20%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n1936.0\n\n\nOtra opci√≥n, mucho mas conveniente, es utilizar funciones.\n\ndef calcular_precio(precio_base, impuesto, descuento):\n    resultado = precio_base * (1 + impuesto) * (1 - descuento)\n    return resultado\n\nLuego, para utilizar la funci√≥n simplemente la llamamos (o invocamos).\n\ncalcular_precio(800, 0.21, 0.10)\n\n871.2\n\n\nTambi√©n es posible indicar los valores de los argumentos utilizando sus nombres.\n\ncalcular_precio(precio_base=2000, impuesto=0.21, descuento=0.20)\n\n1936.0",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#qu√©-es-una-funci√≥n",
    "href": "teoria/01_programacion_en_python/02_funciones.html#qu√©-es-una-funci√≥n",
    "title": "2 - Funciones",
    "section": "",
    "text": "Una funci√≥n puede pensarse como un ‚Äúmini-programa‚Äù dentro de un programa m√°s grande. Su prop√≥sito es cumplir una tarea u objetivo espec√≠fico, de forma independiente del resto del c√≥digo.\nEl uso de funciones tiene varias ventajas:\n\nReutilizaci√≥n de c√≥digo: se define una sola vez y se ejecuta cuando sea necesario.\nMejor organizaci√≥n: dividen el programa en partes m√°s f√°ciles de leer y mantener.\nModularidad: permiten construir programas como bloques independientes que pueden combinarse entre s√≠ (¬°funciones dentro de funciones!).\n\nConsideremos el siguiente caso donde se busca calcuar el precio final de un producto, considerando impuestos y descuentos.\n\nprecio_base = 800   # Precio del producto ($800)\nimpuesto = 0.21     # Impuesto (21%)\ndescuento = 0.10    # Descuento (10%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n871.2\n\n\n¬øQu√© pasa si queremos calcular el precio final para otros productos con diferentes precios, impuestos o descuentos?\nUna opci√≥n es repetir el c√≥digo tantas veces como sea necesario‚Ä¶\n\nprecio_base = 500   # Precio del producto ($500)\nimpuesto = 0.105    # Impuesto (10.5%)\ndescuento = 0.0     # Descuento (0%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n552.5\n\n\n\nprecio_base = 2000  # Precio del producto ($2000)\nimpuesto = 0.21     # Impuesto (21%)\ndescuento = 0.20    # Descuento (20%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n1936.0\n\n\nOtra opci√≥n, mucho mas conveniente, es utilizar funciones.\n\ndef calcular_precio(precio_base, impuesto, descuento):\n    resultado = precio_base * (1 + impuesto) * (1 - descuento)\n    return resultado\n\nLuego, para utilizar la funci√≥n simplemente la llamamos (o invocamos).\n\ncalcular_precio(800, 0.21, 0.10)\n\n871.2\n\n\nTambi√©n es posible indicar los valores de los argumentos utilizando sus nombres.\n\ncalcular_precio(precio_base=2000, impuesto=0.21, descuento=0.20)\n\n1936.0",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#definici√≥n-de-funciones",
    "href": "teoria/01_programacion_en_python/02_funciones.html#definici√≥n-de-funciones",
    "title": "2 - Funciones",
    "section": "Definici√≥n de funciones",
    "text": "Definici√≥n de funciones\nAnalicemos las diferentes partes que forman la definici√≥n de una funci√≥n en Python:\n\n\n\n\n\n\nLa palabra clave def:\n\nMarca el inicio de la definici√≥n de una funci√≥n.\nEs una palabra reservada (keyword).\n\nEl nombre de la funci√≥n:\n\nDebe seguir las mismas reglas que los nombres de las variables.\n\nLos argumentos de la funci√≥n, dentro de par√©ntesis:\n\nSe separan por comas y pueden ser 0 o m√°s.\n\nLos dos puntos (:):\n\nIndican el final de la l√≠nea de definici√≥n y el inicio del bloque de c√≥digo.\n\nEl bloque de c√≥digo, que es el cuerpo de la funci√≥n:\n\nEs el c√≥digo que se ejecuta cada vez que llamamos a la funci√≥n.\n\nLa sentencia return que indica el resultado que devuelve la funci√≥n.\n\nLuego del return viene el valor o nombre de la variable a devolver.\nEs opcional (ya vamos a ver ejemplos).\n\n\n\n\n\n\n\n\nObservaci√≥n üëÄ\n\n\n\nEn R se tiene que asignar de manera expl√≠cita una funci√≥n a una variable. Por ejemplo:\nsumar &lt;- function(x, y) {\n    return(x + y)\n}\nEn cambio, en Python, la sentencia def define la funci√≥n y le asigna un nombre en un mismo paso.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#ejemplos",
    "href": "teoria/01_programacion_en_python/02_funciones.html#ejemplos",
    "title": "2 - Funciones",
    "section": "Ejemplos",
    "text": "Ejemplos\n\n1. Suma de n√∫meros\nComencemos con una funci√≥n super sencilla. La misma se llama sumar, recibe dos argumentos x e y, y devuelve la suma de ambos.\n\ndef sumar(x, y):\n    return x + y\n\n\nsumar(15, 21.9)\n\n36.9\n\n\n\ntype(sumar(15, 21.9))\n\nfloat\n\n\nEl valor que devuelve puede ser tratado como cualquier valor en Python. Por ejemplo, se lo puede asignar a una variable.\n\nresultado = sumar(10, 11)\nresultado\n\n21\n\n\nY el valor de esa variable puede ser luego pasado a una nueva llamada a sumar() (o a cualquier otra funci√≥n).\n\nsumar(resultado, 2.55)\n\n23.55\n\n\nIncluso es posible pasar expresiones y llamadas a funciones a la hora de pasar un argumento:\n\nsumar(sumar(1, 2), 3)\n\n6\n\n\nEn la l√≠nea sumar(sumar(1, 2), 3), Python comienza evaluando la funci√≥n sumar(). Pero para poder hacerlo, primero necesita conocer los valores de los argumentos. Al revisar el primer argumento, detecta que no es un valor directamente, sino otra llamada a la funci√≥n sumar(1, 2), por lo que la eval√∫a primero. El resultado de esa operaci√≥n es 3, que se toma como valor del primer argumento de la llamada externa. El segundo argumento ya est√° dado: tambi√©n es 3. Entonces, Python invoca la funci√≥n sumar() con los argumentos 3 y 3, cuyo resultado es 6. Finalmente, ese valor se muestra en pantalla.\n\n\n2. Saludo personalizado\nOtro ejemplo sencillo consiste en una funci√≥n que recibe un nombre e imprime un saludo en pantalla.\n\ndef saludar(nombre):\n    print(\"Hola\", nombre)\n\n\nsaludar(\"Pablo\")\n\nHola Pablo\n\n\nEsta funci√≥n no devuelve un resultado, sino que utiliza el argumento recibido para mostrar un mensaje en pantalla.\n\nsaludar(\"Juan\" + \" Manuel\")\n\nHola Juan Manuel\n\n\n\n\n3. Sin par√°metros\nY podemos tener funciones que no utilicen ning√∫n argumento.\n\ndef decir_hola():\n    print(\"¬°Hola!\")\n\n\ndecir_hola()\ndecir_hola()\ndecir_hola()\n\n¬°Hola!\n¬°Hola!\n¬°Hola!\n\n\n\n\n4. Devoluci√≥n de m√∫ltiples valores\nEn Python, las funciones pueden devolver m√∫ltiples valores separ√°ndolos por comas en la sentencia return. Por ejemplo:\n\ndef potencias(x):\n    cuadrado = x ** 2\n    cubo = x ** 3\n    return cuadrado, cubo\n\npotencias(2)\n\n(4, 8)\n\n\nEl resultado de este tipo de funciones puede ser asignado a m√∫ltiples variables. De esta forma, podemos obtener el cuadrado y el cubo de un n√∫mero con una sola llamada a una funci√≥n.\n\ncuadrado, cubo = potencias(8)\nprint(cuadrado)\nprint(cubo)\n\n64\n512\n\n\n\n\n\n\n\n\nObservaci√≥n üëÄ\n\n\n\nAl igual que en la asignaci√≥n m√∫ltiple de variables, lo que parece ser una funci√≥n que devuelve m√∫ltiples objetos es en realidad una funci√≥n que devuelve un √∫nico objeto llamado tupla (de tipo tuple) que permite la t√©cnica de unpacking.\nNo te preocupes, m√°s adelante vamos a ver bien c√≥mo funciona.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#diagrama-de-una-funci√≥n",
    "href": "teoria/01_programacion_en_python/02_funciones.html#diagrama-de-una-funci√≥n",
    "title": "2 - Funciones",
    "section": "Diagrama de una funci√≥n",
    "text": "Diagrama de una funci√≥n\n\n\n\n\n\nAlgunos efectos colaterales pueden ser:\n\nImprimir un texto o un gr√°fico.\nCambiar el valor de una variable global.\nCrear, eliminar o modificar un archivo de la computadora.\n\n\n\n\n\n\n\n¬øPuedo devolver una salida y generar efectos colaterales a la vez? ü§î\n\n\n\nUna funci√≥n en Python puede realizar m√∫ltiples tareas, como devolver un valor e imprimir un mensaje en pantalla.\nPor ejemplo:\ndef producto(x, y):\n    resultado = x * y\n    print(\"El producto es\", resultado)\n    return resultado\nLa funci√≥n producto() no solo calcula y devuelve el resultado de multiplicar x por y, sino que adem√°s muestra un mensaje por pantalla.\nSin embargo, en general no es una buena pr√°ctica combinar tareas distintas dentro de una misma funci√≥n, especialmente si son de distinta naturaleza (como devolver un valor y causar un efecto colateral). Esto puede dificultar la reutilizaci√≥n y el mantenimiento del c√≥digo.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#argumentos-nombrados-y-posicionales",
    "href": "teoria/01_programacion_en_python/02_funciones.html#argumentos-nombrados-y-posicionales",
    "title": "2 - Funciones",
    "section": "Argumentos nombrados y posicionales",
    "text": "Argumentos nombrados y posicionales\nAl definir una funci√≥n, debemos darle un nombre a cada uno de los argumentos que va a recibir.\nAl llamar a la funci√≥n, podemos pasar los valores de dos formas: por posici√≥n o por nombre.\nPor ejemplo, las siguientes llamadas a la funci√≥n sumar() son equivalentes:\n\nsumar(x = 10, y = 15)\n\n25\n\n\n\nsumar(10, 15)\n\n25\n\n\nSi utilizamos los nombres para pasar los argumentos no hace falta que est√©n en el mismo orden que en la definici√≥n de la funci√≥n.\n\nsumar(y = 15, x = 10)\n\n25\n\n\n¬°Que sea posible no significa que sea una buena pr√°ctica!",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#ausencia-de-return",
    "href": "teoria/01_programacion_en_python/02_funciones.html#ausencia-de-return",
    "title": "2 - Funciones",
    "section": "Ausencia de return",
    "text": "Ausencia de return\nLa funci√≥n sumar() termina con la siguiente l√≠nea:\n    return x + y\nEs decir, utiliza la sentencia return para devolver un valor.\nPor otro lado, la funci√≥n saludar() termina con un print() y no tiene ning√∫n return.\n    print(\"Hola\", nombre)\n\nresultado = sumar(1, 2)\nresultado\n\n3\n\n\n\nsaludo = saludar(\"Juan\")\n\nHola Juan\n\n\n\n¬øCu√°l es el valor de la variable saludo?\n¬øPor qu√©?\n¬øTiene sentido?\n\n\nprint(saludo)\n\nNone\n\n\nEn Python no existe el concepto de return impl√≠cito.\nSi queremos que una funci√≥n devuelva un valor, es necesario usar la instrucci√≥n return de forma expl√≠cita.\nEn caso de no hacerlo, la funci√≥n devuelve autom√°ticamente None.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#argumentos-por-defecto",
    "href": "teoria/01_programacion_en_python/02_funciones.html#argumentos-por-defecto",
    "title": "2 - Funciones",
    "section": "Argumentos por defecto",
    "text": "Argumentos por defecto\nCuando definimos una funci√≥n podemos determinar valores por defecto para uno o m√°s par√°metros.\nSi cuando llamamos a la funci√≥n le pasamos un valor a ese par√°metro, se utiliza el valor que pasamos. Sino, se usa el valor por defecto.\nEsta pr√°ctica es √∫til para simplificar las llamadas que realizamos a una funci√≥n.\nSupongamos la siguiente funci√≥n describir_mascota() que tiene los par√°metros nombre y tipo\n\ndef describir_mascota(nombre, tipo):\n    print(\"Tengo un\", tipo)\n    print(\"Y su nombre es\", nombre)\n\ndescribir_mascota(\"Bruno\", \"perro\")\n\nTengo un perro\nY su nombre es Bruno\n\n\nAhora, hacemos que el par√°metro tipo sea por defecto igual a \"perro\".\n\ndef describir_mascota(nombre, tipo=\"perro\"):\n    print(\"Tengo un\", tipo)\n    print(\"Y su nombre es\", nombre)\n\nDe este modo, es posible llamar a la funci√≥n solamente pasando valores para aquellos par√°metros sin valor por defecto:\n\ndescribir_mascota(\"Bruno\")\n\nTengo un perro\nY su nombre es Bruno\n\n\nComo es de esperar, tambi√©n es posible pasar valores distintos a los establecidos por defecto:\n\ndescribir_mascota(\"Nemo\", \"pez\")\n\nTengo un pez\nY su nombre es Nemo",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html",
    "title": "4 - Colecciones de datos",
    "section": "",
    "text": "Adem√°s de los tipos de datos elementales que se presentaron en cap√≠tulos anteriores, Python proporciona estructuras de datos m√°s complejas que permiten almacenar colecciones de objetos. Estas estructuras facilitan la organizaci√≥n de m√∫ltiples valores bajo un mismo nombre, posibilitando, entre otras tareas, su manipulaci√≥n de manera conjunta.\nEn este cap√≠tulo exploraremos tres colecciones b√°sicas de Python:\n\nListas (list)\nTuplas (tuple)\nDiccionarios (dict)\n\nEstas estructuras tienen en com√∫n que permiten agrupar varios objetos, aunque presentan diferencias importantes en cuanto a la sintaxis utilizada para definirlas, su mutabilidad (capacidad de modificarse tras su creaci√≥n) y las operaciones disponibles para manipular sus elementos. En definitiva, cada estructura est√° especialmente dise√±ada para representar relaciones particulares entre los datos, adapt√°ndose as√≠ a diversas situaciones y necesidades de programaci√≥n.\nSupongamos que contamos con el nombre y la edad de 4 personas y queremos utilizar estos datos en nuestro programa. Si solamente tenemos acceso a los tipos de datos elementales de Python, una alternativa para almacenar esta informaci√≥n consiste en crear 4 variables para las edades y 4 variables para los nombres:\n\nnombre_1 = \"Juan\"\nnombre_2 = \"Carla\"\nnombre_3 = \"Evelina\"\nnombre_4 = \"Leandro\"\n\nedad_1 = 29\nedad_2 = 34\nedad_3 = 33\nedad_4 = 38\n\nEn este caso, el c√≥digo es legible e incluso permite intuir la relaci√≥n entre los nombres y las edades.\nSin embargo, vale preguntarse qu√© ocurrir√≠a si quisi√©ramos almacenar la informaci√≥n de muchas m√°s personas. Python nos permitir√≠a crear tantas variables como necesitemos, pero trabajar de esa manera no ser√≠a pr√°ctico ni sostenible.\nPor eso, el lenguaje ofrece estructuras de datos que facilitan el manejo de grandes cantidades de valores del mismo tipo, de forma m√°s organizada y eficiente.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#introducci√≥n",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#introducci√≥n",
    "title": "4 - Colecciones de datos",
    "section": "",
    "text": "Adem√°s de los tipos de datos elementales que se presentaron en cap√≠tulos anteriores, Python proporciona estructuras de datos m√°s complejas que permiten almacenar colecciones de objetos. Estas estructuras facilitan la organizaci√≥n de m√∫ltiples valores bajo un mismo nombre, posibilitando, entre otras tareas, su manipulaci√≥n de manera conjunta.\nEn este cap√≠tulo exploraremos tres colecciones b√°sicas de Python:\n\nListas (list)\nTuplas (tuple)\nDiccionarios (dict)\n\nEstas estructuras tienen en com√∫n que permiten agrupar varios objetos, aunque presentan diferencias importantes en cuanto a la sintaxis utilizada para definirlas, su mutabilidad (capacidad de modificarse tras su creaci√≥n) y las operaciones disponibles para manipular sus elementos. En definitiva, cada estructura est√° especialmente dise√±ada para representar relaciones particulares entre los datos, adapt√°ndose as√≠ a diversas situaciones y necesidades de programaci√≥n.\nSupongamos que contamos con el nombre y la edad de 4 personas y queremos utilizar estos datos en nuestro programa. Si solamente tenemos acceso a los tipos de datos elementales de Python, una alternativa para almacenar esta informaci√≥n consiste en crear 4 variables para las edades y 4 variables para los nombres:\n\nnombre_1 = \"Juan\"\nnombre_2 = \"Carla\"\nnombre_3 = \"Evelina\"\nnombre_4 = \"Leandro\"\n\nedad_1 = 29\nedad_2 = 34\nedad_3 = 33\nedad_4 = 38\n\nEn este caso, el c√≥digo es legible e incluso permite intuir la relaci√≥n entre los nombres y las edades.\nSin embargo, vale preguntarse qu√© ocurrir√≠a si quisi√©ramos almacenar la informaci√≥n de muchas m√°s personas. Python nos permitir√≠a crear tantas variables como necesitemos, pero trabajar de esa manera no ser√≠a pr√°ctico ni sostenible.\nPor eso, el lenguaje ofrece estructuras de datos que facilitan el manejo de grandes cantidades de valores del mismo tipo, de forma m√°s organizada y eficiente.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#listas",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#listas",
    "title": "4 - Colecciones de datos",
    "section": "Listas",
    "text": "Listas\n\nDefinici√≥n\nEl siguiente bloque de c√≥digo genera una lista con los n√∫meros 1, 2, 3, 4 y 5.\n\n[1, 2, 3, 4, 5]\n\n[1, 2, 3, 4, 5]\n\n\nUna lista de Python es una secuencia ordenada de objetos mutable. De manera menos t√©cnica, podemos decir que una lista es un objeto que contiene otros objetos en un orden determinado y cuyo contenido puede modificarse.\nLas listas son una de las estructuras m√°s utilizadas en Python. De hecho, programar en este lenguaje implica trabajar constantemente con listas: crearlas, modificarlas, recorrerlas y transformarlas.\nAs√≠ que si queremos ser buenos Pythonistas, ¬°a aprender de listas!\n\n\nCreaci√≥n de listas\nLas listas en Python se crean escribiendo los elementos entre corchetes ([]), separ√°ndolos con comas.\nCreemos una lista que contenga los nombres de nuestras cafeterias de especialidad preferidas: Orlan, Infinita, Arto, Crist√≥bal, Ruffo y Heroica.\n\ncafeterias = [\"Orlan\", \"Infinita\", \"Arto\", \"Crist√≥bal\", \"Ruffo\", \"Heroica\"]\nprint(cafeterias)\n\n['Orlan', 'Infinita', 'Arto', 'Crist√≥bal', 'Ruffo', 'Heroica']\n\n\nCuando imprimimos una lista, Python muestra una representaci√≥n muy parecida a la que usamos al definirla: con corchetes para encerrar los elementos y comas para separarlos.\nSi consultamos el tipo de una lista, no hay sorpresas: es del tipo list.\n\ntype(cafeterias)\n\nlist\n\n\n\n\nObjetos permitidos en una lista\nEn Python, una lista puede contener objetos de cualquier tipo. Incluso es posible mezclar distintos tipos en una misma lista.\nCon los tipos de datos que vimos hasta ahora, podr√≠amos tener listas con n√∫meros, cadenas de texto, valores booleanos e incluso el valor nulo.\nPor ejemplo, la siguiente lista contiene elementos de cuatro tipos distintos:\n\npopurri = [1, \"dos\", True, None, \"dos\"]\npopurri\n\n[1, 'dos', True, None, 'dos']\n\n\nSi bien las listas pueden mezclar objetos de distinto tipo, y algunas veces hacerlo tiene sentido, en general vamos a trabajar con listas donde todos sus objetos son del mismo tipo.\n\n\nQu√© significa que una lista sea ordenada\nConsideremos las listas [1, 2, 3] y [2, 1, 3]. Vale preguntarse si ambas listas son iguales o no. Veamos que dice Python:\n\n[1, 2, 3] == [2, 1, 3]\n\nFalse\n\n\nDado que una lista es una secuencia en la que el orden de los elementos es relevante, dos listas son iguales solo si contienen los mismos elementos y en el mismo orden. A continuaci√≥n se muestra un ejemplo en el que ambas condiciones se cumplen.\n\n[1, 2, 3] == [1, 2, 3]\n\nTrue\n\n\nTambi√©n vale la pena preguntarse si dos listas iguales son, en memoria, el mismo objeto. Debajo definimos dos listas x e y con los mismos elementos, en el mismo orden. Como es de esperarse, ambas listas son iguales en valor.\n\nx = [\"a\", \"b\", \"c\"]\ny = [\"a\", \"b\", \"c\"]\n\nprint(x == y)\nprint(x is y)\n\nTrue\nFalse\n\n\nSin embargo, estas listas no son iguales en memoria, es decir, no son el mismo objeto.\n\nprint(\"id(x):\", id(x))\nprint(\"id(y):\", id(y))\n\nid(x): 139718308051328\nid(y): 139718306480896\n\n\n\n\n\n\n\n\nConclusi√≥n üìù\n\n\n\nDos listas son iguales (en valor) si en cada posici√≥n contienen elementos que tambi√©n son iguales en valor. Sin embargo, que dos listas sean iguales no implica que sean el mismo objeto en memoria.\n\n\n\n\n\n\n\n\nPara pensar üß†\n\n\n\n¬øCu√°l es el resultado de la siguiente comparaci√≥n?\n[1, 2, 3] == [1.0, 2, 3.0]\n\n\n\n\nAcceder a elementos\nDado que una lista es una secuencia ordenada, cada objeto tiene una posici√≥n determinada. Podemos acceder a cualquiera de los elementos de la lista indicando la posici√≥n del objeto que deseamos. Esta posici√≥n se conoce como √≠ndice (o index, en ingl√©s).\nPara acceder a un elemento de una lista, escribimos el nombre de la lista seguido de la posici√≥n del objeto que queremos seleccionar, encerrada entre corchetes [].\nVeamos un ejemplo utilizando la lista cafeterias que creamos anteriormente.\n\ncafeterias = [\"Orlan\", \"Infinita\", \"Arto\", \"Crist√≥bal\", \"Ruffo\", \"Heroica\"]\ncafeterias\n\n['Orlan', 'Infinita', 'Arto', 'Crist√≥bal', 'Ruffo', 'Heroica']\n\n\nIntentemos seleccionar el primer objeto de la lista:\n\ncafeterias[1]\n\n'Infinita'\n\n\nCuando accedemos a un elemento individual de una lista, el resultado no es, en principio, otra lista, sino el objeto que se encuentra en esa posici√≥n. Ese objeto puede ser de cualquier tipo: un n√∫mero, una cadena de texto, otra lista, etc.\nPor lo tanto, si el elemento obtenido es una cadena de caracteres, podemos aplicar directamente los m√©todos que corresponden a ese tipo de dato. Por ejemplo, podemos encadenar la selecci√≥n del elemento en la posici√≥n 1 con una llamada al m√©todo .upper(), sabiendo que es v√°lido porque ese elemento es de tipo str.\n\ncafeterias[1].upper()\n\n'INFINITA'\n\n\nComo es de esperarse, tambi√©n podemos incluir una operaci√≥n de indexaci√≥n dentro de una f-string.\n\nf\"¬°Qu√© rico que es el caf√© de {cafeterias[1]}!\"\n\n'¬°Qu√© rico que es el caf√© de Infinita!'\n\n\n\n\n\n\n\n\nIndexaci√≥n desde cero 0Ô∏è‚É£\n\n\n\nObservamos que cafeterias[1] devuelve \"Infinita\", que es el elemento de la segunda posici√≥n, y no \"Orlan\", que aparece primero. Este resultado no es un error, sino una consecuencia de que Python usa indexaci√≥n desde cero (zero-based indexing, en ingl√©s). Esto significa que, si una lista contiene 6 elementos, sus posiciones van desde el 0 al 5. En general:\n\nEl primer elemento est√° en la posici√≥n 0.\nEl √∫ltimo elemento est√° en la posici√≥n n - 1.\n\n\n\n\n\n\n\n\n\nMisma sintaxis, significados distintos üé≠\n\n\n\nEn Python, los corchetes no siempre significan lo mismo. Sus dos funciones principales son la creaci√≥n de listas y la indexaci√≥n de secuencias. Un ejemplo curioso que combina ambos usos es el siguiente:\n[0][0]\n0\n\n\nEn el siguiente diagrama se muestra que la variable cafeterias referencia a un objeto de tipo list, que a su vez contiene referencias a distintos objetos de tipo str. Cada uno de estos elementos est√° asociado a un √≠ndice, comenzando desde el 0.\n\n\n\nRepresentaci√≥n gr√°fica de la lista cafeterias en Python.\n\n\n\n√çndices negativos\nPython tambi√©n permite utilizar valores negativos como √≠ndices para seleccionar elementos.\n\nEl √≠ndice -1 indica el √∫ltimo elemento.\nEl √≠ndice -2 indica el pen√∫ltimo elemento.\nY as√≠ sucesivamente.\n\n\ncafeterias[-1]\n\n'Heroica'\n\n\n\ncafeterias[-2]\n\n'Ruffo'\n\n\n\n\n\nRepresentaci√≥n gr√°fica de cafeterias utilizando √≠ndices negativos para cada elemento.\n\n\n\n\n\nAcceder a sub-listas\nHasta ahora vimos que, al usar corchetes con un n√∫mero entero, podemos acceder a un √∫nico elemento de una lista. Si en cambio queremos obtener varios elementos a la vez, necesitamos usar una herramienta llamada slice (o rebanada) que permite seleccionar un subconjunto de elementos de una secuencia.\nLa sintaxis para usar slices es la siguiente:\nlista[inicio:fin]\nEsto crea una nueva lista con los elementos que van desde la posici√≥n inicio hasta la posici√≥n fin, sin incluir esta √∫ltima.\nPor ejemplo:\n\ncafeterias[1:4]\n\n['Infinita', 'Arto', 'Crist√≥bal']\n\n\n\n\n\nSelecci√≥n de sublista de cafeterias usando el slice 1:4.\n\n\nComo los slices incluyen el √≠ndice de inicio pero excluyen el de fin, el siguiente c√≥digo funciona correctamente:\n\ncafeterias[4:6]\n\n['Ruffo', 'Heroica']\n\n\n\n\n\nSelecci√≥n de sublista de cafeterias usando el slice 4:6.\n\n\nEn Python, la sintaxis de los slices permite omitir de forma impl√≠cita los valores de inicio o fin cuando se desea tomar una porci√≥n desde el principio o hasta el final de la lista. Por ejemplo:\n\n:n es equivalente a 0:n y selecciona los primeros n elementos.\nn: es equivalente a n:len(lista) y selecciona desde la posici√≥n n hasta el final.\n\nEstas formas abreviadas hacen el c√≥digo m√°s conciso sin perder claridad. Por ejemplo:\n\ncafeterias[:3]\n\n['Orlan', 'Infinita', 'Arto']\n\n\n\n\n\nSelecci√≥n de sublista de cafeterias hasta el √≠ndice 3 usando el slice de inicio impl√≠cito :3.\n\n\n\ncafeterias[3:]\n\n['Crist√≥bal', 'Ruffo', 'Heroica']\n\n\n\n\n\nSelecci√≥n de sublista de cafeterias desde el √≠ndice 3 usando el slice con fin impl√≠cito 3:.\n\n\n\n\nModificar, agregar y eliminar elementos\nEn general, nuestros programas utilizan las listas como objetos din√°micos, es decir, como estructuras cuyo contenido puede cambiar a lo largo del tiempo mediante la modificaci√≥n, agregaci√≥n o eliminaci√≥n de sus elementos.\nPor ejemplo, supongamos que desarrollamos una p√°gina web que permite el registro de usuarios. En este caso, es natural usar una lista para almacenar los nombres de quienes se registran. A medida que pase el tiempo, se espera que se registren nuevos usuarios, otros se den de baja, o algunos incluso decidan cambiar su nombre. Esto implica realizar operaciones sobre la lista, como agregar, eliminar o modificar sus elementos.\n\nModificar elementos\nPara modificar un elemento se utiliza una sintaxis muy similar a la que utilizamos para acceder a un elemento.\nEscribimos el nombre de la lista seguido del √≠ndice del objeto que queremos modificar y el valor que queremos asignar.\nSupongamos que tenemos una lista con diferentes marcas de caf√©: Puerto Blest, Mart√≠nez y Fuego Tostadores.\n\nmarcas = [\"Puerto Blest\", \"Mart√≠nez\", \"Fuego Tostadores\"]\nmarcas\n\n['Puerto Blest', 'Mart√≠nez', 'Fuego Tostadores']\n\n\n¬øC√≥mo hacemos para cambiar el valor del primer elemento?\n\nmarcas[0] = \"Cabrales\"\nmarcas\n\n['Cabrales', 'Mart√≠nez', 'Fuego Tostadores']\n\n\n\n\n\n\n\n\nUna dosis de precisi√≥n üéØ\n\n\n\nEn esta secci√≥n, cuando hablamos de modificar un elemento, nos referimos a reemplazar el objeto que se encuentra en una posici√≥n determinada de la lista. Observemos el siguiente ejemplo:\ningredientes = [\"azucar\", \"flores\", \"colores\"]\nid_original = id(ingredientes[0])\n\n# \"Modifico\" el primer elemento\ningredientes[0] = \"pimienta\"\nid_nuevo = id(ingredientes[0])\n\nprint(\"ID original:\", id_original)\nprint(\"ID nuevo:\", id_nuevo)\nID original: 139872198862160\nID nuevo: 139872198582832\nEste ejemplo muestra que la operaci√≥n no modific√≥ el objeto que se encontraba originalmente en el √≠ndice 0, sino que lo reemplaz√≥ por uno nuevo.\n\n\n\n\n\n\n\n\n\n\n\n\n\n¬°Atenci√≥n! ü§ì\n\n\n\nEl ejemplo del bloque anterior demuestra que la sintaxis lista[indice] = objeto reemplaza el objeto que se encuentra en una determinada posici√≥n, en vez de modificarlo. Sin embargo, vale la pena destacar que s√≠ es posible modificar un elemento de una lista. Para ello, es necesario que el elemento sea un objeto mutable.\n\n\n\n\nAgregar elementos\nSupongamos que queremos construir una lista con los nombres de las ciudades que forman parte del Gran Rosario. Para ello, vamos a utilizar el siguiente mapa como referencia. A medida que identifiquemos las distintas localidades, las vamos a ir incorporando a una lista de Python.\nAgregar elementos a una lista es una tarea com√∫n en programaci√≥n, y Python nos ofrece varias formas de hacerlo. En esta secci√≥n vamos a explorar algunos de estos m√©todos, entendiendo en qu√© se diferencian y cu√°ndo conviene utilizar cada uno.\n\n\n\nMapa ilustrado del Gran Rosario.\n\n\nPrimero vamos a armar una lista que contenga los vecinos de Rosario, considerando solo aquellas localidades que limitan con la ciudad.\nSupongamos que empezamos con una lista que contiene √∫nicamente a la localidad de Funes. A partir de ah√≠, iremos agregando otras localidades vecinas utilizando distintos m√©todos que ofrece Python.\n\nvecinos_de_rosario = [\"Funes\"]\nvecinos_de_rosario\n\n['Funes']\n\n\n\nAgregar elementos al final de la lista\nLa manera m√°s sencilla de agregar un nuevo elemento a una lista es utilizando el m√©todo .append().\nEste m√©todo recibe un √∫nico elemento como argumento y lo agrega al final de la lista.\n\nvecinos_de_rosario.append(\"Soldini\")\n\nLa llamada a este m√©todo parece no devolver ning√∫n resultado. Observemos la lista nuevamente:\n\nvecinos_de_rosario\n\n['Funes', 'Soldini']\n\n\nEl m√©todo .append() agreg√≥ \"Soldini\" al final de la lista sin retornar ning√∫n valor. En lugar de crear una nueva lista, modific√≥ directamente la que referencia nuestra variable vecinos_de_rosario. En otras palabras, el m√©todo .append() no crea una nueva lista, sino que modifica directamente la lista existente.\nVeamos el siguiente ejemplo:\n\nvecinos_de_rosario = []\nprint(\"ID:\", id(vecinos_de_rosario))\nprint(vecinos_de_rosario, \"\\n\")\n\nvecinos_de_rosario.append(\"Funes\")\nprint(\"ID:\", id(vecinos_de_rosario))\nprint(vecinos_de_rosario, \"\\n\")\n\nvecinos_de_rosario.append(\"Soldini\")\nprint(\"ID:\", id(vecinos_de_rosario))\nprint(vecinos_de_rosario)\n\nID: 139718307382528\n[] \n\nID: 139718307382528\n['Funes'] \n\nID: 139718307382528\n['Funes', 'Soldini']\n\n\nComo se puede observar, Python oper√≥ siempre sobre la misma lista. Esto se debe a que el m√©todo .append() modifica la lista existente, en lugar de crear una nueva en cada paso.\n\n\nInsertar elementos en cualquier posici√≥n de una lista\nPara insertar elementos en una lista tambi√©n podemos utilizar el m√©todo .insert().\n¬øCu√°l es la diferencia entre .append() e .insert()?\n\n.append() agrega el nuevo elemento al final de la lista.\n.insert() permite insertar un elemento en cualquier posici√≥n, indicando el √≠ndice donde queremos ubicarlo.\n\nPor ejemplo, si queremos insertar \"Villa Gobernador G√°lvez\" al principio de la lista, podemos hacerlo con .insert(0, \"Villa Gobernador G√°lvez\").\n\nvecinos_de_rosario.insert(0, \"Villa Gobernador G√°lvez\")\nvecinos_de_rosario\n\n['Villa Gobernador G√°lvez', 'Funes', 'Soldini']\n\n\nEl m√©todo .insert() agreg√≥ a \"Villa Gobernador G√°lvez\" en el inicio de la lista y corri√≥ o traslad√≥ al resto de los elementos hacia la derecha.\nY si ahora queremos agregar a \"P√©rez\" en la tercera posici√≥n de la lista, simplemente:\n\nvecinos_de_rosario.insert(2, \"P√©rez\")\nvecinos_de_rosario\n\n['Villa Gobernador G√°lvez', 'Funes', 'P√©rez', 'Soldini']\n\n\nAl igual que .append(), .insert() tambi√©n modifica la lista existente en vez de devolver una lista nueva.\n\n\n\n\n\n\n¬øQu√© significa in-place? ü§î\n\n\n\nQue una operaci√≥n sea in-place significa que la operaci√≥n modifica directamente el objeto original, sin crear uno nuevo. Por ejemplo, objetos.append(e) agrega el elemento e a la lista existente objetos en lugar de crear y devolver una lista nueva.\n\n\n\n\n\nCombinar listas\nEn la secci√≥n anterior vimos c√≥mo insertar elementos individuales en una lista. Ahora vamos a explorar otra operaci√≥n muy com√∫n: combinar listas.\nSupongamos que ya tenemos una lista llamada vecinos_de_rosario, y otra llamada vecinos_al_norte. Queremos unir ambas listas para tener toda la informaci√≥n en una sola. Para lograrlo, una opci√≥n es usar el m√©todo .extend(), que nos permite agregar todos los elementos de una lista al final de otra, modificando directamente la lista original.\n\nprint(vecinos_de_rosario)\n\n['Villa Gobernador G√°lvez', 'Funes', 'P√©rez', 'Soldini']\n\n\n\nvecinos_al_norte = [\"Granadero Baigorria\", \"Ibarlucea\"]\n\nvecinos_de_rosario.extend(vecinos_al_norte)\nvecinos_de_rosario\n\n['Villa Gobernador G√°lvez',\n 'Funes',\n 'P√©rez',\n 'Soldini',\n 'Granadero Baigorria',\n 'Ibarlucea']\n\n\nDe la misma manera que .append() agrega un elemento al final de una lista, el m√©todo .extend() permite agregar todos los elementos de otra lista al final.\nOtra forma de combinar listas es utilizando el operador de suma +, que realiza una concatenaci√≥n de listas. A diferencia de .extend(), este operador no modifica las listas originales, sino que devuelve una nueva lista con los elementos de las dos listas originales concatenados en una nueva.\nPara ver c√≥mo funciona, primero vamos a construir una lista llamada otras_localidades, que contiene localidades del Gran Rosario que no est√°n pegadas a Rosario. Luego, vamos a concatenar esa lista a la que ya tenemos.\n\notras_localidades = [\n    \"Puerto San Mart√≠n\",\n    \"San Lorenzo\",\n    \"Fray Luis Beltr√°n\",\n    \"Capit√°n Bermudez\",\n    \"Ricardone\",\n    \"Rold√°n\",\n    \"Alvear\",\n    \"Pueblo Esther\",\n    \"General Lagos\",\n    \"Arroyo Seco\"\n]\n\nPrimero, observemos los IDs de las listas que vamos a combinar:\n\nprint(id(vecinos_de_rosario))\nprint(id(otras_localidades))\n\n139718307382528\n139718306450176\n\n\nY concatenemos ambas listas utilizando el operador de suma:\n\nvecinos_de_rosario + otras_localidades\n\n['Villa Gobernador G√°lvez',\n 'Funes',\n 'P√©rez',\n 'Soldini',\n 'Granadero Baigorria',\n 'Ibarlucea',\n 'Puerto San Mart√≠n',\n 'San Lorenzo',\n 'Fray Luis Beltr√°n',\n 'Capit√°n Bermudez',\n 'Ricardone',\n 'Rold√°n',\n 'Alvear',\n 'Pueblo Esther',\n 'General Lagos',\n 'Arroyo Seco']\n\n\nPodemos notar que la operaci√≥n s√≠ retorna una lista como resultado, la cual podr√≠amos guardar en una nueva variable.\n\ngran_rosario = vecinos_de_rosario + otras_localidades\ngran_rosario\n\n['Villa Gobernador G√°lvez',\n 'Funes',\n 'P√©rez',\n 'Soldini',\n 'Granadero Baigorria',\n 'Ibarlucea',\n 'Puerto San Mart√≠n',\n 'San Lorenzo',\n 'Fray Luis Beltr√°n',\n 'Capit√°n Bermudez',\n 'Ricardone',\n 'Rold√°n',\n 'Alvear',\n 'Pueblo Esther',\n 'General Lagos',\n 'Arroyo Seco']\n\n\nY finalmente, se puede ver que las listas originales no se han modificado y que gran_rosario referencia una lista nueva.\n\nprint(id(vecinos_de_rosario))\nprint(vecinos_de_rosario, \"\\n\")\n\nprint(id(otras_localidades))\nprint(otras_localidades, \"\\n\")\n\nprint(id(gran_rosario))\nprint(gran_rosario, \"\\n\")\n\n139718307382528\n['Villa Gobernador G√°lvez', 'Funes', 'P√©rez', 'Soldini', 'Granadero Baigorria', 'Ibarlucea'] \n\n139718306450176\n['Puerto San Mart√≠n', 'San Lorenzo', 'Fray Luis Beltr√°n', 'Capit√°n Bermudez', 'Ricardone', 'Rold√°n', 'Alvear', 'Pueblo Esther', 'General Lagos', 'Arroyo Seco'] \n\n139718306451456\n['Villa Gobernador G√°lvez', 'Funes', 'P√©rez', 'Soldini', 'Granadero Baigorria', 'Ibarlucea', 'Puerto San Mart√≠n', 'San Lorenzo', 'Fray Luis Beltr√°n', 'Capit√°n Bermudez', 'Ricardone', 'Rold√°n', 'Alvear', 'Pueblo Esther', 'General Lagos', 'Arroyo Seco'] \n\n\n\n\n\nEliminar elementos\nAs√≠ como es com√∫n agregar elementos a una lista o combinar listas para crear nuevas, tambi√©n lo es eliminar elementos.\nPor ejemplo, si en una p√°gina web guardamos los nombres de los usuarios en una lista, y uno de ellos se da de baja, necesitaremos eliminar su nombre de esa lista.\nPara ilustrarlo, vamos a crear una lista de usuarios ficticios:\n\nusuarios = [\"cyberwolf\", \"neo_404\", \"pixelbyte\", \"alphaX\", \"quantum.dev\"]\nusuarios\n\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX', 'quantum.dev']\n\n\n\nEliminar elementos utilizando del\nLa sentencia del, que ya usamos para eliminar variables, tambi√©n puede usarse para eliminar elementos de una lista.\nPara hacerlo, necesitamos conocer la posici√≥n del elemento que queremos eliminar.\nPor ejemplo, si queremos eliminar a \"neo_404\", que est√° en la segunda posici√≥n, podemos hacerlo con:\n\nprint(usuarios)\n\ndel usuarios[1]\n\nprint(usuarios)\n\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX', 'quantum.dev']\n['cyberwolf', 'pixelbyte', 'alphaX', 'quantum.dev']\n\n\n\n\nEliminar elementos con .pop()\nSi bien la sentencia del permite eliminar elementos de una lista, no nos da acceso al elemento eliminado.\nSin embargo, en muchos casos queremos extraer un elemento de una lista para utilizarlo en otra parte de nuestro programa. Por ejemplo, si tenemos una lista de usuarios, tal vez nos interesa guardar el nombre del usuario que se elimina en otra lista que registre los usuarios dados de baja.\nPara eso podemos usar el m√©todo .pop(), que elimina un elemento de la lista y, al mismo tiempo, lo devuelve.\n\nusuarios = [\"cyberwolf\", \"neo_404\", \"pixelbyte\", \"alphaX\", \"quantum.dev\"]\nusuario_eliminado = usuarios.pop(2)\n\nprint(usuarios) # \"pixelbyte\" es 'extraido'\nprint(usuario_eliminado)\n\n['cyberwolf', 'neo_404', 'alphaX', 'quantum.dev']\npixelbyte\n\n\nEn resumen, usuarios.pop(2) busca el valor en la tercera posici√≥n, lo extrae de la lista y lo devuelve.\nTambi√©n es posible usar .pop() sin indicar una posici√≥n. En ese caso, extrae el √∫ltimo elemento de la lista por defecto.\n\nusuarios = [\"cyberwolf\", \"neo_404\", \"pixelbyte\", \"alphaX\", \"quantum.dev\"]\nprint(usuarios, \"\\n\")\n\nusuario_eliminado = usuarios.pop()\nprint(usuario_eliminado)\nprint(usuarios, \"\\n\")\n\nusuario_eliminado = usuarios.pop()\nprint(usuario_eliminado)\nprint(usuarios)\n\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX', 'quantum.dev'] \n\nquantum.dev\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX'] \n\nalphaX\n['cyberwolf', 'neo_404', 'pixelbyte']\n\n\nY podr√≠amos continuar as√≠ hasta vaciar la lista.\n\n\nEliminar elementos con .remove()\nEl m√©todo .remove() es √∫til para cuando queremos eliminar elementos de una lista a partir de su valor, en lugar de su posici√≥n. Por ejemplo:\n\nusuarios = [\"cyberwolf\", \"neo_404\", \"pixelbyte\", \"alphaX\", \"quantum.dev\"]\nprint(usuarios)\n\nusuarios.remove(\"cyberwolf\")\nprint(usuarios)\n\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX', 'quantum.dev']\n['neo_404', 'pixelbyte', 'alphaX', 'quantum.dev']\n\n\nAl igual que del, remove no devuelve el valor que se remueve.\n\n\n\n\n\n\nResumen üìå\n\n\n\n\n\n\n\n\n\n\n\n\nHerramienta\nQu√© hace\nC√≥mo se usa\nDevuelve\n\n\n\n\ndel\nElimina un elemento por √≠ndice o un segmento por slicing\ndel lista[i]  del lista[i:j]\nNada\n\n\n.pop()\nElimina un elemento por √≠ndice (por defecto el √∫ltimo)\nlista.pop(i)  lista.pop()\nEl elemento eliminado\n\n\n.remove()\nElimina la primera ocurrencia de un valor dado\nlista.remove(valor)\nNada\n\n\n\n\n\n\n\n\n\nFunciones y m√©todos √∫tiles\n\nOrdenamiento\nEs com√∫n que las listas se creen sin seguir un orden particular. Sin embargo, en algunas situaciones puede ser importante conservar el orden en que se agregaron los elementos, mientras que en otras puede resultar √∫til trabajar con los datos ordenados, por ejemplo, para facilitar su presentaci√≥n.\nEn Python existen al menos dos formas de obtener listas ordenadas.\n\nEl m√©todo .sort()\nPara ordenar una lista de manera sencilla, podemos usar el m√©todo .sort(). Veamos un par de ejemplos para entender c√≥mo funciona.\n\nproductos = [\"Fanta\", \"Coca Cola\", \"Sprite\"]\nproductos.sort()\nprint(productos)\n\n['Coca Cola', 'Fanta', 'Sprite']\n\n\n\nprecios = [100, 110, 80.0, 70]\nprecios.sort()\nprint(precios)\n\n[70, 80.0, 100, 110]\n\n\nPodemos concluir que el m√©todo .sort() realiza un ordenamiento permanente, ya que modifica directamente la lista sobre la que se aplica y no devuelve una nueva. Esto significa que, una vez ejecutado, no es posible recuperar la lista original a menos que la hayamos guardado previamente.\nPor defecto, el ordenamiento se hace de menor a mayor: en el caso de cadenas de texto, se compara caracter por caracter, y en el caso de n√∫meros, se ordenan a partir de su valor.\n¬øC√≥mo hacemos para ordenar de manera decreciente?\nEl m√©todo .sort() tiene un argumento llamado reverse. Si este valor es igual a True, se ordenan los elementos de mayor a menor.\n\nproductos = [\"Fanta\", \"Coca Cola\", \"Sprite\"]\nproductos.sort(reverse=True)\nprint(productos)\n\n['Sprite', 'Fanta', 'Coca Cola']\n\n\n\nprecios = [100, 110, 80, 70]\nprecios.sort(reverse=True)\nprint(precios)\n\n[110, 100, 80, 70]\n\n\n\n\nLa funci√≥n sorted()\nAl igual que el m√©todo .sort(), la funci√≥n sorted() permite ordenar una lista. La diferencia principal es que sorted() no modifica la lista original, sino que devuelve una nueva lista ordenada. Esto resulta √∫til cuando queremos conservar tanto el orden original como una versi√≥n ordenada de la misma lista.\nVeamos algunos ejemplos breves:\n\njuegos = [\"Counter Strike\", \"The Sims\", \"Age of Empires II\", \"League of Legends\", \"Among Us\"]\njuegos_ordenados = sorted(juegos)\n\nprint(\"Esta es la lista original:\")\nprint(juegos, \"\\n\")\n\nprint(\"Esta es la lista ordenada:\")\nprint(juegos_ordenados)\n\nEsta es la lista original:\n['Counter Strike', 'The Sims', 'Age of Empires II', 'League of Legends', 'Among Us'] \n\nEsta es la lista ordenada:\n['Age of Empires II', 'Among Us', 'Counter Strike', 'League of Legends', 'The Sims']\n\n\n\nprint(\"id(juegos):\".ljust(22), id(juegos))\nprint(\"id(juegos_ordenados):\".ljust(22), id(juegos_ordenados))\n\nid(juegos):            139718306677440\nid(juegos_ordenados):  139718306597952\n\n\nAl igual que .sort(), sorted() tambi√©n tiene un argumento que determina el orden:\n\nsorted(juegos, reverse=True)\n\n['The Sims',\n 'League of Legends',\n 'Counter Strike',\n 'Among Us',\n 'Age of Empires II']\n\n\n\n\n\nInvertir el orden con .reverse()\nHasta ahora vimos c√≥mo ordenar listas de menor a mayor y de mayor a menor.\nOtra operaci√≥n com√∫n es invertir el orden de los elementos, y para eso podemos usar el m√©todo .reverse().\nAl igual que .sort(), esta operaci√≥n modifica la lista original de forma permanente.\n\nproductos = [\"Fanta\", \"Coca Cola\", \"Sprite\"]\nproductos.reverse()\nprint(productos)\n\n['Sprite', 'Coca Cola', 'Fanta']\n\n\nSi nos arrepentimos de haber invertido el orden, podemos usar .reverse() nuevamente y recuperamos el orden original.\n\nproductos.reverse()\nprint(productos)\n\n['Fanta', 'Coca Cola', 'Sprite']\n\n\n\n\n\n\n\n\n¬øY la funci√≥n reversed()? ü§î\n\n\n\nAs√≠ como tenemos .sort() y sorted(), uno podr√≠a preguntarse si existe un reversed() que complemente .reverse().\nLa respuesta es s√≠, reversed() existe. Sin embargo, su resultado no es una lista, sino un tipo de objeto que a√∫n no hemos explorado.\nSin embargo, lo vamos a ver m√°s adelante üòä\n\n\n\n\nCantidad de elementos\nPara saber cuantos elementos hay en una lista utilizamos la funci√≥n len().\nPor ejemplo, para obtener la cantidad de usuarios de manera program√°tica:\n\nusuarios = [\"cyberwolf\", \"neo_404\", \"pixelbyte\", \"alphaX\", \"quantum.dev\"]\nprint(usuarios)\nlen(usuarios)\n\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX', 'quantum.dev']\n\n\n5\n\n\nY para obtener la cantidad de ciudades del Gran Rosario (aunque falte una üòâ):\n\nprint(gran_rosario)\nlen(gran_rosario)\n\n['Villa Gobernador G√°lvez', 'Funes', 'P√©rez', 'Soldini', 'Granadero Baigorria', 'Ibarlucea', 'Puerto San Mart√≠n', 'San Lorenzo', 'Fray Luis Beltr√°n', 'Capit√°n Bermudez', 'Ricardone', 'Rold√°n', 'Alvear', 'Pueblo Esther', 'General Lagos', 'Arroyo Seco']\n\n\n16\n\n\n\n\nExistencia de elemento\nPara evaluar si un determinado elemento se encuentra en una lista utilizamos el operador in.\n\nnuevo_usuario = \"pepito\"\nnuevo_usuario in usuarios\n\nFalse\n\n\nQue correctamente indica que \"pepito\" no est√° en nuestra base de usuarios. Por otro lado,\n\n\"cyberwolf\" in usuarios\n\nTrue\n\n\n¬øY c√≥mo preguntar si alg√∫n elemento no est√° dentro de la lista? Para eso, utilizamos el operador not in.\n\n\"Col√≥n\" not in gran_rosario\n\nTrue\n\n\nLa respuesta es True porque efectivamente \"Col√≥n\" no pertenece al Gran Rosario.\nEste es uno de los tantos ejemplos donde Python se parece mucho mas al lenguaje humano que al lenguaje de las computadoras.\n\n\nPosici√≥n de un elemento\nSi queremos conocer la posici√≥n de un elemento en la lista podemos utilizar el m√©todo .index(). Por ejemplo:\n\nvocales = [\"a\", \"e\", \"i\", \"o\", \"u\"]\nvocales\n\n['a', 'e', 'i', 'o', 'u']\n\n\n\nvocales.index(\"i\")\n\n2\n\n\nAl igual que .remove(), el m√©todo .index() act√∫a sobre el primer elemento de la lista que coincide con el valor indicado. Es decir, si hay m√∫ltiples apariciones del mismo valor, solo se considera la primera.\n\n[\"a\", \"a\", \"a\"].index(\"a\")\n\n0\n\n\nEl resultado es 0 porque esa es la primera posici√≥n en la que aparece \"a\" en la lista. Sin embargo, esto no quiere decir que \"a\" aparezca una sola vez; simplemente indica la ubicaci√≥n de su primera ocurrencia.\n\n\nFrecuencia de un elemento\nSi queremos saber cu√°ntas veces aparece un elemento en una lista, podemos usar el m√©todo .count(). Este m√©todo devuelve la cantidad de ocurrencias del valor indicado dentro de la lista.\n\n[\"a\", \"a\", \"a\"].count(\"a\")\n\n3\n\n\n\n[\"a\", \"a\", \"a\"].count(\"b\")\n\n0\n\n\n\n\nEstad√≠sticas b√°sicas\nPython ofrece funciones que nos permiten calcular f√°cilmente algunas estad√≠sticas b√°sicas o medidas resumen, como el m√≠nimo, el m√°ximo y la suma de los elementos de una lista.\nSe destacan:\n\nmin(), que devuelve el valor m√≠nimo\nmax(), que devuelve el valor m√°ximo\nsum(), que devuelve la suma total\n\nVeamos algunos ejemplos:\n\nnumeros = [3, 7.5, 12, 1.2, 9, 4.8, 6, 15.3, 2.1, 8]\nnumeros\n\n[3, 7.5, 12, 1.2, 9, 4.8, 6, 15.3, 2.1, 8]\n\n\n\nprint(\"Valor m√≠nimo:\", min(numeros))\nprint(\"Valor m√°ximo:\", max(numeros))\nprint(\"Suma de valores:\", sum(numeros))\n\nValor m√≠nimo: 1.2\nValor m√°ximo: 15.3\nSuma de valores: 68.9\n\n\n\n\n\nResumen de m√©todos in-place\n\n\n\n\n\n\n\nM√©todo\nDescripci√≥n\n\n\n\n\n.append(x)\nInserta el valor x al final de la lista\n\n\n.pop(i)\nRemueve y devuelve el elemento en la posici√≥n i\n\n\n.insert(i, x)\nInserta el valor x en la posici√≥n i\n\n\n.extend(iterable)\nInserta todos los valores de iterable al final de la lista\n\n\n.index(x)\nDevuelve el la posici√≥n donde x aparece por primera vez en la lista\n\n\n.count(x)\nDevuelve la cantidad de veces que aparece x en la lista\n\n\n.sort()\nOrdena los elementos de la lista, de menor a mayor\n\n\n.reverse()\nInvierte el orden de los elementos en la lista",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#tuplas",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#tuplas",
    "title": "4 - Colecciones de datos",
    "section": "Tuplas",
    "text": "Tuplas\n\nDefinici√≥n\nEl siguiente bloque de c√≥digo genera una tupla con los n√∫meros 1, 2, 3, 4 y 5.\n\n(1, 2, 3, 4, 5)\n\n(1, 2, 3, 4, 5)\n\n\nUna tupla es una secuencia ordenada de objetos inmutable. Al igual que las listas, permite almacenar m√∫ltiples elementos de cualquier tipo y acceder a ellos por posici√≥n. Muchas de las operaciones que usamos con listas tambi√©n funcionan con tuplas. La diferencia clave es que las listas son mutables (se pueden modificar), mientras que las tuplas son inmutables (no se pueden cambiar una vez creadas).\nLas tuplas suelen utilizarse para representar registros o estructuras simples. En general, las tuplas se utilizan para representar:\n\nUna colecci√≥n fija de valores posibles para un cierto atributo (e.g., Identificaciones v√°lidas), o\nLos distintos atributos de un objeto. En este caso, cada tupla es como un registro de una base de datos (e.g., Baraja espa√±ola).\n\n\n\nEjemplos\n\nIdentificaciones v√°lidas\nSupongamos que trabajamos en un aeropuerto internacional y estamos implementando un programa de autenticaci√≥n de personas. Para ello, necesitamos definir los tipos de identificaci√≥n que se aceptan. Por ejemplo: LE, LC, DNI, CUIT, CUIL y Pasaporte.\nComo esperamos que estos tipos no vayan a cambiar con el tiempo (¬°al menos mientras corre nuestro programa!), tiene sentido utilizar una tupla (inmutable) en vez de una lista (mutable).\n\ntipos_identificacion = (\"LE\", \"LC\", \"DNI\", \"CUIT\", \"CUIL\", \"Pasaporte\")\ntipos_identificacion\n\n('LE', 'LC', 'DNI', 'CUIT', 'CUIL', 'Pasaporte')\n\n\n\ntype(tipos_identificacion)\n\ntuple\n\n\nAl igual que con las listas, podemos utilizar los √≠ndices para acceder a los elementos de la tupla:\n\nprint(tipos_identificacion[0])\nprint(tipos_identificacion[-1])\n\nLE\nPasaporte\n\n\nAl contrario de lo que sucede con las listas, no es posible modificar ninguno de sus elementos existentes:\ntipos_identificacion[0] = \"NUEVO_TIPO\"\n\n    tipos_identificacion[0] = \"NUEVO_TIPO\"\n    ~~~~~~~~~~~~~~~~~~~~^^^\nTypeError: 'tuple' object does not support item assignment\n\nSin embargo, si necesitamos combinar una o m√°s tuplas en otra tupla, sigue siendo posible utilizar el operador de suma (+) para concatenar tuplas y as√≠ crear una nueva, con sus elementos concatenados.\n\ntupla_nueva = tipos_identificacion + (\"NT1\", \"NT2\")\ntupla_nueva\n\n('LE', 'LC', 'DNI', 'CUIT', 'CUIL', 'Pasaporte', 'NT1', 'NT2')\n\n\n\nprint(\"id(tipos_identificacion):\", id(tipos_identificacion))\nprint(\"id(tupla_nueva):\".ljust(25), id(tupla_nueva))\n\nid(tipos_identificacion): 139718618931520\nid(tupla_nueva):          139718306406336\n\n\nAs√≠, se genera una nueva tupla mientras que la original se mantiene intacta.\n\n\nBaraja espa√±ola\nSupongamos que queremos desarrollar un software para jugar al truco en l√≠nea con nuestros amigos. Tarde o temprano, vamos a necesitar una forma de representar las cartas de la baraja espa√±ola.\nEsta baraja est√° compuesta por 40 cartas, divididas en 4 palos: oros, copas, espadas y bastos. Cada palo incluye las siguientes cartas: 1, 2, 3, 4, 5, 6, 7, 10, 11 y 12.\nUna forma simple y efectiva de representar esta baraja en Python es utilizando una lista de tuplas: la lista representa el mazo completo, y cada tupla representa una carta individual. Cada tupla tiene dos elementos: el palo y el valor. Es decir, cada carta se representa as√≠:\n(palo, valor)\nPor ejemplo: (\"espadas\", 7) representa el 7 de espadas.\n\nbaraja = [\n    (\"oros\", 1), (\"oros\", 2), (\"oros\", 3), (\"oros\", 4), (\"oros\", 5),\n    (\"oros\", 6),  (\"oros\", 7), (\"oros\", 10), (\"oros\", 11), (\"oros\", 12),\n    (\"copas\", 1), (\"copas\", 2), (\"copas\", 3), (\"copas\", 4), (\"copas\", 5),\n    (\"copas\", 6), (\"copas\", 7), (\"copas\", 10), (\"copas\", 11), (\"copas\", 12),\n    (\"espadas\", 1), (\"espadas\", 2), (\"espadas\", 3), (\"espadas\", 4), (\"espadas\", 5),\n    (\"espadas\", 6), (\"espadas\", 7), (\"espadas\", 10), (\"espadas\", 11), (\"espadas\", 12),\n    (\"bastos\", 1), (\"bastos\", 2), (\"bastos\", 3), (\"bastos\", 4), (\"bastos\", 5),\n    (\"bastos\", 6), (\"bastos\", 7), (\"bastos\", 10), (\"bastos\", 11), (\"bastos\", 12)\n]\n\nDe este modo, cada tupla representa una carta y resalta su caracter√≠stica de inmutable.\n\n\n\nCu√°ndo usar tuplas\nSi las tuplas se parecen tanto a las listas, ¬øpara qu√© existen?\nLas tuplas son apropiadas cuando se necesita una colecci√≥n inmutable, es decir, una secuencia que no debe cambiar ni en contenido ni en tama√±o. Esto evita modificaciones accidentales y, adem√°s, es m√°s eficiente en memoria que una lista.\nAunque suelen usarse con datos heterog√©neos, el criterio m√°s importante es la inmutabilidad. Si la colecci√≥n va a cambiar, no corresponde usar una tupla, independientemente del tipo de datos que esta contenga.\nFinalmente, aunque usar una lista en lugar de una tupla no afecte significativamente el rendimiento de un programa particular, elegir la estructura adecuada mejora la legibilidad: una tupla deja en claro que esa secuencia no se modifica en ning√∫n momento.\n\n\nDiferencias entre listas y tuplas\nC√≥mo las creamos:\n\nPara crear listas usamos [].\nPara crear tuplas usamos () (no es del todo cierto, ver Definici√≥n de tuplas üîç).\n\nComportamiento ‚Äúdin√°mico‚Äù vs ‚Äúest√°tico‚Äù:\n\nEl tama√±o de las listas puede ser modificado luego de ser creado (din√°mico).\nEl tama√±o de las tuplas no puede ser modificado luego de ser creado (est√°tico).\n\nObjetos ‚Äúmutables‚Äù vs ‚Äúinmutables‚Äù:\n\nLos elementos de la lista se pueden modificar luego de ser creada (mutable).\nLos elementos de una tupla no se pueden modificar (inmutable).\n\nM√°s all√° de sus diferencias, las listas y las tuplas tienen muchas similitudes:\n\nSon secuencias ordenadas.\nPueden contener objetos de distintos tipos al mismo tiempo.\nPermiten acceder a los elementos mediante su √≠ndice.\nAdmiten operaciones de slicing para obtener subconjuntos.\n\n\n\n\n\n\n\nDefinici√≥n de tuplas üîç\n\n\n\nHasta ahora dijimos que las tuplas se crean utilizando par√©ntesis y separando los elementos con comas. Pero eso no es del todo cierto.\nEn realidad, los par√©ntesis no son necesarios para definir una tupla. Lo que define a una tupla en Python es la coma, no los par√©ntesis. Por ejemplo:\nt = 10, 25.0, 50\nprint(t)\nprint(type(t))\n(10, 25.0, 50)\n&lt;class 'tuple'&gt;\nLos par√©ntesis en Python se usan principalmente para agrupar expresiones y modificar el orden de evaluaci√≥n, pero no son lo que convierte una serie de valores en una tupla. Si pens√°ramos a los par√©ntesis como una funci√≥n, simplemente devuelven el mismo objeto que encierran.\nDicho esto, el uso de par√©ntesis es una convenci√≥n ampliamente aceptada a la hora de definir tuplas. De hecho, por m√°s que los par√©ntesis no sean necesarios para su definici√≥n, Python siempre muestra a las tuplas entre par√©ntesis.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#diccionarios",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#diccionarios",
    "title": "4 - Colecciones de datos",
    "section": "Diccionarios",
    "text": "Diccionarios\nEn el ejemplo al inicio de este apunte presentamos el siguiente bloque de c√≥digo:\nnombre_1 = \"Juan\"\nnombre_2 = \"Carla\"\nnombre_3 = \"Evelina\"\nnombre_4 = \"Leandro\"\n\nedad_1 = 29\nedad_2 = 34\nedad_3 = 33\nedad_4 = 38\nA simple vista, se pudo concluir que exist√≠a una relaci√≥n entre los nombres y las edades. Por ejemplo, pudimos deducir que la edad de Juan es de 29 a√±os.\nCon las herramientas adquiridas en este apunte podr√≠amos representar esta informaci√≥n de las siguientes dos maneras:\n\nnombres = [\"Juan\", \"Carla\", \"Evelina\", \"Leandro\"]\nedades = [29, 34, 33, 38]\n\nAs√≠, el elemento ubicado en la posici√≥n i-√©sima de la lista nombres se corresponde con el elemento de la misma posici√≥n en la lista edades.\nEn principio, este enfoque resuelve el problema de tener que crear una variable distinta para cada valor. Sin embargo, mantener dos colecciones mutables e independientes en sincron√≠a puede convertirse en un verdadero dolor de cabeza. De hecho, podemos estar casi seguros de que, tarde o temprano, esa sincron√≠a se va a romper.\nOtra alternativa es la siguiente:\n\npersonas = [(\"Juan\", 29), (\"Carla\", 34), (\"Evelina\", 33), (\"Leandro\", 38)]\n\nAhora, contamos con un √∫nico objeto de Python que re√∫ne toda la informaci√≥n de las personas. En esta lista de tuplas, cada tupla representa a una persona: el primer elemento es su nombre y el segundo, su edad. Una de las ventajas de este enfoque es que permite agregar o quitar registros sin preocuparse por mantener la sincronizaci√≥n entre distintas colecciones.\nSin embargo, existe otra estructura de datos que puede resultar a√∫n m√°s adecuada para este escenario: el diccionario.\nLos diccionarios son estructuras que establecen un mapeo (del ingl√©s, mapping) o relaci√≥n entre dos conjuntos de elementos: claves y valores (keys y values en Python). En nuestro caso, podemos crear un diccionario donde las claves sean los nombres y los valores, las edades.\nEn Python, los diccionarios se definen entre llaves ({}). Dentro de ellas, cada elemento se escribe como un par clave: valor, separado por comas para distinguirlo de los dem√°s.\n\npersonas = {\"Juan\": 29, \"Carla\": 34, \"Evelina\": 33, \"Leandro\": 38}\npersonas\n\n{'Juan': 29, 'Carla': 34, 'Evelina': 33, 'Leandro': 38}\n\n\n\ntype(personas)\n\ndict\n\n\n\nlen(personas)\n\n4\n\n\nPodemos usar este ejemplo para destacar algunos puntos clave sobre los diccionarios:\n\nLa longitud de un diccionario corresponde a la cantidad de pares clave: valor que contiene, no a la suma de la cantidad de claves y valores.\nAunque es com√∫n usar cadenas de texto como claves, no es obligatorio: cualquier objeto que sea hashable puede ser una clave (lo veremos m√°s adelante).\nLos valores pueden ser de cualquier tipo de objeto en Python.\nLas claves deben ser √∫nicas, pero los valores pueden repetirse.\n\nPor √∫ltimo, veremos con un ejemplo que, aunque desde Python 3.7 los diccionarios mantienen un orden, este no es relevante al compararlos.\n\nd1 = {\"nombre\": \"Juan\", \"apellido\": \"P√©rez\"}\nd2 = {\"apellido\": \"P√©rez\", \"nombre\": \"Juan\"}\n\nprint(d1)\nprint(d2)\nprint(d1 == d2)\n\n{'nombre': 'Juan', 'apellido': 'P√©rez'}\n{'apellido': 'P√©rez', 'nombre': 'Juan'}\nTrue\n\n\nAunque d1 y d2 tengan las claves en distinto orden, para Python son diccionarios equivalentes; lo que importa no es el orden de los elementos en los diccionarios, sino los pares clave: valor que contienen.\n\n\n\n\n\n\n¬øPor qu√© se llaman diccionarios? ü§î\n\n\n\nEl nombre proviene de la idea de que en un diccionario real, uno busca la definici√≥n de una palabra (su valor) a partir de la palabra misma (la clave).\n\n\n\nAcceder a los elementos\nA diferencia de las listas y las tuplas, que son objetos donde el orden importa y se puede acceder a sus elementos por posici√≥n, los diccionarios no utilizan posiciones: en ellos, el acceso a los elementos se realiza mediante sus claves. Por ejemplo, si queremos acceder a la edad de Juan utilizando el √≠ndice 0, vamos a obtener un error:\npersonas[0]\n\n    personas[0]\n    ~~~~~~~~^^^\nKeyError: 0\n\nEn cambio, si usamos la clave \"Juan\", que es lo que corresponde:\n\npersonas[\"Juan\"]\n\n29\n\n\n\n\nVerificar la existencia de un elemento\nLos operadores in y not in permiten determinar si un diccionario contiene a un elemento con una determinada clave.\n\nd = {\"color\": \"azul\", \"forma\": \"cuadrado\"}\n\n\"color\" in d\n\nTrue\n\n\n\n\"area\" in d\n\nFalse\n\n\n\n\"area\" not in d\n\nTrue\n\n\n\n\"azul\" in d\n\nFalse\n\n\nAunque \"azul\" aparece como valor de uno de los elementos del diccionario d, \"azul\" in d retorna False porque no hay ninguna clave que sea \"azul\".\n\n\nAcceder a claves y valores\nEs posible acceder solo a las claves:\n\nd = {\"color\": \"azul\", \"forma\": \"cuadrado\"}\nd.keys()\n\ndict_keys(['color', 'forma'])\n\n\nO a los valores:\n\nd.values()\n\ndict_values(['azul', 'cuadrado'])\n\n\nO a las claves y los valores:\n\nd.items()\n\ndict_items([('color', 'azul'), ('forma', 'cuadrado')])\n\n\nEn todos los casos se obtiene una estructura de datos especial: dict_keys, dict_values o dict_items. No profundizaremos en ellas, ya que rara vez es necesario interactuar directamente con estos objetos. En la pr√°ctica, lo relevante es que permiten iterar sobre sus elementos y convertirse f√°cilmente a tipos m√°s comunes, como las listas.\n\n\nModificar, agregar y eliminar elementos\nLos diccionarios son objetos mutables, lo que significa que podemos modificar, agregar o eliminar elementos. Su funcionamiento es muy similar al de las listas. La diferencia m√°s notable es que, en vez de usar √≠ndices, se usan claves.\n\nModificar elementos\nAl igual que en una lista, podemos modificar un elemento seleccion√°ndolo y asign√°ndole un nuevo valor.\n\npersonas\n\n{'Juan': 29, 'Carla': 34, 'Evelina': 33, 'Leandro': 38}\n\n\n\npersonas[\"Juan\"] = 54\n\n\npersonas\n\n{'Juan': 54, 'Carla': 34, 'Evelina': 33, 'Leandro': 38}\n\n\n\n\nAgregar elementos\nPara agregar un elemento, se utiliza la misma sintaxis que para modificar uno: se asigna un valor a una nueva clave en el diccionario.\n\npersonas[\"Marisa\"] = 29\n\nEn resumen, al asignar un valor a una clave, Python primero verifica si existe: si la encuentra, reemplaza su valor; si no, agrega un nuevo par clave-valor.\n\n\nEliminar elementos\nEn un diccionario, es posible eliminar elementos de distintas maneras. Las m√°s comunes son:\n\nLa sentencia del.\nEl m√©todo .pop().\n\nLa sentencia del elimina un elemento asociado a una clave sin devolver su valor, por lo que no puede usarse posteriormente.\nPor ejemplo:\n\ndescuentos = {\n    \"Lunes\": 0,\n    \"Martes\": 20,\n    \"Miercoles\": 10,\n    \"Jueves\": 20,\n    \"Viernes\": 30,\n    \"S√°bado\": 30,\n    \"Domingo\": 0\n}\ndescuentos\n\n{'Lunes': 0,\n 'Martes': 20,\n 'Miercoles': 10,\n 'Jueves': 20,\n 'Viernes': 30,\n 'S√°bado': 30,\n 'Domingo': 0}\n\n\n\ndel descuentos[\"Domingo\"]\ndescuentos\n\n{'Lunes': 0,\n 'Martes': 20,\n 'Miercoles': 10,\n 'Jueves': 20,\n 'Viernes': 30,\n 'S√°bado': 30}\n\n\nEs como si el elemento \"Domingo\": 0 se hubiera esfumado.\nEn cambio, el m√©todo .pop() extrae el valor del diccionario y lo devuelve, lo que permite almacenarlo o utilizarlo m√°s adelante en el programa.\n\ndescuento_lunes = descuentos.pop(\"Lunes\")\nprint(descuento_lunes)\nprint(descuentos)\n\n0\n{'Martes': 20, 'Miercoles': 10, 'Jueves': 20, 'Viernes': 30, 'S√°bado': 30}\n\n\n\n\nActualizar diccionarios\nLos diccionarios tienen acceso a un m√©todo .update() que permiten actualizar un diccionario a partir de otro diccionario. Supongamos que tenemos un diccionario con informaci√≥n relacionada a una persona y otro diccionario con informaci√≥n actualizada de esa persona.\n\ndatos = {\"nombre\": \"Guillermina\", \"ciudad\": \"Rosario\", \"estado civil\": \"soltera\"}\ndatos_nuevos = {\"ciudad\": \"Rold√°n\", \"estado civil\": \"casada\", \"hijos\": 2}\n\nSe puede actualizar el contenido del diccionario datos con el contenido del diccionario datos_nuevos de la sigiuente manera:\n\ndatos.update(datos_nuevos)\ndatos\n\n{'nombre': 'Guillermina',\n 'ciudad': 'Rold√°n',\n 'estado civil': 'casada',\n 'hijos': 2}\n\n\nEste m√©todo modifica el diccionario datos in-place.\nSi se quiere realizar la operaci√≥n sin alterar el diccionario original, se puede usar el operador pipe (|), que devuelve un nuevo diccionario.\n\nd1 = {\"a\": 1, \"b\": 2}\nd2 = {\"b\": 10, \"c\": 25}\nd3 = d1 | d2\n\nprint(d1)\nprint(d2)\nprint(d3)\n\n{'a': 1, 'b': 2}\n{'b': 10, 'c': 25}\n{'a': 1, 'b': 10, 'c': 25}\n\n\nPor √∫ltimo, vale la pena notar que al actualizar un diccionario podemos modificar elementos existentes o agregar otros nuevos.\n\n\n\nEstructuras anidadas\nAnteriormente mencionamos que los diccionarios pueden contener cualquier tipo de objeto de Python. Por lo tanto, significa que puede contener n√∫meros, cadenas, listas‚Ä¶ ¬°e incluso otros diccionarios!\nVeamos un ejemplo donde esta idea resulta √∫til. Supongamos que queremos representar la informaci√≥n de una persona llamada Julia, que tiene 33 a√±os y realiz√≥ tres cursos de Python: Introducci√≥n a Python, An√°lisis de datos con Python y Python avanzado. El tipo de dato para el nombre y la edad es evidente: str e int, respectivamente. En cambio, para los cursos necesitamos una colecci√≥n de valores, ya que no se trata de un √∫nico elemento. As√≠, podemos crear el siguiente diccionario:\n\npersona = {\n    \"nombre\": \"Julia\",\n    \"edad\": 33,\n    \"cursos\": [\"Introducci√≥n a Python\", \"An√°lisis de datos con Python\", \"Python avanzado\"]\n}\n\nprint(persona)\n\n{'nombre': 'Julia', 'edad': 33, 'cursos': ['Introducci√≥n a Python', 'An√°lisis de datos con Python', 'Python avanzado']}\n\n\n\nprint(f\"Nombre: {persona['nombre']}\")\nprint(f\"Edad: {persona['edad']}\")\nprint(f\"Cursos: {persona['cursos']}\")\n\nNombre: Julia\nEdad: 33\nCursos: ['Introducci√≥n a Python', 'An√°lisis de datos con Python', 'Python avanzado']\n\n\nTambi√©n es posible representar estructuras de datos m√°s complejas, como registros. En el siguiente ejemplo, el diccionario usuarios tiene como valores otros diccionarios. Las claves de usuarios corresponden a nombres de usuario (por ejemplo, \"aeinstein\"), mientras que los valores son diccionarios que almacenan atributos de ese usuario, como su nombre, apellido y ciudad de residencia.\n\nusuarios = {\n    \"aeinstein\": {\n        \"nombre\": \"albert\",\n        \"apellido\": \"einstein\",\n        \"ciudad\": \"princenton\"\n    },\n    \"mcurie\": {\n        \"nombre\": \"marie\",\n        \"apellido\": \"curie\",\n        \"ciudad\": \"paris\"\n    },\n    \"afleming\": {\n        \"nombre\": \"alexander\",\n        \"apellido\": \"fleming\",\n        \"ciudad\": \"londres\"\n    }\n}\n\nPara acceder a un elemento dentro de un diccionario anidado, se encadenan los accesos usando [] tantas veces como sea necesario: primero para obtener el diccionario interno y luego para acceder a la clave deseada dentro de √©l.\n\nprint(usuarios[\"aeinstein\"])\nprint(usuarios[\"aeinstein\"][\"ciudad\"])\n\n{'nombre': 'albert', 'apellido': 'einstein', 'ciudad': 'princenton'}\nprincenton\n\n\n\nusuario = \"aeinstein\"\ndatos = usuarios[usuario]\nf\"El usuario '{usuario}' se llama {datos['nombre'].capitalize()} {datos['apellido'].capitalize()}.\"\n\n\"El usuario 'aeinstein' se llama Albert Einstein.\"",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#secuencias",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#secuencias",
    "title": "4 - Colecciones de datos",
    "section": "Secuencias",
    "text": "Secuencias\nLos tres tipos de datos que presentamos en este apunte pertenecen a la categor√≠a de las colecciones, ya que permiten almacenar una colecci√≥n o conjunto de objetos.\nOtra categor√≠a muy interesante de tipos de datos son las secuencias.\nUna secuencia es una estructura de datos que contiene elementos organizados en orden, y se puede acceder a cada elemento mediante un √≠ndice entero que representa su posici√≥n en la secuencia. Por lo tanto, las listas y las tuplas son ejemplos de secuencias; los diccionarios, en cambio, no lo son.\nAunque pueda parecer sorprendente al principio, las cadenas de texto tambi√©n son secuencias.\nVale la pena destacar a las secuencias, ya que todos los tipos de datos que abarca comparten un conjunto com√∫n de operaciones, que se resumen en la siguiente tabla:\n\n\n\n\n\n\n\n\nOperaci√≥n\nResultado\nComentarios\n\n\n\n\ne in s\nIndica si el valor e se encuentra en s\n¬†\n\n\ne not in s\nIndica si el valor e no se encuentra en s\n¬†\n\n\ns + t\nConcatena las secuencias s y t\n¬†\n\n\ns * n\nConcatena n copias de s\n¬†\n\n\ns[i]\nObtiene el elemento i de s\n¬†\n\n\ns[i:j]\nPorci√≥n de la secuencia s desde i hasta j (no inclusive)\n¬†\n\n\ns[i:j:k]\nPorci√≥n de la secuencia s desde i hasta j (no inclusive), con paso k\n¬†\n\n\nlen(s)\nCantidad de elementos en la secuencia s\n¬†\n\n\nmin(s)\nM√≠nimo elemento en la secuencia s\nRequiere elementos comparables\n\n\nmax(s)\nM√°ximo elemento de la secuencia s\nRequiere elementos comparables\n\n\nsum(s)\nSuma de los elementos de la secuencia s\nNo aplica a str\n\n\nsorted(s)\nOrdena los elementos de la secuencia s y los devuelve en una lista\nRequiere elementos comparables\n\n\nenumerate(s)\nIterador sobre los elementos de s junto con sus posiciones\nPermite iterar con (√≠ndice, valor)\n\n\nreversed(s)\nIterador inverso sobre los elementos de s\n¬†\n\n\nall(s)\nIndica si bool(e) es True para todos los elementos de s\n¬†\n\n\nany(s)\nIndica si bool(e) es True para al menos un elemento de s\n¬†\n\n\ns.index(e)\nPosici√≥n del elemento e en la secuencia s\n¬†\n\n\ns.count(e)\nCantidad de veces que el elemento e aparece la secuencia s\n¬†\n\n\n\nPor ejemplo:\n\ntexto = \"Esto es un texto cualquiera\"\notro = \"y esto es otro texto\"\nprint(\"texto[0]:\", texto[0])\n\ntexto[0]: E\n\n\n\nprint(\"texto[-1]:\", texto[-1])\n\ntexto[-1]: a\n\n\n\nprint(\"texto[0:3]:\", texto[0:3])\n\ntexto[0:3]: Est\n\n\n\nprint(\"texto[0:10:2]:\", texto[0:20:2])\n\ntexto[0:10:2]: Et su et u\n\n\n\nprint(\"texto + otro:\", texto + otro)\n\ntexto + otro: Esto es un texto cualquieray esto es otro texto\n\n\n\nprint(\"texto * 2:\", texto * 2)\n\ntexto * 2: Esto es un texto cualquieraEsto es un texto cualquiera\n\n\n\nprint(\"len(texto):\", len(texto))\n\nlen(texto): 27\n\n\n\nprint(\"sorted(texto):\", sorted(texto))\n\nsorted(texto): [' ', ' ', ' ', ' ', 'E', 'a', 'a', 'c', 'e', 'e', 'e', 'i', 'l', 'n', 'o', 'o', 'q', 'r', 's', 's', 't', 't', 't', 'u', 'u', 'u', 'x']\n\n\nAdem√°s, es posible crear una secuencia (o colecci√≥n) a partir de otra secuencia (o colecci√≥n) utilizando el tipo de dato como constructor. Por ejemplo:\n\nlist(\"texto\")\n\n['t', 'e', 'x', 't', 'o']\n\n\n\ntuple(\"texto\")\n\n('t', 'e', 'x', 't', 'o')\n\n\n\nlist((1, 2, 3, 4))\n\n[1, 2, 3, 4]\n\n\nSin embargo, el resultado puede no ser de lo m√°s intuitivo incialmente:\n\nstr([\"1\", \"2\", \"3\"]) # ¬°Notar que no concatena los elementos!\n\n\"['1', '2', '3']\"\n\n\n\nlist({\"a\": 1, \"b\": 2}) # Crea una lista a partir de las claves\n\n['a', 'b']\n\n\n\nlist({\"a\": 1, \"b\": 2}.values()) # Es posible crear una lista a partir de los valores\n\n[1, 2]\n\n\nSi intentamos crear un diccionario a partir de una lista (o tupla) ‚Äúplana‚Äù, obtendremos un error, ya que no hay una forma clara de identificar las claves y los valores.\ndict([1, 2, 3])\n\n    dict([1, 2, 3])\n    ~~~~^^^^^^^^^^^\nTypeError: cannot convert dictionary update sequence element #0 to a sequence\n\nEn cambio, si usamos una lista (o tupla) compuesta por listas (o tuplas) de longitud 2, la conversi√≥n es posible:\n\ndict([[\"x\", 1], [\"y\", 2]])\n\n{'x': 1, 'y': 2}\n\n\n\ndict([(\"A\", \"aaa\"), (\"B\", \"bbb\")])\n\n{'A': 'aaa', 'B': 'bbb'}",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#resumen-1",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#resumen-1",
    "title": "4 - Colecciones de datos",
    "section": "Resumen",
    "text": "Resumen\n\nLista (list)\n\nSintaxis: [a, b, c]\nEs mutable\nTiene orden\nSe accede a los elementos por √≠ndice\nEs secuencia\nAdmite cualquier objeto\n\nTupla (tuple)\n\nSintaxis: (a, b, c) o a, b, c\nEs inmutable\nTiene orden\nSe accede a los elementos por √≠ndice\nEs secuencia\nAdmite cualquier objeto\n\nDiccionario (dict)\n\nSintaxis: {clave: valor, ...}\nEs mutable\nTiene orden, pero no importa para evaluar igualdad\nSe accede a los elementos por clave\nNo es secuencia\nLas claves admiten objetos hashable, los valores pueden ser cualquier objeto\n\nCadena (str)\n\nSintaxis: \"texto\" o 'texto'\nEs inmutable\nTiene orden\nSe accede a los elementos por √≠ndice\nEs secuencia\nSolo admite caracteres",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/08_io.html",
    "href": "teoria/01_programacion_en_python/08_io.html",
    "title": "8 - Lectura y escritura de archivos",
    "section": "",
    "text": "En nuestros programas de Python utilizamos variables para almacenar datos durante la ejecuci√≥n. Estos datos pueden estar escritos directamente en el c√≥digo o ser ingresados por el usuario (por ejemplo, mediante la funci√≥n input()). Por otro lado, cuando necesitamos mostrar una salida en pantalla, usamos la funci√≥n print().\nSin embargo, el uso exclusivo de input() y print() para la entrada y salida de datos tiene limitaciones. Por ejemplo:\n\nSi trabajamos con m√°s de unos pocos datos, o ni siquiera sabemos cu√°les datos necesitaremos al momento de ejecutar el programa, no resulta pr√°ctico declararlos en el c√≥digo o ingresarlos manualmente.\nSi el resultado de nuestro programa consiste en una gran cantidad de datos que no pueden analizarse visualmente con rapidez, o si necesitamos reutilizarlos en otro programa o proceso m√°s adelante, se hace necesario almacenarlos de manera persistente.\n\nEn resumen, para resolver problemas de mayor complejidad, vamos a necesitar leer y guardar archivos en la computadora.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "8 - Lectura y escritura de archivos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/08_io.html#introducci√≥n",
    "href": "teoria/01_programacion_en_python/08_io.html#introducci√≥n",
    "title": "8 - Lectura y escritura de archivos",
    "section": "",
    "text": "En nuestros programas de Python utilizamos variables para almacenar datos durante la ejecuci√≥n. Estos datos pueden estar escritos directamente en el c√≥digo o ser ingresados por el usuario (por ejemplo, mediante la funci√≥n input()). Por otro lado, cuando necesitamos mostrar una salida en pantalla, usamos la funci√≥n print().\nSin embargo, el uso exclusivo de input() y print() para la entrada y salida de datos tiene limitaciones. Por ejemplo:\n\nSi trabajamos con m√°s de unos pocos datos, o ni siquiera sabemos cu√°les datos necesitaremos al momento de ejecutar el programa, no resulta pr√°ctico declararlos en el c√≥digo o ingresarlos manualmente.\nSi el resultado de nuestro programa consiste en una gran cantidad de datos que no pueden analizarse visualmente con rapidez, o si necesitamos reutilizarlos en otro programa o proceso m√°s adelante, se hace necesario almacenarlos de manera persistente.\n\nEn resumen, para resolver problemas de mayor complejidad, vamos a necesitar leer y guardar archivos en la computadora.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "8 - Lectura y escritura de archivos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/08_io.html#lectura-y-escritura",
    "href": "teoria/01_programacion_en_python/08_io.html#lectura-y-escritura",
    "title": "8 - Lectura y escritura de archivos",
    "section": "Lectura y escritura",
    "text": "Lectura y escritura\n\nArchivos de texto vs archivos binarios\nEn esta secci√≥n vamos a aprender a leer y escribir archivos de texto plano.\nLos archivos de texto plano contienen √∫nicamente caracteres b√°sicos de texto, sin ning√∫n tipo de informaci√≥n adicional. Algunos ejemplos son:\n\nArchivos de texto gen√©ricos con extensi√≥n .txt\nArchivos de c√≥digo Python con extensi√≥n .py\n\nEstos archivos pueden abrirse sin dificultad en cualquier editor de texto como el Notepad o Positron, y Python puede leer su contenido y tratarlo como cadenas de texto normales (str).\nEn contraste, existen los archivos binarios, que contienen secuencias de bits que no se limitan a representar caracteres de texto. Estos pueden almacenar cualquier tipo de datos, como im√°genes, sonidos, videos, PDFs, ejecutables, etc. Aunque en este apunte nos enfocamos en los archivos de texto plato, muchos de los principios que veremos tambi√©n se aplican a los archivos binarios.\n\n\nLos tres pasos fundamentales\nA la hora de trabajar con archivos en Python, normalmente se siguen tres pasos:\n\nAbrir el archivo con la funci√≥n open(), que devuelve un objeto de tipo TextIOWrapper.\nLeer o escribir en el archivo con los m√©todos read() o write() del objeto TextIOWrapper.\nCerrar el archivo con el m√©todo close() para liberar los recursos y asegurarse de que todos los cambios se guarden correctamente.\n\n\n\nLeer archivos\nPara abrir un archivo en Python se utiliza la funci√≥n open(), a la cual se le pasa como argumento la ruta del archivo. Esta ruta puede estar representada con una cadena de texto str o un objeto Path del m√≥dulo pathlib (que veremos en una secci√≥n m√°s adelante). La funci√≥n open() devuelve un objeto de tipo TextIOWrapper que representa al archivo abierto y permite interactuar con √©l.\nSupongamos que tenemos un archivo llamado pensamientos.txt con el siguiente contenido:\nEstoy aprendiendo a leer archivos en Python.\nNo se con qu√© me voy a encontrar.\nPero ac√° vamos.\ny usamos la funci√≥n open() para abrir el archivo.\narchivo = open(\"pensamientos.txt\")\narchivo\n&lt;_io.TextIOWrapper name='pensamientos.txt' mode='r' encoding='cp1252'&gt;\nVemos que el objeto devuelto por open() no solo incluye el nombre del archivo (pensamientos.txt), sino tambi√©n mode=\"r\" y encoding=\"cp1252\".\nTanto mode como encoding son argumentos de la funci√≥n open(). El primero indica el modo en el que se abre el archivo. Por defecto, este valor es \"r\", lo que significa que el archivo se abre en modo lectura de texto plano. En este modo es posible leer su contenido, pero no escribir sobre √©l.\nEl segundo argumento, encoding, especifica la codificaci√≥n que se usar√° para convertir los bytes del archivo en cadenas de texto de Python. En macOS y Linux el valor por defecto es \"utf-8\". En cambio, en Windows, la codificaci√≥n predeterminada es \"cp1252\" (ASCII extendido). Como esto puede generar errores al leer archivos de texto UTF-8 que contengan caracteres no ingleses en Windows, se recomienda siempre incluir expl√≠citamente el argumento encoding=\"utf-8\".\nEl objeto de la variable archivo es de tipo TextIOWrapper. A pesar de que el nombre pueda parecer complicado, no es m√°s que otro tipo de objeto en Python, como son las listas o los diccionarios. Cada vez que necesitemos leer o escribir en el archivo, lo haremos a trav√©s de los m√©todos asociados a este objeto.\n\n\n\n\n\n\nPuede fallar\n\n\n\nSi le pasamos a la funci√≥n open() un nombre de un archivo que no existe, ya sea porque escribimos mal la ruta o cometimos un error de tipeo, obtendremos un FileNotFoundError.\nopen(\"pensamiento.txt\")\n\nFileNotFoundError: [Errno 2] No such file or directory: 'pensamiento.txt'\n\n\n\n\nLeer todo el contenido\nUna forma de leer un archivo de texto plano en Python es cargar todo su contenido de una sola vez como una √∫nica cadena de texto. Para ello se utiliza el m√©todo .read() del objeto TextIOWrapper.\n\narchivo = open(\"pensamientos.txt\", encoding=\"utf-8\")\ncontenido = archivo.read()\ncontenido\n\n'Estoy aprendiendo a leer archivos en Python.\\nNo se con qu√© me voy a encontrar.\\nPero ac√° vamos.'\n\n\nSe puede observar que, salvo la √∫ltima, cada l√≠nea termina con un car√°cter de nueva l√≠nea (\\n). Si hubi√©ramos agregado un salto de l√≠nea al final del archivo pensamientos.txt, la cadena resultante tambi√©n habr√≠a terminado en \"\\n\".\n\n\nLeer l√≠nea a l√≠nea\nUna alternativa al m√©todo .read(), que carga todo el contenido como una √∫nica cadena de texto, es el m√©todo .readlines(). Este devuelve una lista de cadenas, donde cada elemento corresponde a una l√≠nea del archivo.\n\narchivo = open(\"pensamientos.txt\", encoding=\"utf-8\")\narchivo.readlines()\n\n['Estoy aprendiendo a leer archivos en Python.\\n',\n 'No se con qu√© me voy a encontrar.\\n',\n 'Pero ac√° vamos.']\n\n\nTrabajar con una lista de cadenas suele ser m√°s c√≥modo que manejar un √∫nico bloque de texto, ya que te permite acceder directamente a cada l√≠nea por separado.\n\n\nLeer solo algunas l√≠neas\nTambi√©n es posible leer un n√∫mero limitado de l√≠neas en lugar de cargar todo el archivo de una sola vez. Para ello se utiliza el m√©todo .readline(), en singular. Cada vez que se invoca, se obtiene la siguiente l√≠nea del archivo. Cuando ya no quedan m√°s l√≠neas, devuelve una cadena vac√≠a.\n\narchivo = open(\"pensamientos.txt\", encoding=\"utf-8\")\nwhile True:\n    linea = archivo.readline()\n    if linea == \"\":\n        break\n    print(linea, end=\"\") # `end=\"\"` para que Python no agregue salto de l√≠nea\n\nEstoy aprendiendo a leer archivos en Python.\nNo se con qu√© me voy a encontrar.\nPero ac√° vamos.\n\n\nEste m√©todo tambi√©n acepta un argumento opcional size, que permite especificar la cantidad de caracteres a leer en cada llamada.\n\n\nCerrar archivo\nCuando terminamos de trabajar con un archivo, es importante cerrarlo con el m√©todo .close(). Esto libera los recursos asociados y, en caso de escritura, asegura que todo lo que estaba en el b√∫fer se guarde correctamente.\nAunque Python suele cerrar los archivos autom√°ticamente al final del programa, es una buena pr√°ctica hacerlo de forma expl√≠cita para evitar comportamientos inesperados.\n\n\n\n\n\n\nLecturas sucesivas\n\n\n\nCuando se lee un archivo en Python, existe un puntero interno (a veces llamado posici√≥n en el b√∫fer) que avanza a medida que se consume el contenido. Por eso, despu√©s de una primera lectura completa, las siguientes llamadas a m√©todos como .read() o .readlines() no devuelven nada: el puntero ya est√° al final del archivo.\narchivo = open(\"pensamientos.txt\")\narchivo.read()\n'Estoy aprendiendo a leer archivos en Python.\\nNo se con qu√© me voy a encontrar.\\nPero ac√° vamos.'\narchivo.read()\n''\narchivo.readlines()\n[]\nPara volver a leer desde el inicio, hay dos opciones:\n\nCerrar y volver a abrir el archivo.\nUsar el m√©todo .seek(0) para mover el puntero de vuelta al principio.\n\n\n\n\n\n\nEscribir archivos\nPara escribir un archivo en Python, primero debemos abrirlo con la funci√≥n open(), de la misma manera que al leer. Sin embargo, no podemos usar los argumentos por defecto, ya que en ese caso el archivo se abre en modo lectura, lo que impide escribir en √©l.\nPara poder escribir, el archivo debe abrirse en uno de los siguientes modos:\n\nModo escritura (\"w\"): sobrescribe por completo el archivo existente, de forma similar a cuando asignamos un nuevo valor a una variable reemplazando el anterior.\nModo adici√≥n (\"a\"): agrega nuevo contenido al final del archivo existente, sin borrar lo que ya conten√≠a.\n\nSi el archivo indicado en open() no existe, tanto el modo escritura como el modo adici√≥n crear√°n un archivo nuevo y vac√≠o.\nDebajo, abrimos un archivo llamado conclusiones.txt en modo escritura. Como el archivo todav√≠a no existe, Python lo crea autom√°ticamente. Luego, llamamos a write() sobre el archivo abierto y le pasamos la cadena \"Escribir en Python no es tan grave como parece.\\n\" y el texto se escribe dentro del archivo.\n\narchivo = open(\"conclusiones.txt\", mode=\"w\", encoding=\"utf-8\") # Este paso ya crea el archivo\narchivo.write(\"Escribir en Python no es tan grave como parece.\\n\")\n\n48\n\n\nEl m√©todo .write() devuelve el n√∫mero de caracteres escritos, incluyendo el salto de l√≠nea \\n. Despu√©s, cerramos el archivo.\n\narchivo.close()\n\nPara agregar texto sin reemplazar el contenido existente, abrimos el archivo en modo adici√≥n. Escribimos la cadena \"Es solo cuesti√≥n de practica.\" y lo cerramos nuevamente.\n\narchivo = open(\"conclusiones.txt\", mode=\"a\", encoding=\"utf-8\")\narchivo.write(\"Es solo cuesti√≥n de practica.\")\narchivo.close()\n\nFinalmente, para mostrar en pantalla el contenido de conclusiones.txt, abrimos el archivo en modo lectura, cargamos su contenido con .read(), lo guardamos en la variable texto, cerramos el archivo y luego imprimimos texto.\n\narchivo = open(\"conclusiones.txt\", mode=\"r\", encoding=\"utf-8\")\ntexto = archivo.read()\narchivo.close()\nprint(texto)\n\nEscribir en Python no es tan grave como parece.\nEs solo cuesti√≥n de practica.\n\n\n\n\n\n\n\n\nSaltos de l√≠nea\n\n\n\nEs importante tener presente que el m√©todo .write() no agrega un salto de l√≠nea al final del texto de forma autom√°tica, a diferencia de print(). Si queremos que el contenido se escriba en una nueva l√≠nea dentro del archivo, debemos incluir manualmente el car√°cter \\n.\n\n\n\n\nUso de la sentencia with\nCuando abrimos un archivo con open(), debemos cerrarlo despu√©s con .close(). El problema es que a veces podemos olvidarlo o que el programa falle antes de llegar a esa l√≠nea.\nPara evitarlo, Python ofrece la sentencia with, que se encarga de cerrar el archivo autom√°ticamente al terminar el bloque de c√≥digo, incluso si ocurre un error en el medio.\nDebajo, utilizamos la sentencia with para crear un archivo y escribir texto en √©l.\n\nwith open(\"ejemplo.txt\", mode=\"w\", encoding=\"utf-8\") as archivo:\n    archivo.write(\"¬°Hola, mundo!\\n\")\n\nprint(archivo.closed) # Verificar que el archivo est√° cerrado\n\nTrue\n\n\nLuego, podemos utilizar un patr√≥n similar, pero pasando mode=\"r\", para leer el contenido del archivo.\n\nwith open(\"ejemplo.txt\", mode=\"r\", encoding=\"utf-8\") as archivo:\n    contenido = archivo.read()\n\nprint(contenido)\nprint(archivo.closed)\n\n¬°Hola, mundo!\n\nTrue\n\n\n\n\n\n\n\n\nContext managers\n\n\n\nLa sentencia with no es exclusiva para leer o escribir archivos: en realidad funciona con un objeto especial llamado context manager.\nUn context manager se usa en Python para manejar recursos que necesitan ser adquiridos y luego liberados de forma segura, como archivos, conexiones de red o bloqueos de concurrencia.\nLa clave es que with define un bloque de c√≥digo dentro del cual el recurso est√° disponible. Al entrar en el bloque, el recurso se prepara (por ejemplo, se abre un archivo) y, al salir, se libera autom√°ticamente, sin importar si la salida fue normal, si hubo un return o si se produjo una excepci√≥n.\nEsto permite que el c√≥digo sea m√°s claro y seguro, ya que todo el ciclo de vida del recurso queda encapsulado dentro de ese bloque.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "8 - Lectura y escritura de archivos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/08_io.html#archivos-y-rutas",
    "href": "teoria/01_programacion_en_python/08_io.html#archivos-y-rutas",
    "title": "8 - Lectura y escritura de archivos",
    "section": "Archivos y rutas",
    "text": "Archivos y rutas\nUn archivo tiene dos caracter√≠sticas principales: su nombre y su ruta.\nLa ruta indica la ubicaci√≥n exacta del archivo dentro de la computadora y puede incluir directorios, subdirectorios y el nombre del archivo con su extensi√≥n (por ejemplo, .txt, .csv, .py).\nA modo de ejemplo, supongamos que tenemos un archivo con el nombre reporte.docx, que se encuentra en la ruta:\nC:\\Users\\Tomi\\Documentos\nLa parte C:\\ de la ruta es la carpeta ra√≠z (conocida como root directory en ingl√©s), la cual contiene a todas las dem√°s carpetas.\nEn Windows, la carpeta ra√≠z se llama C:\\ y tambi√©n se le conoce como la unidad C:. En macOS y Linux, la carpeta ra√≠z se representa con una simple barra inclinada: /.\nPor otro lado, Users, Tomi y Documentos son carpetas, tambi√©n llamadas directorios. Las carpetas pueden contener archivos y tambi√©n otras carpetas (llamadas subcarpetas o subdirectorios).\n\nEspecificaci√≥n de rutas con pathlib.Path\n\nPor qu√© no es suficiente con str\nPor defecto, Python busca los archivos en el directorio de trabajo actual (current working directory). Por ejemplo:\nopen(\"archivo.txt\")\nEn este caso, archivo.txt debe estar en la misma carpeta desde donde se ejecuta el programa. Si no est√° all√≠, hay que indicar su ruta absoluta o relativa.\nAunque se pueden usar cadenas de texto (str) para definir rutas, esto puede generar problemas porque los sistemas operativos usan separadores distintos. Mientras que Windows usa la barra inclinada hacia atr√°s \\, macOS y Linux usan la barra inclinada hacia delante /.\n\n\nLa soluci√≥n\nPara evitar errores y escribir c√≥digo que funcione en cualquier sistema, conviene usar Path del m√≥dulo pathlib, que maneja autom√°ticamente las diferencias entre las formas de especificar rutas entre los distintos sistemas operativos.\nfrom pathlib import Path\nruta = Path(\"Users/Tomi/Documentos/projecto.docx\")\nprint(ruta)\nEn Windows se mostrar√° como:\nUsers\\Tomi\\Documentos\\project.docx\nY en macOS o Linux como:\nUsers/Tomi/Documentos/projecto.docx\nSi en Windows convertimos al objeto ruta a una cadena de caracteres, nos encontraremos con el siguiente resultado:\nstr(ruta)\n\"Users\\\\Tomi\\\\Documentos\\\\projecto.docx\"\nLas barras invertidas aparecen como dobles barras invertidas porque en Python cada barra invertida debe escaparse con otra barra invertida.\n\n\n\nCombinaci√≥n de rutas con el operador /\nEl operador /, que normalmente usamos para dividir n√∫meros, tambi√©n sirve en Python para combinar rutas cuando trabajamos con pathlib.Path. Esto permite construir rutas de forma clara y sin preocuparse por los separadores que cambian seg√∫n el sistema operativo. Por ejemplo:\nfrom pathlib import Path\n\nruta = Path(\"datos\") / \"usuarios\" / \"reporte.txt\"\nprint(ruta)\nEl resultado ser√° distinto seg√∫n el sistema:\nEn Windows:\ndatos\\usuarios\\reporte.txt\nEn macOS/Linux:\ndatos/usuarios/reporte.txt\nDe esta manera, podemos ir ‚Äúpegando‚Äù carpetas y archivos paso a paso, evitando concatenar cadenas manualmente y asegurando compatibilidad multiplataforma.\n\n\nRutas absolutas y relativas\nExisten dos formas principales de escribir la ruta de un archivo:\n\nRuta absoluta: indica la ubicaci√≥n completa desde la carpeta ra√≠z. En Windows comienza con la letra de unidad, por ejemplo C:\\, y en macOS/Linux comienza con /.\nRuta relativa: se interpreta a partir del directorio de trabajo actual del programa.\n\nAdem√°s, es com√∫n usar dos ‚Äúatajos especiales‚Äù dentro de una ruta:\n\n.: indica el directorio actual.\n..: indica el directorio padre, del ingles parent directory, que es el directorio que contiene al directorio actual.\n\nPor ejemplo, si el directorio de trabajo es C:\\trabajo y queremos acceder al archivo C:\\trabajo\\datos.txt mediante una ruta relativa, podemos usar simplemente:\ndatos.txt\no\n.\\datos.txt\nPor otro lado, si queremos acceder al archivo C:\\estudio\\reporte.txt, la ruta relativa ser√≠a:\n..\\estudio\\reporte.txt\nEsto facilita moverse entre carpetas sin necesidad de escribir rutas absolutas cada vez.\n\n\nAcceso a directorios de inter√©s\n\nDirectorio de trabajo actual\nEl directorio de trabajo actual es la carpeta desde la cual Python busca los archivos cuando usamos rutas relativas. En Python se puede obtener como una cadena de texto usando el m√©todo .cwd() (del ingl√©s, current working directory) de Path:\nfrom pathlib import Path\nprint(Path.cwd())\nSi necesitamos cambiar el directorio de trabajo actual, se puede usar chdir del m√≥dulo os:\nimport os\nos.chdir(\"nueva_ruta\")\n\n\n\n\n\n\nPrecauciones\n\n\n\nHay que tener en cuenta que al modificar el directorio de trabajo cambian todas las rutas relativas en el programa. Por eso, en proyectos grandes suele ser m√°s seguro usar rutas absolutas o construirlas a partir de un directorio base bien definido.\n\n\n\n\nDirectorio personal (home)\nCada usuario tiene un directorio personal que depende del sistema operativo: en Windows suele estar en C:\\Users\\&lt;usuario&gt;, en macOS en /Users/&lt;usuario&gt; y en Linux en /home/&lt;usuario&gt;.\nEn Python se puede acceder a este directorio con el m√©todo Path.home():\nfrom pathlib import Path\nprint(Path.home())\nNormalmente, los programas tienen permisos de lectura y escritura dentro de este directorio, por lo que es un lugar seguro y conveniente para guardar archivos y configuraciones creadas por tus scripts.\n\n\n\nUtilidades\n\nObtenci√≥n ruta absoluta y normalizada\nEl m√©todo .resolve() de Path convierte una ruta relativa en absoluta y, cuando es posible, normaliza la ruta colapsando los atajos . y ... En el siguiente ejemplo, el directorio de trabajo actual es C:\\Users\\Tomi\\Desktop\\proyecto:\nfrom pathlib import Path\n\nruta = Path(\"../datos.txt\")\nprint(ruta.resolve()) # ruta absoluta y normalizada\nC:\\Users\\Tomi\\Desktop\\datos.txt\n\n\nCreaci√≥n de directorios\nEl m√©todo .mkdir() de los objetos Path permite crear un directorio a partir de una ruta.\nfrom pathlib import Path\n\nPath(\"nueva_carpeta\").mkdir(exist_ok=True)\nCon exist_ok=True evitamos errores si la carpeta ya existe.\nPara crear todos los directorios en una ruta de m√∫ltiples directorios en una sola llamada, se puede a√±adir parents=True:\nPath(\"datos/limpios/2025\").mkdir(parents=True, exist_ok=True)\n\n\nVerificaci√≥n de validez y tipo de rutas\nLos objetos Path permiten comprobar si una ruta existe y qu√© tipo de recurso representa:\nfrom pathlib import Path\n\nruta = Path(\"C:/Users/Tomi/Documentos/projecto.docx\")\n\nprint(ruta.exists())   # True si existe\nprint(ruta.is_file())  # True si existe y es archivo\nprint(ruta.is_dir())   # True si existe y es directorio",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "8 - Lectura y escritura de archivos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/08_io.html#ap√©ndice",
    "href": "teoria/01_programacion_en_python/08_io.html#ap√©ndice",
    "title": "8 - Lectura y escritura de archivos",
    "section": "Ap√©ndice",
    "text": "Ap√©ndice\n\nEl arugmento mode de open()\n\nCaracteres v√°lidos\n\n\n\n\n\n\n\nCaracter\nSignificado\n\n\n\n\nr\nabrir para lectura (predeterminado)\n\n\nw\nabrir para escritura, truncando primero el archivo\n\n\nx\ncrear un archivo nuevo y abrirlo para escritura\n\n\na\nabrir para escritura, agregando al final del archivo si existe\n\n\nb\nmodo binario\n\n\nt\nmodo texto (predeterminado)\n\n\n+\nabrir un archivo en disco para actualizaci√≥n (lectura y escritura)\n\n\n\n\n\nEjemplos\n\n\n\n\n\n\n\n\nModo\nEjemplo\nDescripci√≥n\n\n\n\n\nr\nopen(\"datos.txt\", \"r\")\nAbre datos.txt para leer en modo texto.\n\n\nrb\nopen(\"imagen.png\", \"rb\")\nAbre imagen.png para leer en modo binario (√∫til para im√°genes, PDFs, etc).\n\n\nw\nopen(\"salida.txt\", \"w\")\nAbre salida.txt para escritura en texto, truncando el archivo si existe.\n\n\nwb\nopen(\"audio.raw\", \"wb\")\nAbre audio.raw para escritura en binario, truncando si existe.\n\n\na\nopen(\"log.txt\", \"a\")\nAbre log.txt para a√±adir texto al final del archivo.\n\n\nab\nopen(\"video.mp4\", \"ab\")\nAbre video.mp4 en binario para a√±adir datos al final.\n\n\nx\nopen(\"nuevo.txt\", \"x\")\nCrea nuevo.txt y lo abre para escritura en texto. Falla si ya existe.\n\n\nxb\nopen(\"nuevo.dat\", \"xb\")\nCrea nuevo.dat y lo abre para escritura en binario. Falla si ya existe.\n\n\nr+\nopen(\"datos.txt\", \"r+\")\nAbre datos.txt para leer y escribir en texto.\n\n\nrb+\nopen(\"imagen.png\", \"rb+\")\nAbre imagen.png para leer y escribir en binario.\n\n\nw+\nopen(\"datos.txt\", \"w+\")\nAbre datos.txt para leer y escribir en texto, truncando si existe.\n\n\nwb+\nopen(\"datos.bin\", \"wb+\")\nAbre datos.bin para leer y escribir en binario, truncando si existe.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "8 - Lectura y escritura de archivos"
    ]
  },
  {
    "objectID": "teoria/03_oop/05_excepciones.html",
    "href": "teoria/03_oop/05_excepciones.html",
    "title": "5 - Excepciones",
    "section": "",
    "text": "Elevacion de errores\nImplementacion de errores",
    "crumbs": [
      "Teor√≠a",
      "U3 - Programaci√≥n Orientada a Objetos",
      "5 - Excepciones"
    ]
  },
  {
    "objectID": "teoria/03_oop/05_excepciones.html#errores",
    "href": "teoria/03_oop/05_excepciones.html#errores",
    "title": "5 - Excepciones",
    "section": "",
    "text": "Elevacion de errores\nImplementacion de errores",
    "crumbs": [
      "Teor√≠a",
      "U3 - Programaci√≥n Orientada a Objetos",
      "5 - Excepciones"
    ]
  },
  {
    "objectID": "teoria/03_oop/02_encapsulamiento.html",
    "href": "teoria/03_oop/02_encapsulamiento.html",
    "title": "2 - Encapsulamiento",
    "section": "",
    "text": "Los tres principios fundamentales de la programaci√≥n orientada a objetos son la encapsulaci√≥n, la herencia y el polimorfismo.\nA lo largo de los pr√≥ximos apuntes vamos a explorar cada uno en detalle, entendiendo los conceptos que los sustentan y analizando ejemplos concretos de c√≥mo se aplican en Python. En l√≠neas generales, estos principios se pueden describir de la siguiente manera:\n\nEncapsulaci√≥n: consiste en reunir en un mismo lugar tanto los datos como las operaciones que act√∫an sobre ellos, ocultando los detalles internos y exponiendo √∫nicamente la interfaz necesaria para interactuar con el objeto.\nHerencia: permite crear nuevas clases a partir de otras ya existentes, reutilizando su comportamiento y ampli√°ndolo o modific√°ndolo seg√∫n sea necesario.\nPolimorfismo: hace posible que diferentes objetos de diferentes clases respondan de forma distinta a un mismo ‚Äúmensaje‚Äù (por ejemplo, un m√©todo con el mismo nombre), adaptando el comportamiento a las particularidades de cada caso.",
    "crumbs": [
      "Teor√≠a",
      "U3 - Programaci√≥n Orientada a Objetos",
      "2 - Encapsulamiento"
    ]
  },
  {
    "objectID": "teoria/03_oop/02_encapsulamiento.html#prefacio",
    "href": "teoria/03_oop/02_encapsulamiento.html#prefacio",
    "title": "2 - Encapsulamiento",
    "section": "",
    "text": "Los tres principios fundamentales de la programaci√≥n orientada a objetos son la encapsulaci√≥n, la herencia y el polimorfismo.\nA lo largo de los pr√≥ximos apuntes vamos a explorar cada uno en detalle, entendiendo los conceptos que los sustentan y analizando ejemplos concretos de c√≥mo se aplican en Python. En l√≠neas generales, estos principios se pueden describir de la siguiente manera:\n\nEncapsulaci√≥n: consiste en reunir en un mismo lugar tanto los datos como las operaciones que act√∫an sobre ellos, ocultando los detalles internos y exponiendo √∫nicamente la interfaz necesaria para interactuar con el objeto.\nHerencia: permite crear nuevas clases a partir de otras ya existentes, reutilizando su comportamiento y ampli√°ndolo o modific√°ndolo seg√∫n sea necesario.\nPolimorfismo: hace posible que diferentes objetos de diferentes clases respondan de forma distinta a un mismo ‚Äúmensaje‚Äù (por ejemplo, un m√©todo con el mismo nombre), adaptando el comportamiento a las particularidades de cada caso.",
    "crumbs": [
      "Teor√≠a",
      "U3 - Programaci√≥n Orientada a Objetos",
      "2 - Encapsulamiento"
    ]
  },
  {
    "objectID": "teoria/03_oop/02_encapsulamiento.html#introducci√≥n",
    "href": "teoria/03_oop/02_encapsulamiento.html#introducci√≥n",
    "title": "2 - Encapsulamiento",
    "section": "Introducci√≥n",
    "text": "Introducci√≥n\nSupongamos que nos encontramos manejando un auto por el centro rosarino y al llegar a la esquina vemos que por la calle perpendicular se aproxima otro veh√≠culo que no aparenta intenciones de frenar.\nTodo indica que tendremos que detener el auto completamente.\nInstant√°neamente, presionamos el embrague casi al mismo tiempo que el pedal de freno y colocamos la palanca de cambio en la posici√≥n de punto muerto. El auto responde de la manera que esperamos y se detiene.\nUna vez que el otro veh√≠culo cruza, nos disponemos a continuar nuestra marcha. Como a√∫n no soltamos el pie del embrague, movemos la palanca de cambios a la posici√≥n de primera, suavemente soltamos el embrague mientras comenzamos a presionar el acelerador, y finalmente cruzamos.\n¬øY qu√© tiene que ver toda esta escena automovil√≠stica con el encapsulamiento? M√°s de lo que podr√≠amos imaginarnos.\nPara detener el auto, tuvimos que interactuar con los pedales y eventualmente con la palanca de cambios. Todo un esfuerzo, s√≠.\nSin embargo, no necesitamos saber en realidad como funciona el proceso de frenado de un auto: desconocemos como funcionan los discos, la hidr√°ulica y mucho menos podr√≠amos describir como funciona una caja de cambios. Todos estos mecanismos internos permanecen ocultos dentro del sistema (el auto). Lo √∫nico visible es una interfaz sencilla que nos permite lograr nuestro objetivo sin necesidad de saber qu√© ocurre detr√°s.\nEn programaci√≥n ocurre lo mismo: la encapsulaci√≥n consiste en mantener el estado interno y la l√≥gica de un objeto fuera del alcance del exterior, exponiendo √∫nicamente una forma clara y controlada de interactuar con √©l. De este modo, el c√≥digo que interactua con el objeto no necesita conocer sus detalles internos y puede seguir funcionando incluso si estos cambian.",
    "crumbs": [
      "Teor√≠a",
      "U3 - Programaci√≥n Orientada a Objetos",
      "2 - Encapsulamiento"
    ]
  },
  {
    "objectID": "teoria/03_oop/02_encapsulamiento.html#las-m√∫ltiples-caras-del-encapsulamiento",
    "href": "teoria/03_oop/02_encapsulamiento.html#las-m√∫ltiples-caras-del-encapsulamiento",
    "title": "2 - Encapsulamiento",
    "section": "Las m√∫ltiples caras del encapsulamiento",
    "text": "Las m√∫ltiples caras del encapsulamiento\nEn programaci√≥n no existe una √∫nica manera de aplicar el encapsulamiento, es decir, de aislar y proteger los detalles internos de c√≥mo algo funciona. A continuaci√≥n, veremos c√≥mo esta idea aparece y se utiliza en distintos niveles: funciones, objetos y clases.\n\nFunciones\nLas funciones ofrecen un ejemplo clar√≠simo de encapsulaci√≥n: para usarlas, no hace falta conocer como funcionan internamente. De hecho, una funci√≥n bien dise√±ada se caracteriza por cumplir una √∫nica tarea y tener un nombre que la describa con claridad. De esta manera, con solo leer su nombre podemos anticipar qu√© hace, sin preocuparnos por los detalles de su implementaci√≥n.\nPor ejemplo, consideremos la siguiente funci√≥n que devuelve el n√∫mero \\(n\\)-√©simo en la secuencia de Fibonacci:\n\ndef fibonacci(n):\n    if n &lt;= 1:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)\n\nprint(fibonacci(10))\nprint(fibonacci(21))\n\n55\n10946\n\n\nSi est√° clara la interfaz de la funci√≥n (cantidad y tipos de entradas y salidas), no es necesario conocer detalles de la implementaci√≥n, ni si el c√≥digo es largo o complejo. Incluso si se encuentra un mejor algoritmo para resolver el mismo problema, la funci√≥n puede reescribirse sin cambiar su uso externo, siempre que la interfaz no cambie.\nEsta modularizaci√≥n hace que el c√≥digo sea m√°s f√°cil de mantener y adaptar a futuros cambios.\n\n\nObjetos\nEn la programaci√≥n orientada a objetos hay una distinci√≥n clave entre el interior y el exterior de una clase u objeto.\nDesde el interior, al dise√±ar una clase o implementar sus m√©todos, debemos cuidar c√≥mo interact√∫an con los atributos, la eficiencia de los algoritmos y el dise√±o de la interfaz. El objetivo es construir una estructura coherente y f√°cil de mantener.\nDesde el exterior, lo que importa no son los detalles internos sino la interfaz p√∫blica: qu√© hace cada m√©todo, qu√© argumentos necesita y qu√© valores devuelve. Mientras esa interfaz se mantenga, la clase puede usarse sin conocer su implementaci√≥n.\nLas clases favorecen el encapsulamiento porque:\n\nDefinen una interfaz clara para usar sus m√©todos sin saber c√≥mo funcionan por dentro.\nProtegen el estado interno, evitando modificaciones directas desde fuera.\n\nY, gracias a ello, permiten cambiar la implementaci√≥n sin afectar el c√≥digo que las utiliza.\nAhora bien, ¬øc√≥mo es que las clases en Python definen una interfaz clara y protegen el estado interno?",
    "crumbs": [
      "Teor√≠a",
      "U3 - Programaci√≥n Orientada a Objetos",
      "2 - Encapsulamiento"
    ]
  },
  {
    "objectID": "teoria/03_oop/02_encapsulamiento.html#interfaz-clara",
    "href": "teoria/03_oop/02_encapsulamiento.html#interfaz-clara",
    "title": "2 - Encapsulamiento",
    "section": "Interfaz clara",
    "text": "Interfaz clara\n\nDocstrings\n¬øC√≥mo podemos saber cu√°ntos argumentos debemos pasar y de qu√© tipo al inicializar una clase? ¬øY c√≥mo saberlo al llamar a uno de sus m√©todos?\nUna primera opci√≥n ser√≠a leer directamente su implementaci√≥n, pero eso es precisamente lo que queremos evitar.\nUna alternativa mucho mejor es consultar la documentaci√≥n. Para ello, la clase y sus m√©todos deben contar con docstrings adecuados que describan su uso.\nVeamos el siguiente ejemplo:\n\nclass CuentaBancaria:\n    \"\"\"Cuenta bancaria simple con operaciones b√°sicas.\n\n    Esta clase implementa un modelo b√°sico de cuenta bancaria que permite\n    depositar y retirar dinero, as√≠ como consultar el saldo actual.\n    \"\"\"\n    def __init__(self, titular, saldo_inicial=0.0):\n        \"\"\"Inicializa una nueva cuenta bancaria.\n\n        Parameters\n        ----------\n        titular : str\n            Nombre del titular de la cuenta.\n        saldo_inicial : float, optional\n            Saldo inicial de la cuenta. Por defecto es 0.0.\n        \"\"\"\n        self.titular = titular\n        self.saldo = saldo_inicial\n\n    def depositar(self, monto):\n        \"\"\"Depositar dinero en la cuenta.\n\n        Parameters\n        ----------\n        monto : float\n            Monto a depositar. Debe ser un n√∫mero positivo.\n        \"\"\"\n        if monto &lt;= 0:\n            print(\"Error: El monto a depositar debe ser positivo.\")\n            return\n        self.saldo += monto\n\n\n    def retirar(self, monto):\n        \"\"\"Extrae dinero de la cuenta si hay fondos suficientes.\n\n        Parameters\n        ----------\n        monto : float\n            Monto a retirar.\n        \"\"\"\n        if monto &gt; self.saldo:\n            print(\"Error: Fondos insuficientes.\")\n            return\n        self.saldo -= monto\n\n\n    def consultar_saldo(self):\n        \"\"\"Devuelve el saldo actual.\n\n        Returns\n        -------\n        float\n            Saldo disponible en la cuenta.\n        \"\"\"\n        return self.saldo\n\n\ncuenta = CuentaBancaria(titular=\"Jos√© Paso\", saldo_inicial=12000)\ncuenta.consultar_saldo()\n\n12000\n\n\n\ncuenta.retirar(3800)\ncuenta.consultar_saldo()\n\n8200\n\n\n\ncuenta.depositar(1500)\ncuenta.retirar(50000)\ncuenta.consultar_saldo()\n\nError: Fondos insuficientes.\n\n\n9700\n\n\nPara consultar la documentaci√≥n, podemos usar la funci√≥n help de Python.\nSi la ejecutamos en Positron, se abrir√° una ventana a la derecha que muestra la informaci√≥n disponible. Si, en cambio, la usamos desde una terminal, obtendremos un resultado similar al siguiente:\nAyuda para toda clase:\nhelp(CuentaBancaria)\nHelp on class CuentaBancaria in module __main__:\n\nclass CuentaBancaria(builtins.object)\n |  CuentaBancaria(titular, saldo_inicial=0.0)\n |\n |  Cuenta bancaria simple con operaciones b√°sicas.\n |\n |  Esta clase implementa un modelo b√°sico de cuenta bancaria que permite\n |  depositar y retirar dinero, as√≠ como consultar el saldo actual.\n |\n |  Methods defined here:\n |\n |  __init__(self, titular, saldo_inicial=0.0)\n |      Inicializa una nueva cuenta bancaria.\n |\n |      Parameters\n |      ----------\n |      titular : str\n |          Nombre del titular de la cuenta.\n |      saldo_inicial : float, optional\n |          Saldo inicial de la cuenta. Por defecto es 0.0.\nAyuda para el m√©todo depositar, que recibe un flotante y no devuelve nada:\nhelp(CuentaBancaria.depositar)\nHelp on function depositar in module __main__:\n\ndepositar(self, monto)\n    Depositar dinero en la cuenta.\n\n    Parameters\n    ----------\n    monto : float\n        Monto a depositar. Debe ser un n√∫mero positivo.\nAyuda para el m√©todo consultar_saldo, que no recibe ning√∫n parametro y devuelve un flotante:\nhelp(CuentaBancaria.consultar_saldo)\nHelp on function consultar_saldo in module __main__:\n\nconsultar_saldo(self)\n    Devuelve el saldo actual.\n\n    Returns\n    -------\n    float\n        Saldo disponible en la cuenta.\nSi bien en algunos casos puede resultar necesario consultar la ayuda con la funci√≥n help, los editores de c√≥digo suelen mostrar autom√°ticamente una peque√±a ventana junto al c√≥digo mientras escribimos, donde aparece la documentaci√≥n de clases, m√©todos y funciones.\n\n\nAnotaciones de tipo\nSi bien Python es un lenguaje de tipado din√°mico e impl√≠cito ‚Äîes decir, no es necesario especificar el tipo de las variables y este puede cambiar durante la ejecuci√≥n‚Äî, es posible utilizar anotaciones de tipo (del ingl√©s type annotations) para indicar qu√© tipo de dato se espera. Estas anotaciones son opcionales, pero ayudan a que el c√≥digo sea m√°s claro, f√°cil de entender y detectar errores antes de ejecutar el programa.\nPara los par√°metros de una funci√≥n o m√©todo, las anotaciones de tipo se escriben con el formato &lt;nombre_variable&gt;: &lt;tipo&gt;. En el caso la salida, el tipo se indica despu√©s de una flecha (-&gt; &lt;tipo&gt;) al final de la definici√≥n.\nPor ejemplo, en la siguiente funci√≥n se especifica que el par√°metro nombre debe ser de tipo str y que la funci√≥n devuelve tambi√©n un objeto de tipo str:\n\ndef saludar(nombre: str) -&gt; str:\n    return f\"¬°Hola, {nombre}!\"\n\nsaludar(\"Guido\")\n\n'¬°Hola, Guido!'\n\n\nEn nuestra clase CuentaBancaria, la anotaci√≥n de tipos se ve de la siguiente manera:\n\nclass CuentaBancaria:\n1    def __init__(self, titular: str, saldo_inicial: float = 0.0):\n        self.titular = titular\n        self.saldo = saldo_inicial\n\n2    def depositar(self, monto: float):\n        self.saldo += monto\n\n3    def retirar(self, monto: float):\n        self.saldo -= monto\n\n4    def consultar_saldo(self) -&gt; float:\n        return self.saldo\n\n\n1\n\nPara inicializar la clase, se espera un argumento titular de tipo str y otro saldo_inicial de tipo float.\n\n2\n\nEl m√©todo depositar espera recibir un argumento de tipo float.\n\n3\n\nEl m√©todo retirar tambi√©n espera recibir un argumento de tipo float.\n\n4\n\nPor √∫ltimo, consultar_saldo devuelve un valor de tipo float.\n\n\n\n\nSi se eligen nombres representativos para los m√©todos y se utilizan anotaciones de tipo en sus par√°metros, es muy probable que no sea necesario escribir un docstring para que el usuario comprenda c√≥mo funciona la clase.\nSin embargo, ni la documentaci√≥n mediante docstrings ni el uso de anotaciones de tipo garantizan que una funci√≥n o m√©todo se utilice con los tipos de datos adecuados. Por ejemplo, podr√≠amos pasarle un n√∫mero a nuestra funci√≥n saludar sin que Python lo impida:\n\nsaludar(128)\n\n'¬°Hola, 128!'\n\n\nO incluso podr√≠amos inicializar el saldo_inicial de la cuenta bancaria con una lista y luego intentar ‚Äúdepositar‚Äù otra lista.\n\ncuenta = CuentaBancaria(25, saldo_inicial=[\"Cosas\"])\ncuenta.consultar_saldo()\n\n['Cosas']\n\n\n\ncuenta.depositar([\"Otras cosas\", \"A√∫n m√°s cosas\"])\ncuenta.consultar_saldo()\n\n['Cosas', 'Otras cosas', 'A√∫n m√°s cosas']\n\n\nEn resumen, si bien Python nos permite especificar la interfaz de funciones y m√©todos mediante docstrings y anotaciones de tipo, al ser un lenguaje de tipado din√°mico nada impide que se utilicen con tipos de datos para los que no fueron dise√±ados. En algunos casos esto puede resultar en comportamientos inesperados y, en otros, simplemente generar un error en tiempo de ejecuci√≥n.\n\n\n\n\n\n\nDuck typing ü¶Ü\n\n\n\nEn lenguajes din√°micos como Python, muchas veces no importa de qu√© tipo es un objeto, sino qu√© puede hacer. Lo relevante no es su clase, sino si se comporta como necesitamos.\nPor ejemplo, en una funci√≥n como saludar, el par√°metro no tiene que ser necesariamente un str, siempre que pueda usarse dentro de una f-string.\nEste enfoque, donde importa m√°s el comportamiento que el tipo, se llama duck typing y suele expresarse as√≠:\n\nSi camina como un pato y hace cuac como un pato, entonces probablemente es un pato.",
    "crumbs": [
      "Teor√≠a",
      "U3 - Programaci√≥n Orientada a Objetos",
      "2 - Encapsulamiento"
    ]
  },
  {
    "objectID": "teoria/03_oop/02_encapsulamiento.html#estado-interno",
    "href": "teoria/03_oop/02_encapsulamiento.html#estado-interno",
    "title": "2 - Encapsulamiento",
    "section": "Estado interno",
    "text": "Estado interno\nAhora que sabemos qu√© estrategias podemos usar para que la interfaz de una clase sea clara, veamos c√≥mo las clases definen y protegen su estado interno.\nConsideremos a la siguiente clase que sirve para representar a estudiantes de la Facultad de Ciencias Econ√≥micas y Estad√≠stica de la UNR.\n\nclass Estudiante:\n    def __init__(self, nombre, ingreso, carrera):\n        self.nombre = nombre\n        self.ingreso = ingreso\n        self.carrera = carrera\n\n    def resumen(self):\n        return f\"Estudiante(nombre={self.nombre}, ingreso={self.ingreso}, carrera={self.carrera})\"\n\nCada objeto mantiene sus propias variables de instancia, como nombre, ingreso y carrera, con valores independientes de los de otros objetos de la misma clase. Esto implica que modificar los datos de una instancia no afecta en absoluto a las dem√°s: cada objeto gestiona y conserva su propio estado interno, es decir, los objetos son due√±os de sus variables.\n\ne1 = Estudiante(\"Mariano Gonz√°lez\", 2022, \"Contador P√∫blico\")\ne2 = Estudiante(\"Leticia Gallardo\", 2023, \"Licenciatura en Estad√≠stica\")\n\nGracias al m√©todo resumen, podemos obtener una representaci√≥n clara e intuitiva de cada objeto.\n\ne1.resumen()\n\n'Estudiante(nombre=Mariano Gonz√°lez, ingreso=2022, carrera=Contador P√∫blico)'\n\n\nAunque tambi√©n es posible interactuar con los atributos de cada instancia de manera individual.\n\nprint(e1.nombre, e1.carrera, sep=\": \")\nprint(e2.nombre, e2.carrera, sep=\": \")\n\nMariano Gonz√°lez: Contador P√∫blico\nLeticia Gallardo: Licenciatura en Estad√≠stica\n\n\nEsta interacci√≥n no solo implica que podemos acceder a los valores individuales de los atributos, sino tambi√©n que tenemos la posibilidad de modificarlos.\n\ne1.ingreso = 2019\ne1.resumen()\n\n'Estudiante(nombre=Mariano Gonz√°lez, ingreso=2019, carrera=Contador P√∫blico)'\n\n\nTenemos tanta flexibilidad al modificar los atributos de una instancia que incluso podemos asignarles valores que no tienen sentido dentro del contexto de la clase.\n\ne1.ingreso = \"Cualquier cosa\"\ne1.resumen()\n\n'Estudiante(nombre=Mariano Gonz√°lez, ingreso=Cualquier cosa, carrera=Contador P√∫blico)'\n\n\n\nSetters y getters\nEn programaci√≥n orientada a objetos, los getters y setters son m√©todos especiales que permiten acceder y modificar el estado interno de un objeto de forma segura y controlada. Su objetivo principal es proteger los atributos, evitando que se acceda o se cambien directamente desde el exterior de la clase.\nEn particular:\n\ngetter: m√©todo que obtiene o devuelve el valor de un atributo de un objeto.\nsetter: m√©todo que asigna o actualiza el valor de un atributo de un objeto.\n\nNuestra clase Estudiante, incorporando ahora estos m√©todos para acceder y modificar sus atributos, se ver√≠a de la siguiente manera:\n\nclass Estudiante:\n    def __init__(self, nombre):\n1        self.setNombre(nombre)\n\n2    def setNombre(self, nombre):\n        if isinstance(nombre, str):\n            self.nombre = nombre\n        else:\n            print(\"El nombre debe ser de tipo 'str'\")\n\n3    def getNombre(self):\n        return self.nombre\n\n    def resumen(self):\n        return f\"Estudiante(nombre={self.getNombre()})\"\n\n\n1\n\nEl m√©todo de inicializaci√≥n no asigna el atributo directamente, sino que delega la tarea en el setter.\n\n2\n\nEl setter recibe un valor, verifica su tipo y, si es el esperado, lo asigna como atributo de instancia.\n\n3\n\nEl getter simplemente devuelve el valor del atributo, proporcionando un punto de acceso controlado al estado interno.\n\n\n\n\nCreemos un nuevo objeto de tipo Estudiante.\n\ne = Estudiante(\"Macarena Gianetti\")\ne.resumen()\n\n'Estudiante(nombre=Macarena Gianetti)'\n\n\nLuego, obtenemos el nombre de la estudiante mediante su getter.\n\ne.getNombre()\n\n'Macarena Gianetti'\n\n\nSi queremos modificarlo, no asignamos el valor directamente a una variable del objeto, sino que llamamos a su m√©todo setter. Este m√©todo se encarga de validar el dato y evitar que se asignen valores de tipos no permitidos.\n\ne.setNombre(189)\n\nEl nombre debe ser de tipo 'str'\n\n\n\ne.resumen()\n\n'Estudiante(nombre=Macarena Gianetti)'\n\n\nSin embargo, Python no impide que, como usuarios, accedamos y modifiquemos directamente los atributos del objeto. Por ejemplo, podemos asignar un valor de cualquier tipo directamente a la variable nombre:\n\ne.nombre = 2\ne.resumen()\n\n'Estudiante(nombre=2)'\n\n\nEn ese caso, las ventajas de usar setter y getter dejan de tener efecto si el usuario decide ‚Äúromper‚Äù el objeto ignorando su interfaz.\n\n\nAtributos protegidos\nEn muchos lenguajes de programaci√≥n existe una distinci√≥n clara entre atributos p√∫blicos y privados. Los p√∫blicos pueden ser accedidos tanto desde dentro como desde fuera de la clase, mientras que los privados solo pueden usarse internamente. Es decir, un m√©todo de la clase puede acceder a un atributo o m√©todo privado, pero el c√≥digo externo que usa la clase no.\nEn Python no existe una separaci√≥n estricta entre atributos p√∫blicos y privados: todos son t√©cnicamente p√∫blicos. Sin embargo, por convenci√≥n, si el nombre de un atributo o m√©todo comienza con un guion bajo (_), esto indica que no deber√≠a ser accedido ni modificado desde el exterior de la clase, ya que est√° protegido.\nSiguiendo esta convenci√≥n, en nuestro ejemplo con la clase Estudiante podemos usar un atributo llamado _nombre para almacenar el nombre del estudiante.\n\nclass Estudiante:\n    def __init__(self, nombre):\n        self.setNombre(nombre)\n\n    def setNombre(self, nombre):\n        if isinstance(nombre, str):\n1            self._nombre = nombre\n        else:\n            print(\"El nombre debe ser de tipo 'str'\")\n\n    def getNombre(self):\n2        return self._nombre\n\n    def resumen(self):\n        return f\"Estudiante(nombre={self.getNombre()})\"\n\n\n1\n\nSe guarda el nombre en una variable ‚Äúprivada‚Äù _nombre.\n\n2\n\nSe devuelve el nombre usando la variable ‚Äúprivada‚Äù _nombre.\n\n\n\n\n\ne = Estudiante(\"Macarena Gianetti\")\ne.resumen()\n\n'Estudiante(nombre=Macarena Gianetti)'\n\n\nSi asignamos un nuevo valor a la variable nombre de la instancia, no ocurre ning√∫n efecto indeseado. El objeto crea y almacena esa nueva variable, pero el m√©todo getter no la utiliza, ya que sigue accediendo al atributo _nombre.\n\ne.nombre = \"Algo nuevo\"\ne.resumen()\n\n'Estudiante(nombre=Macarena Gianetti)'\n\n\nSin embargo, Python no evita que reemplacemos el valor de la variable _nombre, nuevamente rompiendo el encapsulamiento del objeto:\n\ne._nombre = \"¬°Ahora s√≠!\"\ne.resumen()\n\n'Estudiante(nombre=¬°Ahora s√≠!)'\n\n\n\n\nAtributos privados\nSi bien los objetos en Python no cuentan con atributos verdaderamente privados, es posible emular ese comportamiento. Para ello, se emplean nombres de variables que comienzan con dos guiones bajos (__). En nuestro ejemplo, podemos usar __nombre.\n\nclass Estudiante:\n    def __init__(self, nombre):\n        self.setNombre(nombre)\n\n    def setNombre(self, nombre):\n        if isinstance(nombre, str):\n            self.__nombre = nombre\n        else:\n            print(\"El nombre debe ser de tipo 'str'\")\n\n    def getNombre(self):\n        return self.__nombre\n\n    def resumen(self):\n        return f\"Estudiante(nombre={self.getNombre()})\"\n\ne = Estudiante(\"Macarena Gianetti\")\ne.resumen()\n\n'Estudiante(nombre=Macarena Gianetti)'\n\n\nSi queremos acceder a la variable, obtendremos un error:\ne.__nombre\n\nAttributeError: 'Estudiante' object has no attribute '__nombre'\n\nPor el contrario, si intentamos asignar un valor a esa variable, Python no mostrar√° ning√∫n error y el m√©todo getter continuar√° devolviendo el valor esperado:\n\ne.__nombre = \"¬øY ahora?\"\ne.getNombre()\n\n'Macarena Gianetti'\n\n\n\ne._Estudiante__nombre\n\n'Macarena Gianetti'\n\n\n\n\n\n\n\n\nName mangling\n\n\n\nNunca debemos olvidar que Python no soporta atributos privados. Por lo tanto, en alg√∫n lado tiene que estar disponible el valor de la variable __nombre que se usa dentro de la clase.\nEn particular, cuando el nombre de una variable comienza con dos guiones bajos, Python utiliza una t√©cnica llamada name mangling o ‚Äúestropeo de nombre‚Äù. Para ello, en realidad opera internamente con otra variable, cuyo nombre es el resultado de concatenar un gui√≥n bajo, el nombre de la clase y el nombre del atributo ‚Äúprivado‚Äù. Por ejemplo:\n&gt;&gt;&gt; e._Estudiante__nombre\n'Macarena Gianetti'\n\n\n\n\nAtributos (aparentes) con @property\nPython ofrece un decorador built-in llamado property que permite definir un m√©todo que se comporta como si fuera un atributo, de modo que al accederlo desde fuera parece una variable de instancia, aunque en realidad est√° ejecutando c√≥digo dentro de la clase.\nCon este decorador se pueden definir dos m√©todos: un getter y un setter.\n\nEl getter se declara con @property, y su nombre determina el nombre de la propiedad que se utilizar√° desde el c√≥digo externo.\nEl setter se declara con @&lt;nombre&gt;.setter y permite asignar valores a esa misma propiedad.\n\nVeamos un ejemplo:\n\nclass Estudiante:\n    def __init__(self, nombre):\n3        self.nombre = nombre\n\n1    @property\n    def nombre(self):\n        return self._nombre\n\n2    @nombre.setter\n    def nombre(self, valor):\n        if isinstance(valor, str):\n            self._nombre = valor\n        else:\n            print(\"El nombre debe ser de tipo 'str'\")\n\n    def resumen(self):\n4        return f\"Estudiante(nombre={self.nombre})\"\n\n\n1\n\nCon @property se indica que los objetos de la clase tendr√°n un ‚Äúatributo‚Äù llamado nombre. Al acceder a √©l, Python ejecuta el m√©todo decorado y devuelve el valor de la variable protegida _nombre.\n\n2\n\nCon @nombre.setter se declara el m√©todo setter, que recibe self y el nuevo valor a asignar (valor). As√≠, cada vez que se asigna un nuevo valor al atributo, Python ejecuta este m√©todo y verifica el tipo de dato.\n\n3\n\nIncluso dentro de la clase puede usarse nombre como si fuera un atributo com√∫n, sin necesidad de llamar manualmente al m√©todo decorado.\n\n4\n\n√çdem al punto anterior.\n\n\n\n\n\ne = Estudiante(\"Fernanda Cattalini\")\ne.resumen()\n\n'Estudiante(nombre=Fernanda Cattalini)'\n\n\nEs posible acceder al ‚Äúatributo‚Äù nombre:\n\ne.nombre\n\n'Fernanda Cattalini'\n\n\nTambi√©n modificarlo:\n\ne.nombre = \"Mar√≠a Fernanda Cattalini\"\ne.resumen()\n\n'Estudiante(nombre=Mar√≠a Fernanda Cattalini)'\n\n\nY si se intenta asignarle un valor del tipo incorrecto, no se realiza la operaci√≥n:\n\ne.nombre = True\n\nEl nombre debe ser de tipo 'str'\n\n\n\ne.resumen()\n\n'Estudiante(nombre=Mar√≠a Fernanda Cattalini)'\n\n\n\n\nResumen\nPython no ofrece un control absoluto sobre el estado interno de los objetos, pero s√≠ dispone de mecanismos que permiten gestionarlo mejor, como las convenciones de nombres, los getters y setters, o el uso de @property. Estas herramientas ayudan a ocultar detalles internos, validar datos y mantener la coherencia del objeto.\nSin embargo, por la naturaleza din√°mica del lenguaje, siempre existe la posibilidad de modificar clases y objetos desde el exterior, por lo que el encapsulamiento funciona m√°s como una convenci√≥n para un uso correcto que como una barrera estricta.",
    "crumbs": [
      "Teor√≠a",
      "U3 - Programaci√≥n Orientada a Objetos",
      "2 - Encapsulamiento"
    ]
  },
  {
    "objectID": "teoria/03_oop/02_encapsulamiento.html#atributos-y-m√©todos-de-clase",
    "href": "teoria/03_oop/02_encapsulamiento.html#atributos-y-m√©todos-de-clase",
    "title": "2 - Encapsulamiento",
    "section": "Atributos y m√©todos de clase",
    "text": "Atributos y m√©todos de clase\nEn Python, no solo los objetos pueden encapsular estado: las clases tambi√©n.\nUn atributo de clase est√° asociado a la clase en s√≠ y es compartido por todas sus instancias, en lugar de pertenecer a un objeto espec√≠fico.\nUn m√©todo de clase, en cambio, recibe la propia clase como primer argumento (cls) en lugar de la instancia (self), lo que permite operar sobre la clase en su conjunto.\n\nAtributos\nEs posible asignar un atributo de clase en el c√≥digo que implementa a la clase misma. Simplemente hay que asignar una variable en el bloque de definci√≥n de la clase.\nEn el ejemplo a continuaci√≥n, creamos una clase Gato que representa animales de la especie Felis catus. Como todos los gatos son de la misma especie, tiene sentido utilizar un atributo de clase en vez de un atributo de instancia.\n\nclass Gato:\n1    especie = \"Felis catus\"\n\n    def __init__(self, nombre, raza=None):\n        self.nombre = nombre\n        self.raza = raza\n\n    def resumen(self):\n        return f\"Gato(nombre={self.nombre}, raza={self.raza})\"\n\n\n1\n\nCreaci√≥n del atributo de clase especie.\n\n\n\n\nLuego de instanciar dos objetos, podemos ver que ambos tienen asociados el mismo valor de especie.\n\ng1 = Gato(\"Chispitas\")\ng2 = Gato(\"Bigotes\", \"Siam√©s\")\n\n\nprint(g1.especie)\nprint(g2.especie)\nprint(g1.especie == g2.especie)\n\nFelis catus\nFelis catus\nTrue\n\n\nPodr√≠amos utilizar un atributo de clase an√°logo para otra especie de animales: Canis lupus familiaris, popularmente conocidos como perro.\n\nclass Perro:\n    especie = \"Canis lupus familiaris\"\n\n    def __init__(self, nombre, raza=None):\n        self.nombre = nombre\n        self.raza = raza\n\n    def resumen(self):\n        return f\"Perro(nombre={self.nombre}, raza={self.raza})\"\n\n\nperro = Perro(\"Bruno\")\nprint(perro.resumen())\nprint(perro.especie)\n\nPerro(nombre=Bruno, raza=None)\nCanis lupus familiaris\n\n\nOtro escenario donde tiene sentido pr√°ctico utilizar un atributo de clase es cuando se necesita mantener un estado global.\nLa clase Usuario define usuarios de una cierta aplicaci√≥n. En ella, se tiene la variable total_usuarios que es un contador de los usuarios que se han creado a partir de la clase.\n\nclass Usuario:\n1    total_usuarios = 0\n\n    def __init__(self, nombre):\n        self.nombre = nombre\n2        Usuario.total_usuarios += 1\n\n\n1\n\nInicialmente, el atributo de clase total_usuarios tiene el valor 0.\n\n2\n\nCada vez que se crea un nuevo usuario, se incrementa el valor del atributo de la clase total_usuarios en 1.\n\n\n\n\n\nu1 = Usuario(\"Ana\")\nu2 = Usuario(\"Luis\")\n\nprint(Usuario.total_usuarios)\n\n2\n\n\nDado que las instancias tambi√©n pueden acceder a los atributos de clase, se tiene:\n\nprint(u1.total_usuarios)\nprint(u2.total_usuarios)\n\n2\n2\n\n\n\n\nM√©todos\nPara definir un m√©todo de clase se usa el decorador @classmethod, incluido en Python. Al aplicarlo, el m√©todo recibe como primer argumento a la clase en lugar de a una instancia, por lo que la convenci√≥n es nombrar ese par√°metro como cls en vez de self.\n\nclass Estudiante:\n    def __init__(self, nombre, ingreso):\n        self.nombre = nombre\n        self.ingreso = ingreso\n\n1    @classmethod\n2    def desde_texto(cls, texto):\n        nombre, ingreso = texto.split(\",\")\n3        return cls(nombre, int(ingreso))\n\n    def resumen(self):\n        return f\"Estudiante(nombre={self.nombre}, ingreso={self.ingreso})\"\n\n\n1\n\nLa decoraci√≥n @classmethod indica que el m√©todo desde_texto se invoca desde la clase y reciba a la clase como primer argumento.\n\n2\n\nPor convenci√≥n, ese primer argumento se llama cls.\n\n3\n\nA partir de cls, se crea y devuelve una nueva instancia de la clase (en este caso, Estudiante) utilizando los valores requeridos por su m√©todo __init__.\n\n\n\n\nAunque exista exista un m√©todo de clase para crear objetos, se puede seguir creando objetos de la manera usual:\n\ne1 = Estudiante(\"El Nombre\", 2023)\ne1.resumen()\n\n'Estudiante(nombre=El Nombre, ingreso=2023)'\n\n\nLa diferencia es que ahora podemos usar el m√©todo desde_texto para crear un objeto Estudiante a partir de una cadena de texto con un formato espec√≠fico.\n\ne2 = Estudiante.desde_texto(\"El Estudiante, 2024\")\ne2.resumen()\n\n'Estudiante(nombre=El Estudiante, ingreso=2024)'\n\n\nLos atributos del objeto muestran los valores que esperamos en este caso.\n\ne2.nombre, e2.ingreso\n\n('El Estudiante', 2024)\n\n\nOtro escenario en el que resulta √∫til usar m√©todos de clase es cuando queremos crear objetos ‚Äúpreconfigurados‚Äù.\nPor ejemplo, si tenemos una clase que representa s√°ndwiches con una cantidad arbitraria de ingredientes, podemos definir m√©todos de clase que construyan instancias con combinaciones de ingredientes preestablecidas:\n\nclass Sandwich:\n    def __init__(self, *ingredientes):\n        self.ingredientes = ingredientes\n\n    @classmethod\n    def jyq(cls):\n        return cls(\"jam√≥n\", \"queso\")\n\n    @classmethod\n    def mediterraneo(cls):\n        return cls(\"tomate\", \"mozzarella\", \"r√∫cula\", \"aceitunas\")\n\n    def resumen(self):\n        return f\"Sandwich de: {', '.join(self.ingredientes)}\"\n\n\ns1 = Sandwich(\"tomate\", \"lechuga\", \"queso\")\ns1.resumen()\n\n'Sandwich de: tomate, lechuga, queso'\n\n\n\nSandwich.jyq().resumen()\n\n'Sandwich de: jam√≥n, queso'\n\n\n\nSandwich.mediterraneo().resumen()\n\n'Sandwich de: tomate, mozzarella, r√∫cula, aceitunas'\n\n\n\n\n\n\n\n\nAtributos y m√©todos a posteriori\n\n\n\nPython es tan flexible como lenguaje que incluso podemos asignar atributos y m√©todos luego de su definici√≥n.\nclass Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\ndef f(self):\n    return self.base * self.altura\n\nRectangulo.area = f\nRectangulo.atributo = \"Algo\"\n\nr = Rectangulo(3, 2)\nr.area()\n# 6",
    "crumbs": [
      "Teor√≠a",
      "U3 - Programaci√≥n Orientada a Objetos",
      "2 - Encapsulamiento"
    ]
  },
  {
    "objectID": "teoria/03_oop/03_herencia.html",
    "href": "teoria/03_oop/03_herencia.html",
    "title": "3 - Herencia",
    "section": "",
    "text": "En el Prefacio del apunte anterior mencionamos lo siguiente sobre el principio de herencia:\n\n\nHerencia: permite crear nuevas clases a partir de otras ya existentes, reutilizando su comportamiento y ampli√°ndolo o modific√°ndolo seg√∫n sea necesario.\n\n\nSupongamos que necesitamos representar rect√°ngulos en Python. Anteriormente, optamos por por representarlos con una tupla de longitud dos, donde el primer elemento representaba la base y el segundo la altura. Ahora, que ya dimos nuestros primeros pasos con la programaci√≥n orientada a objetos, podemos crear una clase que no solo nos permite almacenar estado (los atributos de cada rect√°ngulo), sino que nos posibilta implementar m√©todos que nos permiten obtener otras cantidades de inter√©s.\n\nclass Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    @property\n    def area(self):\n        return self.base * self.altura\n\n    @property\n    def perimetro(self):\n        return self.base * 2 + self.altura * 2\n\n    def resumen(self):\n        return f\"Rectangulo(base={self.base}, altura={self.altura})\"\n\n\nr1 = Rectangulo(4, 7)\nprint(r1.resumen())\nprint(\"√Årea:\", r1.area)\nprint(\"Per√≠metro:\", r1.perimetro)\n\nRectangulo(base=4, altura=7)\n√Årea: 28\nPer√≠metro: 22\n\n\nSi queremos representar cuadrados, podemos crear otra clase:\n\nclass Cuadrado:\n    def __init__(self, lado):\n        self.lado = lado\n\n    @property\n    def area(self):\n        return self.lado * self.lado\n\n    @property\n    def perimetro(self):\n        return self.lado * 4\n\n    def resumen(self):\n        return f\"Cuadrado(lado={self.lado})\"\n\nc1 = Cuadrado(3)\nprint(c1.resumen())\nprint(\"√Årea:\", c1.area)\nprint(\"Per√≠metro:\", c1.perimetro)\n\nCuadrado(lado=3)\n√Årea: 9\nPer√≠metro: 12\n\n\nEn Python podemos usar la funci√≥n isinstance para verificar si un objeto es instancia de una clase determinada. Por ejemplo, en el siguiente c√≥digo comprobamos que r1 es una instancia de Rectangulo y que c1 es una instancia de Cuadrado:\n\nprint(isinstance(r1, Rectangulo))\nprint(isinstance(c1, Cuadrado))\n\nTrue\nTrue\n\n\nSabemos que, desde el punto de vista geom√©trico, un cuadrado es un caso particular de rect√°ngulo: tiene base y altura iguales. En otras palabras, todo cuadrado es tambi√©n un rect√°ngulo, aunque no todo rect√°ngulo sea un cuadrado.\nSin embargo, si intentamos verificar esta relaci√≥n en nuestro programa, obtenemos que esto no es asi.\n\nisinstance(c1, Rectangulo)\n\nFalse\n\n\nEsto no significa que los cuadrados no sean rect√°ngulos, sino que nuestro c√≥digo a√∫n no conoce esa relaci√≥n entre las clases.",
    "crumbs": [
      "Teor√≠a",
      "U3 - Programaci√≥n Orientada a Objetos",
      "3 - Herencia"
    ]
  },
  {
    "objectID": "teoria/03_oop/03_herencia.html#introducci√≥n",
    "href": "teoria/03_oop/03_herencia.html#introducci√≥n",
    "title": "3 - Herencia",
    "section": "",
    "text": "En el Prefacio del apunte anterior mencionamos lo siguiente sobre el principio de herencia:\n\n\nHerencia: permite crear nuevas clases a partir de otras ya existentes, reutilizando su comportamiento y ampli√°ndolo o modific√°ndolo seg√∫n sea necesario.\n\n\nSupongamos que necesitamos representar rect√°ngulos en Python. Anteriormente, optamos por por representarlos con una tupla de longitud dos, donde el primer elemento representaba la base y el segundo la altura. Ahora, que ya dimos nuestros primeros pasos con la programaci√≥n orientada a objetos, podemos crear una clase que no solo nos permite almacenar estado (los atributos de cada rect√°ngulo), sino que nos posibilta implementar m√©todos que nos permiten obtener otras cantidades de inter√©s.\n\nclass Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    @property\n    def area(self):\n        return self.base * self.altura\n\n    @property\n    def perimetro(self):\n        return self.base * 2 + self.altura * 2\n\n    def resumen(self):\n        return f\"Rectangulo(base={self.base}, altura={self.altura})\"\n\n\nr1 = Rectangulo(4, 7)\nprint(r1.resumen())\nprint(\"√Årea:\", r1.area)\nprint(\"Per√≠metro:\", r1.perimetro)\n\nRectangulo(base=4, altura=7)\n√Årea: 28\nPer√≠metro: 22\n\n\nSi queremos representar cuadrados, podemos crear otra clase:\n\nclass Cuadrado:\n    def __init__(self, lado):\n        self.lado = lado\n\n    @property\n    def area(self):\n        return self.lado * self.lado\n\n    @property\n    def perimetro(self):\n        return self.lado * 4\n\n    def resumen(self):\n        return f\"Cuadrado(lado={self.lado})\"\n\nc1 = Cuadrado(3)\nprint(c1.resumen())\nprint(\"√Årea:\", c1.area)\nprint(\"Per√≠metro:\", c1.perimetro)\n\nCuadrado(lado=3)\n√Årea: 9\nPer√≠metro: 12\n\n\nEn Python podemos usar la funci√≥n isinstance para verificar si un objeto es instancia de una clase determinada. Por ejemplo, en el siguiente c√≥digo comprobamos que r1 es una instancia de Rectangulo y que c1 es una instancia de Cuadrado:\n\nprint(isinstance(r1, Rectangulo))\nprint(isinstance(c1, Cuadrado))\n\nTrue\nTrue\n\n\nSabemos que, desde el punto de vista geom√©trico, un cuadrado es un caso particular de rect√°ngulo: tiene base y altura iguales. En otras palabras, todo cuadrado es tambi√©n un rect√°ngulo, aunque no todo rect√°ngulo sea un cuadrado.\nSin embargo, si intentamos verificar esta relaci√≥n en nuestro programa, obtenemos que esto no es asi.\n\nisinstance(c1, Rectangulo)\n\nFalse\n\n\nEsto no significa que los cuadrados no sean rect√°ngulos, sino que nuestro c√≥digo a√∫n no conoce esa relaci√≥n entre las clases.",
    "crumbs": [
      "Teor√≠a",
      "U3 - Programaci√≥n Orientada a Objetos",
      "3 - Herencia"
    ]
  },
  {
    "objectID": "teoria/03_oop/03_herencia.html#herencia-simple",
    "href": "teoria/03_oop/03_herencia.html#herencia-simple",
    "title": "3 - Herencia",
    "section": "Herencia simple",
    "text": "Herencia simple\nLa herencia simple, como su nombre indica, es la forma m√°s b√°sica de herencia en programaci√≥n orientada a objetos. Ocurre cuando una clase (que llamaremos hija, del ingl√©s child) hereda de una √∫nica clase (que llamaremos padre, del ingl√©s parent). Al hacerlo, la clase hija obtiene autom√°ticamente los atributos y m√©todos de la clase padre, y puede utilizarlos directamente, modificarlos o agregar otros nuevos. Esto permite reutilizar y ampliar el comportamiento existente sin tener que volver a implementarlo desde cero.\n\nUn primer intento\nLa sintaxis para definir una clase que hereda de otra es la siguiente:\n1class ClasePadre:\n    ...\n\n\n2class ClaseHija(ClasePadre):\n    ...\n\n1\n\nPrimero se define la clase padre de forma habitual, con sus atributos y m√©todos.\n\n2\n\nLuego, al crear la clase hija, se coloca el nombre de la clase padre entre par√©ntesis despu√©s del nombre de la nueva clase, de forma similar a c√≥mo se llama a una funci√≥n.\n\n\nEn el caso de nuestras clases Rectangulo y Cuadrado tendr√≠amos:\n\nclass Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    @property\n    def area(self):\n        return self.base * self.altura\n\n    @property\n    def perimetro(self):\n        return self.base * 2 + self.altura * 2\n\n    def resumen(self):\n        return f\"Rectangulo(base={self.base}, altura={self.altura})\"\n\n\nclass Cuadrado(Rectangulo):\n    def __init__(self, lado):\n        self.lado = lado\n\n    @property\n    def area(self):\n        return self.lado * self.lado\n\n    @property\n    def perimetro(self):\n        return self.lado * 4\n\n    def resumen(self):\n        return f\"Cuadrado(lado={self.lado})\"\n\nAhora, podemos comprobar que los cuadrados s√≠ se reconocen como rect√°ngulos:\n\nr1 = Rectangulo(2, 5)\nc1 = Cuadrado(3)\n\nprint(isinstance(r1, Rectangulo))\nprint(isinstance(c1, Cuadrado))\nprint(isinstance(c1, Rectangulo))\n\nTrue\nTrue\nTrue\n\n\n\n\nSobreescritura de m√©todos\nLa herencia no solo sirve para que nuestro programa entienda las relaciones entre clases, sino tambi√©n para reutilizar c√≥digo sin duplicarlo. Gracias a ella, una clase hija puede aprovechar los atributos y m√©todos definidos en la clase padre y, al mismo tiempo, modificar solo aquello que necesita cambiar. Este proceso, llamado sobreescritura de m√©todos, permite adaptar o ampliar el comportamiento heredado sin necesidad de volver a implementarlo desde cero.\nEn nuestro ejemplo, podemos reutilizar los m√©todos area y perimetro definidos en la clase Rectangulo. Para lograrlo, basta con sobreescribir el m√©todo __init__ en la clase Cuadrado, de modo que asigne el valor de lado a los atributos base y altura.\n\n1class Cuadrado(Rectangulo):\n2    def __init__(self, lado):\n3        self.lado = lado\n        self.base = lado\n        self.altura = lado\n\n\n1\n\nSe crea la clase Cuadrado, que hereda de Rectangulo.\n\n2\n\nSe sobreescribe el m√©todo __init__, que ahora recibe un √∫nico par√°metro: lado.\n\n3\n\nComo los m√©todos heredados utilizan los atributos base y altura, debemos asignarles el valor de lado para que el comportamiento siga siendo correcto.\n\n\n\n\nVemos que es posible acceder a las propiedades area y perimetro (en realidad, m√©todos decorados) de los objetos de la clase Cuadrado gracias a que los heredan de la clase Rectangulo.\n\nc1 = Cuadrado(3)\nprint(\"√Årea:\", c1.area)\nprint(\"Per√≠metro:\", c1.perimetro)\n\n√Årea: 9\nPer√≠metro: 12\n\n\nPor otro lado, el m√©todo resumen indica que se trata de un rect√°ngulo.\n\nc1.resumen()\n\n'Rectangulo(base=3, altura=3)'\n\n\nSi bien la informaci√≥n que se muestra no es incorrecta, ser√≠a a√∫n m√°s claro que se devuelva una cadena que indica que el objeto no es un rect√°ngulo cualquiera, sino que es de un tipo particular: un cuadrado. Para lograrlo, tenemos que reescribir el m√©todo resumen:\n\nclass Cuadrado(Rectangulo):\n    def __init__(self, lado):\n        self.lado = lado\n        self.base = lado\n        self.altura = lado\n\n1    def resumen(self):\n        return f\"Cuadrado(lado={self.lado})\"\n\n\n1\n\nSe reescribe el m√©todo resumen para que devuelva una cadena distinta.\n\n\n\n\n\nCuadrado(3).resumen()\n\n'Cuadrado(lado=3)'\n\n\nEn resumen, nuestro c√≥digo queda organizado de la siguiente manera:\n\nClase Rectangulo\n\nSe inicializa con dos argumentos: base y altura.\nDefine tres m√©todos principales:\n\narea(): calcula el √°rea.\nperimetro(): calcula el per√≠metro.\nresumen(): devuelve una descripci√≥n en texto.\n\n\nClase Cuadrado\n\nHereda de Rectangulo, por lo que tiene acceso a todos sus m√©todos.\nSobreescribe dos de ellos:\n\n__init__(): para inicializar el objeto a partir de un √∫nico valor lado.\nresumen(): para personalizar la descripci√≥n.\n\nUsa directamente los m√©todos heredados area() y perimetro() sin necesidad de redefinirlos.\n\n\n\n\n\n\n\n\n¬øSab√≠as que‚Ä¶? ü§ì\n\n\n\nTodas las clases en Python heredan de una gran clase base llamada object. Por eso, cualquier instancia, sin importar su tipo, es considerada un objeto:\nisinstance(1, object)                  # True\nisinstance(\"algo\", object)             # True\nisinstance([1, 10, 100], object)       # True\nisinstance(Rectangulo(2, 5), object)   # True\nEn Python 2, si quer√≠amos aprovechar todas las caracter√≠sticas modernas de la programaci√≥n orientada a objetos, era necesario declarar expl√≠citamente que nuestra clase heredaba de object. Por eso, era com√∫n encontrar definiciones as√≠:\nclass MiClase(object):\n    ...\nEn Python 3, esto ya no es necesario: todas las clases heredan de object de forma impl√≠cita.\n\n\n\n\nFormas generales\nUn programa que trabaja con cuadrados y rect√°ngulos probablemente tamb√≠en incluya otros tipos de figuras geom√©tricas, como los c√≠rculos. La clase Circulo define c√≠rculos en base a su radio y, al igual que Cuadrado y Rectangulo, permite acceder obter su √°rea y per√≠metro como si fuera un atributo gracias al decorador @property.\n\nimport math\n\nclass Circulo:\n    def __init__(self, radio):\n        self.radio = radio\n\n    @property\n    def area(self):\n1        return self.radio ** 2 * math.pi\n\n    @property\n    def perimetro(self):\n2        return 2 * self.radio * math.pi\n\n    def resumen(self):\n        return f\"Circulo(radio={self.radio})\"\n\n\n1\n\nEl √°rea de un c√≠rculo es \\(r ^ 2 \\pi\\)\n\n2\n\nEl per√≠metro de un c√≠rculo es \\(2 r \\pi\\)\n\n\n\n\n\nc1 = Circulo(3)\nprint(c1.resumen())\nprint(\"√Årea:\", c1.area)\nprint(\"Per√≠metro:\", c1.perimetro)\n\nCirculo(radio=3)\n√Årea: 28.274333882308138\nPer√≠metro: 18.84955592153876\n\n\nEn este caso, no es posible establecer una jerarqu√≠a que relacione directamente a la Circulo con Cuadrado y Rectangulo; no es ni un caso particular de las otras ni nos permitir√≠a reutilizar ninguno de los m√©todos implementados.\nSin embargo, s√≠ es posible considerar a todas estas clases como casos particulares de una clase base mayor: las figuras geom√©tricas.\n\n\nInterfaz informal\nVamos a crear una clase llamada Forma, que servir√° como clase base para todas las figuras geom√©tricas que implementemos. En ella, estableceremos que cualquier clase hija deber√° contar con las propiedades area y perimetro, adem√°s de un m√©todo resumen.\nComo Forma representa un concepto general, no podemos dar una implementaci√≥n concreta de estos m√©todos (ya que el c√°lculo del √°rea o el per√≠metro depende de la figura espec√≠fica). Por eso, en esta primera versi√≥n simplemente hacemos que los m√©todos devuelvan None, indicando que deber√°n ser implementados por las clases hijas.\n\nclass Forma:\n    @property\n    def area(self):\n        return None\n\n    @property\n    def perimetro(self):\n        return None\n\n    def resumen(self):\n        return \"Forma()\"\n\nf1 = Forma()\nprint(f1.resumen())\nprint(\"√Årea:\", f1.area)\nprint(\"Per√≠metro:\", f1.perimetro)\n\nForma()\n√Årea: None\nPer√≠metro: None\n\n\nAhora, volvemos a implementar las clases Rectangulo y Cuadrado. Comenzamos con Rectangulo, haciendo que esta herede de Forma:\n\nclass Rectangulo(Forma):\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    @property\n    def area(self):\n        return self.base * self.altura\n\n    @property\n    def perimetro(self):\n        return self.base * 2 + self.altura * 2\n\n    def resumen(self):\n        return f\"Rectangulo(base={self.base}, altura={self.altura})\"\n\nY vemos que todos sus m√©todos funcionan correctamente:\n\nr1 = Rectangulo(5, 2)\nprint(r1.resumen())\nprint(\"√Årea:\", r1.area)\nprint(\"Per√≠metro:\", r1.perimetro)\n\nRectangulo(base=5, altura=2)\n√Årea: 10\nPer√≠metro: 14\n\n\nHacemos lo propio con la clase Cuadrado. En este caso, no es necesario declarar expl√≠citamente que hereda de Forma, porque la relaci√≥n ya est√° establecida de manera indirecta: Cuadrado hereda de Rectangulo, y Rectangulo hereda de Forma. En otras palabras, como los rect√°ngulos son formas geom√©tricas y los cuadrados son rect√°ngulos, se tiene que los cuadrados tambi√©n son formas geom√©tricas.\n\nclass Cuadrado(Rectangulo):\n    def __init__(self, lado):\n        self.lado = lado\n        self.base = lado\n        self.altura = lado\n\n    def resumen(self):\n        return f\"Cuadrado(lado={self.lado})\"\n\nc1 = Cuadrado(2)\nprint(c1.resumen())\nprint(\"√Årea:\", c1.area)\nprint(\"Per√≠metro:\", c1.perimetro)\n\nCuadrado(lado=2)\n√Årea: 4\nPer√≠metro: 8\n\n\nPor otro lado, volvemos a implementar la clase Circulo, esta vez heredando de Forma:\n\nclass Circulo(Forma):\n    def __init__(self, radio):\n        self.radio = radio\n\n    @property\n    def area(self):\n        return self.radio ** 2 * math.pi\n\n    @property\n    def perimetro(self):\n        return 2 * self.radio * math.pi\n\n    def resumen(self):\n        return f\"Circulo(radio={self.radio})\"\n\nci1 = Circulo(3)\nprint(ci1.resumen())\nprint(\"√Årea:\", ci1.area)\nprint(\"Per√≠metro:\", ci1.perimetro)\n\nCirculo(radio=3)\n√Årea: 28.274333882308138\nPer√≠metro: 18.84955592153876\n\n\nY, finalmente, podemos ver que todas las relaciones entre los tipos creados se reflejan correctamente:\n\n# r1 es Rectangulo y Forma\nprint(isinstance(r1, Rectangulo))\nprint(isinstance(r1, Forma))\n\nTrue\nTrue\n\n\n\n# c1 es Cuadrado, Rectangulo y Forma\nprint(isinstance(c1, Cuadrado))\nprint(isinstance(c1, Rectangulo))\nprint(isinstance(c1, Forma))\n\nTrue\nTrue\nTrue\n\n\n\n# ci1 es Circulo y Forma\nprint(isinstance(ci1, Circulo))\nprint(isinstance(ci1, Forma))\n\nTrue\nTrue\n\n\n\n\nInterfaz formal\nEn programaci√≥n orientada a objetos existe un tipo especial de clase pensado para casos como el de Forma: clases que no se usan para crear objetos directamente, pero que s√≠ definen una interfaz com√∫n para sus clases hijas e imponen la implementaci√≥n de ciertos m√©todos y propiedades. A este tipo de clases se las conoce como clases abstractas.\nEn Python, podemos crear una clase abstracta haciendo que herede de la clase ABC del m√≥dulo est√°ndar abc (cuyas siglas significan abstract base class). Este m√≥dulo tambi√©n ofrece el decorador @abstractmethod, que permite definir m√©todos abstractos y obliga a las clases hijas a implementarlos. Adem√°s, si combinamos @abstractmethod con @property, podemos crear propiedades abstractas que deber√°n ser definidas en las subclases.\nImplementemos ahora la clase abstracta Forma.\n\nfrom abc import ABC, abstractmethod\n\n1class Forma(ABC):\n2    @property\n    @abstractmethod\n    def area(self):\n        pass\n\n3    @property\n    @abstractmethod\n    def perimetro(self):\n        pass\n\n4    @abstractmethod\n    def resumen(self):\n        pass\n\n\n1\n\nSe comienza a implementar la clase Forma, que hereda de la clase ABC.\n\n2\n\nSe implementa la propiedad abstracta area. La decoraci√≥n con @property y @abstractmethod obligan a las clases hijas a implementar un m√©todo area decorado con @property. Se usa pass porque no se provee una implementaci√≥n concreta.\n\n3\n\nSe implementa la propiedad abstracta perimetro de manera similar a area.\n\n4\n\nSe implementa el m√©todo abstracto resumen, que las clases hijas deben implementar como un m√©todo regular.\n\n\n\n\nSi intentamos crear un objeto Forma obtendremos un error porque esta clase no est√° pensada para crear objetos, sino para servir como modelo o interfaz com√∫n de otras clases.\nForma()\n\nTypeError: Can't instantiate abstract class Forma without an implementation for abstract methods 'area', 'perimetro', 'resumen'\n\nTampoco podemos crear una clase que herede de forma e implemente solamente alguno de los m√©todos abstractos. Por ejemplo, si la clase Rectangulo no implementa el m√©todo resumen, tambi√©n se obtiene un error.\nclass Rectangulo(Forma):\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    @property\n    def area(self):\n        return self.base * self.altura\n\n    @property\n    def perimetro(self):\n        return self.base * 2 + self.altura * 2\n\nRectangulo(2, 1)\n\nTypeError: Can't instantiate abstract class Rectangulo without an implementation for abstract method 'resumen'\n\nPara que la implementaci√≥n de una clase derivada de una clase abstracta no arroje ning√∫n error, es necesario implementar todos los m√©todos y propiedades abstractas de la clase base, como se hace a continuaci√≥n:\n\nclass Rectangulo(Forma):\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    @property\n    def area(self):\n        return self.base * self.altura\n\n    @property\n    def perimetro(self):\n        return self.base * 2 + self.altura * 2\n\n    def resumen(self):\n        return f\"Rectangulo(base={self.base}, altura={self.altura})\"\n\nr = Rectangulo(2, 1)\nr.resumen()\n\n'Rectangulo(base=2, altura=1)'\n\n\nDe manera an√°loga, se pueden reimplementar las clases Cuadrado y Rectangulo.\n\nclass Cuadrado(Rectangulo):\n    def __init__(self, lado):\n        self.lado = lado\n        self.base = lado\n        self.altura = lado\n\n    def resumen(self):\n        return f\"Cuadrado(lado={self.lado})\"\n\n\nclass Circulo(Forma):\n    def __init__(self, radio):\n        self.radio = radio\n\n    @property\n    def area(self):\n        return self.radio ** 2 * math.pi\n\n    @property\n    def perimetro(self):\n        return self.radio ** 2 * math.pi\n\n    def resumen(self):\n        return f\"Circulo(radio={self.radio})\"\n\nc = Cuadrado(2)\nprint(c.resumen())\nci = Circulo(1.5)\nprint(ci.resumen())\n\nCuadrado(lado=2)\nCirculo(radio=1.5)\n\n\n\nprint(isinstance(r, Forma))\nprint(isinstance(c, Forma))\nprint(isinstance(ci, Forma))\n\nTrue\nTrue\nTrue\n\n\nAl utilizar una clase abstracta como Forma, no solo definimos una clase base que engloba a todos los tipos de figuras geom√©tricas que podamos implementar, sino que tambi√©n garantizamos que esas clases implementen los m√©todos y propiedades abstractas necesarias (area, perimetro y resumen). El uso de la clases abstractas impone un contrato claro que hace que el c√≥digo sea m√°s predecible y f√°cil de mantener.\n\n\n\n\n\n\nAfinando el vocabulario\n\n\n\nA lo largo de este apunte mencionamos muchos t√©rminos relacionados a la programaci√≥n orientada a objetos, es hora de afinar el vocabulario:\n\nClase padre (o clase base): es la clase de la que heredan otras. Puede ser concreta o abstracta, y define atributos y m√©todos comunes que las clases hijas pueden reutilizar, extender o modificar.\nClase hija (o clase derivada): es la clase que hereda de una clase padre. Hereda sus atributos y m√©todos, y puede agregar nueva funcionalidad o redefinir la existente.\nClase abstracta: es una clase que sirve como modelo general y no est√° pensada para crear objetos directamente. Puede contener m√©todos sin implementar, que deber√°n definirse en las clases hijas.\nImplementaci√≥n concreta: es una clase o m√©todo completamente definido y funcional, que puede usarse directamente para crear objetos o ejecutar comportamiento.",
    "crumbs": [
      "Teor√≠a",
      "U3 - Programaci√≥n Orientada a Objetos",
      "3 - Herencia"
    ]
  },
  {
    "objectID": "teoria/03_oop/03_herencia.html#herencia-m√∫ltiple",
    "href": "teoria/03_oop/03_herencia.html#herencia-m√∫ltiple",
    "title": "3 - Herencia",
    "section": "Herencia m√∫ltiple",
    "text": "Herencia m√∫ltiple\nHasta ahora vimos que en programaci√≥n orientada a objetos una clase puede heredar de otra, lo que permite reutilizar atributos y m√©todos. En todos los ejemplos anteriores, esa herencia fue simple, ya que cada clase hija ten√≠a una √∫nica clase padre, sin importar su complejidad o si era concreta o abstracta.\nSin embargo, al igual que muchos otros lenguajes orientados a objetos, Python tambi√©n permite la herencia m√∫ltiple. El concepto es sencillo: una clase puede heredar de varias clases padre al mismo tiempo, combinando sus funcionalidades y accediendo a todos sus m√©todos y atributos.\nEn esta secci√≥n, utilizaremos herencia m√∫ltiple para representar diferentes distribuciones de probabilidad (discretas y continuas). Nuestro objetivo es implementar dos distribuciones: la normal (Normal) y la Poisson (Poisson). Estas clases van a contar con m√©todos para generar muestras aleatorias y graficar su distribuci√≥n.\n\nEjemplo b√°sico\nAntes de atrevernos a implementar distribuciones de probabilidad en Python usando herencia m√∫ltiple, veamos un ejemplo muy sencillo de c√≥mo funciona:\n\nclass A:\n    def saludar(self):\n        return \"Hola desde A\"\n\nclass B:\n    def despedir(self):\n        return \"Chau desde B\"\n\nclass C(A, B):\n    def saltar(self):\n        return \"Saltando desde C\"\n\n\ncosa = C()\n\n\ncosa.saludar()\n\n'Hola desde A'\n\n\n\ncosa.despedir()\n\n'Chau desde B'\n\n\n\ncosa.saltar()\n\n'Saltando desde C'\n\n\n\n\nDistribuci√≥n normal\nComencemos implementando una clase abstracta llamada Distribucion que contiene los siguientes m√©todos abstractos:\n\nmuestra: Genera un valor aleatorio de la distribuci√≥n\ngraficar: Genera un gr√°fico que permite apreciar la distribuci√≥n.\n\nAdem√°s, tambi√©n incluye un m√©todo concreto que devuelve n muestras de la distribuci√≥n\n\nclass Distribucion(ABC):\n    @abstractmethod\n    def muestra(self):\n        pass\n\n    @abstractmethod\n    def graficar(self):\n        pass\n\n    def muestras(self, n=1):\n        return [self.muestra() for _ in range(n)]\n\nPara inicializar la distribuci√≥n normal usamos su media mu y desv√≠o est√°ndar sigma. Incluimos un m√©todo pdf que devuelve la funci√≥n de densidad normal evaluada en un punto x e implementamos los m√©todos muestra y graficar que son requeridos por la clase padre Distribucion.\n\nimport random\nimport matplotlib.pyplot as plt\n\nclass Normal(Distribucion):\n    def __init__(self, mu, sigma):\n        self.mu = mu\n        self.sigma = sigma\n\n    def pdf(self, x):\n        a = 1 / (self.sigma * (2 * math.pi) ** 0.5)\n        b = math.exp( - 0.5 * ((x - self.mu) ** 2 / self.sigma ** 2))\n        return a * b\n\n    def muestra(self):\n        return random.normalvariate(mu=self.mu, sigma=self.sigma)\n\n    def graficar(self):\n        # Construir valores de 'x'\n        x_inicio = self.mu - self.sigma * 3\n        x_fin = self.mu + self.sigma * 3\n        x_paso = (x_fin - x_inicio) / 500\n        xs = [x_inicio + x_paso * i for i in range(500)]\n\n        # Construir valores de 'y'\n        ys = [self.pdf(x) for x in xs]\n\n        # Crear gr√°fico\n        plt.plot(xs, ys)\n        plt.xlabel(\"x\")\n        plt.ylabel(\"p(x)\")\n        plt.title(f\"Normal(mu={self.mu}, sigma={self.sigma})\")\n        plt.show()\n\nSi queremos trabajar con una distribuci√≥n normal de media 3 y desv√≠o 1, basta con inicializarla de la siguiente manera:\n\nnormal = Normal(mu=3, sigma=1)\n\nAhora, podemos obtener uno o m√∫ltiples n√∫meros aleatorios de dicha distribuci√≥n:\n\nnormal.muestra()\n\n2.248231320099541\n\n\n\nnormal.muestras(10)\n\n[0.6458518679909164,\n 3.9120653695218515,\n 2.1150760712804373,\n 2.9766247862532924,\n 3.9150019616191267,\n 2.4612383165622287,\n 2.0434502376268586,\n 2.3696759257123254,\n 1.8845024386324847,\n 1.9123881947344514]\n\n\nY si queremos evaluar la funci√≥n de densidad en un punto (es decir, obtener la altura de la curva normal en un punto), usamos el m√©todo pdf que implementamos anteriormente.\n\nnormal.pdf(2)\n\n0.24197072451914337\n\n\n\nnormal.pdf(2.5), normal.pdf(3), normal.pdf(3.5) # Simetr√≠a alrededor de la media.\n\n(0.3520653267642995, 0.3989422804014327, 0.3520653267642995)\n\n\nFinalmente, nuestro objeto tambi√©n nos permite visualizar la distribuci√≥n.\n\nnormal.graficar()\n\n\n\n\n\n\n\n\n\n\nDistribuci√≥n Poisson\nAhora que ya contamos la distribuci√≥n normal, podemos continuar con la distribuci√≥n de Poisson.\nPara inicializarla vamos a usar el par√°metro \\(\\lambda\\), que representa tanto la media como la varianza. Pero, como lambda es una palabra reservada en Python, usaremos su versi√≥n abreviada lam.\nAdem√°s, como se trata de una distribuci√≥n para variables discretas, no corresponde implementar un m√©todo pdf (probability density function), sino pmf (probability mass function). Esto tambi√©n influye en la visualizaci√≥n: en lugar de representar una curva continua, utilizaremos un gr√°fico de bastones para mostrar la distribuci√≥n.\n\nclass Poisson(Distribucion):\n    def __init__(self, lam):\n        self.lam = lam\n\n    def pmf(self, x):\n        return (math.exp(-self.lam) * self.lam ** x) / math.factorial(x)\n\n    def muestra(self):\n        S, N = 0, 0\n        while S &lt; 1:\n            u = random.uniform(0, 1)\n            N += 1\n            S += - math.log(u) / self.lam\n        return N - 1\n\n    def graficar(self):\n        # Construir valores de 'x'\n        xs = []\n        x, cdf = 0, 0\n        while cdf &lt; 0.999:\n            xs.append(x)\n            cdf += self.pmf(x)\n            x += 1\n\n        # Construir valores de 'y'\n        ys = [self.pmf(x) for x in xs]\n\n        plt.vlines(xs, ymin=0, ymax=ys, lw=3)\n        plt.xlabel(\"x\")\n        plt.ylabel(\"P(X = x)\")\n        plt.title(f\"Poisson(lam={self.lam})\")\n        plt.show()\n\n\npoisson = Poisson(3)\npoisson.muestra()\n\n1\n\n\n\npoisson.muestras(5)\n\n[3, 6, 7, 3, 9]\n\n\n\npoisson.pmf(3)\n\n0.22404180765538775\n\n\n\npoisson.graficar()\n\n\n\n\n\n\n\n\n\nPoisson(5).graficar()\n\n\n\n\n\n\n\n\n\nPoisson(10).graficar()\n\n\n\n\n\n\n\n\n\n\nHerencia m√∫ltiple en acci√≥n\nSi bien obtuvimos clases funcionales para trabajar con variables aleatorias normales y Poisson, a√∫n no hemos hecho uso de la herencia m√∫ltiple.\nPara hacerlo, vamos a definir tres clases independientes, con responsabilidades bien diferenciadas:\n\nDistribucion: declara m√©todos gen√©ricos comunes a cualquier distribuci√≥n de probabilidad.\nDiscreta: define el m√©todo abstracto pmf y un m√©todo concreto crear_grafico que genera un gr√°fico de bastones.\nContinua: define el m√©todo abstracto pdf y un m√©todo crear_grafico que representa la distribuci√≥n con una curva.\n\nEstas clases servir√°n como base para construir distribuciones m√°s espec√≠ficas combinando funcionalidades a trav√©s de herencia m√∫ltiple.\n\nclass Distribucion(ABC):\n    @abstractmethod\n    def muestra(self):\n        pass\n\n    @abstractmethod\n    def graficar(self):\n        pass\n\n    def muestras(self, n=1):\n        return [self.muestra() for _ in range(n)]\n\n\nclass Discreta(ABC):\n    @abstractmethod\n    def pmf(self, x):\n        pass\n\n    def crear_grafico(self, xs):\n        ys = [self.pmf(x) for x in xs]\n        plt.vlines(xs, ymin=0, ymax=ys, lw=3)\n        plt.xlabel(\"x\")\n        plt.ylabel(\"P(X = x)\")\n\n\nclass Continua(ABC):\n    @abstractmethod\n    def pdf(self, x):\n        pass\n\n    def crear_grafico(self, xs):\n        ys = [self.pdf(x) for x in xs]\n        plt.plot(xs, ys)\n        plt.xlabel(\"x\")\n        plt.ylabel(\"p(x)\")\n\nSi combinamos Distribucion y Continua, tenemos la base para implementar nuestra clase Normal.\n\nclass Normal(Distribucion, Continua):\n    def __init__(self, mu, sigma):\n        self.mu = mu\n        self.sigma = sigma\n\n    def pdf(self, x):\n        a = 1 / (self.sigma * (2 * math.pi) ** 0.5)\n        b = math.exp( - 0.5 * ((x - self.mu) ** 2 / self.sigma ** 2))\n        return a * b\n\n    def muestra(self):\n        return random.normalvariate(mu=self.mu, sigma=self.sigma)\n\n    def graficar(self):\n        x_inicio = self.mu - self.sigma * 3\n        x_fin = self.mu + self.sigma * 3\n        x_paso = (x_fin - x_inicio) / 500\n        xs = [x_inicio + x_paso * i for i in range(500)]\n        self.crear_grafico(xs)\n        plt.title(f\"Normal(mu={self.mu}, sigma={self.sigma})\")\n        plt.show()\n\nnormal = Normal(2, 1)\n\n\nnormal.muestras(5)\n\n[1.9364943585753434,\n 3.431844507514179,\n 4.1148165485370365,\n 0.7869931091513576,\n 1.99320198616381]\n\n\n\nnormal.graficar()\n\n\n\n\n\n\n\n\nCuando llamamos al m√©todo muestras, estamos haciendo uso del m√©todo concreto implementado en Distribucion, y cuando llamamos a graficar, estamos haciendo uso del m√©todo concreto implementado en Continua.\nPor otro lado, si combinamos Distribucion y Discreta tenemos la base para reimplementar nuestra clase Poisson.\n\nclass Poisson(Distribucion, Discreta):\n    def __init__(self, lam):\n        self.lam = lam\n\n    def pmf(self, x):\n        return (math.exp(-self.lam) * self.lam ** x) / math.factorial(x)\n\n    def muestra(self):\n        S, N = 0, 0\n        while S &lt; 1:\n            u = random.uniform(0, 1)\n            N += 1\n            S += - math.log(u) / self.lam\n        return N - 1\n\n    def graficar(self):\n        xs = []\n        x, cdf = 0, 0\n        while cdf &lt; 0.999:\n            xs.append(x)\n            cdf += self.pmf(x)\n            x += 1\n\n        self.crear_grafico(xs)\n        plt.title(f\"Poisson(lam={self.lam})\")\n        plt.show()\n\n\nPoisson(4).graficar()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReflexi√≥n sobre el uso de herencia m√∫ltiple\n\n\n\nEn el ejemplo de las distribuciones de probabilidad, cada clase concreta hereda de dos clases: Distribucion y Discreta o Continua, seg√∫n corresponda. Esta no es la √∫nica forma posible de estructurar el c√≥digo: podr√≠amos haber hecho que Discreta y Continua heredaran de Distribucion, y que las distribuciones concretas heredaran solo de una de ellas (obteniendo as√≠ a Distribucion de manera indirecta).\nComo el objetivo de esta secci√≥n era trabajar con herencia m√∫ltiple, decidimos mantener las clases por separado.\n\n\n\n\n\n\n\n\nMethod resolution order (MRO)\n\n\n\nEn la pr√°ctica, es sencillo usar herencia m√∫ltiple cuando cada clase padre define m√©todos y atributos con nombres distintos. El problema aparece cuando dos o m√°s clases padre implementan un m√©todo con el mismo nombre. En esos casos, Python usa un mecanismo llamado Method resolution order (MRO) para determinar cu√°l ejecutar.\nEn pocas palabras, Python busca primero en la clase actual, luego en el orden en que fueron listadas las clases padre, y finalmente en la jerarqu√≠a de herencia.\nPor ejemplo:\nclass A:\n    def saludar(self):\n        print(\"Hola desde A\")\n\nclass B:\n    def saludar(self):\n        print(\"Hola desde B\")\n\nclass C(A, B):\n    pass\n\nC().saludar()  # Hola desde A\nEn este ejemplo, C hereda de A y B, pero al llamar saludar() se ejecuta el de A porque est√° primero en el MRO. Podemos inspeccionar este orden con C.__mro__ o C.mro().\n\n\n\n\nUso de super()\nA veces queremos extender el comportamiento de un m√©todo heredado sin reescribirlo por completo.\nSupongamos que queremos crear una versi√≥n ‚Äúruidosa‚Äù de las listas, llamada ListaRuidosa, que se comporte exactamente igual que una lista normal salvo por un detalle: cada vez que agreguemos un elemento con append, imprimir√° un mensaje adicional.\nPara lograrlo, podemos sobreescribir el m√©todo append y, en lugar de copiar toda su l√≥gica, simplemente agregar el print en el lugar adecuado y luego llamar al m√©todo original de la clase padre usando super(). As√≠ modificamos solo lo necesario y mantenemos el resto del comportamiento intacto.\n\n1class ListaRuidosa(list):\n2    def append(self, elemento):\n3        print(\"Agregando:\", elemento)\n4        super().append(elemento)\n\n\n1\n\nListaRuidosa hereda de list.\n\n2\n\nSe reimplementa el m√©todo append, que recibe un argumento: el elemento a agregar al final.\n\n3\n\nCuando se llama a append se imprime un mensaje indicando el elemento que se agrega.\n\n4\n\nFinalmente, se llama al m√©todo append de la clase padre.\n\n\n\n\nObservemos a nuestra nueva clase en acci√≥n. Se ve como una lista, porque es una lista.\n\nlista_ruidosa = ListaRuidosa()\nlista_ruidosa\n\n[]\n\n\nPero no es cualquier lista, ¬°es ruidosa!\n\nlista_ruidosa.append(\"¬øfunciona?\")\n\nAgregando: ¬øfunciona?\n\n\n\nlista_ruidosa\n\n['¬øfunciona?']\n\n\n\nprint(type(lista_ruidosa)) # Es una lista ruidosa\nprint(isinstance(lista_ruidosa, list)) # ¬°Pero tambi√©n es una lista!\n\n&lt;class '__main__.ListaRuidosa'&gt;\nTrue\n\n\nY podr√≠amos continuar agregando elementos‚Ä¶\n\nlista_ruidosa.append(\"¬øy esto?\")\n\nAgregando: ¬øy esto?\n\n\n\nlista_ruidosa\n\n['¬øfunciona?', '¬øy esto?']",
    "crumbs": [
      "Teor√≠a",
      "U3 - Programaci√≥n Orientada a Objetos",
      "3 - Herencia"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/01_fundamentos.html",
    "href": "teoria/02_programacion_funcional/01_fundamentos.html",
    "title": "1 - Fundamentos",
    "section": "",
    "text": "La programaci√≥n funcional es un paradigma de programaci√≥n que se centra en el uso de funciones puras y en concebir la computaci√≥n como la evaluaci√≥n de funciones. En lugar de dar instrucciones paso a paso que cambian variables o estados (como ocurre en la programaci√≥n imperativa), la idea es construir programas a partir de funciones que transforman datos.\nExisten lenguajes dise√±ados espec√≠ficamente para la programaci√≥n funcional (como Haskell), pero Python no es uno de ellos. Python es un lenguaje multiparadigma, lo que significa que nos permite combinar diferentes estilos de programaci√≥n. Por este motivo, la programaci√≥n funcional en Python no suele ser el enfoque principal, pero puede ser muy √∫til para escribir c√≥digo m√°s claro, conciso y f√°cil de probar.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/01_fundamentos.html#introducci√≥n",
    "href": "teoria/02_programacion_funcional/01_fundamentos.html#introducci√≥n",
    "title": "1 - Fundamentos",
    "section": "",
    "text": "La programaci√≥n funcional es un paradigma de programaci√≥n que se centra en el uso de funciones puras y en concebir la computaci√≥n como la evaluaci√≥n de funciones. En lugar de dar instrucciones paso a paso que cambian variables o estados (como ocurre en la programaci√≥n imperativa), la idea es construir programas a partir de funciones que transforman datos.\nExisten lenguajes dise√±ados espec√≠ficamente para la programaci√≥n funcional (como Haskell), pero Python no es uno de ellos. Python es un lenguaje multiparadigma, lo que significa que nos permite combinar diferentes estilos de programaci√≥n. Por este motivo, la programaci√≥n funcional en Python no suele ser el enfoque principal, pero puede ser muy √∫til para escribir c√≥digo m√°s claro, conciso y f√°cil de probar.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/01_fundamentos.html#funciones-puras",
    "href": "teoria/02_programacion_funcional/01_fundamentos.html#funciones-puras",
    "title": "1 - Fundamentos",
    "section": "Funciones puras",
    "text": "Funciones puras\nUna funci√≥n es pura cuando su salida depende √∫nicamente de los valores de entrada y no produce ning√∫n efecto secundario o colateral (side effect, en ingl√©s).\nLa funci√≥n sumar, que calcula y devuelve la suma de dos n√∫meros, es un ejemplo de funci√≥n pura: su resultado depende solo de sus argumentos y no genera efectos colaterales.\n\ndef sumar(x, y):\n    return x + y\n\nsumar(3, 11)\n\n14\n\n\nEn cambio, la funci√≥n agregar no es una funci√≥n pura. Esto se debe a que modifica un objeto global, lo que se conoce como un efecto secundario. Adem√°s, el valor de su salida no depende √∫nicamente de la entrada, sino tambi√©n de un estado global: la cantidad de elementos en lista.\n\nlista = []\n\ndef agregar(x):\n    \"\"\"Agrega el elemento `x` al final de `lista` y devuelve la longitud de `lista`\"\"\"\n    lista.append(x)\n    return len(lista)\n\n\nagregar(\"azucar\")\n\n1\n\n\n\nagregar(\"flores\")\n\n2\n\n\n\nagregar(\"colores\")\n\n3\n\n\n\nlista\n\n['azucar', 'flores', 'colores']\n\n\n\nEfectos secundarios\nUn efecto secundario (side effect) es cualquier cambio de estado observable que ocurre fuera del √°mbito local de una funci√≥n. En otras palabras, se trata de una modificaci√≥n del entorno externo de la funci√≥n que va m√°s all√° de simplemente devolver un valor.\nAlgunos ejemplos de side effects son:\n\nModificar una variable global o un objeto mutable.\nImprimir en la consola.\nEscribir en un archivo.\nRealizar una llamada a una API o a una base de datos.\n\nLas funciones con efectos secundarios pueden ser problem√°ticas porque, al modificar elementos externos, hacen que el c√≥digo sea impredecible y dif√≠cil de probar.\nEn el ejemplo de la funci√≥n agregar que creamos anteriormente, no es posible predecir el valor de salida para un valor de entrada determinado.\nPor eso, la programaci√≥n funcional promueve el uso de funciones puras, que no producen efectos secundarios. De esta manera, con las mismas entradas siempre se obtiene la misma salida, logrando un c√≥digo m√°s confiable, predecible y sencillo de mantener.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/01_fundamentos.html#sec-ciudadanos",
    "href": "teoria/02_programacion_funcional/01_fundamentos.html#sec-ciudadanos",
    "title": "1 - Fundamentos",
    "section": "Ciudadanos de primera clase",
    "text": "Ciudadanos de primera clase\nDefinamos otra funci√≥n muy sencilla, restar, que calcula y devuelve la diferencia entre dos objetos.\n\ndef restar(x, y):\n    return x - y\n\nrestar(10, 5)\n\n5\n\n\nPodemos observar que esta funci√≥n es un objeto de tipo function.\nprint(type(restar))\nprint(restar)\nrestar\n&lt;class 'function'&gt;\n&lt;function restar at 0x7f71cee62020&gt;\n&lt;function __main__.restar(x, y)&gt;\nAl imprimir la funci√≥n, Python nos muestra su nombre y la direcci√≥n de memoria donde est√° almacenada (en formato hexadecimal). En cambio, al mostrar su representaci√≥n, obtenemos informaci√≥n adicional: el m√≥dulo en el que fue definida (en este caso __main__) y la lista de par√°metros que recibe (x e y).\nDado que la funci√≥n restar es un objeto de Python, podemos asignarla a una nueva variable y realizar una llamada utilizando esa nueva etiqueta en vez de la original.\n\nresta_especial = restar\nresta_especial(10, 5)\n\n5\n\n\nNotemos que resta_especial no es una nueva funci√≥n; es solamente una nueva referencia a la funci√≥n antes definida.\n\nresta_especial # muestra 'restar', no 'resta_especial'\n\n&lt;function __main__.restar(x, y)&gt;\n\n\n\nresta_especial is restar\n\nTrue\n\n\nEn Python, las funciones son ciudadanos de primera clase. Esto significa que son objetos, al igual que las cadenas o los n√∫meros. Por lo tanto, todo lo que se puede hacer con una cadena o un n√∫mero tambi√©n puede hacerse con una funci√≥n.\nPor ejemplo, se pueden almacenar dentro de una lista junto con otros objetos de distintos tipos:\npopurri = [128, restar, None]\nprint(popurri[0])\nprint(popurri[1])\nprint(popurri[2])\n128\n&lt;function restar at 0x7f71cee62020&gt;\nNone\nIncluso una funci√≥n puede ser almacenada como valor en un diccionario:\n\nmapeo = {\n    \"sum\": sumar,\n    \"sub\": restar,\n}\n\nLuego, se las puede usar de la siguiente manera:\n\nmapeo[\"sum\"](25, 4)\n\n29\n\n\n\nmapeo[\"sub\"](25, 4)\n\n21\n\n\n\nFunciones de orden superior\nComo cualquier objeto de Python, una funci√≥n puede ser pasada como argumento de otra funci√≥n. Debajo definimos dos funciones muy simples. Una imprime un mensaje de bienvenida y la otra uno de despedida.\n\ndef bienvenida():\n    print(\"¬°Hola!\")\n\ndef despedida():\n    print(\"¬°Chau!\")\n\n\nbienvenida()\ndespedida()\n\n¬°Hola!\n¬°Chau!\n\n\nSe puede definir otra funci√≥n, que llamaremos externa (del ingl√©s outer function), que tiene un √∫nico par√°metro interna. En su cuerpo, la funci√≥n externa llama a la funci√≥n interna y devuelve lo que sea que interna devuelva.\n\ndef externa(interna):\n    return interna()\n\nDe este modo, si llamamos a externa pas√°ndole como argumento a bienvenida, se imprimir√° ¬°Hola!; y si lo hacemos con despedida, se imprimir√° ¬°Chau!.\n\nexterna(bienvenida)\n\n¬°Hola!\n\n\n\nexterna(despedida)\n\n¬°Chau!\n\n\nComo ni bienvenida ni despedida devuelven nada, lo mismo ocurre con externa en los dos ejemplos anteriores.\nA esta funci√≥n podemos pasarle cualquier funci√≥n que pueda ser llamada sin ning√∫n argumento. Por ejemplo:\n\ndef crear_lista():\n    return []\n\nexterna(crear_lista)\n\n[]\n\n\nTambi√©n es posible que una funci√≥n devuelva como resultado otra funci√≥n. La funci√≥n fabricar construye y devuelve una funci√≥n que computa la suma de dos objetos.\n\ndef fabricar():\n    def interna(x, y):\n        return x + y\n    return interna\n\n# La llamada a 'fabricar' genera y devuelve una funci√≥n\nf = fabricar()\n\n# La funci√≥n obtenida puede ser tratada como cualquier otra funci√≥n\nf(10, 15)\n\n25\n\n\nUna funci√≥n que fabrica otras funciones puede recibir par√°metros que luego son utilizados dentro de la funci√≥n interna. En el bloque siguiente, la funci√≥n crear_multiplicador recibe un par√°metro x, que define el valor por el cual se multiplicar√° el argumento de la funci√≥n interna que se devuelve.\n\ndef crear_multiplicador(x):\n    def interna(y):\n        return y * x\n    return interna\n\nAs√≠, es posible crear funciones para duplicar, triplicar, etc.\n\nduplicar = crear_multiplicador(2)\ntriplicar = crear_multiplicador(3)\n\nprint(duplicar(5))\nprint(triplicar(5))\nprint(triplicar(18))\n\n10\n15\n54\n\n\n\n\n\n\n\n\nObservaci√≥n üëÄ\n\n\n\nCada vez que se invoca la funci√≥n fabricar, se crea y devuelve una nueva funci√≥n. Por eso, el resultado de la comparaci√≥n en el siguiente bloque es False.\nf1 = fabricar()\nf2 = fabricar()\nprint(f1 is f2)\nFalse\n\n\n\n\n\n\n\n\nFunction factory üè≠\n\n\n\nA las funciones que crean y devuelven funciones se las conoce como f√°brica de funciones, del ingl√©s function factory.\n\n\n\n\nAtributos de una funci√≥n\nEn Python, las funciones tambi√©n cuentan con atributos, del mismo modo que otros objetos. En el siguiente ejemplo definimos la funci√≥n resolvente, que recibe las constantes a, b y c de un polinomio de segundo grado, calcula sus ra√≠ces usando la f√≥rmula resolvente y las devuelve en una tupla.\n\ndef resolvente(a, b, c):\n    discriminante = b ** 2 - 4 * a * c\n    x0 = (-b + (discriminante) ** 0.5) / (2 * a)\n    x1 = (-b - (discriminante) ** 0.5) / (2 * a)\n\n    return x0, x1\n\nresolvente(2, 5, -3)\n\n(0.5, -3.0)\n\n\nA trav√©s del atributo especial __code__ es posible consultar ciertos atributos o detalles internos de una funci√≥n:\n\nprint(resolvente.__code__.co_argcount) # Cantidad de argumentos\nprint(resolvente.__code__.co_name)     # Nombre de la funci√≥n\nprint(resolvente.__code__.co_varnames) # Variables en el √°mbito local\n\n3\nresolvente\n('a', 'b', 'c', 'discriminante', 'x0', 'x1')\n\n\nAcceder a la informaci√≥n de una funci√≥n a trav√©s de __code__ puede resultar poco pr√°ctico, ya que los atributos disponibles son t√©cnicos y no siempre coinciden directamente con lo que solemos necesitar (por ejemplo, obtener solo los nombres de los argumentos).\nPara facilitar esta tarea, la librer√≠a est√°ndar de Python incluye el m√≥dulo inspect, que ofrece herramientas m√°s claras e intuitivas para explorar los atributos y detalles de una funci√≥n.\nA modo ilustrativo tomemos la funci√≥n signature, que devuelve un objeto que representa la firma de la funci√≥n resolvente.\n\nimport inspect\n\nfirma = inspect.signature(resolvente)\nfirma\n\n&lt;Signature (a, b, c)&gt;\n\n\nA partir de esta firma podemos consultar distintos aspectos de los par√°metros, como sus valores por defecto:\n\nfirma.parameters[\"a\"].default # 'a' no tiene asignado un valor por defecto\n\ninspect._empty\n\n\nFinalmente, inspect tambi√©n permite acceder al c√≥digo fuente de la funci√≥n en forma de cadena de texto:\n\nprint(inspect.getsource(resolvente))\n\ndef resolvente(a, b, c):\n    discriminante = b ** 2 - 4 * a * c\n    x0 = (-b + (discriminante) ** 0.5) / (2 * a)\n    x1 = (-b - (discriminante) ** 0.5) / (2 * a)\n\n    return x0, x1",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/01_fundamentos.html#funciones-an√≥nimas",
    "href": "teoria/02_programacion_funcional/01_fundamentos.html#funciones-an√≥nimas",
    "title": "1 - Fundamentos",
    "section": "Funciones an√≥nimas",
    "text": "Funciones an√≥nimas\nLa programaci√≥n funcional se basa en llamar funciones y pasarlas, por lo que, naturalmente, puede implicar definir muchas funciones. En Python, adem√°s de usar def, podemos crear funciones an√≥nimas de forma r√°pida con una expresi√≥n lambda.\nLa sintaxis es la siguiente:\nlambda &lt;argumentos&gt;: &lt;expresi√≥n&gt;\ny devuelve como resultado una funci√≥n an√≥nima. Un ejemplo es el siguiente:\n\nlambda x, y: x + y\n\n&lt;function __main__.&lt;lambda&gt;(x, y)&gt;\n\n\nComo la funci√≥n an√≥nima que acabamos de crear no fue asignada a ninguna variable, ya no podemos usarla.\nUna posibilidad es invocarla inmediatamente al momento de su creaci√≥n:\n\n(lambda x, y: x + y)(7, 15)\n\n22\n\n\nOtra opci√≥n es asignarla a una variable para poder llamarla m√°s adelante:\n\nsumar = lambda x, y: x + y\nsumar(7, 15)\n\n22\n\n\n\n\n\n\n\n\nAusencia de return\n\n\n\nA diferencia de las funciones definidas con def, las expresiones lambda no requieren la sentencia return. De forma impl√≠cita, siempre devuelven el resultado de la √∫nica expresi√≥n que contienen.\n\n\n\nUsos de funciones an√≥nimas\nEn ninguno de los ejemplos anteriores parece que obtengamos alguna ventaja frente a usar def para definir una funci√≥n. De hecho, da la impresi√≥n de que estamos complicando el c√≥digo innecesariamente.\nLo cierto es que las funciones an√≥nimas no est√°n pensadas para emplearse de la manera expuesta en nuestros ejemplos. Su uso principal es en operaciones simples y puntuales, cuando no resulta pr√°ctico definir una funci√≥n regular con def.\nUn caso de uso t√≠pico de la funciones an√≥nimas es cuando se tiene que pasar una funci√≥n como argumento de otra funci√≥n.\nSupongamos que queremos ordenar la siguiente lista de refranes seg√∫n diferentes criterios.\n\nrefranes = [\n    \"Al mal tiempo, buena cara\",\n    \"Perro que ladra no muerde\",\n    \"A caballo regalado no se le miran los dientes\",\n    \"Cada loco con su tema\",\n    \"El que mucho abarca, poco aprieta\",\n    \"M√°s vale p√°jaro en mano que cien volando\",\n]\n\nPor defecto, la funci√≥n sorted ordena una lista de cadenas de manera alfab√©tica.\n\nsorted(refranes)\n\n['A caballo regalado no se le miran los dientes',\n 'Al mal tiempo, buena cara',\n 'Cada loco con su tema',\n 'El que mucho abarca, poco aprieta',\n 'M√°s vale p√°jaro en mano que cien volando',\n 'Perro que ladra no muerde']\n\n\nSi quisi√©ramos ordenar los refranes por su longitud, podemos usar el argumento opcional key de sorted. Este argumento recibe una funci√≥n que, aplicada a cada elemento, devuelve el valor a utilizar en el ordenamiento. En nuestro caso, basta con usar len, ya que solo nos interesa la cantidad de caracteres de cada cadena.\n\nsorted(refranes, key=len)\n\n['Cada loco con su tema',\n 'Al mal tiempo, buena cara',\n 'Perro que ladra no muerde',\n 'El que mucho abarca, poco aprieta',\n 'M√°s vale p√°jaro en mano que cien volando',\n 'A caballo regalado no se le miran los dientes']\n\n\nAs√≠, obtenemos una lista donde las frases se ordenan seg√∫n la cantidad de caracteres.\n¬øY si quisi√©ramos ordenarlos seg√∫n la cantidad de palabras? Para eso necesitamos una funci√≥n que reciba una cadena, la divida en palabras y cuente cu√°ntas tiene.\nSin funciones an√≥nimas podr√≠amos hacer lo siguiente:\n\ndef contar_palabras(x):\n    return len(x.split())\n\nsorted(refranes, key=contar_palabras)\n\n['Al mal tiempo, buena cara',\n 'Perro que ladra no muerde',\n 'Cada loco con su tema',\n 'El que mucho abarca, poco aprieta',\n 'M√°s vale p√°jaro en mano que cien volando',\n 'A caballo regalado no se le miran los dientes']\n\n\nEn cambio, con una funci√≥n an√≥nima podemos escribir todo el programa en una sola l√≠nea:\n\nsorted(refranes, key=lambda x: len(x.split()))\n\n['Al mal tiempo, buena cara',\n 'Perro que ladra no muerde',\n 'Cada loco con su tema',\n 'El que mucho abarca, poco aprieta',\n 'M√°s vale p√°jaro en mano que cien volando',\n 'A caballo regalado no se le miran los dientes']\n\n\nDe esta forma el c√≥digo es m√°s conciso y evitamos definir funciones ‚Äúdescartables‚Äù que no volver√°n a usarse.\n\n\n\n\n\n\nOrigen del nombre lambda Œª‚ú®\n\n\n\nEl t√©rmino lambda proviene del c√°lculo lambda, un sistema formal de l√≥gica matem√°tica para expresar c√°lculos basados en la abstracci√≥n y aplicaci√≥n de funciones.\nSe le dio ese nombre porque Alonzo Church, creador del c√°lculo lambda en la d√©cada de 1930, us√≥ la letra griega Œª para denotar la operaci√≥n de abstracci√≥n de funciones.\n\n\n\n\n\n\n\n\nFunciones an√≥nimas sin par√°metros\n\n\n\nUna funci√≥n lambda normalmente recibe uno o m√∫ltiples par√°metros, pero no es obligatorio, por lo que es posibile escribir una funci√≥n an√≥nima sin par√°metros:\ncrear_numero_magico = lambda: 128\ncrear_numero magico()\n128\nLa funci√≥n an√≥nima crear_numero_magico es equivalente a la siguiente funci√≥n\ndef f():\n    return 128",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/01_fundamentos.html#funciones-vari√°dicas",
    "href": "teoria/02_programacion_funcional/01_fundamentos.html#funciones-vari√°dicas",
    "title": "1 - Fundamentos",
    "section": "Funciones vari√°dicas",
    "text": "Funciones vari√°dicas\nLas funciones vari√°dicas son funciones que pueden recibir una cantidad variable de argumentos.\nA lo largo de estos apuntes hemos utilizado funciones vari√°dicas en tant√≠simas oportunidades. Un ejemplo de funci√≥n vari√°dica es print, que acepta tantos argumentos posicionales como necesitemos.\n\nprint(\"Primero\")\n\nPrimero\n\n\n\nprint(\"Primero\", \"segundo\")\n\nPrimero segundo\n\n\n\nprint(\"Primero\", \"segundo\", \"tercero\")\n\nPrimero segundo tercero\n\n\nAfortunadamente, no solo las funciones built-in pueden ser vari√°dicas, sino que tambi√©n podemos implementarlas nosotros mismos.\n\nCantidad variable de argumentos posicionales *args\nSupongamos que queremos una funci√≥n que recibe una cantidad arbitraria de gustos de helado e imprime un mensaje como si lo agregase a un pedido. Por ejemplo:\narmar_pedido(\"Dulce de leche\")\nAgregando 'Dulce de leche'\narmar_pedido(\"Dulce de leche\", \"Sambay√≥n\", \"Frutos del bosque\")\nAgregando 'Dulce de leche'\nAgregando 'Sambay√≥n'\nAgregando 'Frutos del bosque'\nUna posible implementaci√≥n para tal funci√≥n es:\ndef armar_pedido(gusto_1=None, gusto_2=None, gusto_3=None):\n    if gusto_1 is not None:\n        print(f\"Agregando '{gusto_1}'\")\n    if gusto_2 is not None:\n        print(f\"Agregando '{gusto_2}'\")\n    if gusto_3 is not None:\n        print(f\"Agregando '{gusto_3}'\")\nAunque funciona en los ejemplos anteriores, esta soluci√≥n est√° lejos de ser ideal. Requiere definir un argumento separado para cada gusto, asignarle un valor por defecto y luego verificar si es distinto de None antes de agregarlo al pedido.\nAdem√°s, el c√≥digo resulta repetitivo y restrictivo: solo permite un m√°ximo de tres gustos.\nEn cambio, podemos crear una funci√≥n que reciba una cantidad arbitraria de argumentos posicionales. Para ello se utiliza un argumento especial precedido por un asterisco (*), lo que le permite recibir una cantidad arbitraria de valores no nombrados.\n\ndef armar_pedido(*args):\n    for gusto in args:\n        print(f\"Agregando '{gusto}'\")\n\n\narmar_pedido(\"Dulce de leche\", \"Sambay√≥n\", \"Frutos del bosque\", \"Menta granizada\")\n\nAgregando 'Dulce de leche'\nAgregando 'Sambay√≥n'\nAgregando 'Frutos del bosque'\nAgregando 'Menta granizada'\n\n\n\narmar_pedido(\"gusto 1\", \"gusto 2\", \"gusto 3\", \"gusto 4\", \"gusto 5\", \"gusto 6\", \"gusto 7\")\n\nAgregando 'gusto 1'\nAgregando 'gusto 2'\nAgregando 'gusto 3'\nAgregando 'gusto 4'\nAgregando 'gusto 5'\nAgregando 'gusto 6'\nAgregando 'gusto 7'\n\n\nPor convenci√≥n, este argumento suele escribirse como *args, aunque en realidad el nombre del argumento puede ser cualquiera que resulte apropiado. En nuestro caso, resulta m√°s intuitivo usar *gustos, y la funci√≥n quedar√≠a as√≠:\n\ndef armar_pedido(*gustos):\n    for gusto in gustos:\n        print(f\"Agregando '{gusto}'\")\n\n\narmar_pedido(\"gusto 1\", \"gusto 2\", \"gusto 3\", \"gusto 4\", \"gusto 5\", \"gusto 6\", \"gusto 7\")\n\nAgregando 'gusto 1'\nAgregando 'gusto 2'\nAgregando 'gusto 3'\nAgregando 'gusto 4'\nAgregando 'gusto 5'\nAgregando 'gusto 6'\nAgregando 'gusto 7'\n\n\n\n\n\n\n\n\nQu√© hay debajo de *args üîç\n\n\n\nPython agrupa autom√°ticamente en una tupla los valores pasados mediante el argumento especial *args. Esto permite acceder a todos los argumentos como miembros de una colecci√≥n inmutable.\ndef fun(*args):\n    print(len(args))\n    print(args)\n    print(type(args))\n\nfun(\"que\", \"es\", \"esto\", True, None)\n5\n('que', 'es', 'esto', True, None)\n&lt;class 'tuple'&gt;\n\n\n\n\nCantidad variable de argumentos nombrados **kwargs\nAs√≠ como recibimos una cantidad arbitraria de argumentos posicionales, tambi√©n podemos recibir una cantidad arbitraria de argumentos nombrados.\nEn este caso, se utilizan dos aster√≠scos (**) en vez de uno (*) en la definici√≥n de los par√°metros de la funci√≥n.\nLa convenci√≥n es usar el nombre **kwargs, pero tambi√©n es v√°lido usar cualquier otro nombre que sea adecuado en nuestro contexto.\nComencemos por un ejemplo elemental, que solo imprime el objeto kwargs y su tipo:\n\ndef ejemplo(**kwargs):\n    print(kwargs)\n    print(type(kwargs))\n\nejemplo(nombre=\"Mariano\", apellido=\"P√©rez\")\n\n{'nombre': 'Mariano', 'apellido': 'P√©rez'}\n&lt;class 'dict'&gt;\n\n\nCuando usamos una cantidad variable de argumentos nombrados, Python los agrupa en un diccionario, ya que esta estructura permite asociar cada nombre con su valor de forma natural.\nDentro de la funci√≥n, se puede manipular al diccionario kwargs como a cualquier otro diccionario de Python.\nImaginemos, por ejemplo, una funci√≥n que registra informaci√≥n de distintos departamentos. En este caso, no sabemos de antemano qu√© atributos se van a proporcionar, pero s√≠ sabemos que ciertos atributos deben contar con un valor por defecto si no se especifican.\n\ndef registrar_propiedad(**kwargs):\n    print(\"Diccionario original:\")\n    print(kwargs)\n\n    # Si no se especifica la cantidad de cocheras, se pone 0 por defecto\n    if \"cochera\" not in kwargs:\n        kwargs[\"cochera\"] = 0\n\n    # Si no se especifica la ciudad, se pone 'Desconocido' por defecto\n    if \"ciudad\" not in kwargs:\n        kwargs[\"ciudad\"] = \"Desconocido\"\n\n    return kwargs\n\nCuando no se especifician la cantidad de cocheras, la funci√≥n nos devuelve un diccionario donde la cantidad de cocheras es 0.\n\ndatos = registrar_propiedad(ambientes=2, ciudad=\"Rosario\")\n\nprint(\"\\nDiccionario sanitizado\")\nprint(datos)\n\nDiccionario original:\n{'ambientes': 2, 'ciudad': 'Rosario'}\n\nDiccionario sanitizado\n{'ambientes': 2, 'ciudad': 'Rosario', 'cochera': 0}\n\n\nSi los atributos requeridos son especificados, se devuelve el diccionario sin cambios.\n\ndatos = registrar_propiedad(ambientes=2, ciudad=\"Santa Fe\", cochera=2)\n\nprint(\"\\nDiccionario sanitizado\")\nprint(datos)\n\nDiccionario original:\n{'ambientes': 2, 'ciudad': 'Santa Fe', 'cochera': 2}\n\nDiccionario sanitizado\n{'ambientes': 2, 'ciudad': 'Santa Fe', 'cochera': 2}\n\n\nY si se pasan otros atributos, tambi√©n se incluyen en la salida.\n\ndatos = registrar_propiedad(ambientes=4, dormitorios=2)\n\nprint(\"\\nDiccionario sanitizado\")\nprint(datos)\n\nDiccionario original:\n{'ambientes': 4, 'dormitorios': 2}\n\nDiccionario sanitizado\n{'ambientes': 4, 'dormitorios': 2, 'cochera': 0, 'ciudad': 'Desconocido'}\n\n\n\n\nCombinando *args y **kwargs\nLas funciones en Python pueden recibir simult√°neamente una cantidad variable de argumentos posicionales y nombrados. Para lograrlo, se combinan *args y **kwargs. Es importante recordar que, al definir la funci√≥n, *args debe colocarse antes que **kwargs, ya que los argumentos posicionales siempre se pasan antes que los nombrados.\n\ndef superfuncion(*args, **kwargs):\n    for arg in args:\n        print(f\"Me pasaron el argumento posicional '{arg}'\")\n\n    for key, value in kwargs.items():\n        print(f\"Me pasaron el argumento con nombre '{key}' y valor '{value}'\")\n\nsuperfuncion(True, 64, nombre=\"Elsa\", apellido=\"Pato\")\n\nMe pasaron el argumento posicional 'True'\nMe pasaron el argumento posicional '64'\nMe pasaron el argumento con nombre 'nombre' y valor 'Elsa'\nMe pasaron el argumento con nombre 'apellido' y valor 'Pato'\n\n\nSi se intenta pasar un argumento posicional (sin nombre) despu√©s de un argumento nombrado, obtendr√≠amos un error:\nsuperfuncion(True, nombre=\"Elsa\", apellido=\"Pato\", 64)\n\n    superfuncion(True, nombre=\"Elsa\", apellido=\"Pato\", 64)\n                                                         ^\nSyntaxError: positional argument follows keyword argument\n\n\n\n\n\n\n\n¬øY para qu√© me sirven? ü§î\n\n\n\nA primera vista, los ejemplos de *args y **kwargs pueden dar la impresi√≥n de que estas herramientas solo complican la escritura del c√≥digo. Sin embargo, su verdadero valor aparece al trabajar en programas m√°s complejos, donde se vuelven fundamentales para simplificar la l√≥gica y aportar flexibilidad en la resoluci√≥n de una gran variedad de problemas.\nYa llegaremos‚Ä¶\n\n\n\n\n\n\n\n\nEs solo una convenci√≥n ü§ù\n\n\n\nPara reforzar que los nombres *args y **kwargs son solamente una convenci√≥n, podr√≠amos escribir la funci√≥n superfuncion como:\ndef superfuncion(*posicionales, **nombrados):\n    for arg in posicionales:\n        print(f\"Me pasaron el argumento posicional '{arg}'\")\n\n    for key, value in nombrados.items():\n        print(f\"Me pasaron el argumento con nombre '{key}' y valor '{value}'\")\ny funcionar√≠a de igual modo.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/01_fundamentos.html#closures",
    "href": "teoria/02_programacion_funcional/01_fundamentos.html#closures",
    "title": "1 - Fundamentos",
    "section": "Closures",
    "text": "Closures\nEn la Secci√≥n¬†3.1 vimos el siguiente ejemplo:\ndef crear_multiplicador(x):\n    def interna(y):\n        return y * x\n    return interna\n\nduplicar = crear_multiplicador(2)\ntriplicar = crear_multiplicador(3)\n\nprint(duplicar(5))\nprint(triplicar(5))\n10\n15\nLa funci√≥n crear_multiplicador es una f√°brica de funciones que devuelve otra funci√≥n que se encarga de realizar la multiplicaci√≥n. Lo interesante de esta implementaci√≥n es que la funci√≥n interna solo recibe uno de los dos valores necesarios para la multiplicaci√≥n; el otro queda que fijado cuando se ejecuta la funci√≥n externa crear_multiplicador.\nPara que duplicar y triplicar funcionen correctamente, ambas funciones internas deben conservar acceso al entorno en el que est√° definido el valor de x. Ese mecanismo, que permite a una tener acceso a las variables de su contexto incluso despu√©s de que la ejecuci√≥n de la funci√≥n externa haya conclu√≠do, es precisamente lo que se conoce como un closure.\n\ndef crear_multiplicador(x):\n    def interna(y):\n        return y * x\n    return interna\n\nduplicar = crear_multiplicador(2)\ntriplicar = crear_multiplicador(3)\n\nprint(duplicar(5))\nprint(triplicar(5))\n\n10\n15\n\n\nEl siguiente ejemplo hace a√∫n m√°s evidente el funcionamiento de este mecanismo.\nDentro del cuerpo de la function factory externa, se define valor con el n√∫mero 256. Luego, la funci√≥n interna hace uso de esta variable valor dentro de print.\n\ndef externa():\n    valor = 256\n    def closure():\n        print(f\"¬°El valor es: {valor}!\")\n    return closure\n\nrevelar_numero = externa()\nrevelar_numero()\n\n¬°El valor es: 256!\n\n\nAunque desde fuera no podemos acceder directamente a valor:\nvalor\n\nNameError: name 'valor' is not defined\n\nla funci√≥n interna s√≠ puede hacerlo tantas veces como sea necesario:\n\nrevelar_numero()\nrevelar_numero()\nrevelar_numero()\n\n¬°El valor es: 256!\n¬°El valor es: 256!\n¬°El valor es: 256!\n\n\nPara finalizar, veamos un ejemplo similar al anterior, pero donde el valor de la variable numero es desconocido para nosotros. Dicho valor se genera de manera aleatoria cuando se ejecuta la f√°brica de funciones crear_funcion.\n\nimport random\n\ndef crear_funcion():\n    numero = random.randint(1, 1000)\n    def closure():\n        print(\"El valor es...\", numero)\n    return closure\n\nreveladora = crear_funcion()\n\nLuego, sin importar cu√°ntas veces llamemos a reveladora, el mensaje ser√° siempre el mismo, ya que el valor de numero se defini√≥ una sola vez en el momento en que se cre√≥ la funci√≥n.\n\nreveladora()\n\nEl valor es... 393\n\n\n\nreveladora()\n\nEl valor es... 393\n\n\n\n\n\n\n\n\nUna dosis de precisi√≥n üéØüò±\n\n\n\nA menudo se dice que un closure es una funci√≥n. As√≠, en el siguiente ejemplo, duplicar ser√≠a considerado un closure:\ndef crear_multiplicador(x):\n    def interna(y):\n        return y * x\n    return interna\n\nduplicar = crear_multiplicador(2)\nSin embargo, esa definici√≥n es un tanto imprecisa. Un closure no es simplemente una funci√≥n, sino el mecanismo que permite a las funciones acceder a las variables del entorno en el que fueron definidas, incluso cuando ese entorno ya dej√≥ de existir (por ejemplo, despu√©s de que termina la ejecuci√≥n de la funci√≥n externa que las cre√≥).\nUf‚Ä¶ ¬°qu√© complicado!\n\n\n\n\n\n\n\n\nobject of type 'closure' is not subsettable üòµ\n\n\n\nSi en R intentamos seleccionar filas o columnas de data sin haberle asignado un objeto previamente, obtendremos el siguiente error:\n\nError in data[1] : object of type 'closure' is not subsettable\n\nEsto ocurre porque data es en realidad una funci√≥n en R. En este lenguaje, el tipo de los objetos funci√≥n se denomina closure, haciendo referencia la capacidad que tienen las funciones de acceder a valores del ambiente donde fueron definidas.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/05_generadores.html",
    "href": "teoria/02_programacion_funcional/05_generadores.html",
    "title": "5 - Generadores üß©",
    "section": "",
    "text": "En este cap√≠tulo vamos a introducirnos en los generadores, tanto en las funciones como en las expresiones generadoras. A diferencia de las funciones regulares, que devuelven un resultado con return, los generadores no devuelven un √∫nico resultado, sino que van entregando valores de a uno a medida que se lo solicita. Cada vez que se entrega un valor, la ejecuci√≥n queda en pausa y se conserva el estado de las variables, de modo que puede reanudarse m√°s adelante. De este modo, los generadores resultan ideales para definir iteradores y trabajar con grandes vol√∫menes de datos sin necesidad de almacenarlos al mismo tiempo en memoria.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "5 - Generadores üß©"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/05_generadores.html#introducci√≥n",
    "href": "teoria/02_programacion_funcional/05_generadores.html#introducci√≥n",
    "title": "5 - Generadores üß©",
    "section": "",
    "text": "En este cap√≠tulo vamos a introducirnos en los generadores, tanto en las funciones como en las expresiones generadoras. A diferencia de las funciones regulares, que devuelven un resultado con return, los generadores no devuelven un √∫nico resultado, sino que van entregando valores de a uno a medida que se lo solicita. Cada vez que se entrega un valor, la ejecuci√≥n queda en pausa y se conserva el estado de las variables, de modo que puede reanudarse m√°s adelante. De este modo, los generadores resultan ideales para definir iteradores y trabajar con grandes vol√∫menes de datos sin necesidad de almacenarlos al mismo tiempo en memoria.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "5 - Generadores üß©"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/05_generadores.html#funciones-generadoras",
    "href": "teoria/02_programacion_funcional/05_generadores.html#funciones-generadoras",
    "title": "5 - Generadores üß©",
    "section": "Funciones generadoras",
    "text": "Funciones generadoras\nUna funci√≥n generadora se define igual que una funci√≥n com√∫n con def, pero en lugar de devolver un valor con return, lo hace con yield.\nCuando se ejecuta una funci√≥n generadora, no se ejecuta el c√≥digo en su cuerpo de manera inmediata ni se obtiene un resultado. En cambio, se obtiene un generador que luego puede entregar valores.\n\ndef gen():\n    yield \"¬°Resultado!\"\n\ng = gen()\ng\n\n&lt;generator object gen at 0x7f90c8738ca0&gt;\n\n\nComo los generadores son iteradores (ver Iterables e iteradores), se puede usar next para obtener el siguiente valor de manera manual:\n\nnext(g)\n\n'¬°Resultado!'\n\n\nEste primer ejemplo es demasiado simple para apreciar la verdadera utilidad de los generadores. Si solo necesit√°ramos devolver un √∫nico valor, bastar√≠a con usar una funci√≥n com√∫n.\nLa ventaja de los generadores est√° en que pueden entregar varios valores de a uno, a medida que se los solicita, mientras conservan el estado de las variables.\nVeamos ahora una segunda funci√≥n generadora, esta vez con dos instrucciones yield en lugar de una. En la primera llamada a next, obtenemos \"Primer resultado\".\n\ndef gen():\n    yield \"Primer resultado\"\n    yield \"Segundo resultado\"\n\ng = gen()\nnext(g)\n\n'Primer resultado'\n\n\nY en la segunda llamada a next el generador entrega el segundo valor: \"Segundo resultado\".\n\nnext(g)\n\n'Segundo resultado'\n\n\nEn la primera llamada a next, la funci√≥n se ejecuta hasta llegar a la primera instrucci√≥n yield. All√≠ el generador devuelve un valor y suspende su ejecuci√≥n. Con la segunda llamada, la ejecuci√≥n se reanuda desde ese punto y contin√∫a hasta encontrar el siguiente yield, entregando otro valor.\nAhora bien, ¬øqu√© ocurre si llamamos a next cuando el generador ya entreg√≥ todos los valores disponibles?\nnext(g)\n\n    next(g)\n    ~~~~^^^\nStopIteration\n\nUna vez que un generador se agota, cualquier llamada adicional a next elevar√° la excepci√≥n StopIteration, que se√±ala que ya no quedan valores por producir.\nPara observar con m√°s detalle c√≥mo funciona la ejecuci√≥n y suspensi√≥n en los generadores, vamos a implementar una funci√≥n que mantiene el estado de una variable num√©rica e imprime un mensaje justo antes de cada yield.\n\ndef generador(x):\n    print(\"Recib√≠ el valor\", x)\n\n    x = x + 18\n    print(\"Entrego el valor\", x)\n    yield x\n\n    x = x - 5\n    print(\"Esto una entrega siguiente, devuelvo el valor\", x)\n    yield x\n\n    print(\"Este mensaje est√° bien al final\")\n\ng = generador(7)\n\nComo se puede observar, la ejecuci√≥n de la funci√≥n generadora no imprimi√≥ ning√∫n mensaje, ya que esto no ejecuta el cuerpo de la funci√≥n. Reci√©n al pedir el primer valor se ejecutan los dos print previos al primer yield. Adem√°s, el valor inicial 7 se incrementa en 18 y luego es devuelto.\n\nnext(g)\n\nRecib√≠ el valor 7\nEntrego el valor 25\n\n\n25\n\n\nEn la segunda llamada a next(g) se imprime un mensaje y se entrega el valor 25 - 5 = 20. Esto muestra que el generador conserva el estado de las variables: en lugar de usar el valor original de x, utiliza el valor actualizado en la entrega anterior.\n\nnext(g)\n\nEsto una entrega siguiente, devuelvo el valor 20\n\n\n20\n\n\nSin embargo, el print al final, debajo del √∫ltimo yield, a√∫n no se ejecut√≥. Para eso, usamos next(g) nuevamente.\nnext(g)\n\nEste mensaje est√° bien al final\n\n    next(g)\n    ~~~~^^^\nStopIteration\n\nComo no hay ning√∫n otro valor por entregar, se imprime el mensaje y luego se obtiene la excepci√≥n StopIteration.\n\nEjemplo 1: Secuencia de n√∫meros naturales\nLos generadores tambi√©n permiten crear secuencias infinitas. Para ello, basta con escribir un bucle infinito dentro de la funci√≥n generadora. Esto no representa un problema, ya que el generador produce un valor a la vez, √∫nicamente cuando se le solicita.\n\ndef numeros_naturales():\n    n = 0\n    while True:\n        yield n\n        n = n + 1\n\nsecuencia = numeros_naturales()\n\nLuego, pedimos los valores de a uno:\n\nprint(next(secuencia))\nprint(next(secuencia))\nprint(next(secuencia))\nprint(next(secuencia))\nprint(next(secuencia))\n\n0\n1\n2\n3\n4\n\n\nVale la pena notar que un generador no tiene longitud, ya que podr√≠a ser infinito, ni permite acceder a sus elementos por √≠ndice. Solo sabe c√≥mo producir el pr√≥ximo valor, sin conocer de antemano cu√°ntos quedan por generar.\nlen(secuencia)\n\n    len(secuencia)\n    ~~~^^^^^^^^^^\nTypeError: object of type 'generator' has no len()\n\nsecuencia[0]\n\n    secuencia[0]\n    ~~~~~~~~~^^^\nTypeError: 'generator' object is not subscriptable\n\nComo los generadores son iteradores, podemos recorrerlos con un bucle for. En el caso de secuencias infinitas, es necesario usar un break para evitar que el bucle nunca termine.\n\ni = 0\nfor n in secuencia:\n    print(n)\n    i += 1\n    if i &gt;= 5:\n        break\n\n5\n6\n7\n8\n9\n\n\nSi nuestro √∫nico objetivo es recorrer los elementos del generador, podemos inicializarlo directamente en el bucle for.\n\nfor n in numeros_naturales():\n    print(n)\n    if n &gt;= 7:\n        break\n\n0\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\nEjemplo 2: Secuencia de Fibonacci\nLas secuencias infinitas no se limitan a los n√∫meros naturales. Como los generadores conservan el estado de las variables dentro de la funci√≥n, tambi√©n pueden usarse para producir otras secuencias, como la de Fibonacci.\n\\[\nF_n =\n\\begin{cases}\n0 & \\text{si } n = 0 \\\\\n1 & \\text{si } n = 1 \\\\\nF_{n-1} + F_{n - 2} & \\text{si } n \\ge 2 \\\\\n\\end{cases}\n\\]\n\ndef fibonacci():\n    a = 0\n    b = 1\n    while True:\n        yield a\n        a, b = b, a + b\n\nSi queremos los primeros 10 n√∫meros de la secuencia, podemos utilizar un bucle for que ejecuta next(g) 10 veces seguidas.\n\ng = fibonacci()\nfor _ in range(10):\n    print(next(g))\n\n0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n\n\nAl volver a pedir un nuevo valor a nuestro generador, este contin√∫a avanzando en la secuencia de Fibonacci.\n\nnext(g)\n\n55\n\n\n\nnext(g)\n\n89\n\n\n\n\nEjemplo 3: Promedio acumulado\nEn este ejemplo se muestra un generador que procesa una secuencia num√©rica y va devolviendo el promedio acumulado a medida que avanza.\nComo los valores se producen bajo demanda, en memoria solo se conserva la secuencia original y el √∫ltimo promedio calculado.\n\ndef promedio_acumulado(numeros):\n    numerador = 0\n    for i, numero in enumerate(numeros):\n        numerador += numero\n        yield numerador / (i + 1)\n\nvalores = [2, 4, 9, 1, 7, 11] # Supongamos una lista muy grande de n√∫meros\n\nfor m in promedio_acumulado(valores):\n    print(f\"Promedio acumulado: {m:.2f}\")\n\nPromedio acumulado: 2.00\nPromedio acumulado: 3.00\nPromedio acumulado: 5.00\nPromedio acumulado: 4.00\nPromedio acumulado: 4.60\nPromedio acumulado: 5.67",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "5 - Generadores üß©"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/05_generadores.html#expresiones-generadoras",
    "href": "teoria/02_programacion_funcional/05_generadores.html#expresiones-generadoras",
    "title": "5 - Generadores üß©",
    "section": "Expresiones generadoras",
    "text": "Expresiones generadoras\nLas expresiones generadoras, del ingl√©s generator expressions, proveen una manera concisa para construir generadores. Se parecen a las list comprehensions, pero usan par√©ntesis en vez de corchetes.\nSupongamos una lista de n√∫meros cualquiera y que usamos una list comprehension para obtener el triple de cada n√∫mero.\n\nnumeros = [3, 14, 2, 7, 1, 28]\ntriples = [n * 3 for n in numeros]\n\nprint(numeros)\nprint(triples)\n\n[3, 14, 2, 7, 1, 28]\n[9, 42, 6, 21, 3, 84]\n\n\nLa expresi√≥n generadora equivalente es la siguiente:\n\ntriples = (n * 3 for n in numeros)\ntriples\n\n&lt;generator object &lt;genexpr&gt; at 0x7f90c87702b0&gt;\n\n\nComo todo generador, implementa la estrategia de evaluaci√≥n perezosa. Esto quiere decir que el triple de cada n√∫mero se calcula justo en el momento en que se solicita, no antes.\nAs√≠, podemos obtener los valores mediante un bucle:\n\nfor n in triples:\n    print(n)\n\n9\n42\n6\n21\n3\n84\n\n\nUn generador creado con una expresi√≥n generadora es equivalente a uno definido con una funci√≥n generadora. En ambos casos, si se intenta obtener un valor de un generador ya agotado, se producir√° un error.\nnext(triples)\n\n    next(triples)\n    ~~~~^^^^^^^^^\nStopIteration\n\nY al intentar obtener una lista a partir de un generador agotado, obtendremos una lista vac√≠a.\n\nlist(triples)\n\n[]\n\n\nAdem√°s de ser perezosos, los generadores son de √∫nico uso. Sus valores se generan a medida que se solicitan y no se guardan en memoria, de modo que, una vez consumidos, no es posible volver a iterarlos.\nEsta aparente limitaci√≥n es en realidad una ventaja. A diferencia de una lista, que construye y guarda todos sus elementos en memoria, un generador solo define una receta para producirlos cuando se necesiten. En el siguiente ejemplo se muestra c√≥mo esto impacta en el consumo de memoria frente a una lista.\n\nimport sys\n\n# Enteros divisibles por 3 o 5 entre 1 y 10,000,000\nlista = [n for n in range(1, 10_000_001) if n % 3 == 0 or n % 5 == 0]\ngenexpr = (n for n in range(1, 10_000_001) if n % 3 == 0 or n % 5 == 0)\n\nprint(sys.getsizeof(lista))   # bytes\nprint(sys.getsizeof(genexpr)) # bytes\n\n39064728\n200\n\n\nY a partir de ambos objetos se puede computar, por ejemplo, la suma.\n\nsum(lista), sum(genexpr)\n\n(23333341666668, 23333341666668)\n\n\nEn resumen, mientras que una lista es una colecci√≥n de valores, un generador es una receta para producir valores.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "5 - Generadores üß©"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/05_generadores.html#sec-iteradores",
    "href": "teoria/02_programacion_funcional/05_generadores.html#sec-iteradores",
    "title": "5 - Generadores üß©",
    "section": "Iterables e iteradores",
    "text": "Iterables e iteradores\nA lo largo de este cap√≠tulo dijimos varias veces que los generadores son iteradores, aunque todav√≠a no definimos con precisi√≥n qu√© significa eso.\nLo que s√≠ sabemos es que un objeto es iterable cuando puede recorrerse con un bucle for. En Python, las listas, las cadenas y los diccionarios son ejemplos de objetos iterables, por lo que los siguientes bloques de c√≥digo funcionan sin problemas:\nfor i in [10, 55, 2]:\n    print(i + 5)\n\nfor c in \"palabras\":\n    print(c.upper())\n\nfor k in {\"nombre\": \"Juan\", \"apellido\": \"P√©rez\"}:\n    print(k)\nComo ya vimos que una lista se puede recorrer con un bucle, podr√≠amos preguntarnos si tambi√©n es posible usar la funci√≥n next para obtener su siguiente elemento.\n\nnums = [-10, 0, 10]\n\nnext(nums)\n\n    next(nums)\n    ~~~~^^^^^^\nTypeError: 'list' object is not an iterator\n\nSin embargo, al hacerlo obtenemos un TypeError que indica que la lista no es un iterador. Lo mismo ocurre si intentamos usar next directamente con una cadena o un diccionario.\nnext(\"palabra\")\n\n    next(\"palabra\")\n    ~~~~^^^^^^^^^^^\nTypeError: 'str' object is not an iterator\n\nnext({\"nombre\": \"Juan\", \"apellido\": \"P√©rez\"})\n\n    next({\"nombre\": \"Juan\", \"apellido\": \"P√©rez\"})\n    ~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: 'dict' object is not an iterator\n\nEl error que aparece al usar next sobre una lista, una cadena o un diccionario muestra que no basta con que un objeto sea iterable para poder aplicarle next directamente.\nLo que sucede, es que, en realidad, nuestra definici√≥n inicial de iterable era incompleta: un objeto es iterable cuando puede generar un iterador a partir de √©l.\nLuego, es el iterador que conoce c√≥mo producir los valores uno a uno y, por eso, es sobre el iterador (y no sobre el iterable) que Python puede aplicar next para avanzar en la secuencia.\nPara crear un iterador a partir de un iterable usamos iter.\n\niterador = iter(nums)\niterador\n\n&lt;list_iterator at 0x7f90c87337f0&gt;\n\n\nY ahora s√≠ es posible avanzar a trav√©s de los elementos de la lista original:\n\nnext(iterador)\n\n-10\n\n\n\nnext(iterador)\n\n0\n\n\n\nnext(iterador)\n\n10\n\n\nnext(iterador)\n\n    next(iterador)\n    ~~~~^^^^^^^^^^\nStopIteration\n\nPor √∫ltimo, vale la pena se√±alar que los iteradores solo pueden construirse a partir de objetos iterables. Por ejemplo, un n√∫mero entero no es iterable, por lo que no es posible obtener un iterador a partir de √©l.\niter(10)\n\n    iter(10)\n    ~~~~^^^^\nTypeError: 'int' object is not iterable\n\nEn resumen, en Python solo se puede iterar sobre iteradores. Un objeto es iterable cuando puede generar un iterador a partir de √©l, y es este √∫ltimo el que sabe c√≥mo devolver los elementos uno a uno mediante la funci√≥n next. Cuando ya no quedan m√°s valores por producir, el iterador eleva la excepci√≥n StopIteration.\nLos generadores son un caso particular de iteradores: producen sus valores bajo demanda y mantienen el estado entre llamadas.\nFinalmente, al usar un bucle for con un iterable, todo este mecanismo ocurre de forma autom√°tica: Python crea el iterador por nosotros y se encarga de avanzar en la secuencia hasta agotarla.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "5 - Generadores üß©"
    ]
  },
  {
    "objectID": "informacion/programa.html",
    "href": "informacion/programa.html",
    "title": "Programa",
    "section": "",
    "text": "Los profesionales en Estad√≠stica y Ciencia de Datos necesitan contar con habilidades avanzadas de programaci√≥n, que les permitan abordar problemas complejos y desarrollar soluciones eficientes y robustas.\nLa asignatura Programaci√≥n 2 introduce a los estudiantes a conceptos y pr√°cticas avanzadas de la programaci√≥n, incorporando herramientas y paradigmas que resultan fundamentales para el desarrollo profesional en Estad√≠stica y Ciencia de Datos.\nLa asignatura profundiza en enfoques como la programaci√≥n funcional y la programaci√≥n orientada a objetos, promoviendo el desarrollo de soluciones estructuradas, reutilizables, robustas y escalables. Adem√°s, se abordan conceptos fundamentales de estructuras de datos y algoritmos, relevantes para el dise√±o y an√°lisis de programas eficientes, as√≠ como para la comprensi√≥n de la complejidad computacional. Se focaliza en el lenguaje Python, ampliamente utilizado en la industria y la academia por su versatilidad, su ecosistema de librer√≠as y su capacidad para integrarse con diversas tecnolog√≠as.\nDictada en el segundo cuatrimestre del primer a√±o, Programaci√≥n 2 completa los contenidos del √°rea de Fundamentos Computacionales en el Ciclo de Formaci√≥n T√©cnica en Estad√≠stica y Ciencia de Datos, iniciada en el primer cuatrimestre con Programaci√≥n 1. De este modo, consolida las competencias inform√°ticas de los estudiantes y los prepara para afrontar asignaturas m√°s avanzadas y desaf√≠os profesionales que requieren un dominio s√≥lido de la programaci√≥n. Asimismo, fomenta buenas pr√°cticas de desarrollo de c√≥digo, el uso eficiente de los recursos computacionales y el pensamiento cr√≠tico en la resoluci√≥n de problemas.",
    "crumbs": [
      "Informaci√≥n",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/programa.html#fundamentaci√≥n",
    "href": "informacion/programa.html#fundamentaci√≥n",
    "title": "Programa",
    "section": "",
    "text": "Los profesionales en Estad√≠stica y Ciencia de Datos necesitan contar con habilidades avanzadas de programaci√≥n, que les permitan abordar problemas complejos y desarrollar soluciones eficientes y robustas.\nLa asignatura Programaci√≥n 2 introduce a los estudiantes a conceptos y pr√°cticas avanzadas de la programaci√≥n, incorporando herramientas y paradigmas que resultan fundamentales para el desarrollo profesional en Estad√≠stica y Ciencia de Datos.\nLa asignatura profundiza en enfoques como la programaci√≥n funcional y la programaci√≥n orientada a objetos, promoviendo el desarrollo de soluciones estructuradas, reutilizables, robustas y escalables. Adem√°s, se abordan conceptos fundamentales de estructuras de datos y algoritmos, relevantes para el dise√±o y an√°lisis de programas eficientes, as√≠ como para la comprensi√≥n de la complejidad computacional. Se focaliza en el lenguaje Python, ampliamente utilizado en la industria y la academia por su versatilidad, su ecosistema de librer√≠as y su capacidad para integrarse con diversas tecnolog√≠as.\nDictada en el segundo cuatrimestre del primer a√±o, Programaci√≥n 2 completa los contenidos del √°rea de Fundamentos Computacionales en el Ciclo de Formaci√≥n T√©cnica en Estad√≠stica y Ciencia de Datos, iniciada en el primer cuatrimestre con Programaci√≥n 1. De este modo, consolida las competencias inform√°ticas de los estudiantes y los prepara para afrontar asignaturas m√°s avanzadas y desaf√≠os profesionales que requieren un dominio s√≥lido de la programaci√≥n. Asimismo, fomenta buenas pr√°cticas de desarrollo de c√≥digo, el uso eficiente de los recursos computacionales y el pensamiento cr√≠tico en la resoluci√≥n de problemas.",
    "crumbs": [
      "Informaci√≥n",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/programa.html#objetivos",
    "href": "informacion/programa.html#objetivos",
    "title": "Programa",
    "section": "Objetivos",
    "text": "Objetivos\nQue los estudiantes logren:\n\nanalizar problemas computacionales y formular soluciones algor√≠tmicas adecuadas;\nimplementar esas soluciones mediante el desarrollo de programas en Python, seleccionando estructuras de datos apropiadas y evaluando la eficiencia de los algoritmos involucrados;\nidentificar y aplicar los paradigmas funcional y orientado a objetos cuando resulte pertinente, desarrollando programas que integren estos enfoques; y\nutilizar e integrar m√≥dulos y librer√≠as que permitan extender, organizar y mejorar las funcionalidades de sus programas.",
    "crumbs": [
      "Informaci√≥n",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/programa.html#contenidos",
    "href": "informacion/programa.html#contenidos",
    "title": "Programa",
    "section": "Contenidos",
    "text": "Contenidos\n\nUnidad 1: Introducci√≥n a Python\n\nLenguaje Python y su ecosistema. Uso de la interfaz Positron. Sintaxis de Python. Expresiones. Variables y asignaciones. Tipos de datos elementales. Operadores num√©ricos, de comparaci√≥n y l√≥gicos. Funciones. Ejecuci√≥n condicional de c√≥digo. Bucles definidos y no definidos. Listas, tuplas y diccionarios. Uso de c√≥digo externo. M√≥dulos y librer√≠as. Librer√≠a est√°ndar de Python. Instalaci√≥n y gesti√≥n de librer√≠as. Scripting. Lectura y escritura de archivos de texto plano. Modularizaci√≥n de programas.\n\nUnidad 2: Programaci√≥n funcional\n\nPrincipios fundamentales. Funciones como ciudadanos de primera clase. Funciones puras. Funciones an√≥nimas. Closures. Recursi√≥n. Funciones de orden superior: map, filter, reduce. Evaluaci√≥n estricta y no estricta. Evaluaci√≥n perezosa (lazy) e inmediata (eager). Generadores. Aplicaci√≥n parcial de funciones. Decoradores.\n\nUnidad 3: Programaci√≥n orientada a objetos\n\nPrincipios fundamentales. Objetos, clases e instancias. Atributos y m√©todos. Propiedades p√∫blicas y privadas. M√©todos de clase y m√©todos de instancia. Encapsulamiento. Herencia simple y m√∫ltiple. Polimorfismo. M√©todos especiales (dunder methods). Decoradores aplicados a m√©todos. Sobrecarga de operadores.\n\nUnidad 4: Estructuras de datos\n\nConcepto y clasificaci√≥n. Estructuras lineales: listas, listas enlazadas, pilas y colas. Operaciones b√°sicas: agregar, quitar y recorrer. Estructuras no lineales: √°rboles y grafos. Recorridos de √°rboles y grafos. Uso de colecciones de Python (list, deque, dict, set). Arreglos multidimensionales de NumPy.\n\nUnidad 5: Algoritmos de b√∫squeda y ordenamiento\n\nConcepto de algoritmo y complejidad. Notaci√≥n Big O. B√∫squeda lineal y binaria. Algoritmos de ordenamiento: bubble sort, insertion sort, selection sort, quick sort y merge sort. Comparaci√≥n de eficiencia. Funciones de b√∫squeda y ordenamiento en Python (sorted, sort, heapq).",
    "crumbs": [
      "Informaci√≥n",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/aprobacion.html",
    "href": "informacion/aprobacion.html",
    "title": "Condiciones de aprobaci√≥n",
    "section": "",
    "text": "üìù Examen parcial: individual y escrito. Hay un recuperatorio, de similares caracter√≠sticas, que reemplaza la nota del parcial.\nü§ù Trabajo pr√°ctico grupal: se hace fuera de clase, en grupos de entre dos y tres integrantes.\nüßë‚Äçüíª Trabajo pr√°ctico individual: opcional para promoci√≥n, con presentaci√≥n y defensa oral.\nTodas las instancias se califican en una escala de 0 a 10 y se aprueban con 6.",
    "crumbs": [
      "Informaci√≥n",
      "Condiciones de aprobaci√≥n"
    ]
  },
  {
    "objectID": "informacion/aprobacion.html#instancias-de-evaluaci√≥n",
    "href": "informacion/aprobacion.html#instancias-de-evaluaci√≥n",
    "title": "Condiciones de aprobaci√≥n",
    "section": "",
    "text": "üìù Examen parcial: individual y escrito. Hay un recuperatorio, de similares caracter√≠sticas, que reemplaza la nota del parcial.\nü§ù Trabajo pr√°ctico grupal: se hace fuera de clase, en grupos de entre dos y tres integrantes.\nüßë‚Äçüíª Trabajo pr√°ctico individual: opcional para promoci√≥n, con presentaci√≥n y defensa oral.\nTodas las instancias se califican en una escala de 0 a 10 y se aprueban con 6.",
    "crumbs": [
      "Informaci√≥n",
      "Condiciones de aprobaci√≥n"
    ]
  },
  {
    "objectID": "informacion/aprobacion.html#condiciones-de-aprobaci√≥n",
    "href": "informacion/aprobacion.html#condiciones-de-aprobaci√≥n",
    "title": "Condiciones de aprobaci√≥n",
    "section": "Condiciones de aprobaci√≥n",
    "text": "Condiciones de aprobaci√≥n\n\nPromoci√≥n\n\nQuienes aprueben el parcial individual (con nota \\(\\text{P}\\)), el trabajo pr√°ctico grupal (con nota \\(\\text{T}\\)) y el trabajo pr√°ctico individual con defensa oral (con nota \\(\\text{O}\\)), adquieren la condici√≥n de estudiante promovido y su nota final se calcula como \\(0.5 \\times \\text{P} + 0.2 \\times \\text{T} + 0.3 \\times \\text{O}\\).\n\nRegularidad\n\nQuienes aprueben el parcial individual (o su recuperatorio) y el trabajo pr√°ctico grupal, pero no accedan o no aprueben el trabajo pr√°ctico individual, adquieren la condici√≥n de estudiante regular.\n\nLibres\n\nQuienes no aprueben el parcial individual (ni su recuperatorio) o el trabajo pr√°ctico grupal, adquieren la condici√≥n de estudiante libre.",
    "crumbs": [
      "Informaci√≥n",
      "Condiciones de aprobaci√≥n"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html",
    "href": "trabajos_practicos/trabajo_grupal.html",
    "title": "Trabajo pr√°ctico grupal",
    "section": "",
    "text": "El objetivo de este trabajo pr√°ctico es implementar un decorador en Python que permita monitorear la ejecuci√≥n de funciones y luego utilizarlo en un programa que realiza operaciones de ordenamiento\nMonitorear la ejecuci√≥n del c√≥digo es una tarea fundamental en el desarrollo de software: permite detectar cuellos de botella de rendimiento, identificar funciones costosas y generar registros √∫tiles para el debugging o auditor√≠a.\nIncorporar herramientas de monitoreo desde etapas tempranas del desarrollo favorece la escritura de c√≥digo m√°s eficiente, mantenible y confiable.",
    "crumbs": [
      "Trabajos Pr√°cticos",
      "Trabajo pr√°ctico grupal"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html#objetivo",
    "href": "trabajos_practicos/trabajo_grupal.html#objetivo",
    "title": "Trabajo pr√°ctico grupal",
    "section": "",
    "text": "El objetivo de este trabajo pr√°ctico es implementar un decorador en Python que permita monitorear la ejecuci√≥n de funciones y luego utilizarlo en un programa que realiza operaciones de ordenamiento\nMonitorear la ejecuci√≥n del c√≥digo es una tarea fundamental en el desarrollo de software: permite detectar cuellos de botella de rendimiento, identificar funciones costosas y generar registros √∫tiles para el debugging o auditor√≠a.\nIncorporar herramientas de monitoreo desde etapas tempranas del desarrollo favorece la escritura de c√≥digo m√°s eficiente, mantenible y confiable.",
    "crumbs": [
      "Trabajos Pr√°cticos",
      "Trabajo pr√°ctico grupal"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html#decorador-monitor",
    "href": "trabajos_practicos/trabajo_grupal.html#decorador-monitor",
    "title": "Trabajo pr√°ctico grupal",
    "section": "2 Decorador monitor",
    "text": "2 Decorador monitor\nEl decorador a implementar se llamar√° monitor y deber√° ser capaz de registrar informaci√≥n sobre cada ejecuci√≥n de la funci√≥n decorada. Su interfaz contar√° con los siguientes argumentos:\n\nfuncion: la funci√≥n decorada o None. Por defecto, ser√° None. Su valor ser√° distinto None solo cuando se use el decorador sin argumentos.\nconsola (bool): indica si los mensajes se muestran por consola. Por defecto es True.\narchivo (str o None): nombre del archivo donde se escribir√°n los mensajes de monitoreo.\n\nPor defecto: None. En ese caso, no se guarda ning√∫n archivo.\n\nformato (str): cadena de formato que determina c√≥mo se construye el mensaje de monitoreo.\n\n\n2.1 Componentes del formato\nLa cadena de formato puede incluir los siguientes componentes:\n\n{tiempo}: fecha y hora de la llamada en formato YYYY-MM-DD HH:mm:ss.mss, donde mss son tres d√≠gitos para los milisegundos.\n{funcion}: nombre de la funci√≥n.\n{modulo}: nombre del m√≥dulo donde se define la funci√≥n.\n{duracion}: duraci√≥n total de la ejecuci√≥n en milisegundos.\n\nEl formato por defecto es:\nformato = \"({tiempo}) {funcion} demor√≥ {duracion} milisegundos.\"\n\n\n2.2 Ejemplos de formato\nformato = \"({tiempo}) {funcion} demor√≥ {duracion} milisegundos.\"\n# (2025-10-08 11:54:12.123) fun demor√≥ 735 milisegundos.\n\nformato = \"({tiempo}) {modulo}::{funcion} demor√≥ {duracion} milisegundos.\"\n# (2025-10-08 11:54:12.123) __main__::fun demor√≥ 735 milisegundos.\n\n\n2.3 Ejemplos\n# Ejemplo 1: comportamiento por defecto\n@monitor\ndef fun(x, y):\n    return x + y\n\n# Ejemplo 2: uso de archivo de registros\n@monitor(archivo=\"registros.log\")\ndef fun(x, y, z):\n    return x ** y * z\n\n# Ejemplo 3: uso de formato alternativo\nformato = \"({tiempo}) {modulo}::{funcion} demor√≥ {duracion} milisegundos.\"\n@monitor(archivo=\"registros.log\", formato=formato)\ndef fun(a, b):\n    return list(range(a, b))",
    "crumbs": [
      "Trabajos Pr√°cticos",
      "Trabajo pr√°ctico grupal"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html#aplicaci√≥n-monitoreo-de-algoritmos-de-ordenamiento",
    "href": "trabajos_practicos/trabajo_grupal.html#aplicaci√≥n-monitoreo-de-algoritmos-de-ordenamiento",
    "title": "Trabajo pr√°ctico grupal",
    "section": "3 Aplicaci√≥n: monitoreo de algoritmos de ordenamiento",
    "text": "3 Aplicaci√≥n: monitoreo de algoritmos de ordenamiento\nPara comprobar el correcto funcionamiento del decorador, se deben decorar las funciones merge_sort y bubble_sort, ambas encargadas de ordenar listas de n√∫meros de menor a mayor.\n\n3.1 Implementaci√≥n de los algoritmos\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if arr[j] &gt; arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n    return arr\n\ndef _merge_sort(arr):\n    if len(arr) &lt;= 1:\n        return arr\n\n    mitad = len(arr) // 2\n    izquierda = _merge_sort(arr[:mitad])\n    derecha = _merge_sort(arr[mitad:])\n\n    return merge(izquierda, derecha)\n\ndef merge(izquierda, derecha):\n    resultado = []\n    i = 0\n    j = 0\n\n    while i &lt; len(izquierda) and j &lt; len(derecha):\n        if izquierda[i] &lt; derecha[j]:\n            resultado.append(izquierda[i])\n            i += 1\n        else:\n            resultado.append(derecha[j])\n            j += 1\n\n    resultado.extend(izquierda[i:])\n    resultado.extend(derecha[j:])\n\n    return resultado\n\ndef merge_sort(arr):\n    return _merge_sort(arr)\n\n\n3.2 Generaci√≥n de datos de prueba\nPara generar secuencias de n√∫meros aleatorios se utilizar√° la funci√≥n crear_numeros:\nimport random\n\ndef crear_numeros(n):\n    return [random.random() for _ in range(n)]",
    "crumbs": [
      "Trabajos Pr√°cticos",
      "Trabajo pr√°ctico grupal"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html#ejecuci√≥n-del-programa",
    "href": "trabajos_practicos/trabajo_grupal.html#ejecuci√≥n-del-programa",
    "title": "Trabajo pr√°ctico grupal",
    "section": "4 Ejecuci√≥n del programa",
    "text": "4 Ejecuci√≥n del programa\nFinalmente, se debe implementar un script llamado programa.py que se ejecute desde la terminal. Este programa generar√° secuencias aleatorias de diferentes tama√±os, las ordenar√° utilizando ambos algoritmos y registrar√° el monitoreo correspondiente.\nEjemplo de ejecuci√≥n:\npython programa.py -n 100 1000 5000 10000 -o monitoreo.log\n\nCon -n se especifica una lista de tama√±os de secuencias a generar.\nCon -o se indica el nombre del archivo donde se deben guardar los mensajes de monitoreo.\n\nSi no se especifica, no se guardan los mensajes en ning√∫n archivo.\n\nCon --silencio",
    "crumbs": [
      "Trabajos Pr√°cticos",
      "Trabajo pr√°ctico grupal"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html#entregable",
    "href": "trabajos_practicos/trabajo_grupal.html#entregable",
    "title": "Trabajo pr√°ctico grupal",
    "section": "5 Entregable",
    "text": "5 Entregable\nLa entrega de este trabajo pr√°ctico debe consistir exclusivamente en un archivo .zip que contiene los siguientes archivos, con estos nombres y contenidos exactos:\n\nmonitor.py: contiene la implementaci√≥n del decorador monitor y todas las funciones auxiliares necesarias para su funcionamiento.\nprograma.py: contiene las funciones de ordenamiento (merge_sort y bubble_sort) y la implementaci√≥n de la interfaz de l√≠nea de comandos (CLI) que admite los argumentos -n y -o.\nsalida.log: archivo generado al ejecutar el programa con el siguiente comando:\npython programa.py -n 100 1000 5000 10000 -o salida.log\n\nNo se deben incluir archivos adicionales ni con nombres distintos a los especificados.\nEl nombre del archivo .zip debe seguir el siguiente formato:\nG{n}_{Apellido1}_{Apellido2}_{Apellido3}.zip\ndonde:\n\n{n} es el n√∫mero de grupo asignado.\n{Apellido1}, {Apellido2}, {Apellido3} son los apellidos de los integrantes del grupo.\n\nPor ejemplo:\nG1_Demicco_Gonzalez_Messi.zip",
    "crumbs": [
      "Trabajos Pr√°cticos",
      "Trabajo pr√°ctico grupal"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html#evaluaci√≥n",
    "href": "trabajos_practicos/trabajo_grupal.html#evaluaci√≥n",
    "title": "Trabajo pr√°ctico grupal",
    "section": "6 Evaluaci√≥n",
    "text": "6 Evaluaci√≥n\nLa evaluaci√≥n contempla no solo la correcta ejecuci√≥n del programa, sino tambi√©n la calidad del c√≥digo desarrollado, considerando aspectos como la organizaci√≥n, claridad, robustez y el uso de estructuras de datos y algoritmos apropiados\nAdem√°s, el programa ser√° ejecutado desde la l√≠nea de comandos con otros valores de entrada para verificar su correcto funcionamiento en diferentes situaciones.",
    "crumbs": [
      "Trabajos Pr√°cticos",
      "Trabajo pr√°ctico grupal"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html#ayuda",
    "href": "trabajos_practicos/trabajo_grupal.html#ayuda",
    "title": "Trabajo pr√°ctico grupal",
    "section": "7 Ayuda",
    "text": "7 Ayuda\n\nDado que el decorador tiene que poder usarse de las siguientes dos maneras:\n@monitor\ndef f(...):\n    ...\n\n@monitor(archivo=\"registros.log\")\ndef f(...):\n    ...\nser√° necesario inspeccionar si el argumento funcion de monitor es una funci√≥n o no. Para ello, puede usar:\nif callable(funcion):\n    # accion\nConsidere el m√©todo .format de las cadenas de caracteres para usar el formato pasado al decorador.\nAlgunos enlaces √∫tiles:\n\nUso de c√≥digo externo\nScripting\nLectura y escritura de archivos\nDecoradores\nF√°brica de decoradores",
    "crumbs": [
      "Trabajos Pr√°cticos",
      "Trabajo pr√°ctico grupal"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programaci√≥n II",
    "section": "",
    "text": "Programaci√≥n II\n\n\n ¬† Ciclo de Formaci√≥n T√©cnica - Estad√≠stica y Ciencia de Datos\n ¬† Facultad de Ciencias Econ√≥micas y Estad√≠stica (UNR)\n ¬† 2¬∞ Cuatrimestre 2025"
  },
  {
    "objectID": "index.html#docentes",
    "href": "index.html#docentes",
    "title": "Programaci√≥n II",
    "section": "Docentes",
    "text": "Docentes\n\n\nTom√°s Capretto\n\n ¬† tomas.capretto@fcecon.unr.edu.ar \n\n\n\nLuciano Anselmino\n\n ¬† luciano.anselmino@fcecon.unr.edu.ar \n\n\n\nJoaqu√≠n Bermejo\n\n ¬† joaquin.bermejo@fcecon.unr.edu.ar \n\n\n\nDolores Sollberger\n\n ¬† dolores.sollberger@fcecon.unr.edu.ar"
  },
  {
    "objectID": "informacion/bibliografia.html",
    "href": "informacion/bibliografia.html",
    "title": "Bibliograf√≠a",
    "section": "",
    "text": "Principal\n\nCormen et¬†al. (2022) Downey (2024) Kalb (2022) Kubica (2022) Lott y Phillips (2021) Lott (2022) Mertz (2015) Miller, Ranum, y Yasinovskyy (2023) Sedgewick y Wayne (2011) Sedgewick, Wayne, y Dondero (2015) Sweigart (2020) Tuckfield (2021)\n\n\n\nCormen, Thomas H., Charles E. Leiserson, Ronald L. Rivest, y Clifford Stein. 2022. Introduction to Algorithms. 4th ed. MIT.\n\n\nDowney, Allen B. 2024. Think Python. 3.¬™ ed. O‚ÄôReilly Media. https://allendowney.github.io/ThinkPython/.\n\n\nKalb, Irv. 2022. Object-Oriented Python. No Starch Press.\n\n\nKubica, Jacek. 2022. Data Structures the Fun Way. 1st ed. No Starch Press.\n\n\nLott, Steven F. 2022. Functional Python Programming. 3rd ed. Packt Publishing.\n\n\nLott, Steven F., y Dusty Phillips. 2021. Python Object-Oriented Programming. 4th ed. Packt Publishing.\n\n\nMertz, David. 2015. Functional Programming in Python. O‚ÄôReilly Media.\n\n\nMiller, Bradley, David Ranum, y Jan Yasinovskyy. 2023. Problem Solving with Algorithms and Data Structures Using Python. 3rd ed. Franklin, Beedle & Associates.\n\n\nSedgewick, Robert, y Kevin Wayne. 2011. Algorithms. 4th ed. Addison-Wesley Professional.\n\n\nSedgewick, Robert, Kevin Wayne, y Robert Dondero. 2015. Introduction to Programming in Python. Addison-Wesley Professional.\n\n\nSweigart, Al. 2020. Beyond the Basic Stuff with Python. No Starch Press. https://inventwithpython.com/beyond/.\n\n\nTuckfield, Bradford. 2021. Dive Into Algorithms. No Starch Press.\n\n\n\n\nComplementaria\n\nHetland (2014) Mailund (2023) Sweigart (2021) Vaughan (2019) Wickham (2019)\n\n\n\n\n\nHetland, Magnus Lie. 2014. Python Algorithms. 2.¬™ ed. Apress.\n\n\nMailund, Thomas. 2023. Functional Programming in R 4. 2.¬™ ed. Apress.\n\n\nSweigart, Al. 2021. The Big Book of Small Python Projects. No Starch Press. https://inventwithpython.com/bigbookpython/.\n\n\nVaughan, Lee. 2019. Impractical Python Projects. No Starch Press.\n\n\nWickham, Hadley. 2019. Advanced R. 2.¬™ ed. Chapman & Hall/CRC. https://adv-r.hadley.nz/.",
    "crumbs": [
      "Informaci√≥n",
      "Bibliograf√≠a"
    ]
  },
  {
    "objectID": "informacion/calendario.html",
    "href": "informacion/calendario.html",
    "title": "Calendario",
    "section": "",
    "text": "Semana\nFecha\nTemas\nOtras actividades\n\n\n\n\n1\n4 de agosto\n‚Ä¢ Lenguaje Python y su ecosistema.‚Ä¢ Uso de Python en la terminal.‚Ä¢ Uso de Positron.‚Ä¢ Python en Positron.‚Ä¢ Python: expresiones; variables y asignaciones; tipos de datos elementales; operadores num√©ricos, de comparaci√≥n y l√≥gicos.‚Ä¢ Jupyter Notebooks.‚Ä¢ Definici√≥n de funciones.‚Ä¢ Ejecuci√≥n condicional de c√≥digo.\n\n\n\n2\n11 de agosto\n‚Ä¢ Colecciones de datos en Python: list, tuple, dict y set.‚Ä¢ Secuencias.‚Ä¢ Las secuencias str y range.‚Ä¢ Bucles definidos (for) y no definidos (while).‚Ä¢ Sentencias break y continue.\n\n\n\n3\n17 de agosto\n‚Ä¢ Uso de c√≥digo externo (propio y de terceros).‚Ä¢ M√≥dulos y librer√≠as.‚Ä¢ Librer√≠a est√°ndar de Python.‚Ä¢ Instalaci√≥n y gesti√≥n de librer√≠as.‚Ä¢ Scripting.‚Ä¢ Modularizaci√≥n de programas.‚Ä¢ Lectura y escritura de archivos de texto plano.\n\n\n\n4\n25 de agosto\n‚Ä¢ Funciones como ciudadanos de primera clase.‚Ä¢ Funciones puras.‚Ä¢ Funciones an√≥nimas.‚Ä¢ Closures.‚Ä¢ Recursi√≥n.\n\n\n\n5\n1 de septiembre\n‚Ä¢ Funciones de orden superior: map, filter, reduce.‚Ä¢ Evaluaci√≥n estricta y no estricta.‚Ä¢ Evaluaci√≥n perezosa (lazy) e inmediata (eager).‚Ä¢ Generadores.‚Ä¢ Aplicaci√≥n parcial de funciones.‚Ä¢ Decoradores.\n\n\n\n6\n15 de septiembre\n‚Ä¢ Objetos, clases e instancias.‚Ä¢ Atributos y m√©todos.‚Ä¢ Propiedades p√∫blicas y privadas.‚Ä¢ M√©todos de clase y m√©todos de instancia.\n\n\n\n7\n22 de septiembre\n‚Ä¢ Encapsulamiento.‚Ä¢ Herencia simple y m√∫ltiple.‚Ä¢ Polimorfismo.‚Ä¢ Abstracci√≥n.\n\n\n\n8\n29 de septiembre\n‚Ä¢ M√©todos especiales (dunder methods).‚Ä¢ Decoradores aplicados a m√©todos.‚Ä¢ Sobrecarga de operadores.\nParcial\n\n\n9\n6 de octubre\n‚Ä¢ Concepto y clasificaci√≥n.‚Ä¢ Estructuras lineales y no lineales.‚Ä¢ Listas y listas enlazadas.‚Ä¢ Operaciones b√°sicas: agregar, quitar y recorrer.\nPresentaci√≥n TP Grupal\n\n\n10\n13 de octubre\n‚Ä¢ Hashing.‚Ä¢ Diccionarios y conjuntos como estructuras asociativas.‚Ä¢ √Årboles y grafos.\nRecuperatorio\n\n\n11\n20 de octubre\n‚Ä¢ Arreglos multidimensionales de NumPy.\n\n\n\n12\n27 de octubre\n‚Ä¢ Concepto de algoritmo y complejidad.‚Ä¢ Algoritmos de b√∫squeda.‚Ä¢ B√∫squeda lineal y binaria.‚Ä¢ Notaci√≥n Big O.\n\n\n\n13\n3 de noviembre\n‚Ä¢ Algoritmos de ordenamiento.‚Ä¢ bubble sort, insert sort, select sort, quick sort y merge sort.‚Ä¢ Comparaci√≥n de algoritmos de ordenamiento.\nEntrega TP GrupalPresentaci√≥n TP Individual\n\n\n14\n10 de noviembre\n‚Ä¢ Funciones de b√∫squeda y ordenamiento en Python.\n\n\n\n15\n17 de noviembre\n\n\n\n\n16\n24 de noviembre\n\nEntrega y defensa TP Individual",
    "crumbs": [
      "Informaci√≥n",
      "Calendario"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html",
    "href": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html",
    "title": "4 - Estrategias de evaluaci√≥n üß©",
    "section": "",
    "text": "En este breve cap√≠tulo vamos a explorar las diferentes estrategias de evaluaci√≥n que utiliza Python. En programaci√≥n, una estrategia de evaluaci√≥n es el conjunto de reglas que define c√≥mo y cu√°ndo se calculan las expresiones.\nAnalizaremos la evaluaci√≥n inmediata (eager) y la evaluaci√≥n perezosa (lazy), as√≠ como la diferencia entre evaluaci√≥n estricta y no estricta.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "4 - Estrategias de evaluaci√≥n üß©"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#introducci√≥n",
    "href": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#introducci√≥n",
    "title": "4 - Estrategias de evaluaci√≥n üß©",
    "section": "",
    "text": "En este breve cap√≠tulo vamos a explorar las diferentes estrategias de evaluaci√≥n que utiliza Python. En programaci√≥n, una estrategia de evaluaci√≥n es el conjunto de reglas que define c√≥mo y cu√°ndo se calculan las expresiones.\nAnalizaremos la evaluaci√≥n inmediata (eager) y la evaluaci√≥n perezosa (lazy), as√≠ como la diferencia entre evaluaci√≥n estricta y no estricta.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "4 - Estrategias de evaluaci√≥n üß©"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluaci√≥n-estricta",
    "href": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluaci√≥n-estricta",
    "title": "4 - Estrategias de evaluaci√≥n üß©",
    "section": "Evaluaci√≥n estricta",
    "text": "Evaluaci√≥n estricta\nSupongamos una funci√≥n a la que le pasamos dos n√∫meros a y b y nos devuelve una lista con todos los enteros entre a y b.\n\ndef intervalo(a, b):\n    return list(range(a, b + 1))\n\nintervalo(5, 12)\n\n[5, 6, 7, 8, 9, 10, 11, 12]\n\n\nPara cumplir su objetivo, esta funci√≥n solo necesita los valores a y b. Pero, ¬øqu√© pasar√≠a si por error le agregamos otro par√°metro y despu√©s la llamamos sin darle ning√∫n valor para ese par√°metro?\n\ndef intervalo(a, b, c):\n    return list(range(a, b + 1))\n\nintervalo(5, 12)\n\n    intervalo(5, 12)\n    ~~~~~~~~~^^^^^^^\nTypeError: intervalo() missing 1 required positional argument: 'c'\n\nPython devuelve un error indicando que la funci√≥n intervalo no puede ejecutarse porque falta un valor para el par√°metro c. Aunque sepamos que dicho par√°metro no se utiliza dentro de la funci√≥n, Python igualmente exige que se le pase un valor.\nEsta exigencia se debe a que las funciones de Python se eval√∫an bajo las reglas de la evaluaci√≥n estricta. Bajo este enfoque, una funci√≥n no puede producir un resultado si alguno de sus par√°metros no est√° definido. Por eso, aun cuando el valor de c nunca se use en el cuerpo de la funci√≥n, la ausencia de un valor para √©l provoca un error.\nPara que la funci√≥n se ejecute correctamente, basta con pasarle cualquier valor:\n\nintervalo(5, 12, None)\n\n[5, 6, 7, 8, 9, 10, 11, 12]\n\n\nEn Python, todas las llamadas a funciones siguen la estrategia de evaluaci√≥n estricta, y esto no es algo que podamos modificar: forma parte del dise√±o del lenguaje. De todas formas, como veremos m√°s adelante, existen ciertas construcciones del propio lenguaje que aplican una estrategia de evaluaci√≥n no estricta.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "4 - Estrategias de evaluaci√≥n üß©"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluaci√≥n-inmediata",
    "href": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluaci√≥n-inmediata",
    "title": "4 - Estrategias de evaluaci√≥n üß©",
    "section": "Evaluaci√≥n inmediata",
    "text": "Evaluaci√≥n inmediata\nOtro aspecto interesante al trabajar con funciones es el momento en que se eval√∫an los argumentos que se pasan en las llamadas.\nTomemos de nuevo nuestra funci√≥n original:\ndef intervalo(a, b):\n    return list(range(a, b + 1))\ny la siguiente llamada:\nintervalo(1 + 3, 5 + 12)\nLa pregunta es: ¬øqu√© pasa primero? ¬øSe ejecuta la funci√≥n intervalo y reci√©n ah√≠ se resuelven las expresiones 1 + 3 y 5 + 12, o esas expresiones se calculan antes y luego se pasan sus resultados a la funci√≥n?\nPara aclarar esta duda, en lugar de usar una suma directa podemos probar con una funci√≥n que sume pero que, adem√°s, imprima los argumentos que recibe. Del mismo modo, podemos modificar la funci√≥n intervalo para que muestre un mensaje cuando sea llamada y as√≠ ver con m√°s claridad el orden en que ocurren las cosas.\n\ndef suma(x, y):\n    print(f\"suma(x={x}, y={y})\")\n    return x + y\n\n\ndef intervalo(a, b):\n    print(f\"intervalo(a={a}, b={b})\")\n    return list(range(a, b + 1))\n\nintervalo(suma(1, 3), suma(5, 12))\n\nsuma(x=1, y=3)\nsuma(x=5, y=12)\nintervalo(a=4, b=17)\n\n\n[4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]\n\n\nPor el orden en que aparecen los mensajes impresos, vemos que Python primero ejecut√≥ la llamada suma(1, 3), luego suma(5, 12) y reci√©n despu√©s invoc√≥ a la funci√≥n intervalo, ya recibiendo los valores resultantes de las llamadas a suma.\nEn otras palabras, antes de llamar a intervalo, Python evalu√≥ las expresiones que se pasaron como argumentos.\nA esta estrategia de evaluaci√≥n, donde los argumentos se resuelven antes de ejecutar la funci√≥n, se la conoce como evaluaci√≥n inmediata, o por su nombre en ingl√©s, eager evaluation.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "4 - Estrategias de evaluaci√≥n üß©"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluaci√≥n-no-estricta",
    "href": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluaci√≥n-no-estricta",
    "title": "4 - Estrategias de evaluaci√≥n üß©",
    "section": "Evaluaci√≥n no estricta",
    "text": "Evaluaci√≥n no estricta\nEn contraste con la evaluaci√≥n estricta, la evaluaci√≥n no estricta es una estrategia en la que se puede determinar el resultado de una expresi√≥n sin necesidad de evaluar todos sus argumentos u operandos.\nEn Python, solo tres tipos de expresiones siguen esta estrategia: and, or y las expresiones condicionales.\nEn los siguientes ejemplos, vamos a utilizar una funci√≥n que imprime el valor ingresado y lo devuelve:\n\ndef f(x):\n    print(f\"el valor es {x}\")\n    return x\n\n\nExpresi√≥n and\nUna expresi√≥n and devuelve True √∫nicamente cuando todos sus argumentos son verdaderos. Por eso, en el siguiente ejemplo, se imprime el valor es True antes de obtener el resultado de la operaci√≥n and, ya que fue necesario evaluar la funci√≥n f.\n\nTrue and f(True)\n\nel valor es True\n\n\nTrue\n\n\nEn cambio, cuando el primero de sus argumentos es False, se puede anticipar que el resultado de la operaci√≥n and ser√° False, sin necesidad de evaluar el segundo argumento. Por este motivo, la funci√≥n f no se ejecuta en ninguno de los siguientes casos, al punto de que podemos pasarle argumentos absurdos:\n\nFalse and f(True)\n\nFalse\n\n\n\nFalse and f(1 / 0)\n\nFalse\n\n\nEn Python, este mecanismo tambi√©n se conoce como cortocircuito. Al detectar que el resultado de la operaci√≥n ya est√° decidido con el primer argumento, el int√©rprete ‚Äúcorta camino‚Äù y decide no evaluar al resto.\n\n\nExpresi√≥n or\nEl mecanismo de cortocircuito tambi√©n funciona para el operador or:\n\n# El primer argumento es True, el resultado es True\nTrue or f(True)\n\nTrue\n\n\n\n# El primer arugmento es False, hay que evaluar el segundo para determinar el resultado\nFalse or f(True)\n\nel valor es True\n\n\nTrue\n\n\nLas mismas reglas de evaluaci√≥n se mantienen en expresiones m√°s complejas. En el siguiente ejemplo, es necesario ejecutar f(True) para poder resolver el primer or, pero no hace falta evaluar 1 + [2, 3], que provocar√≠a un error, porque el valor True ya alcanza para determinar el resultado de toda la operaci√≥n.\n\nFalse or f(True) or (1 + [2, 3])\n\nel valor es True\n\n\nTrue\n\n\n\n\nExpresiones condicionales\nFinalmente, esta estrategia de evaluaci√≥n no estricta (o cortocircuito) tambi√©n se aplica en las expresiones condicionales.\nEn el siguiente ejemplo, la expresi√≥n devuelve 10 porque la condici√≥n es verdadera, sin necesidad de ejecutar f(20).\n\n10 if True else f(20)\n\n10\n\n\nEn cambio, esta segunda expresi√≥n s√≠ requiere que se ejecute la llamada en la parte else de la expresi√≥n.\n\n10 if False else f(20)\n\nel valor es 20\n\n\n20",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "4 - Estrategias de evaluaci√≥n üß©"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluaci√≥n-perezosa",
    "href": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluaci√≥n-perezosa",
    "title": "4 - Estrategias de evaluaci√≥n üß©",
    "section": "Evaluaci√≥n perezosa",
    "text": "Evaluaci√≥n perezosa\nPara terminar, veamos una √∫ltima estrategia de evaluaci√≥n: la evaluaci√≥n perezosa (en ingl√©s, lazy evaluation).\nPartimos de una funci√≥n que recibe un valor, imprime un mensaje con √©l y lo devuelve:\ndef identidad(x):\n    print(\"Devuelvo\", x)\n    return x\nSi usamos map para aplicar la funci√≥n identidad a los n√∫meros 0, 1, 2 y 3:\nmap_obj = map(identidad, range(4))\nmap_obj\n&lt;map at 0x7fedb41f3cd0&gt;\nvemos que se crea un objeto map, pero no aparece ning√∫n mensaje de la funci√≥n identidad. Esto pasa porque map no ejecuta la funci√≥n sobre los elementos hasta que realmente hace falta.\nPor ejemplo, si convertimos el objeto map en una lista, reci√©n ah√≠ se produce la evaluaci√≥n:\nlista = list(map_obj)\nDevuelvo 0\nDevuelvo 1\nDevuelvo 2\nDevuelvo 3\nlista\n[0, 1, 2, 3]\nA esta estrategia, en la que se retrasa la evaluaci√≥n de las expresiones hasta el √∫ltimo momento posible, se la llama evaluaci√≥n perezosa o lazy evaluation.\nDe manera similar, filter tambi√©n utiliza una estrategia de evaluaci√≥n perezosa. Reci√©n cuando queremos materializar los elementos se aplica la funci√≥n de filtro.\n\ndef es_multiplo_5(x):\n    print(f\"x={x}\")\n    return x % 5  ==0\n\nfilter_obj = filter(es_multiplo_5, [12, 10, 8, 5, 125, 55, 11, 9])\n\n\nfor x in filter_obj:\n    print(f\"El numero {x} es m√∫ltiplo de 5\")\n\nx=12\nx=10\nEl numero 10 es m√∫ltiplo de 5\nx=8\nx=5\nEl numero 5 es m√∫ltiplo de 5\nx=125\nEl numero 125 es m√∫ltiplo de 5\nx=55\nEl numero 55 es m√∫ltiplo de 5\nx=11\nx=9\n\n\nComo se puede ver, la funci√≥n es_multiplo_5 se ejecut√≥ para cada valor de la lista num√©rica, pero filter √∫nicamente devolvi√≥ aquellos que efectivamente son m√∫ltiplos de 5.\nEn el pr√≥ximo y √∫ltimo cap√≠tulo vamos a explorar los generadores, un tipo especial de iterador que implementa una estrategia de evaluaci√≥n perezosa y nos permite recorrer secuencias incluso potencialmente infinitas.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "4 - Estrategias de evaluaci√≥n üß©"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html",
    "href": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html",
    "title": "3 - Funciones de orden superior",
    "section": "",
    "text": "Las funciones de orden superior son una herramienta muy importante en la programaci√≥n funcional. A lo largo de esta unidad, trabajaremos con las siguientes variedades de funciones de orden superior:\n\nFunciones que aceptan funciones como argumentos.\nFunciones que devuelven una funci√≥n como resultado.\nFunciones que aceptan funciones como argumentos y devuelven una funci√≥n como resultado.\n\nEn este cap√≠tulo comenzamos enfoc√°ndonos en las funciones de orden superior m√°s elementales: map, filter y reduce; todas ellas reciben funciones como argumentos. Luego, aprenderemos sobre las comprehensions, que constituyen la alternativa moderna y Pythonica a las funciones mencionadas anteriormente. Finalmente, trabajaremos con funciones que devuelven funciones cuando exploremos evaluaci√≥n parcial de funciones y el uso de decoradores.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "3 - Funciones de orden superior"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#introducci√≥n",
    "href": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#introducci√≥n",
    "title": "3 - Funciones de orden superior",
    "section": "",
    "text": "Las funciones de orden superior son una herramienta muy importante en la programaci√≥n funcional. A lo largo de esta unidad, trabajaremos con las siguientes variedades de funciones de orden superior:\n\nFunciones que aceptan funciones como argumentos.\nFunciones que devuelven una funci√≥n como resultado.\nFunciones que aceptan funciones como argumentos y devuelven una funci√≥n como resultado.\n\nEn este cap√≠tulo comenzamos enfoc√°ndonos en las funciones de orden superior m√°s elementales: map, filter y reduce; todas ellas reciben funciones como argumentos. Luego, aprenderemos sobre las comprehensions, que constituyen la alternativa moderna y Pythonica a las funciones mencionadas anteriormente. Finalmente, trabajaremos con funciones que devuelven funciones cuando exploremos evaluaci√≥n parcial de funciones y el uso de decoradores.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "3 - Funciones de orden superior"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#pilares-fundamentales",
    "href": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#pilares-fundamentales",
    "title": "3 - Funciones de orden superior",
    "section": "Pilares fundamentales",
    "text": "Pilares fundamentales\nLas funciones map, filter y reduce son funciones de orden superior fundamentales en la programaci√≥n funcional. Act√∫an como primitivas b√°sicas para procesar y transformar secuencias, y muchas otras operaciones funcionales pueden construirse a partir de ellas o expresarse en t√©rminos de estas.\nLas primeras dos, map y filter, est√°n disponibles por defecto en nuestra sesi√≥n de Python (ya que son funciones built-in), mientras que a reduce la tenemos que importar desde el m√≥dulo est√°ndar functools.\n\nMap\nSupongamos que tenemos una secuencia de palabras y queremos invertir el orden de los caracteres de cada una. Para ello, vamos a rebanadar cada cadena desde el principio al final usando un paso de -1. Por ejemplo:\n\n\"cosa\"[::-1]\n\n'asoc'\n\n\nSi quisi√©ramos obtener una lista con las palabras invertidas, podr√≠amos crear una nueva lista, recorrer la original con un bucle for, invertir cada palabra y guardarla en la lista nueva.\n\npalabras = [\"hola\", \"mate\", \"somos\",\" libro\", \"conocer\", \"anilina\", \"programa\"]\npalabras_invertidas = []\n\nfor palabra in palabras:\n    palabras_invertidas.append(palabra[::-1])\n\nprint(\"Palabras originales:\", palabras, \"\\n\", sep=\"\\n\")\nprint(\"Palabras invertidas:\", palabras_invertidas, sep=\"\\n\")\n\nPalabras originales:\n['hola', 'mate', 'somos', ' libro', 'conocer', 'anilina', 'programa']\n\n\nPalabras invertidas:\n['aloh', 'etam', 'somos', 'orbil ', 'reconoc', 'anilina', 'amargorp']\n\n\nLa alternativa funcional consiste en utilizar map para aplicar una funci√≥n a cada palabra de la secuencia. En este caso, aplicamos la funci√≥n invertir, que invierte los caracteres de una palabra, a cada elemento de la lista palabras.\n\ndef invertir(x):\n    return x[::-1]\n\nlist(map(invertir, palabras))\n\n['aloh', 'etam', 'somos', 'orbil ', 'reconoc', 'anilina', 'amargorp']\n\n\nAs√≠, se obtiene una nueva lista con las palabras invertidas, sin necesidad de iterar manualmente con un bucle for.\nSi quisi√©ramos que el programa fuese a√∫n m√°s conciso, podr√≠amos usar una funci√≥n an√≥nima en vez de una funci√≥n regular:\n\nlist(map(lambda x: x[::-1], palabras))\n\n['aloh', 'etam', 'somos', 'orbil ', 'reconoc', 'anilina', 'amargorp']\n\n\n\n\n\n\n\n\nEl objeto map üîç\n\n\n\nEn el ejemplo anterior usamos list para convertir el resultado de map en una lista. Este paso, que puede parecer innecesario, es fundamental si queremos obtener una lista como resultado final. De lo contrario, la llamada a map devuelve un objeto de tipo map.\nmap(lambda x: x[::-1], palabras)\n&lt;map object at 0x7fd2fc1ad360&gt;\nEste objeto, perezoso e iterable, puede recorrerse o convertirse en otras colecciones como listas, tuplas o conjuntos:\nlist(map(lambda x: x[::-1], palabras))\n['aloh', 'etam', 'somos', 'orbil ', 'reconoc', 'anilina', 'amargorp']\n\n\n\nmap con datos complejos\nEn el ejemplo anterior se us√≥ map sobre una secuencia simple de cadenas de texto. Sin embargo, eso no implica que su uso se limite a casos sencillos.\nSupongamos ahora que tenemos una lista anidada de n√∫meros, es decir, una lista que contiene otras listas con valores num√©ricos:\n\nventas = [\n    [22.5, 9.3, 11.0],\n    [5.4, 22.5],\n    [3.0, 3.0, 12.9, 7.5],\n]\n\nSi queremos calcular el total de cada sublista, podemos combinar map con la funci√≥n sum. Esto aplica sum a cada elemento de la lista ventas, generando como resultado una nueva lista con los totales de cada sublista.\n\nlist(map(sum, ventas))\n\n[42.8, 27.9, 26.4]\n\n\nDe manera similar, se puede obtener el m√≠nimo, el m√°ximo, la media u otra medida de inter√©s aplicando la funci√≥n correspondiente a cada sublista.\nUsando una combinaci√≥n m√°s compleja de maps y expresiones lambda, se puede determinar cu√°les sublistas de ventas contienen al menos un valor mayor a 20.\n\nlist(\n    map(\n        lambda sublista: any(map(lambda x: x &gt; 20,  sublista)),\n        ventas\n    )\n)\n\n[True, True, False]\n\n\nComo puede observarse, un programa que utiliza map junto con expresiones lambda puede volverse dif√≠cil de leer y comprender r√°pidamente, especialmente a medida que la l√≥gica se vuelve m√°s compleja.\nPara finalizar este listado de ejemplos, observemos uno donde se crea un diccionario a partir del map, en vez de una lista.\nSe cuenta con una lista de diccionarios. Cada diccionario contiene el nombre y las calificaciones de una persona. Nuestro objetivo es obtener un nuevo diccionario que tenga por claves al nombre de la persona, y por valor a la nota promedio.\n\nnotas = [\n    {\n        \"nombre\": \"Mariano\",\n        \"notas\": [6, 9, 9, 8]\n    },\n    {\n        \"nombre\": \"Daniela\",\n        \"notas\": [6, 7, 7, 8]\n    },\n    {\n        \"nombre\": \"Sof√≠a\",\n        \"notas\": [8, 6, 9, 8]\n    },\n]\n\nSin utilizar un enfoque funcional, una soluci√≥n posible es la siguiente:\n\ndef media(x):\n    return sum(x) / len(x)\n\npromedios = {}\n\nfor datum in notas:\n    promedios[datum[\"nombre\"]] = media(datum[\"notas\"])\n\npromedios\n\n{'Mariano': 8.0, 'Daniela': 7.0, 'Sof√≠a': 7.75}\n\n\nEn cambio, utilizando map:\n\ndict(map(lambda datum: (datum[\"nombre\"], media(datum[\"notas\"])), notas))\n\n{'Mariano': 8.0, 'Daniela': 7.0, 'Sof√≠a': 7.75}\n\n\nLa clave est√° en notar que la expresi√≥n lambda devuelve una tupla de dos elementos, donde el primero es el nombre y el segundo, la nota promedio. A partir de estos pares (str, float), dict puede construir directamente un diccionario con los str en las claves y los float en los valores.\n\n\nmap con m√∫ltiples iterabes\nHasta ahora hemos utilizado map con funciones que se aplican sobre los elementos de un √∫nico iterable. Sin embargo, map tambi√©n acepta m√∫ltiples iterables y los recorre en paralelo, lo que la convierte en una funci√≥n vari√°dica. De este modo, se puede usar map para aplicar funciones que toman m√°s de un argumento.\nSupongamos que queremos redondear un listado de n√∫meros utilizando diferentes niveles de precisi√≥n. Para redondear un √∫nico n√∫mero podemos usar directamente round:\n\nround(29.12951138, 4)\n\n29.1295\n\n\nSi quisi√©ramos redonear m√∫ltiples n√∫meros en una lista, usando el mismo nivel de precisi√≥n, podemos usar map y round:\n\nnumeros = [\n    30.60726375,\n    78.12297368,\n    61.94972186,\n    68.78842783,\n    55.60016942,\n    94.9760221,\n    90.41151716,\n    38.72727347,\n    21.30193307,\n    66.39407577\n]\nlist(map(lambda x: round(x, 3), numeros))\n\n[30.607, 78.123, 61.95, 68.788, 55.6, 94.976, 90.412, 38.727, 21.302, 66.394]\n\n\n¬øY si quisi√©ramos aplicar diferentes niveles de precisi√≥n a cada n√∫mero? Para ello, tambi√©n podemos usar map. Definimos una funci√≥n que reciba dos argumentos y luego iteramos en paralelo sobre dos iterables: uno con los n√∫meros y otro con las precisiones correspondientes.\n\nprecisiones = [2, 2, 3, 3, 4, 4, 5, 5, 2, 2]\nlist(map(lambda x, y: round(x, y), numeros, precisiones))\n\n[30.61, 78.12, 61.95, 68.788, 55.6002, 94.976, 90.41152, 38.72727, 21.3, 66.39]\n\n\n\n\n\n\n\n\n¬øQu√© pasa si un iterable es m√°s corto que el otro? ü§î\n\n\n\nCuando se recorren m√∫ltiples iterables con map, la iteraci√≥n se detiene tan pronto como se agota el iterable m√°s corto. Por ejemplo, si tenemos 10 n√∫meros pero solo 5 precisiones, map aplicar√° la funci√≥n √∫nicamente a los primeros 5 pares de elementos:\nprecisiones = [1, 2, 3, 4, 5]\nlist(map(lambda x, y: round(x, y), numeros, precisiones))\n[30.6, 78.12, 61.95, 68.7884, 55.60017]\n\n\n\n\n\nFilter\nfilter se utiliza para seleccionar ‚Äîo, m√°s precisamente, filtrar‚Äî elementos de un iterable seg√∫n el resultado de aplicar una funci√≥n. A diferencia de map, la funci√≥n usada por filter se aplica sobre los elementos de un solo iterable y debe devolver un valor booleano. El resultado es un nuevo iterable que contiene √∫nicamente los elementos para los que la funci√≥n retorna True.\nComo ejemplo del uso de filter, vamos a seleccionar las notas menores a 6 a partir de una lista de calificaciones.\n\nnotas = [6, 9, 6, 5, 7, 4, 5, 8, 3, 10, 9, 4, 7, 8]\nlist(filter(lambda x: x &lt; 6, notas))\n\n[5, 4, 5, 3, 4]\n\n\nDe este modo, resulta sencillo calcular el promedio de las notas de aquellos que no aprobaron:\n\nmedia(list(filter(lambda x: x &lt; 6, notas)))\n\n4.2\n\n\nRetomando el ejemplo del listado de palabras que se quer√≠an invertir, se podr√≠a usar filter para seleccionar solo aquellas palabras que sean pal√≠ndromos, es decir, capic√∫a.\n\npalabras = [\"hola\", \"mate\", \"somos\",\" libro\", \"conocer\", \"anilina\", \"programa\"]\ncapicuas = list(filter(lambda p: p[::-1] == p, palabras))\ncapicuas\n\n['somos', 'anilina']\n\n\nNaturalmente, filter tambi√©n puede utilizarse para filtrar objetos m√°s complejos. Por ejemplo, si tenemos una lista de diccionarios con informaci√≥n de estudiantes (nombre, ciudad de origen, edad y fecha de inscripci√≥n), podemos usar filter para seleccionar aquellos que cumplan una o m√°s condiciones. En ese caso, el valor booleano que devuelve la funci√≥n se construye combinando condiciones mediante operadores l√≥gicos como and.\n\ndatos = [\n    {\"nombre\": \"Agustina\", \"ciudad\": \"Casilda\", \"edad\": 18, \"inscripcion\": 2025},\n    {\"nombre\": \"Emiliano\", \"ciudad\": \"Rosario\", \"edad\": 21, \"inscripcion\": 2024},\n    {\"nombre\": \"David\", \"ciudad\": \"Pergamino\", \"edad\": 19, \"inscripcion\": 2024},\n    {\"nombre\": \"Julieta\", \"ciudad\": \"Rosario\", \"edad\": 19, \"inscripcion\": 2025},\n    {\"nombre\": \"Victoria\", \"ciudad\": \"Cha√±ar Ladeado\", \"edad\": 18, \"inscripcion\": 2025},\n    {\"nombre\": \"Fernando\", \"ciudad\": \"Rosario\", \"edad\": 20, \"inscripcion\": 2024},\n    {\"nombre\": \"Mateo\", \"ciudad\": \"P√©rez\", \"edad\": 23, \"inscripcion\": 2025},\n    {\"nombre\": \"Luc√≠a\", \"ciudad\": \"Rosario\", \"edad\": 22, \"inscripcion\": 2022},\n    {\"nombre\": \"Joaqu√≠n\", \"ciudad\": \"Casilda\", \"edad\": 19, \"inscripcion\": 2025},\n    {\"nombre\": \"Micaela\", \"ciudad\": \"Rosario\", \"edad\": 18, \"inscripcion\": 2024},\n]\n\nlist(filter(lambda x: x[\"ciudad\"] == \"Rosario\" and x[\"inscripcion\"] == 2025, datos))\n\n[{'nombre': 'Julieta', 'ciudad': 'Rosario', 'edad': 19, 'inscripcion': 2025}]\n\n\n\n\nReduce\nLa funci√≥n reduce permite reducir una secuencia a un √∫nico valor aplicando de forma sucesiva una funci√≥n de dos argumentos sobre sus elementos.\nPara utilizarla, es necesario importarla desde el m√≥dulo est√°ndar functools:\n\nfrom functools import reduce\n\nreduce aplica la funci√≥n acumulando resultados de a pares, desde el primer elemento hasta el √∫ltimo. Por ejemplo:\nreduce(lambda x, y: x + y, [1, 2, 3, 4, 5])\nequivale a:\n((((1 + 2) + 3) + 4) + 5)\nEn este caso, es simplemente una forma m√°s rebuscada de escribir sum([1, 2, 3, 4, 5]) en Python.\nPara entender c√≥mo funciona el proceso de acumulaci√≥n en reduce, podemos definir una funci√≥n que imprima los valores de sus argumentos en cada paso:\n\ndef sumar(x, y):\n    print(f\"x={x}, y={y}\")\n    return x + y\n\nreduce(sumar, [1, 2, 3, 4, 5])\n\nx=1, y=2\nx=3, y=3\nx=6, y=4\nx=10, y=5\n\n\n15\n\n\nEn la primera llamada, x e y son los dos primeros elementos de la secuencia. En la segunda, x es el resultado de la llamada anterior, e y es el siguiente elemento de la secuencia. Este proceso contin√∫a hasta que se recorre toda la lista. En resumen:\n\nx representa el valor acumulado hasta el momento, e\ny es el nuevo elemento a combinar.\n\nAs√≠, reduce va aplicando la funci√≥n paso a paso, acumulando resultados hasta obtener un √∫nico valor final.\nMuchas operaciones comunes, como sumas, productos, m√≠nimos o m√°ximos, pueden expresarse mediante reducciones. Por ejemplo, es posible calcular el factorial de un n√∫mero utilizando una reduce:\n\ndef factorial(n):\n    return reduce(lambda x, y: x * y, range(1, n + 1))\n\nfactorial(5)\n\n120\n\n\nLa reducci√≥n mediante la multiplicaci√≥n de dos n√∫meros, aplicada a la secuencia del 1 al n, da como resultado el factorial de n.\nFinalmente, podemos ver que combinando una funci√≥n que devuelve el mayor de dos n√∫meros y una reducci√≥n, es posible obtener el m√°ximo de una secuencia.\n\ndef mayor(x, y):\n    if x &gt; y:\n        return x\n    return y\n\nreduce(mayor, [23, 49, 6, 32, 101, 9])\n\n101\n\n\nVale la pena mencionar que reduce acepta un tercer argumento opcional, que especifica el valor inicial de la reducci√≥n. Este valor se utiliza como punto de partida antes de procesar los elementos del iterable.\n\ndef sumar(x, y):\n    print(f\"x={x}, y={y}\")\n    return x + y\n\nreduce(sumar, [1, 2, 3, 4, 5], 20)\n\nx=20, y=1\nx=21, y=2\nx=23, y=3\nx=26, y=4\nx=30, y=5\n\n\n35\n\n\n\n\n\n\n\n\nExpresiones condicionales üîÄüò±\n\n\n\nLa reducci√≥n anterior puede expresarse de forma m√°s concisa utilizando expresiones condicionales:\nreduce(lambda x, y: x if x &gt; y else y, [23, 49, 6, 32, 101, 9])\nEstas expresiones permiten simplificar asignaciones condicionales. Por ejemplo, el siguiente bloque:\nif x &gt; y:\n    valor = x\nelse:\n    valor = y\npuede escribirse de manera m√°s compacta as√≠:\nvalor = x if x &gt; y else y\nEn t√©rminos generales, la sintaxis es:\n&lt;valor_si_verdadero&gt; if &lt;condici√≥n&gt; else &lt;valor_si_falso&gt;\n\n\n\n\nResumen\nEl siguiente bloque de c√≥digo resume el funcionamiento de map, filter y reduce.\n\nnumeros = [1, 2, 3, 4, 5]\n\n# Map: Aplicar una funci√≥n a cada elemento de un iterable\ncuadrados = list(map(lambda x: x**2, numeros))\nprint(\"Map [cuadrados]:\", cuadrados)\n\n# Filter: Devuelve el subconjunto de elementos para los que la funci√≥n devuelve True\npares = list(filter(lambda x: x % 2 == 0, numeros))\nprint(\"Filter [pares]:\", pares)\n\n# Reduce: Aplica una funci√≥n de dos argumentos de manera acumulativa a los elementos de una secuencia\nproducto = reduce(lambda x, y: x * y, numeros)\nprint(\"Reduce [producto]:\", producto)\n\nMap [cuadrados]: [1, 4, 9, 16, 25]\nFilter [pares]: [2, 4]\nReduce [producto]: 120\n\n\n\nMap y filter como casos particulares de reduce üò±\nPor otro lado, algo menos evidente es que tanto map como filter pueden verse como casos particulares de reduce.\nEsta aplicaci√≥n de map:\n\nlist(map(lambda x: x * 2, range(10)))\n\n[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n\n\nPuede ser reproducida con el siguiente uso de reduce:\n\ndef dup(x):\n    return x * 2\n\nreduce(lambda seq, x: seq + [dup(x)], range(10), [])\n\n[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n\n\nY el siguiente uso de filter\n\nlist(filter(lambda x: x % 2 == 1, range(10)))\n\n[1, 3, 5, 7, 9]\n\n\nSe puede expresar tambi√©n con reduce:\n\ndef es_impar(x):\n    return x % 2 == 1\n\nreduce(lambda seq, x: seq + [x] if es_impar(x) else seq, range(10), [])\n\n[1, 3, 5, 7, 9]\n\n\nEstas expresiones con reduce() son complejas, pero ilustran claramente el poder de la funci√≥n: cualquier operaci√≥n que pueda definirse a partir de una combinaci√≥n sucesiva de elementos puede, al menos en principio, expresarse como una reducci√≥n, aunque no siempre sea la forma m√°s clara o recomendada de hacerlo.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "3 - Funciones de orden superior"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#comprehensions",
    "href": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#comprehensions",
    "title": "3 - Funciones de orden superior",
    "section": "Comprehensions",
    "text": "Comprehensions\nCuando usamos map y filter obtenemos objetos especiales: map devuelve un objeto de tipo map, y filter devuelve un objeto de tipo filter. Estos objetos son iterables y perezosos, lo que significa que no realizan ninguna operaci√≥n hasta que se los recorre o convierte en una colecci√≥n, como una lista. Por eso, si queremos ver directamente el resultado de una transformaci√≥n o filtrado, necesitamos envolverlos con list():\nnumeros = [1, 2, 3]\nlist(map(lambda x: x * 2, numeros))          # ‚Üí [2, 4, 6]\nlist(filter(lambda x: x % 2 == 0, numeros))  # ‚Üí [2]\nAunque map y filter siguen siendo completamente v√°lidos y √∫tiles, hoy en d√≠a se consideran formas anticuadas o menos idiom√°ticas de construir listas transformadas o filtradas en Python.\nLa alternativa moderna y, en general preferida, son las comprensiones de listas (del ingl√©s, list comprehensions), que permiten expresar las mismas ideas de forma m√°s clara y legible:\n\nnumeros = list(range(11))\n[x * 2 for x in numeros] # Reemplaza a list(map(...))\n\n[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n\n\n\n[x for x in numeros if x % 2 == 0] # Reemplaza a list(filter(...))\n\n[0, 2, 4, 6, 8, 10]\n\n\n\nComprehension como reemplazo de map\nSupongamos que tenemos una lista de n√∫meros y queremos restarles su media.\nUna forma de hacerlo utilizando un bucle for es:\n\nvector = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]\n\nmedia = media(vector)\nvector_centrado = []\nfor x in vector:\n    vector_centrado.append(x - media)\n\nvector_centrado\n\n[-4.5, -3.5, -2.5, -1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5]\n\n\nSi, en cambio, decidimos usar map, podemos hacer:\n\nlist(map(lambda x: x - media, vector))\n\n[-4.5, -3.5, -2.5, -1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5]\n\n\nFinalmente, se puede obtener el mismo resultado usando una list comprehension:\n\n[x - media for x in vector]\n\n[-4.5, -3.5, -2.5, -1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5]\n\n\nLa sintaxis general de una list comprehension que aplica una transformaci√≥n sobre los elementos de un iterable es:\n[&lt;expresi√≥n&gt; for elemento in iterable]\nComo se observa en el ejemplo anterior, lo que aparece en la parte izquierda como &lt;expresi√≥n&gt; no tiene por qu√© ser una llamada a una funci√≥n; puede ser cualquier expresi√≥n v√°lida que produzca un resultado. Es decir, una operaci√≥n matem√°tica, un formateo de texto, la construcci√≥n de una estructura de datos, una llamada a una funci√≥n, etc.\n\n\nComprehension como reemplazo de filter\nAhora veamos con mayor detalle c√≥mo funciona una list comprehension que reemplaza al uso de filter. Para eso, retomemos el ejemplo de las palabras capic√∫a.\n\npalabras = [\"hola\", \"mate\", \"somos\",\" libro\", \"conocer\", \"anilina\", \"programa\"]\n\nInicialmente, podemos construir un listado de palabras capic√∫a usando un bucle for.\n\ncapicuas = []\nfor palabra in palabras:\n    if palabra == palabra[::-1]:\n        capicuas.append(palabra)\ncapicuas\n\n['somos', 'anilina']\n\n\nLuego, podemos construir el listado de palabras capic√∫a usando la funci√≥n de orden superior filter.\n\nlist(filter(lambda x: x == x[::-1], palabras))\n\n['somos', 'anilina']\n\n\nY finalmente, se puede obtener exactamente el mismo resultado mediante una list comprehension.\n\n[palabra for palabra in palabras if palabra == palabra[::-1]]\n\n['somos', 'anilina']\n\n\nLa sintaxis general de una list comprehension que filtra los elementos de un iterable es:\n[elemento for elemento in iterable if &lt;expresi√≥n_l√≥gica&gt;]\nAl igual que en la list comprehension que aplica funciones a todos los ementos, &lt;expresi√≥n_l√≥gica&gt; puede ser cualquier expresi√≥n de Python que devuelva un valor True o False, o que pueda interpretarse como tal.\nTambi√©n podr√≠a usarse una list comprehension que transforme elementos filtrados de un iterable:\n[&lt;expresi√≥n&gt; for elemento in iterable if &lt;expresi√≥n_l√≥gica&gt;]\nPor ejemplo:\n\n# Multiplica por 2 a los numeros impares de `range(5)`\n[x * 2 for x in range(5) if x % 2]\n\n[2, 6]\n\n\n\n\n\n\n\n\nComprehensions con expresiones condicionales üò±\n\n\n\nLa estructura general:\n[elemento for elemento in iterable if &lt;expresi√≥n_l√≥gica&gt;]\npuede modificarse cuando se desea evaluar una expresi√≥n en caso de que se cumpla una condici√≥n y otra distinta si no se cumple. Para ello, se usa una expresi√≥n condicional directamente en la parte izquierda de la comprensi√≥n:\n[&lt;expresi√≥n_si_verdadero&gt; if &lt;condici√≥n&gt; else &lt;expresi√≥n_si_falso&gt; for elemento in iterable]\nPor ejemplo:\nnumeros = [1, 2, 3, 4, 5]\n[f\"{x} es par\" if x % 2 == 0 else f\"{x} es impar\" for x in numeros]\n['1 es impar', '2 es par', '3 es impar', '4 es par', '5 es impar']\n\n\n\n\n\n\n\n\nDictionary comprehensions üò±üò±\n\n\n\nLas comprensiones en Python no est√°n limitadas a listas. Este patr√≥n tambi√©n puede utilizarse para construir otras estructuras de datos como diccionarios, conjuntos e incluso generadores (estructura que veremos m√°s adelante).\nPor ejemplo, una comprensi√≥n de diccionario permite crear un dict a partir de una secuencia de pares clave-valor:\ndef media(x):\n    return sum(x) / len(x)\n\ndatos = [\n    (\"Marcos\", (4, 8, 9, 9)),\n    (\"Joaqu√≠n\", (10, 8, 8, 7)),\n    (\"Luj√°n\", (10, 9, 9, 10)),\n]\n\n{nombre: media(notas) for nombre, notas in datos}\n{'Marcos': 7.5, 'Joaqu√≠n': 8.25, 'Luj√°n': 9.5}",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "3 - Funciones de orden superior"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#evaluaci√≥n-parcial-de-funciones",
    "href": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#evaluaci√≥n-parcial-de-funciones",
    "title": "3 - Funciones de orden superior",
    "section": "Evaluaci√≥n parcial de funciones",
    "text": "Evaluaci√≥n parcial de funciones\nEn Fundamentos comenzamos a trabajar con function factories, es decir, con funciones que definen y devuelven funciones. El ejemplo que vimos consist√≠a en la funci√≥n crear_multiplicador que recib√≠a un m√∫ltiplo y devolv√≠a una funci√≥n de un argumento que al llamarla realizaba la multiplcaci√≥n. As√≠, era posible crear funciones para duplicar, triplicar, cuadruplicar, etc.\n\ndef crear_multiplicador(x):\n    def interna(y):\n        return y * x\n    return interna\n\nduplicar = crear_multiplicador(2)\ntriplicar = crear_multiplicador(3)\n\nprint(duplicar(10), triplicar(22))\n\n20 66\n\n\nAhora bien, esta no es la √∫nica forma de crear funciones que multipliquen dos numeros dejando uno de sus argumentos fijo.\nUna alternativa consiste en crear una funci√≥n general de multiplicaci√≥n y usar partial del m√≥dulo functools para obtener una versi√≥n de la misma con alguno de sus argumentos fijados.\n\ndef multiplicar(x, y):\n    return x * y\n\nmultiplicar(7, 8)\n\n56\n\n\n\nfrom functools import partial\n\ncuadruplicar = partial(multiplicar, 4)\ncuadruplicar(2)\n\n8\n\n\nEn esencia, partial toma una funci√≥n y fija algunos de sus par√°metros, devolviendo una nueva funci√≥n con argumentos ya establecidos. Dicho de otro modo, partial produce una funci√≥n parcialmente evaluada, de ah√≠ su nombre.\nDe un modo similar, se podr√≠an crear funciones de potencia a partir de una funci√≥n gen√©rica.\n\ndef potencia(x, n):\n    return x ** n\n\ncuadrado = partial(potencia, n=2)\ncubo = partial(potencia, n=3)\n\nprint(cuadrado(5), cubo(9))\n\n25 729\n\n\nMediante un ejemplo podemos ver que partial tambi√©n permite fijar m√°s de un par√°metro. Supongamos que tenemos una lista de n√∫meros que queremos estandarizar; es decir, restarles la media y dividir cada valor por el desv√≠o.\n\nnums = [\n    4.74346239e-01, -2.90877176e-01, -1.44377789e+00, -4.48680759e+01,\n    -1.21249801e+00, -3.32729317e-01,  2.21676912e-01,  1.05599711e+00,\n    -3.62372053e+00, -2.96441579e-01, -4.28304222e+00,  1.55908820e+02,\n    9.00858234e-01, -1.09384173e+00, -1.51083571e+00, -5.38491167e-01,\n    -3.84153084e-02,  1.20393395e+00,  1.82651406e-01,  2.05179405e+00\n]\n\ndef media(x):\n    return sum(x) / len(x)\n\ndef varianza(x):\n    numerador = 0\n    x_media = media(x)\n    for x_i in x:\n        numerador += (x_i - x_media) ** 2\n    return numerador / len(x)\n\nestandarizar = partial(\n1    lambda x, media, desvio: (x - media) / desvio,\n2    media=media(nums),\n    desvio=varianza(nums) ** 0.5\n)\n\n\n1\n\nDefinimos una funci√≥n lambda que implementa la estandarizaci√≥n. Esta funci√≥n recibe el valor a estandarizar, la media y el desv√≠o correspondientes.\n\n2\n\nCalculamos la media y el desv√≠o de la lista, y luego los pasamos a partial como par√°metros a fijar.\n\n\n\n\nDe esta manera, obtenemos la funci√≥n estandarizar, que al recibir un n√∫mero le resta la media y lo divide por el desv√≠o calculado a partir de nums.\n\nestandarizar(nums[0])\n\n-0.12933243764138067\n\n\nY, si queremos estandarizar toda la secuencia, podemos usar una list comprehension.\n\n[estandarizar(num) for num in nums]\n\n[-0.12933243764138067,\n -0.1506204085674334,\n -0.18269328610772323,\n -1.390726359064761,\n -0.17625924440864513,\n -0.15178470535100874,\n -0.13636151853677025,\n -0.1131513242720763,\n -0.24333773925841856,\n -0.1507752062996549,\n -0.2616795995472022,\n 4.1947440261328905,\n -0.11746717741646615,\n -0.1729583111265218,\n -0.1845587869464874,\n -0.1575088536123251,\n -0.1435970990449382,\n -0.10903582664474336,\n -0.13744718034588063,\n -0.08544896194045284]\n\n\n\n\n\n\n\n\nArgumentos posicionales y nombrados üî¢üè∑Ô∏è\n\n\n\npartial puede utilizarse para fijar tanto argumentos posicionales como nombrados. Cuando recibe argumentos posicionales, estos se transmiten a la funci√≥n original en el mismo orden; mientras que, si se le pasan argumentos nombrados, se reenv√≠an como tales.\nPor ejemplo, las siguientes llamadas a partial generan funciones equivalentes:\ndef prod(x, y):\n    return x * y\n\npartial(prod, 5)     # 5 * y\npartial(prod, x=5)   # 5 * y\npartial(prod, y=5)   # x * 5",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "3 - Funciones de orden superior"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#decoradores",
    "href": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#decoradores",
    "title": "3 - Funciones de orden superior",
    "section": "Decoradores",
    "text": "Decoradores\nEn Ciudadanos de primera clase aprendimos que las funciones son un objeto como cualquier otro. Por eso, ya no nos sorprende que puedan pasarse como argumento a otra funci√≥n o devolverse como resultado de otra funci√≥n.\nAhora vamos a explorar un tipo de funciones que son muy √∫tiles en Python: los decoradores.\nLos decoradores son funciones que ‚Äúenvuelven‚Äù o ‚Äúencapsulan‚Äù funciones y modifican su comportamiento.\nEmpecemos con un ejemplo: la funci√≥n decorador recibe una funci√≥n fun, define una funci√≥n envoltura que contiene una llamada a fun y la devuelve.\n\ndef decorador(fun):\n\n    def envoltura():\n        print(\"Antes de llamar a la funci√≥n...\")\n        fun()\n        print(\"Listo, ya se llam√≥ a la funci√≥n.\")\n\n    return envoltura\n\nPara mostrar el funcionamiento del decorador, definamos una funci√≥n muy sencilla, que simplemente imprime un saludo.\n\ndef decir_hola():\n    print(\"¬°Hola hola!\")\n\ndecir_hola()\n\n¬°Hola hola!\n\n\nAhora, invocamos a decorador pasandole la funci√≥n decir_hola y obtenemos una nueva una funci√≥n.\nPodemos ver que esta nueva funci√≥n es la funci√≥n envoltura definida dentro del decorador.\n\nnueva = decorador(decir_hola)\nnueva\n\n&lt;function __main__.decorador.&lt;locals&gt;.envoltura()&gt;\n\n\nAntes de ejecutar la funci√≥n nueva, intentemos anticipar qu√© va a ocurrir cuando la llamemos.\nAl invocar nueva, se ejecutar√°n las siguientes tres l√≠neas de c√≥digo:\n1print(\"Antes de llamar a la funci√≥n...\")\n2fun()\n3print(\"Listo, ya se llam√≥ a la funci√≥n.\")\n\n1\n\nLa primera l√≠nea contiene directamente un print, por lo que podemos anticipar que lo primero que vamos a ver es un mensaje que dice \"Antes de llamar a la funci√≥n...\".\n\n2\n\nLa segunda l√≠nea contiene una llamada a la funci√≥n fun. Esta es la funci√≥n que le pasamos a decorador al momento de crear nueva, es decir, es la funci√≥n decir_hola.\nPor lo tanto, habr√° un segundo mensaje que dice \"¬°Hola hola!\".\n\n3\n\nFinalmente, se ejecuta la tercera l√≠nea, y como vemos que es un print, sabemos que vamos a ver un mensaje que dice \"Listo, ya se llam√≥ a la funci√≥n.\".\n\n\n\nnueva()\n\nAntes de llamar a la funci√≥n...\n¬°Hola hola!\nListo, ya se llam√≥ a la funci√≥n.\n\n\nEn este ejemplo vemos que el decorador ‚Äúenvuelve‚Äù o ‚Äúencapsula‚Äù a la funci√≥n decir_hola. Gracias a esto, la funci√≥n decorada ya no se ejecuta como antes, sino que ahora tambi√©n imprime mensajes antes y despu√©s de realizar la tarea en su definici√≥n original.\n\nDecoradores que reciben argumentos\nSi intentamos pasarle argumentos a la funci√≥n nueva, obtendremos un error. Este error no se debe a que la funci√≥n decorada, decir_hola, no acepte par√°metros, sino a que la funci√≥n que devuelve el decorador, envoltura, no est√° preparada para recibirlos.\nAhora bien, si queremos que nuestra funci√≥n de envoltura pueda transmitir argumentos a la funci√≥n decorada, necesitamos un mecanismo flexible. No podemos conocer de antemano qu√© par√°metros recibir√° la funci√≥n a decorar, justamente porque no sabemos cu√°l ser√° esa funci√≥n.\nLa soluci√≥n es definir envoltura de manera que acepte una cantidad arbitraria de argumentos posicionales y nombrados. De esta forma, podemos propagar todos esos argumentos a la funci√≥n decorada sin importar cu√°les sean.\n\ndef decorador(fun):\n\n1    def envoltura(*args, **kwargs):\n        if args:\n            print(\"Argumentos posicionales:\", args)\n        if kwargs:\n            print(\"Argumentos nombrados:\", kwargs)\n2        fun(*args, **kwargs)\n\n    return envoltura\n\ndef potencia(x, n):\n    return x ** n\n\npotencia = decorador(potencia)\n\n\n1\n\nenvoltura recibe una cantidad arbitraria de argumentos posicionales y nombrados.\n\n2\n\nCuando se llama a fun, se le pasan todos los argumentos posicionales y nombrados recibidos.\n\n\n\n\n\npotencia(5, 3)\n\nArgumentos posicionales: (5, 3)\n\n\n\npotencia(5, n=3)\n\nArgumentos posicionales: (5,)\nArgumentos nombrados: {'n': 3}\n\n\n\npotencia(x=5, n=3)\n\nArgumentos nombrados: {'x': 5, 'n': 3}\n\n\nEl ejemplo muestra que el decorador imprime los argumentos de la funci√≥n original, tanto posicionales como nombrados, siempre que se le haya pasado alguno.\n\n\nDecoradores que devuelven valores\nSi bien el decorador anterior funcionaba correctamente con funciones que reciben tanto argumentos posicionales como nombrados, no vemos que la funci√≥n decorada devuelva la potencia calculada. Para que eso ocurra, la envoltura no solo tiene que llamar a fun, sino tambi√©n retornar lo que esta retorne.\n\ndef decorador(fun):\n\n    def envoltura(*args, **kwargs):\n        if args:\n            print(\"Argumentos posicionales:\", args)\n        if kwargs:\n            print(\"Argumentos nombrados:\", kwargs)\n1        return fun(*args, **kwargs)\n\n    return envoltura\n\ndef potencia(x, n):\n    return x ** n\n\n\n1\n\nGracias a esta l√≠nea, la funci√≥n envoltura retorna lo que sea que fun retorne.\n\n\n\n\n\npotencia = decorador(potencia)\npotencia(x=5, n=3)\n\nArgumentos nombrados: {'x': 5, 'n': 3}\n\n\n125\n\n\n\n\nAz√∫car sint√°ctico\nDado que los decoradores cumplen un rol muy importante en la programaci√≥n con Python, el lenguaje ofrece una sintaxis especial para aplicarlos directamente al momento de definir una funci√≥n.\nPara ello, basta con escribir @&lt;nombre_decorador&gt; en la l√≠nea anterior a la definici√≥n de la funci√≥n. Por ejemplo:\n\n@decorador\ndef producto(x, y):\n    return x * y\n\nproducto(3, 7)\n\nArgumentos posicionales: (3, 7)\n\n\n21\n\n\n\nproducto(x=3, y=7)\n\nArgumentos nombrados: {'x': 3, 'y': 7}\n\n\n21\n\n\nDe esta manera, no es necesario incluir l√≠neas adicionales del estilo:\ndef funcion(...):\n    ...\n    return ...\n\nfuncion = decorador(funcion)\nA este tipo de atajos sint√°cticos que brinda el lenguaje se los conoce como az√∫car sint√°ctico (del ingl√©s, syntax sugar).\n\n\nEjemplo: medir tiempo de ejecuci√≥n\nHasta ahora, los ejemplos que vimos fueron un tanto artificiales, pensados √∫nicamente para mostrar qu√© son los decoradores y c√≥mo se utilizan. A continuaci√≥n, presentamos un ejemplo m√°s cercano a un uso pr√°ctico.\nEl decorador timer imprime el tiempo de ejecuci√≥n que le toma a una funci√≥n. Luego, lo aplicamos para comparar los tiempos entre la funci√≥n built-in max y otra implementaci√≥n que obtiene el m√°ximo mediante una reducci√≥n.\n\nimport time\n\ndef timer(fun):\n    def envoltura(*args, **kwargs):\n        inicio = time.time()\n        resultado = fun(*args, **kwargs)\n        fin = time.time()\n        print(f\"{fun.__name__} demor√≥ {fin - inicio:6f} segundos\")\n        return resultado\n    return envoltura\n\n\ndef mayor(x, y):\n    if x &gt; y:\n        return x\n    return y\n\n@timer\ndef maximo_reduce(x):\n    return reduce(mayor, x)\n\n@timer\ndef maximo_builtin(x):\n    return max(x)\n\n\nlista = list(range(1_000_000))\n\nmaximo_reduce(lista)\n\nmaximo_reduce demor√≥ 0.044118 segundos\n\n\n999999\n\n\n\nmaximo_builtin(lista)\n\nmaximo_builtin demor√≥ 0.017050 segundos\n\n\n999999",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "3 - Funciones de orden superior"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/02_recursion.html",
    "href": "teoria/02_programacion_funcional/02_recursion.html",
    "title": "2 - Recursi√≥n",
    "section": "",
    "text": "En el apunte anterior vimos que en Python las funciones son ciudadanos de primera clase. Esto significa que una funci√≥n es un objeto, al igual que un n√∫mero, una cadena de texto o incluso un diccionario anidado con una estructura bastante enredada. Gracias a esto, no solo podemos inspeccionar sus atributos o hacer que una funci√≥n llame a otras, sino que tambi√©n es posible que una funci√≥n cree y retorne nuevas funciones.\nAdem√°s de los casos ya mencionados, tambi√©n es posible que una funci√≥n se llame a s√≠ misma. Es decir, que en el cuerpo de la definici√≥n de esa funci√≥n se incluya una llamada a la funci√≥n que se est√° definiendo (ü§Ø). A este tipo de funciones se las llama recursivas, y la t√©cnica en s√≠ recibe el nombre de recursi√≥n.\nAunque pueda sonar extra√±o que una funci√≥n se invoque a s√≠ misma, en programaci√≥n existen problemas para los que funciones recursivas resultan una soluci√≥n natural y efectiva.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "2 - Recursi√≥n"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/02_recursion.html#introducci√≥n",
    "href": "teoria/02_programacion_funcional/02_recursion.html#introducci√≥n",
    "title": "2 - Recursi√≥n",
    "section": "",
    "text": "En el apunte anterior vimos que en Python las funciones son ciudadanos de primera clase. Esto significa que una funci√≥n es un objeto, al igual que un n√∫mero, una cadena de texto o incluso un diccionario anidado con una estructura bastante enredada. Gracias a esto, no solo podemos inspeccionar sus atributos o hacer que una funci√≥n llame a otras, sino que tambi√©n es posible que una funci√≥n cree y retorne nuevas funciones.\nAdem√°s de los casos ya mencionados, tambi√©n es posible que una funci√≥n se llame a s√≠ misma. Es decir, que en el cuerpo de la definici√≥n de esa funci√≥n se incluya una llamada a la funci√≥n que se est√° definiendo (ü§Ø). A este tipo de funciones se las llama recursivas, y la t√©cnica en s√≠ recibe el nombre de recursi√≥n.\nAunque pueda sonar extra√±o que una funci√≥n se invoque a s√≠ misma, en programaci√≥n existen problemas para los que funciones recursivas resultan una soluci√≥n natural y efectiva.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "2 - Recursi√≥n"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/02_recursion.html#cuenta-regresiva",
    "href": "teoria/02_programacion_funcional/02_recursion.html#cuenta-regresiva",
    "title": "2 - Recursi√≥n",
    "section": "Cuenta regresiva",
    "text": "Cuenta regresiva\nSupongamos que queremos crear una funci√≥n que imprima una cuenta regresiva desde un n√∫mero entero dado hasta el 0. Es decir, la funci√≥n se deber√≠a comportar de la siguiente manera:\nregresiva(3)\n3\n2\n1\n0\nregresiva(5)\n5\n4\n3\n2\n1\n0\nUna implementaci√≥n no recursiva es la siguiente, basada en un bucle while:\ndef regresiva(n):\n    while n &gt; 0:\n        print(n)\n        n = n - 1\nOtra alternativa, que usa un bucle for y un range es:\ndef regresiva(n):\n    for i in range(n, -1, -1):\n        print(i)\nAmbas implementaciones resultan en funciones que se comportan correctamente y producen el resultado deseado.\nSin embargo, existe una alternativa recursiva para obtener la secuencia de n√∫meros deseados.\n\ndef regresiva(i):\n    print(i)\n1    if i &gt; 0:\n        regresiva(i - 1)\n2    else:\n        return\n\n\n1\n\nEl caso recursivo: Es la condici√≥n donde la funci√≥n se llama a s√≠ misma. En este caso, regresiva vuelve a llamarse a s√≠ misma solo cuando el n√∫mero impreso sea mayor que 0. La llamada se hace pasando como argumento el valor i - 1, lo que nos acerca progresivamente al caso base.\n\n2\n\nEl caso base: Es la condici√≥n que detiene la recursi√≥n. Cuando se cumple, la funci√≥n devuelve un valor sin volver a llamarse a s√≠ misma, lo que evita que la ejecuci√≥n contin√∫e de manera infinita.\n\n\n\n\nAmbos casos trabajan en conjunto. Por un lado, el caso recursivo es la parte de la funci√≥n que se llama a s√≠ misma, pero con una entrada modificada que se acerca progresivamente al caso base. Por el otro, el caso base es la condici√≥n que detiene las llamadas recursivas, representando la versi√≥n m√°s simple del problema que puede ser resuelta directamente.\n\nregresiva(3)\n\n3\n2\n1\n0\n\n\n\nregresiva(5)\n\n5\n4\n3\n2\n1\n0\n\n\n\n\n\n\n\n\nVersi√≥n con return impl√≠cito\n\n\n\nLa funci√≥n recursiva regresiva usa return para terminar su ejecuci√≥n devolviendo un None impl√≠cito en el caso base. Otra forma de implementar la misma funci√≥n es omitiendo el return:\ndef regresiva(i):\n    print(i)\n    if i &gt; 0:\n1        regresiva(i - 1)\n2\n\n1\n\nEsta l√≠nea marca el caso recursivo y es id√©ntica a la anterior.\n\n2\n\nAc√° no se usa return para devolver None, directamente no se escribe nada. El efecto es el mismo y constituye el caso base. En Python, si una funci√≥n no incluye ning√∫n return, se comporta como si al final hubiera un return o return None, es decir, la funci√≥n termina y devuelve None.\n\n\n\n\n\nVersi√≥n comentada\nPara entender mejor el funcionamiento de la funci√≥n recursiva progresiva, se pueden incorporar unos print en el cuerpo de la misma. En el ejemplo de abajo se muestra un print justo cuando la funci√≥n es llamada, y otro cuando la funci√≥n vuelve a invocarse a s√≠ misma.\ndef regresiva(i):\n    print(f\"regresiva({i})\")\n    print(i)\n    if i &gt; 0:\n        print(f\"regresiva({i}) --&gt; regresiva({i -1})\")\n        regresiva(i - 1)\n\nregresiva(2)\n1regresiva(2)\n22\n3regresiva(2) --&gt; regresiva(1)\n4regresiva(1)\n51\n6regresiva(1) --&gt; regresiva(0)\n7regresiva(0)\n80\n\n1\n\nSe ejecuta regresiva con i = 2\n\n2\n\nregresiva(2) imprime 2\n\n3\n\nregresiva(2) llama a regresiva(1)\n\n4\n\nSe ejecuta regresiva con i = 1\n\n5\n\nregresiva(1) imprime 1\n\n6\n\nregresiva(1) llama a regresiva(0)\n\n7\n\nSe ejecuta regresiva con i = 0\n\n8\n\nregresiva(0) imprime 0\n\n\n\n\n¬°Qu√© no falte el caso base!\nCuando escribimos una funci√≥n recursiva es fundamental implementar el caso base, que determina la condici√≥n donde la funci√≥n deja de llamarse a s√≠ misma y comienza a devolver un valor.\nDebajo se muestra una implementaci√≥n incorrecta de la funci√≥n regresiva como funci√≥n recursiva. La misma tiene el caso recursivo, donde la funci√≥n se llama a s√≠ misma, pero le falta el caso base, que es el que detiene esa cadena de llamadas. Como resultado, la funci√≥n sigue contando n√∫meros, incluso negativos, y Python termina frenando la ejecuci√≥n con un RecursionError. Este error aperece cuando la profundidad de la pila de llamadas recursivas supera un l√≠mite predeterminado y, como regla general, indica que hay un problema en nuestra recursi√≥n.\ndef regresiva(i):\n    print(i)\n    regresiva(i - 1)\n\nregresiva(1)\n\n1\n0\n-1\n-2\n...\n-988\n-989\nTraceback (most recent call last):\n  File \"&lt;python-input-5&gt;\", line 1, in &lt;module&gt;\n    regresiva(1)\n    ~~~~~~~~~^^^\n  File \"&lt;python-input-2&gt;\", line 3, in regresiva\n    regresiva(i - 1)\n    ~~~~~~~~~^^^^^^^\n  File \"&lt;python-input-2&gt;\", line 3, in regresiva\n    regresiva(i - 1)\n    ~~~~~~~~~^^^^^^^\n  File \"&lt;python-input-2&gt;\", line 3, in regresiva\n    regresiva(i - 1)\n    ~~~~~~~~~^^^^^^^\n  [Previous line repeated 988 more times]\nRecursionError: maximum recursion depth exceeded",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "2 - Recursi√≥n"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/02_recursion.html#factorial",
    "href": "teoria/02_programacion_funcional/02_recursion.html#factorial",
    "title": "2 - Recursi√≥n",
    "section": "Factorial",
    "text": "Factorial\nUn ejemplo cl√°sico para estudiar c√≥mo funciona la recursi√≥n en programaci√≥n es el c√°lculo del factorial. El factorial de un n√∫mero positivo \\(n\\) se define como:\n\\[\nn! = n \\times (n - 1) \\times (n - 2) \\times \\cdots \\times 2 \\times 1\n\\]\nEs decir, el factorial de un n√∫mero es el producto de todos los enteros desde \\(1\\) hasta \\(n\\). Por convenci√≥n, adem√°s, se establece que \\(0! = 1\\).\nUna forma de calcular el factorial de un n√∫mero sin recurrir a la recursi√≥n es la siguiente:\n\ndef factorial(n):\n    resultado = 1\n    for i in range(2, n + 1):\n        resultado = resultado * i\n    return resultado\n\nfactorial(6)\n\n720\n\n\nSin embargo, y dado que el factorial admite la siguiente expresi√≥n como funci√≥n recursiva,\n\\[\nn! = \\begin{cases}\n1 & \\text{para } n = 0 \\text{ o } n = 1 \\\\\nn \\times (n - 1)! & \\text {para } n \\ge 2\n\\end{cases}\n\\]\nse puede implementar en Python de la siguiente manera:\n\ndef factorial(n):\n    if n &lt;= 1:\n1        return 1\n    else:\n2        return n * factorial(n - 1)\n\n\n1\n\nCaso base.\n\n2\n\nCaso recursivo. La funci√≥n hace uso del resultado que ella misma produce.\n\n\n\n\nPodemos ver algunos ejemplos:\n\nprint(\"factorial(1):\", factorial(1))\nprint(\"factorial(0):\", factorial(0))\nprint(\"factorial(6):\", factorial(6))\nprint(\"factorial(10):\", factorial(10))\n\nfactorial(1): 1\nfactorial(0): 1\nfactorial(6): 720\nfactorial(10): 3628800\n\n\n\nVersi√≥n comentada\nLa funci√≥n regresiva nos sirvi√≥ como primera aproximaci√≥n a la recursi√≥n. Sin embargo, en ella, no se hace uso del resultado que la misma funci√≥n produce. En cambio, con factorial s√≠ se utiliza el valor producido en el caso recursivo, lo que la vuelve m√°s interesante para analizar c√≥mo se van encadenando los distintos pasos.\n\ndef factorial(n):\n    print(f\"factorial({n})\")\n    if n &lt;= 1:\n        salida = 1\n    else:\n        print(f\"factorial({n}) -&gt; factorial({n - 1})\")\n        salida = n * factorial(n - 1)\n\n    print(f\"&gt; factorial({n}) devuelve {salida}\")\n    return salida\n\nfactorial(4)\n\nfactorial(4)\nfactorial(4) -&gt; factorial(3)\nfactorial(3)\nfactorial(3) -&gt; factorial(2)\nfactorial(2)\nfactorial(2) -&gt; factorial(1)\nfactorial(1)\n&gt; factorial(1) devuelve 1\n&gt; factorial(2) devuelve 2\n&gt; factorial(3) devuelve 6\n&gt; factorial(4) devuelve 24\n\n\n24\n\n\nEl proceso arranca con la llamada a factorial(4). Para calcular su resultado, la funci√≥n necesita antes el valor de factorial(3). Esa, a su vez, depende de factorial(2), que depende de factorial(1). Finalmente, cuando llegamos a factorial(1), entramos en el caso base, que devuelve un resultado sin hacer m√°s llamadas.\nPor eso primero vemos c√≥mo se acumula la pila de llamadas, que crece paso a paso hasta llegar al caso base. Reci√©n ah√≠ comienza el camino de regreso: cada llamada se va resolviendo, utilizando el valor devuelto por la llamada anterior, hasta llegar de nuevo a factorial(4), donde se completa el c√°lculo y obtenemos el resultado final.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "2 - Recursi√≥n"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/02_recursion.html#letra-chica",
    "href": "teoria/02_programacion_funcional/02_recursion.html#letra-chica",
    "title": "2 - Recursi√≥n",
    "section": "Letra chica",
    "text": "Letra chica\nCada vez que una funci√≥n se invoca a s√≠ misma, crea un nuevo contexto de ejecuci√≥n (con sus propias variables locales y el punto al que debe regresar) y lo apila sobre el anterior en una estructura que se llama pila de llamadas (del ingl√©s, call stack). Por lo tanto, cuando llamamos a factorial(4), apilamos cuatro contextos de ejecuci√≥n distintos, uno por cada llamada que va quedando pendiente, antes de empezar a devolver resultados.\nEste apilamiento no es gratis, consume memoria de nuestra computadora. Aunque para factorial(4) el consumo de memoria es insignificante, si intent√°ramos calcular un factorial muy grande, la pila podr√≠a crecer hasta agotar la cantidad de memoria disponible en nuestra computadora. Para evitar que las funciones recursivas causen una falla estrepitosa, Python establece un l√≠mite en la profundidad de la recursi√≥n. Al alcanzarlo, el int√©rprete se detiene con la excepci√≥n RecursionError que nos proteje de una ejecuci√≥n recursiva infinita o excesivamente profunda.\nDado su potencial alto consumo de memoria y la sobrecarga que genera gestionar la pila de llamadas, una implementaci√≥n recursiva no suele ser la m√°s eficiente. De hecho, su equivalente iterativo suele ser m√°s eficiente y adem√°s evita los riesgos asociados al desbordamiento de la pila. Sin embargo, el principal valor de la recursi√≥n reside en la claridad conceptual para modelar problemas de naturaleza inherentemente recursiva.",
    "crumbs": [
      "Teor√≠a",
      "U2 - Programaci√≥n Funcional",
      "2 - Recursi√≥n"
    ]
  },
  {
    "objectID": "teoria/03_oop/04_polimorfismo.html",
    "href": "teoria/03_oop/04_polimorfismo.html",
    "title": "4 - Polimorfismo",
    "section": "",
    "text": "El t√©rmino polimorfismo tiene origen en las palabras poly (muchos) y morfo (formas). Aplicado a la programaci√≥n hace referencia a que los objetos pueden tomra diferentes formas.\nPero, ¬øqu√© significa que los objetos pueden tomar diferentes formas? En el contexto de programaci√≥n orientada a objetos significa que los objetos pueden responder a una misma operaci√≥n de distintas maneras.\nTomemos, por ejemplo, la suma de dos variables:\na + b\nSi a y b son de tipo int, la operaci√≥n est√° definida y devuelve otro int. Si son de tipo list, la operaci√≥n tambi√©n est√° definida y devuelve un nuevo objeto list. As√≠, diferentes tipos de datos, responden al mismo mensaje (la suma) de maneras distintas.",
    "crumbs": [
      "Teor√≠a",
      "U3 - Programaci√≥n Orientada a Objetos",
      "4 - Polimorfismo"
    ]
  },
  {
    "objectID": "teoria/03_oop/04_polimorfismo.html#introducci√≥n",
    "href": "teoria/03_oop/04_polimorfismo.html#introducci√≥n",
    "title": "4 - Polimorfismo",
    "section": "",
    "text": "El t√©rmino polimorfismo tiene origen en las palabras poly (muchos) y morfo (formas). Aplicado a la programaci√≥n hace referencia a que los objetos pueden tomra diferentes formas.\nPero, ¬øqu√© significa que los objetos pueden tomar diferentes formas? En el contexto de programaci√≥n orientada a objetos significa que los objetos pueden responder a una misma operaci√≥n de distintas maneras.\nTomemos, por ejemplo, la suma de dos variables:\na + b\nSi a y b son de tipo int, la operaci√≥n est√° definida y devuelve otro int. Si son de tipo list, la operaci√≥n tambi√©n est√° definida y devuelve un nuevo objeto list. As√≠, diferentes tipos de datos, responden al mismo mensaje (la suma) de maneras distintas.",
    "crumbs": [
      "Teor√≠a",
      "U3 - Programaci√≥n Orientada a Objetos",
      "4 - Polimorfismo"
    ]
  },
  {
    "objectID": "teoria/03_oop/04_polimorfismo.html#ejemplos",
    "href": "teoria/03_oop/04_polimorfismo.html#ejemplos",
    "title": "4 - Polimorfismo",
    "section": "Ejemplos",
    "text": "Ejemplos\nA lo largo de esta secci√≥n vamos a introducirnos en el polimorfismo mediante diferentes ejemplos.\n\nAnimales que hablan\nEn programaci√≥n orientada a objetos (POO), el polimorfismo se refiere a la capacidad que tiene el programa de invocar un mismo m√©todo en objetos distintos, y que cada objeto responda de la forma que le corresponde seg√∫n su propia implementaci√≥n.\nPor ejemplo, imaginemos que tenemos una colecci√≥n de perros, gatos y p√°jaros, y que cada uno entiende algunos comandos b√°sicos. Si les pedimos a estas mascotas que hablen (es decir, si les enviamos el mensaje ‚Äúhabla‚Äù), los perros van a ladrar, los gatos van a maullar y los p√°jaros van a piar.\n\nclass Animal:\n    def __init__(self, nombre):\n        self.nombre = nombre\n\nclass Perro(Animal):\n1    def hablar(self):\n        print(self.nombre, \"dice ¬°guau!\")\n\nclass Gato(Animal):\n2    def hablar(self):\n        print(self.nombre, \"dice ¬°miau!\")\n\nclass Pajaro(Animal):\n3    def hablar(self):\n        print(self.nombre, \"dice ¬°pio pio!\")\n\n\n1\n\nLos perros dicen guau.\n\n2\n\nLos gatos dicen miau.\n\n3\n\nLos p√°jaros dicen pio pio.\n\n\n\n\nComo todos los animales tienen la capacidad de hablar, podemos recorrer una lista de animales y ejecutar el m√©todo hablar en cada uno de ellos, sin importar de qu√© tipo de animal se trate. Todos podr√°n responder a la llamada, cada uno a su manera.\n\nmascotas = [\n    Perro(\"Julio\"),\n    Gato(\"Micha\"),\n    Perro(\"Justo\"),\n    Pajaro(\"Pedrito\")\n]\n\nfor mascota in mascotas:\n    mascota.hablar()\n\nJulio dice ¬°guau!\nMicha dice ¬°miau!\nJusto dice ¬°guau!\nPedrito dice ¬°pio pio!\n\n\n\n\n\n\n\n\n¬øEnviar un mensaje?\n\n\n\nEn el contexto de la programaci√≥n orientada a objetos se suele usar la expresi√≥n ‚Äúenviar un mensaje‚Äù cuando hablamos de que un programa (tambi√©n llamado cliente) llama a un m√©todo de un objeto o invoca una operaci√≥n sobre el mismo. Por ejemplo:\nobjeto.correr() # Se env√≠a el mensaje correr\nobj + obj2      # Se env√≠a el mensaje de suma (__add__)\nLo que el objeto haga al recibir ese mensaje depende exclusivamente de √©l. Con el polimorfismo, podemos enviar el mismo mensaje a varios objetos, y cada uno va a reaccionar de manera diferente seg√∫n c√≥mo fue dise√±ado y seg√∫n los datos que tenga disponibles.\n\n\n\n\nLa forma es lo de menos\nPodemos retomar el ejemplo de los rect√°ngulos y circulos del apunte anterior. Ambos tienen acceso al m√©todo area que devuelve el √°rea de la figura.\n\nimport math\n\nclass Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    def area(self):\n        return self.base * self.altura\n\n    def resumen(self):\n        return f\"Rectangulo(base={self.base}, altura={self.altura})\"\n\n\nclass Circulo:\n    def __init__(self, radio):\n        self.radio = radio\n\n    def area(self):\n        return self.radio ** 2 * math.pi\n\n    def resumen(self):\n        return f\"Circulo(radio={self.radio})\"\n\nSi contamos con un listado de rect√°ngulos y c√≠rculos, podemos usar la funci√≥n sorted junto a una funci√≥n an√≥nima para ordenar los elementos seg√∫n su √°rea.\n\nformas = [\n    Circulo(2),\n    Rectangulo(3, 2),\n    Circulo(1.4),\n    Rectangulo(4, 3),\n    Rectangulo(6, 4),\n]\n\n# Ordenar\nformas_ordenadas = sorted(formas, key=lambda f: f.area())\n\n# Imprimir formas en orden\nfor forma in formas_ordenadas:\n    print(forma.resumen(), forma.area(), sep=\": \")\n\nRectangulo(base=3, altura=2): 6\nCirculo(radio=1.4): 6.157521601035993\nRectangulo(base=4, altura=3): 12\nCirculo(radio=2): 12.566370614359172\nRectangulo(base=6, altura=4): 24\n\n\nCuando la funci√≥n an√≥nima recibe una forma f, ejecuta su m√©todo area sin importar de qu√© tipo sea. Como tanto rect√°ngulos como c√≠rculos saben c√≥mo responder a esa llamada devolviendo un n√∫mero, pueden ordenarse correctamente seg√∫n ese valor.\nAunque ambos m√©todos devuelvan el mismo tipo de resultado (un n√∫mero), la forma en que se calcula ese resultado es distinta y depende de cada figura geom√©trica. De eso se trata el polimorfismo.",
    "crumbs": [
      "Teor√≠a",
      "U3 - Programaci√≥n Orientada a Objetos",
      "4 - Polimorfismo"
    ]
  },
  {
    "objectID": "teoria/03_oop/04_polimorfismo.html#m√©todos-m√°gicos",
    "href": "teoria/03_oop/04_polimorfismo.html#m√©todos-m√°gicos",
    "title": "4 - Polimorfismo",
    "section": "M√©todos m√°gicos",
    "text": "M√©todos m√°gicos\nEl polimorfismo no solo se da con m√©todos regulares como hablar o area. Realmente, la magia del polimorfismo aparece cuando incorporamos los m√©todos m√°gicos de Python en nuestras clases.\nLos m√©todos m√°gicos ‚Äîtambi√©n llamados dunder methods (por ‚Äúdouble underscore‚Äù)‚Äî son m√©todos especiales que permiten que nuestros objetos participen en operaciones est√°ndar del lenguaje, como comparaciones, sumas, conversiones a cadenas o iteraciones.\nPor ejemplo, si intentamos comparar dos rect√°ngulos creados con nuestra clase Rectangulo, incluso si tienen las mismas dimensiones, la comparaci√≥n devolver√° False.\n\nr1 = Rectangulo(3, 2)\nr2 = Rectangulo(3, 2)\n\nr1 == r2\n\nFalse\n\n\nConceptualmente, tiene sentido esperar que la comparaci√≥n en valor de dos rect√°ngulos de iguales dimensiones sea True. Pero obtenemos False.\nEsto no ocurre porque r1 y r2 representen objetos distintos, sino porque todav√≠a no hemos implementado el m√©todo m√°gico que define como se deben comparar objetos de la clase Rectangulo por valor.\n\nComparaciones\nEn Python, el operador de comparaci√≥n por valor == utiliza internamente el m√©todo m√°gico __eq__. Si queremos comparar rect√°ngulos con ==, entonces debemos implementar __eq__.\n\nclass Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    @property\n    def area(self):\n        return self.base * self.altura\n\n1    def __eq__(self, other):\n2        if self.base == other.base and self.altura == other.altura:\n            return True\n3        return False\n\n\n1\n\nEl m√©todo __eq__ recibe siempre dos objetos a comparar, llamados por convenci√≥n self y other.\n\n2\n\nSi las bases y las alturas de los objetos son iguales, devuelve True, ya que consideramos que los rect√°ngulos son iguales.\n\n3\n\nEn caso contrario, devuelve False, indicando que los rect√°ngulos no son iguales.\n\n\n\n\nSi probamos nuestro m√©todo de comparaci√≥n reci√©n implementado, vemos que funciona correctamente:\n\nr1 = Rectangulo(3, 2)\nr2 = Rectangulo(3, 2)\nr3 = Rectangulo(5, 3)\n\n\nr1 == r3\n\nFalse\n\n\n\nr2 == r3\n\nFalse\n\n\n\nr1 == r2\n\nTrue\n\n\nNo solo tenemos acceso al operador ==, ahora tambi√©n podemos usar !=.\n\nr1 != r3\n\nTrue\n\n\nTodos los operadores de comparaci√≥n se corresponden con un m√©todo especial determinado. La tabla a continuaci√≥n incluye el nombre del m√©todo, el operador binario que utulizamos y una descripci√≥n de c√≥mo funciona.\n\n\n\n\n\n\n\n\nM√©todo\nOperador asociado\nDescripci√≥n\n\n\n\n\n__eq__(self, other)\n==\nTrue si self es igual a other.\n\n\n__ne__(self, other)\n!=\nTrue si self no es igual a other.\n\n\n__lt__(self, other)\n&lt;\nTrue si self es menor que other.\n\n\n__le__(self, other)\n&lt;=\nTrue si self es menor o igual que other.\n\n\n__gt__(self, other)\n&gt;\nTrue si self es mayor que other.\n\n\n__ge__(self, other)\n&gt;=\nTrue si self es mayor o igual que other.\n\n\n\nDebajo incorporamos todos estos m√©todos en nuestra clase Rectangulo. No existe un criterio universal para determinar si un rect√°ngulo es menor o mayor a otro. En nuestro caso, con el objetivo de mostrar la implementaci√≥n de estos m√©todos, podemos decir que un rect√°ngulo es menor a otro si su √°rea es menor.\n\nclass Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    @property\n    def area(self):\n        return self.base * self.altura\n\n    def __eq__(self, other):\n        return self.base == other.base and self.altura == other.altura\n\n    def __lt__(self, other):\n        return self.area &lt; other.area\n\n    def __le__(self, other):\n        return self.area &lt;= other.area\n\n    def __gt__(self, other):\n        return self.area &gt; other.area\n\n    def __ge__(self, other):\n        return self.area &gt;= other.area\n\n\nr1 = Rectangulo(3, 5) # √Årea: 15\nr2 = Rectangulo(3, 4) # √Årea: 12\nr3 = Rectangulo(5, 3) # √Årea: 15\n\n\nr1 &lt; r2\n\nFalse\n\n\n\nr1 &lt; r3\n\nFalse\n\n\n\nr1 &lt;= r3\n\nTrue\n\n\n\nr3 &gt; r2\n\nTrue\n\n\n\nr1 == r2\n\nFalse\n\n\n\nr1 == r3 # No son iguales porque sus dimensiones no lo son.\n\nFalse\n\n\n\n\nApariencias\nAdem√°s de los operadores de comparaci√≥n, muchas funciones built-in de Python utilizan m√©todos m√°gicos internamente. Una de las m√°s comunes es repr(), que se encarga de devolver una representaci√≥n de un objeto cuando se lo muestra en pantalla. Para personalizar esa representaci√≥n en nuestras clases, debemos implementar el m√©todo m√°gico __repr__.\n\nclass Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    def __repr__(self):\n        return f\"Rectangulo(base={self.base}, altura={self.altura})\"\n\n\nr1 = Rectangulo(5, 3.5)\nr1\n\nRectangulo(base=5, altura=3.5)\n\n\nTambi√©n str utiliza internamente un m√©todo especial llamado __str__, que define c√≥mo debe mostrarse un objeto cuando se convierte a texto de forma legible.\n\nclass Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    def __repr__(self):\n        return f\"Rectangulo(base={self.base}, altura={self.altura})\"\n\n    def __str__(self):\n        return f\"Rect√°ngulo de base {self.base} y altura {self.altura}\"\n\n\nr1 = Rectangulo(5, 3.5)\nr1\n\nRectangulo(base=5, altura=3.5)\n\n\n\nprint(\"repr:\", repr(r1))\nprint(\"str:\", str(r1))\n\nrepr: Rectangulo(base=5, altura=3.5)\nstr: Rect√°ngulo de base 5 y altura 3.5\n\n\n\n\n\n\n\n\nDiferencia entre __repr__ y __str__\n\n\n\nAunque ambos m√©todos devuelven una representaci√≥n en texto de un objeto, tienen prop√≥sitos distintos:\n\n__repr__ busca ofrecer una representaci√≥n precisa y detallada, √∫til para desarrolladores. Idealmente, deber√≠a ser lo m√°s cercana posible al c√≥digo necesario para reconstruir el objeto.\n__str__, en cambio, devuelve una representaci√≥n m√°s legible y amigable, pensada para usuarios finales o para mostrar el objeto en interfaces y mensajes.\n\nPor ejemplo:\nfrom datetime import datetime\n\nd = datetime(2025, 10, 7, 17, 30)\nprint(\"repr:\", repr(d))\nprint(\"str:\", str(d))\nrepr: datetime.datetime(2025, 10, 7, 17, 30)\nstr: 2025-10-07 17:30:00\n\n\n\n\nAritm√©tica\nFinalmente, retomamos el ejemplo de la introducci√≥n del apunte, que tanto hemos mencionado a lo largo del curso: la suma de objetos.\nResulta que el operador de suma + utiliza internamente el m√©todo especial __add__. Gracias a esto, tambi√©n podemos definir c√≥mo deben sumarse dos objetos de una clase que nosotros creamos.\nPor ejemplo, supongamos una clase que representa vectores en dos dimensiones, inicializada con valores para x e y.\nLa suma de dos vectores est√° definida componente a componente:\n\\[\n\\vec{u} + \\vec{v} = (x_1 + x_2, y_1 + y_2)\n\\]\nY podemos implementar la clase de la siguiente manera:\n\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n\n    def __repr__(self):\n        return f\"Vector({self.x}, {self.y})\"\n\n\nv = Vector(2, 2)\nu = Vector(1, -0.5)\nprint(v)\nprint(u)\n\nVector(2, 2)\nVector(1, -0.5)\n\n\nGracias a la implementaci√≥n de __add__, est√° definida la suma entre vectores:\n\nv + u\n\nVector(3, 1.5)\n\n\nY como tambi√©n implementamos __repr__, obtenemos una representaci√≥n textual legible.\nTodos los operadores aritm√©ticos en Python utilizan internamente m√©todos especiales. A continuaci√≥n se muestran algunos de los m√°s comunes:\n\n\n\n\n\n\n\n\nM√©todo\nOperador asociado\nDescripci√≥n\n\n\n\n\n__add__(self, other)\n+\nSuma: self + other\n\n\n__sub__(self, other)\n-\nResta: self - other\n\n\n__mul__(self, other)\n*\nMultiplicaci√≥n: self * other\n\n\n__truediv__(self, other)\n/\nDivisi√≥n real: self / other\n\n\n__floordiv__(self, other)\n//\nDivisi√≥n entera: self // other\n\n\n__mod__(self, other)\n%\nM√≥dulo: self % other\n\n\n__pow__(self, other)\n**\nPotencia: self ** other\n\n\n\nConsiderando los vectores \\(\\vec{u}\\), \\(\\vec{v}\\) y el escalar \\(c\\), podemos implementar las siguientes operaciones en nuestra clase Vector:\n\\[\n\\begin{aligned}\n\\vec{u} + \\vec{v} &= (x_1 + x_2, y_1 + y_2) \\\\\n\\vec{u} - \\vec{v} &= (x_1 - x_2, y_1 - y_2) \\\\\n\\vec{u} \\times c &= (x_1 \\times c, y_1 \\times c) \\\\\n\\frac{\\vec{u}}{c} &= \\left(\\frac{x_1}{c}, \\frac{y_1}{c}\\right) \\\\\n\\end{aligned}\n\\]\nEn Python:\n\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vector(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, scalar):\n        return Vector(self.x * scalar, self.y * scalar)\n\n    def __truediv__(self, scalar):\n        return Vector(self.x / scalar, self.y / scalar)\n\n    def __repr__(self):\n        return f\"Vector({self.x}, {self.y})\"\n\nVeamos algunos ejemplos:\n\nu = Vector(1, -0.5)\nv = Vector(2, 1)\n\n\nu + v\n\nVector(3, 0.5)\n\n\n\nu - v\n\nVector(-1, -1.5)\n\n\n\nv - u \n\nVector(1, 1.5)\n\n\n\nu * 2.5\n\nVector(2.5, -1.25)\n\n\n\nv / 4\n\nVector(0.5, 0.25)\n\n\nPara finalizar, podemos usar la funci√≥n graficar_vectores, que recibe una lista de vectores y los representa gr√°ficamente en el plano, mostrando de forma visual el resultado de las operaciones realizadas.\n\n\nC√≥digo\nimport matplotlib.pyplot as plt\n\ndef graficar_vectores(vectores):\n    x_range = [0, 0]\n    y_range = [0, 0]\n\n    fig, ax = plt.subplots(figsize=(6, 5))\n\n    for i, vector in enumerate(vectores):\n        ax.quiver(\n            0, 0, vector.x, vector.y,\n            angles='xy',\n            scale_units='xy',\n            scale=1,\n            color=f\"C{i}\",\n            label=str(vector)\n        )\n\n        x_range[0] = min(x_range[0], vector.x)\n        x_range[1] = max(x_range[1], vector.x)\n\n        y_range[0] = min(y_range[0], vector.y)\n        y_range[1] = max(y_range[1], vector.y)\n\n    x_range[0] = x_range[0] - 0.5\n    x_range[1] = x_range[1] + 0.5\n    y_range[0] = y_range[0] - 0.5\n    y_range[1] = y_range[1] + 0.5\n\n    ax.axhline(0, color='k', linewidth=0.5)\n    ax.axvline(0, color='k', linewidth=0.5)\n    ax.set(xlim=x_range, ylim=y_range, xlabel=\"x\", ylabel=\"y\")\n    ax.grid()\n    ax.set_axisbelow(True)\n    ax.legend(loc=\"upper left\")\n    plt.show()\n\n\nGrafiquemos tres vectores cualesquiera:\n\ngraficar_vectores(\n    [\n        Vector(1, 2),\n        Vector(0.5, 0.75),\n        Vector(-1, 0.5),\n    ]\n)\n\n\n\n\n\n\n\n\nEl vector \\(\\vec{v}\\) y su opuesto \\(-\\vec{v}\\):\n\nv = Vector(2.5, 3)\n\ngraficar_vectores([v, v * (-1)])\n\n\n\n\n\n\n\n\nEl vector \\(\\vec{v}\\) y \\(1.5 \\times \\vec{v}\\):\n\ngraficar_vectores([v, v * 1.5])\n\n\n\n\n\n\n\n\nEl vector \\(\\vec{v}\\) y \\(0.5 \\times \\vec{v}\\):\n\ngraficar_vectores([v, v * 0.5])\n\n\n\n\n\n\n\n\nLos vectores \\(\\vec{u}\\), \\(\\vec{v}\\) y su suma:\n\nu = Vector(0.5, 0.3)\nv = Vector(0.2, 0.7)\n\ngraficar_vectores([u, v, u + v])\n\n\n\n\n\n\n\n\nY ahora su resta:\n\ngraficar_vectores([u, v, u - v])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSobrecarga de operadores\n\n\n\nA la capacidad de redefinir el comportamiento de los operadores est√°ndar (como +, -, ==, etc.) se la conoce como sobrecarga de operadores.\nGracias a ella, podemos escribir programas m√°s expresivos, legibles e intuitivos, haciendo que nuestras clases se comporten como tipos nativos de Python.",
    "crumbs": [
      "Teor√≠a",
      "U3 - Programaci√≥n Orientada a Objetos",
      "4 - Polimorfismo"
    ]
  },
  {
    "objectID": "teoria/03_oop/04_polimorfismo.html#otros-m√©todos",
    "href": "teoria/03_oop/04_polimorfismo.html#otros-m√©todos",
    "title": "4 - Polimorfismo",
    "section": "Otros m√©todos",
    "text": "Otros m√©todos\nLos m√©todos m√°gicos que cubrimos en este apunte solo incluyen alg√∫nos de los m√©todos disponibles.\nAlguno de ellos se muestran a continuaci√≥n:\n\n\n\n\n\n\n\n\nM√©todo\nC√≥mo se usa\nDescripci√≥n\n\n\n\n\n__neg__(self)\n-obj\nDevuelve el valor negado del objeto.\n\n\n__pos__(self)\n+obj\nDevuelve el valor positivo del objeto.\n\n\n__abs__(self)\nabs(obj)\nDevuelve el valor absoluto del objeto.\n\n\n__len__(self)\nlen(obj)\nDevuelve la longitud del objeto.\n\n\n__iter__(self)\nfor x in obj\nDevuelve un iterador.\n\n\n__next__(self)\nnext(obj)\nDevuelve el siguiente elemento de un iterador.\n\n\n__contains__(self, item)\nitem in obj\nComprueba pertenencia.\n\n\n__call__(self, ...)\nobj()\nPermite llamar a un objeto como si fuera funci√≥n.\n\n\n__bool__(self)\nbool(obj)\nDefine si el objeto se considera True o False.\n\n\n__hash__(self)\nhash(obj)\nPermite usar el objeto en conjuntos y como clave en diccionarios.\n\n\n\nUn recurso √∫til para explorar el funcionamiento de ellos es Python Magic Methods de Real Python. El listado exhaustivo se puede encontrar en la documentaci√≥n oficial de Python.",
    "crumbs": [
      "Teor√≠a",
      "U3 - Programaci√≥n Orientada a Objetos",
      "4 - Polimorfismo"
    ]
  },
  {
    "objectID": "teoria/03_oop/01_fundamentos.html",
    "href": "teoria/03_oop/01_fundamentos.html",
    "title": "1 - Fundamentos",
    "section": "",
    "text": "Para hablar de programaci√≥n orientada a objetos (OOP, por sus siglas en ingl√©s), podemos empezar pregunt√°ndonos qu√© es un objeto. Aunque no solemos pensar en ello de forma consciente, porque todos podemos distinguir un objeto de lo que no lo es, vale la pena definirlo como algo tangible, que se puede percibir, tocar y manipular. ¬°Nos pasamos toda la vida interactuando con objetos!\nEn el mundo real, los objetos tienen atributos o propiedades que los describen. Por ejemplo, un televisor tiene forma, tama√±o, color, peso, entre otros. Adem√°s, los objetos tambi√©n pueden realizar acciones. Siguiendo con el ejemplo del televisor, puede encenderse, apagarse, cambiar de canal, modificar la fuente de entrada para ver una serie en Netflix o simplemente reproducir m√∫sica.\nEn programaci√≥n, la definici√≥n de objeto no difiere mucho de la anterior. Aunque los objetos no sean elementos f√≠sicos, representan entidades que poseen atributos y pueden ejecutar acciones.\nLa programaci√≥n orientada a objetos es un paradigma que organiza el c√≥digo en torno a estos objetos, que combinan datos (atributos) y comportamientos o acciones (m√©todos) dentro de una misma entidad. Este enfoque permite no solo crear e interactuar con objetos, sino tambi√©n definir nuestros propios tipos de objetos, adaptados a las necesidades del programa.",
    "crumbs": [
      "Teor√≠a",
      "U3 - Programaci√≥n Orientada a Objetos",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/03_oop/01_fundamentos.html#introducci√≥n",
    "href": "teoria/03_oop/01_fundamentos.html#introducci√≥n",
    "title": "1 - Fundamentos",
    "section": "",
    "text": "Para hablar de programaci√≥n orientada a objetos (OOP, por sus siglas en ingl√©s), podemos empezar pregunt√°ndonos qu√© es un objeto. Aunque no solemos pensar en ello de forma consciente, porque todos podemos distinguir un objeto de lo que no lo es, vale la pena definirlo como algo tangible, que se puede percibir, tocar y manipular. ¬°Nos pasamos toda la vida interactuando con objetos!\nEn el mundo real, los objetos tienen atributos o propiedades que los describen. Por ejemplo, un televisor tiene forma, tama√±o, color, peso, entre otros. Adem√°s, los objetos tambi√©n pueden realizar acciones. Siguiendo con el ejemplo del televisor, puede encenderse, apagarse, cambiar de canal, modificar la fuente de entrada para ver una serie en Netflix o simplemente reproducir m√∫sica.\nEn programaci√≥n, la definici√≥n de objeto no difiere mucho de la anterior. Aunque los objetos no sean elementos f√≠sicos, representan entidades que poseen atributos y pueden ejecutar acciones.\nLa programaci√≥n orientada a objetos es un paradigma que organiza el c√≥digo en torno a estos objetos, que combinan datos (atributos) y comportamientos o acciones (m√©todos) dentro de una misma entidad. Este enfoque permite no solo crear e interactuar con objetos, sino tambi√©n definir nuestros propios tipos de objetos, adaptados a las necesidades del programa.",
    "crumbs": [
      "Teor√≠a",
      "U3 - Programaci√≥n Orientada a Objetos",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/03_oop/01_fundamentos.html#objetos-familiares",
    "href": "teoria/03_oop/01_fundamentos.html#objetos-familiares",
    "title": "1 - Fundamentos",
    "section": "Objetos familiares",
    "text": "Objetos familiares\nAs√≠ como interactuamos con objetos en la vida real desde nuestros primeros d√≠as, tambi√©n lo hemos estado haciendo en Python desde el comienzo. Por ejemplo, cada vez que creamos una cadena de texto, en realidad estamos creando un objeto de la clase str.\n\nx = \"Hola, soy un objeto de tipo 'str'.\"\ny = \"¬øY yo? ¬°Yo tambi√©n soy un objeto de tipo 'str'!\"\nprint(f\"x = {x}\")\nprint(f\"y = {y}\")\n\nx = Hola, soy un objeto de tipo 'str'.\ny = ¬øY yo? ¬°Yo tambi√©n soy un objeto de tipo 'str'!\n\n\nTanto x como y son objetos del mismo tipo: cadenas de caracteres, que en Python corresponden al tipo str. Sin embargo, x e y no son el mismo objeto, sino dos objetos distintos. Esto puede comprobarse no solo por su contenido (uno de sus atributos), sino tambi√©n comparando sus identificadores √∫nicos (ID), que son diferentes.\n\nprint(id(x))\nprint(id(y))\n\n140223504929120\n140223504962192\n\n\nA su vez, los objetos de tipo str pueden realizar ciertas acciones. Por ejemplo, si queremos convertir todas las letras de una cadena a may√∫sculas, podemos hacer lo siguiente:\n\nx.upper()\n\n\"HOLA, SOY UN OBJETO DE TIPO 'STR'.\"\n\n\nLas cadenas de caracteres son uno de los muchos tipos de objetos con los que ya hemos interactuado. Todas las estructuras de datos que hemos utilizado ‚Äîdesde las m√°s simples, como los enteros, flotantes y booleanos, hasta las m√°s complejas, como listas, tuplas y diccionarios‚Äî no son m√°s que distintos tipos de objetos.\nEn Python, cada tipo de dato est√° implementado como una clase, y trabajar con estas clases no solo nos permite crear nuestros propios tipos de datos seg√∫n nuestras necesidades, sino tambi√©n interactuar con los objetos que generamos a partir de ellas.",
    "crumbs": [
      "Teor√≠a",
      "U3 - Programaci√≥n Orientada a Objetos",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/03_oop/01_fundamentos.html#clases-y-objetos",
    "href": "teoria/03_oop/01_fundamentos.html#clases-y-objetos",
    "title": "1 - Fundamentos",
    "section": "Clases y objetos",
    "text": "Clases y objetos\nEn el contexto de la programaci√≥n orientada a objetos, se utilizan clases para definir nuevas clases o tipos de objetos, especificando qu√© atributos deben tener y qu√© acciones pueden realizar. De forma informal, una clase puede pensarse como una plantilla que determina c√≥mo se ve y se comporta un objeto.\nPor ejemplo, imaginemos un molde para hacer paletas heladas. Este molde permite producir paletas, pero no es una paleta en s√≠. De hecho, se parece m√°s a una f√°brica de paletas.\nEl molde define aspectos estructurales como la forma y el tama√±o de las paletas, pero no determina por completo c√≥mo ser√°n. Podemos llenarlo con diferentes l√≠quidos, sabores, colores o aromas, y as√≠ obtener resultados variados a partir del mismo molde.\nEn programaci√≥n orientada a objetos, una clase cumple un rol similar: define la estructura y el comportamiento general de los objetos que se crear√°n a partir de ella. Los objetos, en cambio, son las instancias concretas generadas a partir de esa clase, cada una con sus propias caracter√≠sticas particulares, como cada paleta helada que sale del molde.\n\n\n\n\n\n\n¬øClases o tipos?\n\n\n\nEn Python, los tipos de datos est√°n implementados como clases. Por eso mismo, en todos los casos debajo, se puede ver que el tipo est√° precedido por class.\nprint(type(\"texto\"))\nprint(type([1, 2, 3]))\nprint(type({\"a\": 1, \"b\": 2}))\n&lt;class 'str'&gt;\n&lt;class 'list'&gt;\n&lt;class 'dict'&gt;\nAs√≠, en Python, es lo mismo hablar de clases o tipos de datos.\n\n\n\nEjemplo: la clase dict\nLos diccionarios de Python son instancias de la clase dict. Es esta clase la que define, entre otras cosas, que los diccionarios tienen claves y valores.\nEn el ejemplo debajo, tanto d1 como d2 son instancias u objetos de la clase dict (es decir, son objetos creados con el mismo molde). Sin embargo, d1 y d2 son objetos distintos, que adem√°s tienen diferentes valores para sus atributos (claves y valores).\n\nd1 = {\"a\": 100, \"b\": 250}\nd2 = {\"m\": 20, \"n\": False}\n\nprint(type(d1))\nprint(type(d2))\n\n&lt;class 'dict'&gt;\n&lt;class 'dict'&gt;\n\n\n\nprint(d1 is d2)\nprint(d1 == d2)\n\nFalse\nFalse\n\n\nSi consultamos la ayuda de dict mediante help(dict), podemos ver que Python dice que esto se refiere a una clase:\nhelp(dict)\n\nHelp on class dict in module builtins:\n\n\n\n\n\n\n\n¬øObjetos o instancias?\n\n\n\nEn el contexto de programaci√≥n orientada a objetos, los t√©rminos ‚Äúobjeto‚Äù e ‚Äúinstancia‚Äù suelen usarse de manera intercambiable: ambos hacen referencia a una entidad concreta creada a partir de una clase.\nEn el siguiente ejemplo, decimos que l es una instancia de la clase list:\nl = list(\"abcde\")",
    "crumbs": [
      "Teor√≠a",
      "U3 - Programaci√≥n Orientada a Objetos",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/03_oop/01_fundamentos.html#creando-nuestras-propias-clases",
    "href": "teoria/03_oop/01_fundamentos.html#creando-nuestras-propias-clases",
    "title": "1 - Fundamentos",
    "section": "Creando nuestras propias clases",
    "text": "Creando nuestras propias clases\nLa definici√≥n de una clase, que crea un nuevo tipo de dato, define los atributos de un objeto (datos que representan estado) y las cosas que este objeto puede hacer (funciones que representan comportamiento).\nPara definir una nueva clase en Python se usa la sentencia class seguida del nombre de la clase. Veamos el siguiente ejemplo comentado l√≠nea a l√≠nea.\n\n1class PaletaHelada:\n2    def __init__(self):\n3        print(\"Creando nueva paleta helada\")\n\n\n1\n\nLa sentencia class indica el inicio de la definici√≥n de una clase. A continuaci√≥n se escribe el nombre de la clase y, al final, los dos puntos (:), que se√±alan el comienzo del bloque donde se definen sus atributos y funciones (llamados m√©todos).\n\n2\n\nPor lo general, lo primero que se define dentro de una clase es su m√©todo de inicializaci√≥n, siempre llamado __init__.\n\n3\n\nEsta l√≠nea se ejecuta cada vez que se crea un nuevo objeto de la clase. En este caso, imprime un mensaje en pantalla como parte del proceso de inicializaci√≥n.\n\n\n\n\nDefinir una clase no crea ning√∫n objeto por s√≠ misma; simplemente construye el molde o plantilla a partir del cual se podr√°n crear objetos m√°s adelante.\nPara crear un objeto a partir de una clase, es necesario ‚Äúllamar‚Äù a la clase, lo que genera una nueva instancia de esa clase.\n\npaleta1 = PaletaHelada()\n\nCreando nueva paleta helada\n\n\nLa variable paleta1 representa un objeto de la clase PaletaHelada. En otras palabras, hemos creado, al menos en c√≥digo, una paleta helada.\nComo las clases son reutilizables, podemos crear tantas paletas heladas como queramos, simplemente creando nuevas instancias de la clase.\n\npaleta2 = PaletaHelada()\n\nCreando nueva paleta helada\n\n\nAl imprimir estos objetos, obtenemos una representaci√≥n generada autom√°ticamente por Python. En ella podemos ver que ambos son instancias de la clase PaletaHelada, aunque tambi√©n queda claro que ocupan ubicaciones distintas en memoria. Esto confirma que se trata de objetos distintos, aunque provengan de la misma clase.\n\nprint(paleta1)\nprint(paleta2)\n\n&lt;__main__.PaletaHelada object at 0x7f8854339220&gt;\n&lt;__main__.PaletaHelada object at 0x7f8854338530&gt;\n\n\n\nPar√°metros de inicializaci√≥n\nTambi√©n es posible pasar argumentos al momento de inicializar un objeto. Previamente, tenemos que agregar los par√°metros necesarios en el m√©todo de inicializaci√≥n.\n\nclass PaletaHelada:\n1    def __init__(self, gusto):\n2        print(f\"Creando nueva paleta helada de gusto {gusto}\")\n\n\n1\n\nEl m√©todo __init__ ahora recibe dos par√°metros:\n\n2\n\nEl valor de gusto se utiliza para mostrar un mensaje de inicializaci√≥n personalizado, indicando el sabor de la paleta.\n\n\n\n\nGracias a esto, ahora podemos crear paletas heladas con distintos sabores, como frutilla, naranja, entre otros.\n\npaleta1 = PaletaHelada(\"frutilla\")\npaleta2 = PaletaHelada(\"naranja\")\n\nCreando nueva paleta helada de gusto frutilla\nCreando nueva paleta helada de gusto naranja\n\n\nSin embargo, podemos observar que ninguna de estas dos instancias recuerda algo relacionado al gusto con el que fue inicializado.\npaleta1.gusto\n\nAttributeError: 'PaletaHelada' object has no attribute 'gusto'\n\npaleta2.gusto\n\nAttributeError: 'PaletaHelada' object has no attribute 'gusto'\n\nSi queremos que nuestros objetos puedan recordar datos, necesitamos comprender c√≥mo se utilizan los atributos.\n\n\n\n\n\n\nInstanciaci√≥n de un nuevo objeto\n\n\n\nLa instanciaci√≥n es el proceso mediante el cual se crea un objeto a partir de una clase. La sintaxis general es la siguiente:\n&lt;objeto&gt; = &lt;NombreClase&gt;(&lt;argumentos opcionales&gt;)\nAunque al principio pueda parecer poco familiar, en realidad hemos estado instanciando objetos desde los primeros pasos que dimos en Python. Por ejemplo, al escribir list(\"hola\"), estamos creando un objeto de la clase list a partir de la cadena \"hola\". Del mismo modo, con range(10) craemos un objeto de la clase range.",
    "crumbs": [
      "Teor√≠a",
      "U3 - Programaci√≥n Orientada a Objetos",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/03_oop/01_fundamentos.html#atributos",
    "href": "teoria/03_oop/01_fundamentos.html#atributos",
    "title": "1 - Fundamentos",
    "section": "Atributos",
    "text": "Atributos\nLos atributos son variables asociadas a un objeto que representan su estado.\nEn Python, los atributos no requieren ninguna sintaxis especial para ser declarados. Simplemente se crean dentro de un m√©todo (generalmente en __init__) usando la notaci√≥n self.&lt;atributo&gt;.\nEn nuestro ejemplo de la clase PaletaHelada, podemos hacer:\n\nclass PaletaHelada:\n    def __init__(self, gusto):\n1        self.gusto = gusto\n\n\n1\n\nEl valor de gusto que se pasa al momento de crear la instancia se asigna al atributo gusto del objeto.\n\n\n\n\nAunque la representaci√≥n autom√°tica del objeto no cambia, ahora el objeto tiene estado: puede ‚Äúrecordar‚Äù el gusto con el que fue inicializado.\n\npaleta1 = PaletaHelada(\"frutilla\")\npaleta1\n\n&lt;__main__.PaletaHelada at 0x7f8854339c70&gt;\n\n\n\npaleta1.gusto\n\n'frutilla'\n\n\nEn este caso, la variable gusto es una variable de instancia o atributo de instancia. Estas variables existen solo dentro del objeto que las contiene, y no afectan a otras instancias de la misma clase. As√≠, distintos objetos de una misma clase pueden tener valores diferentes en sus atributos.\n\npaleta2 = PaletaHelada(\"naranja\")\nprint(paleta2.gusto)\nprint(paleta1.gusto)\n\nnaranja\nfrutilla\n\n\nLos atributos tambi√©n pueden definirse o modificarse fuera de los m√©todos de la clase.\nPor ejemplo, es posible cambiar el valor de un atributo simplemente asign√°ndole un nuevo valor utilizando la instancia:\n\npaleta1.gusto = \"crema americana\"\n\n\npaleta1.gusto\n\n'crema americana'\n\n\nY tambi√©n se puede asignarle un valor a un nuevo atributo:\n\npaleta1.cobertura = \"chocolate\"\n\nprint(paleta1.gusto, paleta1.cobertura, sep=\", \")\n\ncrema americana, chocolate\n\n\nEste nuevo atributo existe √∫nicamente en la instancia a la que fue asignado (paleta1). Es decir, paleta2 no tiene un atributo llamado cobertura, ya que no fue definido durante su inicializaci√≥n ni se le asign√≥ m√°s adelante.\npaleta2.cobertura\n\nAttributeError: 'PaletaHelada' object has no attribute 'cobertura'\n\nEn Python, los atributos de instancia son independientes entre objetos: si un atributo no se define expl√≠citamente en una instancia, simplemente no existe en ella.\n\nAtributos opcionales\nAunque Python permite crear nuevos atributos fuera del proceso de inicializaci√≥n de un objeto, eso no significa que sea una pr√°ctica recomendable en todos los casos.\nAsignar un atributo directamente a una instancia espec√≠fica puede generar inconsistencias: terminamos con objetos de la misma clase que no comparten la misma estructura de atributos. Esto puede dificultar la lectura del c√≥digo y producir errores si intentamos acceder a un atributo que no existe en todas las instancias.\nUna alternativa m√°s clara y segura es definir atributos opcionales dentro del m√©todo __init__, asign√°ndoles un valor por defecto como None. De esta forma, todas las instancias tendr√°n los mismos atributos, aunque algunos puedan no tener un valor definido inicialmente.\n\nclass PaletaHelada:\n    def __init__(self, gusto, cobertura=None):\n        self.gusto = gusto\n        self.cobertura = cobertura\n\npaleta1 = PaletaHelada(\"crema americana\", \"chocolate\")\npaleta2 = PaletaHelada(\"frutilla\")\n\n\nprint(paleta1.gusto, paleta1.cobertura, sep=\", \")\nprint(paleta2.gusto, paleta2.cobertura, sep=\", \")\n\ncrema americana, chocolate\nfrutilla, None\n\n\nCon este enfoque, ambos objetos tienen los mismos atributos (gusto y cobertura), lo que mantiene la consistencia entre instancias de la clase. En el caso de paleta2, como no se especific√≥ ninguna cobertura al crear el objeto, el valor de cobertura es None, lo cual indica que esa paleta no tiene ninguna cobertura.",
    "crumbs": [
      "Teor√≠a",
      "U3 - Programaci√≥n Orientada a Objetos",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/03_oop/01_fundamentos.html#m√©todos",
    "href": "teoria/03_oop/01_fundamentos.html#m√©todos",
    "title": "1 - Fundamentos",
    "section": "M√©todos",
    "text": "M√©todos\nAhora que comprendemos c√≥mo los datos definen el estado de un objeto, el √∫ltimo concepto que nos falta abordar son las acciones que un objeto puede realizar.\nPara llevar a cabo acciones, los objetos utilizan m√©todos.\nLos m√©todos son funciones asociadas a una clase determinada, y permiten que los objetos de la clase realicen operaciones o modifiquen su propio estado.\nPor ejemplo, el m√©todo upper es un m√©todo propio de los objetos de tipo str (cadenas de caracteres) y podemos invocarlo de la siguiente manera:\n\n\"Rosario\".upper()\n\n'ROSARIO'\n\n\nPero no podemos llamarlo sobre una lista:\n[\"Rosario\", \"Santa Fe\"].upper()\n\nAttributeError: 'list' object has no attribute 'upper'\n\nEn el caso de las clases creadas por nosotros, los m√©todos no son m√°s que funciones definidas dentro de la clase.\nA diferencia de las funciones normales, todos los m√©todos deben tener al menos un par√°metro especial, llamado self por convenci√≥n, que representa a la instancia sobre la que se est√° llamando el m√©todo.\nGracias a self, los m√©todos pueden acceder y modificar los atributos del objeto:\n\nclass PaletaHelada:\n    def __init__(self, gusto, cobertura=None):\n        self.gusto = gusto\n        self.cobertura = cobertura\n\n    def mostrar_info(self):\n        print(\"PaletaHelada\")\n        print(f\" - Gusto: {self.gusto}\")\n        print(f\" - Cobertura: {self.cobertura}\")\n\n\npaleta = PaletaHelada(gusto=\"Dulce de leche\", cobertura=\"Chocolate amargo\")\npaleta\n\n&lt;__main__.PaletaHelada at 0x7f885433b440&gt;\n\n\nPara ejecutar el m√©todo, se lo llama de la misma forma que a cualquier otro m√©todo.\n\npaleta.mostrar_info()\n\nPaletaHelada\n - Gusto: Dulce de leche\n - Cobertura: Chocolate amargo\n\n\n\npaleta2 = PaletaHelada(gusto=\"Mentra granizada\", cobertura=\"Chocolate blanco\")\npaleta2.mostrar_info()\n\nPaletaHelada\n - Gusto: Mentra granizada\n - Cobertura: Chocolate blanco\n\n\n\nM√©todos que modifican estado\nEl m√©todo mostrar_info no altera el estado del objeto: simplemente muestra un resumen de su estado actual.\nSin embargo, como los m√©todos acceden al objeto mediante self, tambi√©n pueden modificar su estado.\nEn el siguiente ejemplo, el m√©todo quitar_cobertura elimina cualquier cobertura que pueda tener nuestro helado.\n\nclass PaletaHelada:\n    def __init__(self, gusto, cobertura=None):\n        self.gusto = gusto\n        self.cobertura = cobertura\n\n    def mostrar_info(self):\n        print(\"PaletaHelada\")\n        print(f\" - Gusto: {self.gusto}\")\n        print(f\" - Cobertura: {self.cobertura}\")\n\n    def quitar_cobertura(self):\n        self.cobertura = None\n\n\npaleta = PaletaHelada(\"Chocolate\", \"Chocolate\")\npaleta.mostrar_info()\nprint(\"\")\npaleta.quitar_cobertura()\npaleta.mostrar_info()\n\nPaletaHelada\n - Gusto: Chocolate\n - Cobertura: Chocolate\n\nPaletaHelada\n - Gusto: Chocolate\n - Cobertura: None\n\n\n\n\nM√©todos que reciben argumentos\nLos m√©todos mostrar_info y quitar_cobertura no reciben argumentos, a lo sumo usan los datos ya almacenados en el objeto.\nTambi√©n es posible definir m√©todos que acepten argumentos, lo que permite realizar distintas operaciones y, por ejemplo, modificar el estado interno del objeto.\nA continuaci√≥n, incorporamos a la clase un nuevo m√©todo que permite actualizar la cobertura de la paleta helada.\n\nclass PaletaHelada:\n    def __init__(self, gusto, cobertura=None):\n        self.gusto = gusto\n        self.cobertura = cobertura\n\n    def mostrar_info(self):\n        print(\"PaletaHelada\")\n        print(f\" - Gusto: {self.gusto}\")\n        print(f\" - Cobertura: {self.cobertura}\")\n\n    def cambiar_cobertura(self, cobertura):\n        self.cobertura = cobertura\n\n\npaleta = PaletaHelada(\"Chocolate\", \"Chocolate\")\npaleta.mostrar_info()\n\nprint(\"\")\npaleta.cambiar_cobertura(\"Chocolate blanco\")\npaleta.mostrar_info()\n\nPaletaHelada\n - Gusto: Chocolate\n - Cobertura: Chocolate\n\nPaletaHelada\n - Gusto: Chocolate\n - Cobertura: Chocolate blanco\n\n\n\n\nM√©todos que devuelven resultados\nComo los m√©todos son funciones de Python, tambi√©n pueden devolver un resultado.\nPor ejemplo, el m√©todo tiene_cobertura retorna True cuando la paleta helada tiene asignada alguna cobertura, sin importar cu√°l sea.\n\nclass PaletaHelada:\n    def __init__(self, gusto, cobertura=None):\n        self.gusto = gusto\n        self.cobertura = cobertura\n\n    def mostrar_info(self):\n        print(\"PaletaHelada\")\n        print(f\" - Gusto: {self.gusto}\")\n        print(f\" - Cobertura: {self.cobertura}\")\n\n    def cambiar_cobertura(self, cobertura):\n        self.cobertura = cobertura\n\n    def tiene_cobertura(self):\n        return self.cobertura is not None\n\n\npaleta = PaletaHelada(\"Dulce de leche\", \"Chocolate blanco\")\npaleta2 = PaletaHelada(\"Dulce de leche\")\n\nprint(paleta.tiene_cobertura())\nprint(paleta2.tiene_cobertura())\n\nTrue\nFalse\n\n\n\n\nM√©todos que devuelven al objeto\nFinalmente, como un m√©todo puede devolver cualquier tipo de objeto, tambi√©n puede retornar la propia instancia sobre la que fue llamado (es decir, la que recibe en self).\nEste patr√≥n se utiliza con frecuencia cuando se desea permitir el encadenamiento de m√©todos, ya que cada m√©todo devuelve el mismo objeto y permite seguir llamando otros m√©todos sobre √©l en una sola l√≠nea.\n\nclass PaletaHelada:\n    def __init__(self, gusto, cobertura=None):\n        self.gusto = gusto\n        self.cobertura = cobertura\n\n    def mostrar_info(self):\n        print(\"PaletaHelada\")\n        print(f\" - Gusto: {self.gusto}\")\n        print(f\" - Cobertura: {self.cobertura}\")\n\n    def cambiar_cobertura(self, cobertura):\n        self.cobertura = cobertura\n1        return self\n\nPaletaHelada(\"Frutilla\").cambiar_cobertura(\"Chocolate\").mostrar_info()\n\n\n1\n\nLuego de actualizar la cobertura, se devuelve a la instancia con la que se llam√≥ al m√©todo.\n\n\n\n\nPaletaHelada\n - Gusto: Frutilla\n - Cobertura: Chocolate\n\n\nComo el m√©todo cambiar_cobertura devuelve la propia instancia, es posible encadenar su llamada con otros m√©todos de la clase, como por ejemplo .mostrar_info.",
    "crumbs": [
      "Teor√≠a",
      "U3 - Programaci√≥n Orientada a Objetos",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/03_oop/01_fundamentos.html#ejemplo-final-cuenta-bancaria",
    "href": "teoria/03_oop/01_fundamentos.html#ejemplo-final-cuenta-bancaria",
    "title": "1 - Fundamentos",
    "section": "Ejemplo final: Cuenta bancaria",
    "text": "Ejemplo final: Cuenta bancaria\nPara concluir este apunte, vamos a implementar una clase que represente de forma sencilla una cuenta bancaria.\nEn este modelo simplificado, cada cuenta tendr√° tres atributos:\n\ntitular: el nombre de la persona due√±a de la cuenta\nsaldo: el dinero disponible en la cuenta\nmoneda: el tipo de moneda en el que est√° expresado el saldo (por ejemplo, \"ARS\" o \"USD\")\n\nAdem√°s, la clase contar√° con m√©todos que permitan realizar operaciones b√°sicas:\n\ndepositar: suma dinero al saldo actual\nretirar: descuenta dinero del saldo, si hay fondos suficientes\ntransferir: mueve dinero de una cuenta a otra\nresumen: muestra el estado actual de la cuenta de forma clara y legible\n\n\nclass CuentaBancaria:\n    def __init__(self, titular, saldo=0, moneda=\"ARS\"):\n        self.titular = titular\n        self.saldo = saldo\n        self.moneda = moneda\n\n    def depositar(self, monto):\n        self.saldo = self.saldo + monto\n\n    def retirar(self, monto):\n        if monto &lt;= self.saldo:\n            self.saldo = self.saldo - monto\n            return True\n\n        print(f\"El saldo es insuficiente ({self.saldo} {self.moneda})\")\n        return False\n\n    def transferir(self, other, monto): # 'other' es tambien una 'CuentaBancaria'\n        if self.moneda != other.moneda:\n            print(f\"Las cuentas usan monedas distintas ({self.moneda} vs {other.moneda})\")\n            return False\n\n        if self.retirar(monto):\n            other.depositar(monto)\n\n        return True\n\n    def resumen(self):\n        print(\"Cuenta bancaria\")\n        print(f\" - Titular: {self.titular}\")\n        print(f\" - Saldo: {self.saldo}\")\n        print(f\" - Moneda: {self.moneda}\")\n\n\ncuenta_A = CuentaBancaria(\"Guido Van Rossum\", saldo=20000, moneda=\"ARS\")\ncuenta_B = CuentaBancaria(\"Ross Ihaka\", saldo=8000, moneda=\"ARS\")\n\ncuenta_A.resumen()\nprint(\"\")\ncuenta_B.resumen()\n\nCuenta bancaria\n - Titular: Guido Van Rossum\n - Saldo: 20000\n - Moneda: ARS\n\nCuenta bancaria\n - Titular: Ross Ihaka\n - Saldo: 8000\n - Moneda: ARS\n\n\n\ncuenta_A.retirar(2500)\n\nTrue\n\n\n\ncuenta_A.resumen()\n\nCuenta bancaria\n - Titular: Guido Van Rossum\n - Saldo: 17500\n - Moneda: ARS\n\n\nEn el caso de las transferencias, no solo se modifica el estado de la cuenta desde la que se realiza la operaci√≥n (cuenta_A), sino tambi√©n el estado de la cuenta que recibe el dinero (cuenta_B).\n\ncuenta_A.transferir(cuenta_B, 10000)\n\nTrue\n\n\n\ncuenta_A.resumen()\n\nCuenta bancaria\n - Titular: Guido Van Rossum\n - Saldo: 7500\n - Moneda: ARS\n\n\n\ncuenta_B.resumen()\n\nCuenta bancaria\n - Titular: Ross Ihaka\n - Saldo: 18000\n - Moneda: ARS\n\n\n\ncuenta_B.retirar(20000)\n\nEl saldo es insuficiente (18000 ARS)\n\n\nFalse\n\n\n\n\n\n\n\n\n¬øSab√≠as que ‚Ä¶? Sobre __init__\n\n\n\n\n__init__ no lleva una sentencia return. Su prop√≥sito no es devolver datos, sino inicializar el objeto.\n__init__ no crea la instancia (eso lo hace Python antes); su funci√≥n es inicializar el estado del objeto reci√©n creado.\n__init__ no es obligatorio: una clase puede funcionar perfectamente sin definirlo, aunque en ese caso no se podr√°n establecer valores iniciales personalizados al instanciar.\n\n\n\n\n\n\n\n\n\nSobre self\n\n\n\nNunca se debe pasar expl√≠citamente un valor para self, Python lo hace autom√°ticamente.",
    "crumbs": [
      "Teor√≠a",
      "U3 - Programaci√≥n Orientada a Objetos",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html",
    "title": "3 - Ejecuci√≥n condicional",
    "section": "",
    "text": "Las computadoras son muy buenas para much√≠simas cosas. En particular:\n\nDeterminar autom√°ticamente que secciones de un programa se debe ejecutar.\nRealizar tareas repetitivas.\n\nEl primer punto se refiere a la ejecuci√≥n condicional de c√≥digo y el segundo a la ejecuci√≥n repetitiva de c√≥digo.\nEstos dos puntos pueden ser vistos de manera general como control de flujo del c√≥digo.\nEn este apunte hablamos de la ejecuci√≥n condicional de c√≥digo.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "3 - Ejecuci√≥n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#introducci√≥n",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#introducci√≥n",
    "title": "3 - Ejecuci√≥n condicional",
    "section": "",
    "text": "Las computadoras son muy buenas para much√≠simas cosas. En particular:\n\nDeterminar autom√°ticamente que secciones de un programa se debe ejecutar.\nRealizar tareas repetitivas.\n\nEl primer punto se refiere a la ejecuci√≥n condicional de c√≥digo y el segundo a la ejecuci√≥n repetitiva de c√≥digo.\nEstos dos puntos pueden ser vistos de manera general como control de flujo del c√≥digo.\nEn este apunte hablamos de la ejecuci√≥n condicional de c√≥digo.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "3 - Ejecuci√≥n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if",
    "title": "3 - Ejecuci√≥n condicional",
    "section": "Bloques if",
    "text": "Bloques if\nLos bloques if utilizan la keyword if para evaluar una condici√≥n y ejecutar una secci√≥n de c√≥digo en base al resultado de esta evaluaci√≥n.\n\n\n\n\n\nVeamos un ejemplo.\n\ncondicion = True\nif condicion:\n    print(\"Se ejecuta el bloque if\")\n\nSe ejecuta el bloque if\n\n\n\ncondicion = False\nif condicion:\n    print(\"Se ejecuta el bloque if\")\n\nDe manera mas general, un bloque if es de la siguiente forma:\n\n\n\n\n\nTiene los siguientes componentes:\n\nLa palabra clave if.\nLa condici√≥n a evaluar, que tiene que ser True o False. Esta va seguida de los dos puntos : que indican el fin de la condici√≥n a evaluar y que lo siguiente es el bloque de c√≥digo a ejecutar condicionalmente.\nEl bloque de c√≥digo a evaluar si condici√≥n es verdadera.\n\nVeamos otro ejemplo.\n\ncondicion = True\nif condicion:\n    print(\"Se ejecuta el bloque if\")\n\nprint(\"Esto se imprime siempre\")\n\nSe ejecuta el bloque if\nEsto se imprime siempre\n\n\nEl segundo print() se imprime siempre porque est√° por fuera del bloque de ejecuci√≥n condicional.\n¬øC√≥mo nos damos cuenta que no est√° dentro del bloque condicional?\nSimplemente la indentaci√≥n vuelve a ser normal. El fin de la indentaci√≥n indica el fin del bloque de c√≥digo.\n\nvalor = 12\nif valor &gt; 10:\n    print(\"Se ejecuta el bloque if\")\n\nSe ejecuta el bloque if",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "3 - Ejecuci√≥n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if---else",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if---else",
    "title": "3 - Ejecuci√≥n condicional",
    "section": "Bloques if - else",
    "text": "Bloques if - else\nVimos que el bloque if nos permite ejecutar un bloque de c√≥digo de manera condicional, y que luego el programa sigue su ejecuci√≥n normal.\nTambi√©n es posible que necesitemos ejecutar un bloque de c√≥digo cuando las condiciones resulten en True y un bloque distinto en el caso contrario.\nPara eso, utilizamos el bloque if-else.\nUn bloque if-else es muy similar a un bloque if.\nLa diferencia es que nos permite definir otro bloque de c√≥digo que se ejecuta cuando la prueba condicional es False.\n\n\n\n\n\n\nedad = 21\nif edad &gt;= 16:\n    print(\"Ten√©s la edad suficiente para votar\")\nelse:\n    print(\"Lo siento, a√∫n sos demasiado j√≥ven para votar\")\n\nTen√©s la edad suficiente para votar\n\n\n\n\n\n\n\nAl igual que con el bloque if, cualquier parte del c√≥digo que se escriba luego del bloque if-else es ejecutada sin importar el valor de las condiciones.\nVeamos otro ejemplo donde evaluamos si un n√∫mero es par o impar.\n\nvalor = 10\nprint(valor)\n\nif valor % 2 == 0:\n    mensaje = \"Es par\"\nelse:\n    mensaje = \"Es impar\"\n\nprint(mensaje)\n\n10\nEs par\n\n\nEn este caso, print(mensaje) se ejecuta siempre.\nLo que var√≠a es el valor de la variable mensaje, que depende de si el n√∫mero es par o impar.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "3 - Ejecuci√≥n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if-elif-else",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if-elif-else",
    "title": "3 - Ejecuci√≥n condicional",
    "section": "Bloques if-elif-else",
    "text": "Bloques if-elif-else\nEs muy probable que tengamos situaciones donde necesitemos considerar m√°s de dos escenarios posibles.\nPara esto, Python ofrece los bloques if-elif-else.\nEste tipo de programa considera varias condiciones y las eval√∫a de a una a la vez hasta que alguna es verdadera. Luego se ejecuta solamente el bloque de c√≥digo que corresponde a la primer condici√≥n verdadera.\n\n\n\n\n\nSupongamos que viene un parque de diversiones a Rosario y tiene los siguientes precios para la entrada:\n\nMenores de 4 a√±os, gratis.\nPersonas entre 4 y 18 a√±os, $400.\nPersonas de 18 o mas a√±os, $600.\n\n\nedad = 3\n\nif edad &lt; 4:\n    print(\"El costo de entrada para vos es de $0.\")\nelif edad &lt; 18:\n    print(\"El costo de entrada para vos es de $400.\")\nelse:\n    print(\"El costo de entrada para vos es de $600.\")\n\nEl costo de entrada para vos es de $0.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "3 - Ejecuci√≥n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#m√∫ltiples-bloques-elif",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#m√∫ltiples-bloques-elif",
    "title": "3 - Ejecuci√≥n condicional",
    "section": "M√∫ltiples bloques elif",
    "text": "M√∫ltiples bloques elif\nHasta ahora utilizamos un √∫nico bloque elif, pero podemos usar tantos como sea necesario.\nPor ejemplo, si el parque de diversiones decide realizar un descuento para adultos mayores, dejando el precio en $350, podriamos agregar otro bloque elif que represente la evaluaci√≥n de esta condici√≥n.\n\nedad = 68\n\nif edad &lt; 4:\n    precio = 0\nelif edad &lt; 18:\n    precio = 400\nelif edad &lt; 65:\n    precio = 600\nelse:\n    precio = 350\n\nprint(f\"El precio de entrada para vos es de ${precio}.\")\n\nEl precio de entrada para vos es de $350.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "3 - Ejecuci√≥n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#omitir-el-bloque-else",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#omitir-el-bloque-else",
    "title": "3 - Ejecuci√≥n condicional",
    "section": "Omitir el bloque else",
    "text": "Omitir el bloque else\nNo hay ninguna regla que nos obligue a terminar un bloque de if-elif con un bloque else.\nUtilizar el bloque else a veces es lo correcto, pero otras veces puede ser mejor poner una condici√≥n expl√≠cita en un √∫ltimo elif que contemple solamente la condici√≥n que realmente nos interesa.\n\nedad = 10\n\nif edad &lt; 4:\n    precio = 0\nelif edad &lt; 18:\n    precio = 400\nelif edad &lt; 65:\n    precio = 600\nelif edad &gt;= 65:\n    precio = 350\n\nprint(f\"El precio de entrada para vos es de ${precio}.\")\n\nEl precio de entrada para vos es de $400.\n\n\nEl bloque elif que agregamos indica que el precio ser√° de $350 cuando la edad de la persona sea mayor o igual a 65 a√±os.\nEsta condici√≥n es m√°s expl√≠cita y f√°cil de entender que el bloque else que us√°bamos antes.\nSin embargo, todav√≠a hay un problema: el programa sigue funcionando incluso si se ingresan edades fuera de un rango razonable. A continuaci√≥n se muestra una versi√≥n m√°s completa:\n\nedad = 125\n\nif edad &lt; 0:\n    print(\"¬°Error!\")\n    precio = None\nelif edad &lt; 4:\n    precio = 0\nelif edad &lt; 18:\n    precio = 400\nelif edad &lt; 65:\n    precio = 600\nelif edad &gt;= 65 and edad &lt;= 120:\n    precio = 350\nelse:\n    print(\"¬°Error!\")\n    precio = None\n\nprint(f\"El precio de entrada para vos es ${precio}.\")\n\n¬°Error!\nEl precio de entrada para vos es $None.\n\n\nEl diagrama y el c√≥digo para el caso solo con elif se ven de la siguiente manera:",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "3 - Ejecuci√≥n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html",
    "href": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html",
    "title": "6 - Uso de c√≥digo externo",
    "section": "",
    "text": "En la mayor√≠a de los proyectos de programaci√≥n no alcanza con el c√≥digo que escribimos nosotros mismos. Con frecuencia necesitamos utilizar c√≥digo externo y/o de terceros, ya sea para resolver problemas comunes de manera m√°s r√°pida o para aprovechar el trabajo de la comunidad.\nPython facilita este proceso a trav√©s de m√≥dulos y paquetes, que nos permiten organizar, compartir e integrar c√≥digo de forma sencilla. Gracias a ellos podemos sumar nuevas funcionalidades sin tener que programar todo desde cero, mantener el c√≥digo m√°s ordenado y evitar errores innecesarios.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "6 - Uso de c√≥digo externo"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#introducci√≥n",
    "href": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#introducci√≥n",
    "title": "6 - Uso de c√≥digo externo",
    "section": "",
    "text": "En la mayor√≠a de los proyectos de programaci√≥n no alcanza con el c√≥digo que escribimos nosotros mismos. Con frecuencia necesitamos utilizar c√≥digo externo y/o de terceros, ya sea para resolver problemas comunes de manera m√°s r√°pida o para aprovechar el trabajo de la comunidad.\nPython facilita este proceso a trav√©s de m√≥dulos y paquetes, que nos permiten organizar, compartir e integrar c√≥digo de forma sencilla. Gracias a ellos podemos sumar nuevas funcionalidades sin tener que programar todo desde cero, mantener el c√≥digo m√°s ordenado y evitar errores innecesarios.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "6 - Uso de c√≥digo externo"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#m√≥dulos-y-paquetes",
    "href": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#m√≥dulos-y-paquetes",
    "title": "6 - Uso de c√≥digo externo",
    "section": "M√≥dulos y paquetes",
    "text": "M√≥dulos y paquetes\nUn m√≥dulo es un archivo de Python (por ejemplo, modulo.py) que contiene c√≥digo que se puede reutilizar. En general, los m√≥dulos definen funciones, clases y objetos que representan datos de distinta complejidad. Estos pueden ir desde estructuras simples, como una constante num√©rica, hasta otras m√°s elaboradas, como una tabla de datos con columnas de diferentes tipos.\nUn paquete, por otro lado, es una colecci√≥n de m√≥dulos, generalmente interdependientes. En la pr√°ctica, un paquete es una carpeta que contiene varios m√≥dulos e, incluso, subpaquetes (carpetas con m√≥dulos). Por lo general, los paquetes ofrecen un conjunto de herramientas m√°s amplio que un m√≥dulo individual. Adem√°s, suelen distribuirse de forma que puedan ser instalados y utilizados por otros usuarios.\n\nPor qu√© existen\nAs√≠ como las funciones ayudan a reutilizar un programa sin repetir el c√≥digo y los bucles permiten repetir la misma acci√≥n muchas veces, los m√≥dulos y paquetes tambi√©n permiten la reutilizaci√≥n de c√≥digo.\nDe este modo se evita, por ejemplo, tener que crear una funci√≥n cada vez que la queremos usar. Simplemente la importamos o la ‚Äútraemos‚Äù de un m√≥dulo o paquete. Se ahorra tiempo, se reduce la probabilidad de errores y se mejora la mantenibilidad del c√≥digo.\nAdem√°s, los paquetes y m√≥dulos nos ayudan a mantener el c√≥digo organizado y modular. Al dividir el c√≥digo en ‚Äúpartes‚Äù m√°s peque√±as y manejables, facilitamos su comprensi√≥n y mantenimiento.\nPor √∫ltimo pero no menos importante, los m√≥dulos paquetes nos permiten aprovechar el trabajo de otros. De esta manera, podemos hacer mucho m√°s sin tener que programar todo desde cero.\n\n\n\n\n\n\nGlosario üéØ\n\n\n\nLa documentaci√≥n de Python 3 provee un glosario con definiciones precisas para t√©rminos relevantes en el universo de Python. Entre ellas, podemos destacar las de m√≥dulo y paquete:\n\nM√≥dulo: Un objeto que funciona como una unidad de organizaci√≥n de c√≥digo de Python. Los m√≥dulos tienen un espacio de nombres (namespace) que contiene objetos de Python arbitrarios. Los m√≥dulos se cargan en Python a trav√©s del proceso de importaci√≥n.\nPaquete: Un m√≥dulo de Python que puede contener subm√≥dulos o, de forma recursiva, subpaquetes. T√©cnicamente, un paquete es un m√≥dulo de Python con un atributo __path__.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "6 - Uso de c√≥digo externo"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#c√≥mo-importar-c√≥digo",
    "href": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#c√≥mo-importar-c√≥digo",
    "title": "6 - Uso de c√≥digo externo",
    "section": "C√≥mo importar c√≥digo",
    "text": "C√≥mo importar c√≥digo\n\nLa sentencia import\nPara importar un m√≥dulo usamos la sentencia import seguida del nombre del m√≥dulo a importar.\nimport nombre\nDe esta manera, podemos importar el m√≥dulo math que pertenece a la librer√≠a est√°ndar de Python.\n\nimport math\n\nLuego, podemos acceder a los objetos dentro del namespace math utilizando math.nombre_objeto. Por ejemplo, para usar la funci√≥n sqrt(), que calcula la ra√≠z cuadrada de un numero n, escribimos math.sqrt(n).\n\nmath.sqrt(16)\n\n4.0\n\n\nSi quisi√©ramos importar m√°s de una m√≥dulo, solo tenemos que agregar una nueva l√≠nea con el import correspondiente. As√≠, podemos tambi√©n importar el m√≥dulo random que provee herramientas para generar n√∫meros aleatorios.\n\nimport math\nimport random\n\n\nrandom.random() # n√∫mero aleatorio entre 0 y 1\n\n0.02007022378062895\n\n\n\n\n\n\n\n\nLibrer√≠a est√°ndar de Python üìö\n\n\n\nLa librer√≠a est√°ndar de Python es un conjunto de m√≥dulos y paquetes incluidos por defecto con cualquier instalaci√≥n oficial de Python, listos para usar sin necesidad de hacer instalaciones adicionales.\n\n\n\n\n\n\n\n\nDiferencias con R üé≠\n\n\n\nA diferencia de la carga de paquetes en R, que pone a disposici√≥n objetos del paquete en el ambiente global, el comando import math en Python no carga los objetos del m√≥dulo math directamente en el ambiente donde se ejecuta; solo carga el m√≥dulo en s√≠.\nPara acceder a las funciones de math, es necesario hacerlo mediante el nombre del m√≥dulo. Por este motivo, el siguiente bloque de c√≥digo produce un error:\nimport math\nsqrt(16)\n\nNameError: name 'sqrt' is not defined\n\n\n\n\n\nListar nombres disponibles\nPara obtener un listado con los nombres de los objetos disponibles dentro de un m√≥dulo, podemos usar la funci√≥n dir().\ndir(math)\n['__doc__',\n '__file__',\n '__loader__',\n '__name__',\n '__package__',\n '__spec__',\n 'acos',\n 'acosh',\n 'asin',\n 'asinh',\n...\n 'tan',\n 'tanh',\n 'tau',\n 'trunc',\n 'ulp']\nSin embargo, en la pr√°ctica, esta funci√≥n no suele usarse demasiado para explorar los nombres disponibles en un m√≥dulo.\nPor lo general, trabajamos en editores de c√≥digo que muestran autom√°ticamente la lista de variables disponibles en un m√≥dulo.\nEn Positron, si escribimos math seguido de un punto (math.), el editor desplegar√° un listado de los objetos disponibles en dicho m√≥dulo.\n\n\n\n\n\n\n\nImportar objetos de un m√≥dulo\nLa flexibilidad en la carga de m√≥dulos en Python permite importar uno o m√°s objetos de un m√≥dulo (o subm√≥dulo) sin necesidad de importar el m√≥dulo completo.\nLa sintaxis para traer un objeto de un m√≥dulo llamado cosas es:\nfrom cosas import objeto\nDe este modo, podemos cargar la constante pi del m√≥dulo math.\n\nfrom math import pi\n\nLuego, es posible acceder a la variable pi sin tener que pasar por el nombre del m√≥dulo donde se define.\n\npi\n\n3.141592653589793\n\n\nEn nuestro caso, como anteriormente tambi√©n importamos el m√≥dulo math, seguimos teniendo acceso a pi a trav√©s de math.\n\nprint(math.pi)\nprint(pi)\n\n3.141592653589793\n3.141592653589793\n\n\nPara importar varios objetos a la vez, se utiliza una sintaxis similar a la anterior, separando sus nombres con comas. A modo de ejemplo, importemos las funciones mean() y median() de otro m√≥dulo est√°ndar llamado statistics.\n\nfrom statistics import mean, median\n\n\nnumeros = [4, 5, 9, 30, 3, 8, 6]\n\nprint(\"La media es:\", mean(numeros))\nprint(\"La mediana es:\", median(numeros))\n\nLa media es: 9.285714285714286\nLa mediana es: 6\n\n\n\n\nImportar con alias\nPython no solo permite decidir que objetos importar de un m√≥dulo, si no que tambi√©n hace posible asignar un alias al objeto o m√≥dulo que se importa.\nPara un m√≥dulo:\nimport modulo as alias\nY para un objeto dentro de un m√≥dulo:\nfrom modulo import objeto as alias\nPodemos importar el m√≥dulo math usando el alias mates:\n\nimport math as mates\n\nprint(mates.cos(mates.pi)) # coseno(pi)\n\n-1.0\n\n\nO importar la funcion sqrt con el nombre raiz:\n\nfrom math import sqrt as raiz\n\nraiz(81)\n\n9.0\n\n\n\n\n\n\n\n\nEl problema de importar todo\n\n\n\nPython permite cargar todos los objetos definidos en un m√≥dulo o paquete directamente en el ambiente actual. La sintaxis es:\nfrom nombre import *\nEsta no es una pr√°ctica recomendable, ya que no sabemos cu√°ntos elementos se importar√°n ni qu√© conflictos podr√≠an surgir entre los nombres definidos en el m√≥dulo y los que ya tenemos en nuestro programa.\nEl uso de from nombre import * produce un efecto similar al de library(paquete) en R, pero en Python se desaconseja.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "6 - Uso de c√≥digo externo"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#m√≥dulos-propios",
    "href": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#m√≥dulos-propios",
    "title": "6 - Uso de c√≥digo externo",
    "section": "M√≥dulos propios",
    "text": "M√≥dulos propios\nLa sintaxis para importar un m√≥dulo propio, u objetos definidos en √©l, es la misma que la que se utiliza para importar cualquier otro m√≥dulo.\nSupongamos que tenemos un archivo llamado funciones.py con el siguiente contenido:\n\n\nfunciones.py\n\ndef es_par(n):\n    if n % 2 == 0:\n        return True\n    return False\n\n\ndef es_primo(n):\n    if n &lt;= 1:\n        return False\n\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n\n    return True\n\ny queremos usar las funciones es_par y es_primo en nuestro programa principal.\nUn aspecto fundamental a tener en cuenta para poder importar el m√≥dulo funciones desde nuestro programa principal es su ubicaci√≥n.\nSi el archivo funciones.py no se encuentra en alguno de los directorios que Python recorre al ejecutar la sentencia import, obtendremos un error.\nUno de los directorios en los que Python busca m√≥dulos al importar es el directorio actual, es decir, aquel desde donde se ejecuta nuestro programa principal.\nSupongamos una carpeta (es decir, un proyecto) con la siguiente estructura de archivos:\nproyecto/                  # Carpeta\n‚îú‚îÄ‚îÄ funciones.py           # M√≥dulo\n‚îî‚îÄ‚îÄ programa.py            # Programa principal\nAqu√≠, programa.py es nuestro programa principal y contiene el siguiente c√≥digo:\nimport funciones\n\nprint(funciones.es_par(12))\nprint(funciones.es_par(15))\n\nprint(funciones.es_primo(1))\nprint(funciones.es_primo(11))\nprint(funciones.es_primo(15))\nAl ejecutarlo, obtendremos la siguiente salida:\nTrue\nFalse\nFalse\nTrue\nFalse\nUn programa equivalente es el siguiente:\nfrom funciones import es_par, es_primo\n\nprint(es_par(12))\nprint(es_par(15))\n\nprint(es_primo(1))\nprint(es_primo(11))\nprint(es_primo(15))\nLa salida de este programa ser√° la misma que la del ejemplo anterior. La diferencia es que en este segundo programa se importan directamente las funciones es_par y es_primo desde el m√≥dulo funciones, en lugar de importar el m√≥dulo y luego acceder a las funciones a trav√©s de funciones.es_par y funciones.es_primo.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "6 - Uso de c√≥digo externo"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#paquetes-externos",
    "href": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#paquetes-externos",
    "title": "6 - Uso de c√≥digo externo",
    "section": "Paquetes externos",
    "text": "Paquetes externos\nLa instalaci√≥n de paquetes en Python se realiza mediante un sistema de gesti√≥n de paquetes que se encarga de instalar y administrar paquetes.\nEstos paquetes se encuentran alojados en repositorios p√∫blicos (o privados) a los que los gestores acceden para descargar y actualizar el software.\nEn el ecosistema de Python existe una gran variedad de sistemas de gesti√≥n de paquetes, cuya adopci√≥n depende de las necesidades de cada usuario o proyecto.\nEn cuanto a los repositorios, tambi√©n hay varias alternativas. Sin embargo, a diferencia de los gestores, el Python Package Index (PyPI) es el m√°s utilizado por la gran mayor√≠a de la comunidad.\n\n\n\n\n\n\nNota üìù\n\n\n\nSe puede considerar al Python Package Index (PyPI) como el equivalente del Comprehensive R Archive Network (CRAN) en el ecosistema de R.\n\n\n\nInstalaci√≥n de paquetes con pip\nLa instalaci√≥n oficial de Python incluye un administrador de paquetes est√°ndar llamado pip. Esta herramienta permite instalar y gestionar paquetes que no forman parte de la biblioteca est√°ndar de Python.\nEs importante resaltar que pip se utiliza desde la terminal, no desde el int√©rprete de Python.\nEn Windows, es posible usar el comando where pip para localizar la ubicaci√≥n del programa. Otra opci√≥n es ejecutar pip --version, que muestra la versi√≥n instalada de pip junto con la ruta de la instalaci√≥n de Python a la que est√° vinculado.\nAntes de instalar paquetes con pip, es posible consultar qu√© paquetes ya se encuentran instalados mediante esta herramienta con el comando list:\npip list\nEste comando muestra un listado con los paquetes instalados y sus respectivas versiones.\nC:\\Users\\tutoriales&gt;pip list\nPackage Version\n------- -------\npip     25.1.1\nComo a√∫n no hemos instalado ning√∫n paquete adicional a los que vienen con Python, solo se muestra pip.\nLa instalaci√≥n de paquetes se hace con el comando install. Luego, para instalar el paquete NumPy hacemos:\npip install numpy\nDebajo se incluye una captura de la terminal de Windows donde se muestra la ejecuci√≥n de los comandos antes mencionados y sus respectivas salidas:\n\n\n\n\n\n\n\n\n\n\n\nEjecutar pip como m√≥dulo de Python\n\n\n\nLa herramienta pip es simplemente un m√≥dulo de Python. Si tenemos m√∫ltiples instalaciones de Python y/o pip, es posible que la versi√≥n de pip a la que se accede en nuestra terminal no sea la que est√° asociada a la versi√≥n de Python que queremos utilizar. Para evitar este tipo de problemas, se puede ejecutar el programa pip como un m√≥dulo de Python. De este modo, la instalaci√≥n de NumPy se ver√≠a de la siguiente manera:\npython -m pip install numpy\nLa opci√≥n -m le indica a Python que ejecute un m√≥dulo como si fuera un programa dentro del int√©rprete de Python.\n\n\n\n\n\n\n\n\n¬øEn qu√© momento seleccionamos a PyPI? ü§î\n\n\n\nNo es necesario que manualmente selccionemos a PyPI como repositorio de c√≥digo. Por defecto, pip ya instala los paquetes desde PyPI.\n\n\n\n\nCreaci√≥n de ambientes con venv\nCuando instalamos paquetes con la versi√≥n de pip que se incluye por defecto en Python, estos se instalan de forma global. Esto no siempre representa un problema, pero suele complicarse cuando trabajamos en varios proyectos distintos.\nCada proyecto puede depender de diferentes paquetes, e incluso de diferentes versiones de Python. Si todos comparten una misma instalaci√≥n global, es muy probable que aparezcan conflictos: algunos programas podr√≠an dejar de funcionar o comportarse de manera incorrecta.\nUna soluci√≥n ser√≠a reinstalar todas las dependencias desde cero cada vez, pero esto implica una p√©rdida de tiempo innecesaria y, adem√°s, no garantiza el correcto funcionamiento. La soluci√≥n m√°s aceptada por la comunidad es usar ambientes virtuales.\nUn ambiente virtual en Python permite aislar dependencias y paquetes para evitar conflictos entre proyectos.\nExisten distintas herramientas para crear y administrar ambientes virtuales; la que se incluye en la instalaci√≥n oficial de Python es venv.\nPara crear un ambiente virtual con venv, primero debemos ubicarnos en la carpeta de nuestro proyecto y ejecutar en la terminal:\npython -m venv .venv\nEl nombre .venv es una convenci√≥n adoptada por la comunidad, aunque puede usarse cualquier nombre v√°lido de directorio.\nEste comando genera una carpeta con la siguiente estructura:\n.venv\n‚îú‚îÄ‚îÄ Include\n‚îú‚îÄ‚îÄ Lib\n‚îÇ   ‚îî‚îÄ‚îÄ site-packages\n‚îÇ       ‚îú‚îÄ‚îÄ pip\n‚îÇ       ‚îî‚îÄ‚îÄ pip-25.1.1.dist-info\n‚îú‚îÄ‚îÄ Scripts\n‚îÇ   ‚îú‚îÄ‚îÄ Activate.ps1\n‚îÇ   ‚îú‚îÄ‚îÄ activate\n‚îÇ   ‚îú‚îÄ‚îÄ activate.bat\n‚îÇ   ‚îú‚îÄ‚îÄ activate.fish\n‚îÇ   ‚îú‚îÄ‚îÄ deactivate.bat\n‚îÇ   ‚îú‚îÄ‚îÄ pip.exe\n‚îÇ   ‚îú‚îÄ‚îÄ pip3.13.exe\n‚îÇ   ‚îú‚îÄ‚îÄ pip3.exe\n‚îÇ   ‚îú‚îÄ‚îÄ python.exe\n‚îÇ   ‚îî‚îÄ‚îÄ pythonw.exe\n‚îî‚îÄ‚îÄ pyvenv.cfg\nDentro de .venv/Lib/site-packages se almacenan los paquetes instalados en el ambiente, y en .venv/Scripts se encuentra el ejecutable de Python (python.exe) junto con otros scripts de utilidad.\nPara usar el int√©rprete de Python del ambiente e instalar paquetes en √©l, es necesario activarlo con el comando:\n.venv\\Scripts\\activate\nAl hacerlo, se mostrar√° (.venv) al inicio de la l√≠nea de la terminal.\nFinalmente, para desactivar el ambiente, basta con ejecutar:\ndeactivate\n\n\nEjemplo: NumPy\nNumPy es una paquete de Python especializado en el c√°lculo num√©rico y el an√°lisis de datos.\nProvee un nuevo tipo de objeto llamado array que permite representar colecciones de datos de un mismo tipo en varias dimensiones y funciones muy eficientes para su manipulaci√≥n.\n\n\n\n\n\nPara crear un proyecto, un ambiente con venv e instalar NumPy, seguimos los siguientes pasos:\nmkdir proyecto          # Crear directorio\ncd proyecto             # Mover la terminal al directorio del proyecto\npython -m venv .venv    # Crear ambiente virtual llamado .venv\n.venv\\Scripts\\activate  # Activar ambiente\npip install numpy       # Instalar numpy en el ambiente del proyecto\npython                  # Iniciar el int√©rprete interactivo de Python\nEl siguiente video muestra los pasos realizados en la terminal de Windows:\n\n\n\n\n\nLos paquetes de Python suelen importarse utilizando un alias. En el caso de los m√°s populares, como NumPy, la mayor√≠a de la comunidad usa el alias np.\n\nimport numpy as np\n\narray = np.array([1, 2, 3, 4])\narray\n\narray([1, 2, 3, 4])\n\n\n\ntype(array)\n\nnumpy.ndarray\n\n\nLa propiedad .ndim nos devuelve el n√∫mero de dimensiones del array.\n\narray.ndim\n\n1\n\n\nY .shape nos devuelve la ‚Äúforma‚Äù del array. Es decir, la cantidad de elementos por cada dimensi√≥n. Se puede notar que el .shape de un array es una tupla.\n\narray.shape\n\n(4,)\n\n\nEn este caso creamos un array a partir de una lista, pero tambi√©n es posible crear arrays a partir de otros objetos.\nSi continuamos utilizando listas, el n√∫mero de dimensiones del array va a depender del anidamiento que tengamos en las listas que utilizamos.\nA modo de ejemplo, podemos crear un array de dos dimensiones de la siguiente manera:\n\narray_2d = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])\narray_2d\n\narray([[1, 2, 3, 4],\n       [5, 6, 7, 8]])\n\n\n\nprint(array_2d.ndim)\nprint(array_2d.shape)\n\nUna de las caracter√≠sticas m√°s atractivas de NumPy es que las operaciones matem√°ticas con arrays est√°n vectorizadas, es decir, se realizan al nivel del arreglo.\n\nprint(array * 10)\nprint(array - 5)\nprint(array / 10)\nprint(array ** 2.4)\n\n[10 20 30 40]\n[-4 -3 -2 -1]\n[0.1 0.2 0.3 0.4]\n[ 1.          5.27803164 13.96661017 27.85761803]\n\n\nNumPy tambi√©n provee much√≠simas funciones para hacer c√°lculos com√∫nmente realizados con los arrays.\n\nprint(np.mean(array))\nprint(np.median(array))\nprint(np.std(array))\nprint(np.exp(array))\n\n2.5\n2.5\n1.118033988749895\n[ 2.71828183  7.3890561  20.08553692 54.59815003]",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "6 - Uso de c√≥digo externo"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#ap√©ndice",
    "href": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#ap√©ndice",
    "title": "6 - Uso de c√≥digo externo",
    "section": "Ap√©ndice",
    "text": "Ap√©ndice\n\nAlgunos comandos de pip\n\n\n\n\n\n\n\nComando\nDescripci√≥n\n\n\n\n\npip install pkg1 pkg2\nInstala uno o varios paquetes.\n\n\npip install pkg==1.2.3pip install pkg&gt;=1.0,&lt;=2.0\nInstala una versi√≥n espec√≠fica o un rango de versiones de un paquete.\n\n\npip install pkg --upgrade\nActualiza un paquete a la √∫ltima versi√≥n disponible.\n\n\npip freeze\nMuestra todos los paquetes instalados y sus versiones en formato compatible con requirements.txt.\n\n\npip uninstall pkg\nDesinstala un paquete instalado.\n\n\npip show pkg\nMuestra informaci√≥n detallada sobre un paquete (versi√≥n, ubicaci√≥n, dependencias).\n\n\npip help\nMuestra la ayuda general de pip o de un subcomando espec√≠fico.\n\n\npip install -r dependencias.txt\nInstala todas las dependencias listadas en un archivo.\n\n\n\n\nEjemplos\npip install requests flask        # Instala varios paquetes\npip install numpy==1.25.0         # Instala una versi√≥n exacta\npip install pandas&gt;=1.0,&lt;2.0      # Instala dentro de un rango de versiones\npip install requests --upgrade    # Actualiza un paquete\npip freeze                        # Lista paquetes instalados y versiones\npip uninstall flask               # Desinstala un paquete\npip show numpy                    # Muestra informaci√≥n de un paquete\npip help install                  # Muestra ayuda sobre 'install'\npip install -r requirements.txt   # Instala dependencias desde un archivo",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "6 - Uso de c√≥digo externo"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html",
    "title": "5 - Ejecuci√≥n repetitiva",
    "section": "",
    "text": "Anteriormente aprendimos a crear objetos que contienen otros objetos (listas, tuplas y diccionarios).\nCuando quer√≠amos realizar una acci√≥n con cada uno de los objetos que estos conten√≠an, ten√≠amos que escribir el mismo c√≥digo para acceder a cada uno de ellos de a uno.\nPor ejemplo, supongamos que tenemos un listado con nombres de nuestros amigos y queremos ponerlos a todos en may√∫sculas:\n\nnombres = [\"julieta\", \"facundo\", \"emiliano\", \"lorenzo\", \"victoria\"]\nprint(\"Nombres originales:\")\nprint(nombres)\n\nnombres[0] = nombres[0].upper()\nnombres[1] = nombres[1].upper()\nnombres[2] = nombres[2].upper()\nnombres[3] = nombres[3].upper()\nnombres[4] = nombres[4].upper()\n\nprint(\"\\nNombres modificados:\")\nprint(nombres)\n\nNombres originales:\n['julieta', 'facundo', 'emiliano', 'lorenzo', 'victoria']\n\nNombres modificados:\n['JULIETA', 'FACUNDO', 'EMILIANO', 'LORENZO', 'VICTORIA']\n\n\nVemos que realizamos exactamente la misma acci√≥n con cada nombre en la lista‚Ä¶ ¬øNo estar√≠a bueno poder automatizarlo?\nY para eso, en esta secci√≥n vamos a aprender sobre bucles.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "5 - Ejecuci√≥n repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#introducci√≥n",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#introducci√≥n",
    "title": "5 - Ejecuci√≥n repetitiva",
    "section": "",
    "text": "Anteriormente aprendimos a crear objetos que contienen otros objetos (listas, tuplas y diccionarios).\nCuando quer√≠amos realizar una acci√≥n con cada uno de los objetos que estos conten√≠an, ten√≠amos que escribir el mismo c√≥digo para acceder a cada uno de ellos de a uno.\nPor ejemplo, supongamos que tenemos un listado con nombres de nuestros amigos y queremos ponerlos a todos en may√∫sculas:\n\nnombres = [\"julieta\", \"facundo\", \"emiliano\", \"lorenzo\", \"victoria\"]\nprint(\"Nombres originales:\")\nprint(nombres)\n\nnombres[0] = nombres[0].upper()\nnombres[1] = nombres[1].upper()\nnombres[2] = nombres[2].upper()\nnombres[3] = nombres[3].upper()\nnombres[4] = nombres[4].upper()\n\nprint(\"\\nNombres modificados:\")\nprint(nombres)\n\nNombres originales:\n['julieta', 'facundo', 'emiliano', 'lorenzo', 'victoria']\n\nNombres modificados:\n['JULIETA', 'FACUNDO', 'EMILIANO', 'LORENZO', 'VICTORIA']\n\n\nVemos que realizamos exactamente la misma acci√≥n con cada nombre en la lista‚Ä¶ ¬øNo estar√≠a bueno poder automatizarlo?\nY para eso, en esta secci√≥n vamos a aprender sobre bucles.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "5 - Ejecuci√≥n repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#qu√©-son-los-bucles",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#qu√©-son-los-bucles",
    "title": "5 - Ejecuci√≥n repetitiva",
    "section": "¬øQu√© son los bucles?",
    "text": "¬øQu√© son los bucles?\nLos bucles son una estrcutura de los lenguajes de programaci√≥n que nos permite repetir la ejecuci√≥n de c√≥digo de manera autom√°tica.\nEn otras palabras, los bucles hacen que sea muy f√°cil ejecutar el mismo bloque de c√≥digo una y otra vez.\nA la repetici√≥n del mismo bloque de c√≥digo una y otra vez le decimos iteraci√≥n. Entonces, los bucles nos ayudan a iterar.\nEn Python tenemos dos tipos de bucles:\n\nEl bucle for (for-loop).\nEl bucle while (while-loop).\n\nLa diferencia entre este tipo de bucles es que con el for conocemos la cantidad de iteraciones que vamos a realizar de antemano.\nEn cambio, con el while no conocemos la cantidad de iteraciones que vamos a realizar de antemano.\nVeamos el ejemplo anterior pero utilizando un bucle for. En este caso, generamos una nueva lista llamada nombres_modificados donde vamos a almacenar los nombres modificados.\n\nnombres = [\"julieta\", \"facundo\", \"emiliano\", \"mariana\", \"victoria\"]\nnombres_modificados = []\n\n# Bucle for\nfor nombre in nombres:\n    nombres_modificados.append(nombre.upper())\n\nprint(\"Nombres originales:\")\nprint(nombres)\n\nprint(\"\\nNombres modificados:\")\nprint(nombres_modificados)\n\nNombres originales:\n['julieta', 'facundo', 'emiliano', 'mariana', 'victoria']\n\nNombres modificados:\n['JULIETA', 'FACUNDO', 'EMILIANO', 'MARIANA', 'VICTORIA']",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "5 - Ejecuci√≥n repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#el-bucle-for",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#el-bucle-for",
    "title": "5 - Ejecuci√≥n repetitiva",
    "section": "El bucle for",
    "text": "El bucle for\n\nPresentaci√≥n\nEn un bucle for encontramos los siguientes componentes.\n\nLa palabra clave for\nEl nombre de una variable que se usa para iterar (variable de iteraci√≥n)\nLa palabra clave in\nEl objeto sobre el cual iteramos, seguido por :\nEn la siguiente linea y con indentaci√≥n, el bloque de c√≥digo a ejecutar\n\n\n\n\n\n\nEn Python, al igual que en las sentencias if, else y otras estructuras de control, los dos puntos (:) se utilizan para indicar el comienzo de un bloque de c√≥digo, y la indentaci√≥n define el contenido de ese bloque. Nunca se emplean llaves {} como en otros lenguajes.\nEn el caso de un bucle for, se declara una variable que va tomando, en cada iteraci√≥n, uno de los valores del iterable que se est√° recorriendo. Por ejemplo, si el iterable contiene 10 objetos, el bucle ejecutar√° 10 iteraciones y la variable de iteraci√≥n (por convenci√≥n llamada i, aunque puede tener cualquier nombre) ir√° adoptando esos valores, uno por uno.\n\n\nEjemplos\nDado que a iterar se aprende iterando, veamos algunos ejemplos:\n\nfor i in [3, 1, 2]:\n    print(f\"El n√∫mero es {i}.\")\n\nEl n√∫mero es 3.\nEl n√∫mero es 1.\nEl n√∫mero es 2.\n\n\nTambi√©n podemos ordenar los valores de la lista sobre la que iteramos:\n\nfor i in sorted([3, 1, 2]):\n    print(f\"El n√∫mero es {i}.\")\n\nEl n√∫mero es 1.\nEl n√∫mero es 2.\nEl n√∫mero es 3.\n\n\nPero no es necesario iterar sobre listas. De hecho, podemos iterar sobre cualquier secuencia, por ejemplo, una tupla:\n\nfor i in (3, 1, 2):\n    print(f\"El n√∫mero es {i}.\")\n\nEl n√∫mero es 3.\nEl n√∫mero es 1.\nEl n√∫mero es 2.\n\n\n\nfor i in sorted((3, 1, 2)):\n    print(f\"El n√∫mero es {i}.\")\n\nEl n√∫mero es 1.\nEl n√∫mero es 2.\nEl n√∫mero es 3.\n\n\nE incluso una cadena de caracteres:\n\nfor c in \"Hola Curso\":\n    print(c)\n\nH\no\nl\na\n \nC\nu\nr\ns\no\n\n\n\n\n\n\n\n\nVariable de iteraci√≥n\n\n\n\nEl nombre de la variable que se usa para iterar es arbitrario. Sin embargo, es recomendable no utilizar el mismo nombre que el de otra variable en nuestro programa. Por ejemplo:\ni = 1\nfor i in [1, 2, 3]:\n    print(i)\nprint(i)\n1\n2\n3\n3\nLa variable de iteraci√≥n i va pisando su valor y cualquier valor que esta pudo haber tenido antes.\nAs√≠, luego de la finalizar el bucle, el valor de i es 3.\n\n\nLos bucles permiten generar nuevos objetos de forma autom√°tica.\nEn el siguiente ejemplo, partimos de una lista con cadenas que pueden contener n√∫meros o letras. Mediante un for, crearemos tres listas: una con los n√∫meros, otra con el texto y una tercera con los elementos que no sean ninguno de los dos.\n\nlista_original = [\"1\", \"@\", \"x\", \"y\", \"?\", \"3\", \"4\", \"7\", \"f\", \"l\", \"9\", \"10\", \"!\"]\n\n\n# Crear tres listas vac√≠as (que contienen los diferentes tipos de datos)\nnumeros = []\ntexto = []\notros = []\n\n# Iterar a traves de los valores de la lista original\nfor valor in lista_original:\n    # Si es num√©rico, lo agregamos en la lista 'numeros'\n    if valor.isnumeric():\n        numeros.append(valor)\n    # Sino es num√©rico, pregunto si es alfab√©tico (o una letra del abecedario)\n    elif valor.isalpha():\n        texto.append(valor)\n    # Caso contrario, lo metemos en la lista de otros\n    else:\n        print(f\"La cadena '{valor}' no es ni num√©rica ni alfab√©tica.\")\n        otros.append(valor)\n\nprint(lista_original)\nprint(numeros)\nprint(texto)\nprint(otros)\n\nLa cadena '@' no es ni num√©rica ni alfab√©tica.\nLa cadena '?' no es ni num√©rica ni alfab√©tica.\nLa cadena '!' no es ni num√©rica ni alfab√©tica.\n['1', '@', 'x', 'y', '?', '3', '4', '7', 'f', 'l', '9', '10', '!']\n['1', '3', '4', '7', '9', '10']\n['x', 'y', 'f', 'l']\n['@', '?', '!']\n\n\n\n\nCrear listas num√©ricas con range().\nPython provee una funci√≥n llamada range() que hace que sea muy f√°cil generar una secuencia de n√∫meros. Por ejemplo, podemos usar range() para imprimir una serie de n√∫meros.\n\nfor i in range(1, 5):\n    print(i)\n\n1\n2\n3\n4\n\n\nrange() funciona de manera similar a los slices, es decir, no incluye el l√≠mite superior. Adem√°s, si se usa con un solo argumento, es equivalente a range(0, numero).\n\nfor i in range(5):\n    print(i)\n\n0\n1\n2\n3\n4\n\n\nUna forma √∫til de entender range(n) es verlo como la creaci√≥n de una secuencia con los primeros n n√∫meros, comenzando desde 0.\n\nx = range(5)\nprint(x)\nprint(type(x))\n\nrange(0, 5)\n&lt;class 'range'&gt;\n\n\nPodemos obtener una lista a partir de un range usando la funci√≥n list().\n\nlist(x)\n\n[0, 1, 2, 3, 4]\n\n\nY, por qu√© no, una tupla tambi√©n.\n\ntuple(x)\n\n(0, 1, 2, 3, 4)\n\n\nrange() admite un tercer argumento opcional que especifica el paso entre valores. Por defecto es 1. Veamos algunos ejemplos:\nLista de n√∫meros entre 0 y 10 (no inclusivo), avanzando de a 2 en cada paso.\n\nlist(range(0, 10, 2))\n\n[0, 2, 4, 6, 8]\n\n\nIntento de lista de n√∫meros entre 10 y 0 (no inclusivo).\n\nlist(range(10, 0))\n\n[]\n\n\nVemos que el resultado no es el esperado. Esto se debe a que el paso es por defecto 1 y es imposible recorrer desde el 10 al 0 sumando de a 1. Si cambiamos el paso a -1, funciona correctamente:\n\nlist(range(10, 0, -1))\n\n[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n\n\n\n\n¬øSobre qu√© cosas podemos iterar en un bucle for?\nRecordemos el diagrama que vimos anteriormente‚Ä¶\n\n\n\n\n\nEn naranja tenemos resaltado iterable. Pero, ¬øqu√© significa que un objeto sea iterable?\n\nQue podemos iterar a trav√©s de el.\nQue podemos recorrerlo elemento por elemento.\nQue puede devolver sus elementos de a uno a la vez.\n\nDe manera similar a las secuencias, el t√©rmino iterable describe una categor√≠a de tipos de datos. De hecho, todas las secuencias son iterables (por eso podemos recorrer listas, tuplas y cadenas), pero no es requisito ser una secuencia para ser iterable. Por ejemplo, los diccionarios no son secuencias y, sin embargo, pueden recorrerse porque implementan un m√©todo para entregar sus elementos de uno en uno.\n\nfor i in {\"a\": 1, \"b\": 2}:\n    print(i)\n\na\nb",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "5 - Ejecuci√≥n repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#el-bucle-while",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#el-bucle-while",
    "title": "5 - Ejecuci√≥n repetitiva",
    "section": "El bucle while",
    "text": "El bucle while\nEn un bucle while encontramos los siguientes componentes.\n\nLa palabra clave while.\nUna condici√≥n, es decir, una expresi√≥n que se eval√∫a a True o False, seguido por los dos puntos :.\nEn la siguiente linea y con indentaci√≥n, el bloque de c√≥digo a ejecutar.\n\n\n\n\n\n\n\nnumero = 0\nwhile numero &lt; 5:\n    numero += 1 # Abreviaci√≥n de x = x + 1\n    print(f\"El numero es {numero}\")\n\nEl numero es 1\nEl numero es 2\nEl numero es 3\nEl numero es 4\nEl numero es 5\n\n\n\n\n\n\n\nAnalicemos el diagrama:\n\nMientras numero &lt; 5 sea True, Python ejecutar√° el cuerpo del bucle completo.\nEn la primera iteraci√≥n, numero es 0.\n\nComo 0 es menor a 5, Python imprime el n√∫mero y luego le agrega 1, haciendo que el n√∫mero sea 1.\n\nEn la segunda iteraci√≥n, numero es 1.\n\nComo 1 es menor a 5, Python imprime el n√∫mero y luego le agrega 1, haciendo que el n√∫mero sea 2.\n\n\nEl proceso contin√∫a hasta que numero deja de ser menor que 5, momento en el que el bucle se detiene.\n\n\n\n\n\n\nBucles infinitos ‚ôæÔ∏è\n\n\n\nVeamos el siguiente ejemplo:\nx = 0\nwhile x &lt; 5:\n    print(x)\nSi ejecutamos este c√≥digo, Python nunca detendr√° su ejecuci√≥n. Esto sucede porque el valor de x nunca cambia, por lo que la condici√≥n x &lt; 5 es siempre verdadera. Este es un caso t√≠pico de bucle infinito, algo que puede ocurrir con cualquier while, y en particular con while True si no incluimos una forma de salir del bucle (por ejemplo, con break).\nSi entramos en un bucle infinito, la √∫nica forma de detenerlo es interrumpir la ejecuci√≥n manualmente:\n\nEn la terminal: CTRL + C\nEn un editor de c√≥digo: usar el bot√≥n de interrupci√≥n\n\n\n\n\nLa sentencia break\nPython provee la sentencia break que sirve para terminar un bucle (for o while) de manera anticipada.\nVeamos algunos ejemplos de uso.\n\nwhile True:\n    print(\"¬°Hola!\")\n    break\n\n¬°Hola!\n\n\nEn el ejemplo anterior, la condici√≥n del bucle era True, lo que implicar√≠a una ejecuci√≥n infinita. Sin embargo, al final de la primera iteraci√≥n encontramos un break, que fuerza la salida del bucle. De forma similar, podemos reescribir el primer while utilizando esta estructura alternativa.\n\nnumero = 0\nwhile True:\n    if numero &gt;= 5:\n        break\n    numero += 1\n    print(f\"El numero es {numero}\")\n\nEl numero es 1\nEl numero es 2\nEl numero es 3\nEl numero es 4\nEl numero es 5\n\n\n\nnumero = 0\nwhile True:\n    numero += 1\n    print(f\"El numero es {numero}\")\n    if numero &gt;= 5:\n        break\n\nEl numero es 1\nEl numero es 2\nEl numero es 3\nEl numero es 4\nEl numero es 5\n\n\nSupongamos que queremos sumar los valores de una lista hasta que se cumpla cierta condici√≥n, por ejemplo, que el total sea mayor o igual a 20.\nSi partimos de una lista de n√∫meros cualquiera, no sabemos de antemano cu√°ntos elementos ser√° necesario sumar. Sin embargo, esto no ser√° un problema si utilizamos la estructura while en combinaci√≥n con la sentencia break.\n\nsuma = 0\numbral = 20\nvalores = [3, 5, 4, 4, 5, 5, 3, 5, 2, 7]\n\nwhile valores:\n    suma += valores.pop(0)\n    print(suma)\n    if suma &gt;= umbral:\n        break\n\n3\n8\n12\n16\n21\n\n\n\nvalores # valores que no se sumaron\n\n[5, 3, 5, 2, 7]\n\n\nEn el bloque de c√≥digo anterior puede llamar la atenci√≥n el uso de\nwhile valores:\nEl bucle while valores: se ejecuta mientras la lista tenga elementos. En cada iteraci√≥n, .pop(0) extrae el primer elemento, se suma a suma y se imprime el total acumulado. Si en alg√∫n momento suma alcanza o supera el umbral, se ejecuta break para detener el bucle aunque a√∫n queden elementos en la lista. Si la lista se vac√≠a antes de llegar al umbral, el bucle tambi√©n finaliza autom√°ticamente gracias a la condici√≥n while valores:.\nUn ejemplo m√°s conciso es el siguiente:\n\nif [1, 2, 3]:\n    print(\"Bloque 'if'\")\nelse:\n    print(\"Bloque 'else'\")\n\nBloque 'if'\n\n\n\nif []:\n    print(\"Bloque 'if'\")\nelse:\n    print(\"Bloque 'else'\")\n\nBloque 'else'\n\n\nAhora supongamos que tenemos una lista de n√∫meros aleatorios que representan alg√∫n conteo.\nEstamos interesados en la cantidad de extracciones que se necesitaron hasta que el conteo supere cierto umbral, por ejemplo, 30.\n\nnumeros_aleatorios = [\n    5, 7, 6, 4, 2, 2, 5, 3, 6, 4, 4, 6, 3, 6, 1,\n    3, 3, 1, 9, 5, 5, 6, 5, 1, 7, 3, 3, 1, 3, 4\n]\n\numbral = 30\n\n# Inicializamos suma y cantidad de iteraciones en 0\nsuma = 0\niteraciones = 0\n\n# Mientras la lista no est√© vac√≠a\nwhile numeros_aleatorios:\n    # Agregamos 1 al conteo de iteraciones realizadas\n    iteraciones += 1\n\n    # Extraemos el primer n√∫mero de la lista y lo sumamos a la suma\n    suma += numeros_aleatorios.pop(0)\n\n    # Si la suma es mayor o igual al umbral, dejamos de iterar\n    if suma &gt;= umbral:\n        break\n\nif suma &gt;= umbral:\n    print(f\"Se super√≥ el umbral de {umbral} en la iteraci√≥n {iteraciones}, sumando {suma}.\")\nelse:\n    print(f\"La suma de los elementos de la lista no llega a superar {umbral}\")\n\nSe super√≥ el umbral de 30 en la iteraci√≥n 7, sumando 31.\n\n\n\nSolicitar valores de entrada al usuario\nPython provee una funci√≥n llamada input() que sirve para solicitar al usuario que ingrese un valor.\n\nEl argumento es el mensaje que se mostrar√° en pantalla.\nEl tipo de dato que se devuelve es str.\n\n\nnombre = input(\"Ingresa tu nombre: \")\nprint(f\"El nombre ingresado es '{nombre}'\")\n\nEl nombre ingresado es 'Tomi'\n\n\nEsta funcion combinada con el bucle while nos permite generar programas interactivos que solicitan entrada al usuario hasta que se cumple una condici√≥n. Por ejemplo, supongamos que queremos solicitar una contrase√±a que tenga 8 caracteres o m√°s.\n\nwhile True:\n    pwd = input(\"Ingrese su contrase√±a: \")\n    if len(pwd) &gt;= 8:\n        print(\"¬°Muchas gracias!\")\n        break\n    else:\n        print(f\"La contrase√±a '{pwd}' es corta\")\nprint(f\"La contrase√±a ingresada es '{pwd}'\")\n\nLa contrase√±a '' es corta\nLa contrase√±a 'prueba' es corta\n¬°Muchas gracias!\nLa contrase√±a ingresada es 'prueba 2'\n\n\n\n\n\nLa sentencia continue\nAs√≠ como tenemos la sentencia break que le dice a Python que interrumpa la ejecuci√≥n de un bucle, tenemos la sentencia continue que le dice que pase a la siguiente iteraci√≥n sin ejecutar el c√≥digo a continuaci√≥n de la misma.\nCuando un programa se encuentra con continue se procede a la siguiente iteraci√≥n del bucle, re-evaluando la condici√≥n del while de ser necesario.\nEn el siguiente ejemplo tenemos una lista con n√∫meros del 1 al 10 y queremos sumar solamente los n√∫meros pares.\n\n# Crear lista del 1 al 10\nnumeros = list(range(1, 11))\nprint(numeros)\n\nsuma = 0\nwhile numeros:\n    numero = numeros.pop(0)\n    if numero % 2 != 0:\n        continue\n    suma += numero\n    print(\"Sumando el numero\", numero)\n\nprint(\"La suma es\", suma)\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nSumando el numero 2\nSumando el numero 4\nSumando el numero 6\nSumando el numero 8\nSumando el numero 10\nLa suma es 30\n\n\nEn este programa, si numero % 2 != 0, el continue le indica a Python que debe pasar a la siguiente iteraci√≥n sin evaluar lo que hay debajo. Por lo tanto, cuando el n√∫mero es impar, no se ejecuta ni la suma ni el print.\nEste problema se puede resolver tambi√©n utilizando un bucle for en vez de un bucle while.\n\nnumeros = list(range(1, 11))\nsuma = 0\nfor numero in numeros:\n    if numero % 2 != 0:\n        continue\n    suma += numero\n    print(\"Sumando el numero\", numero)\nprint(\"La suma es\", suma)\n\nSumando el numero 2\nSumando el numero 4\nSumando el numero 6\nSumando el numero 8\nSumando el numero 10\nLa suma es 30",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "5 - Ejecuci√≥n repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#conclusi√≥n",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#conclusi√≥n",
    "title": "5 - Ejecuci√≥n repetitiva",
    "section": "Conclusi√≥n",
    "text": "Conclusi√≥n\nCu√°ndo usar un bucle for.\n\nSabemos exactamente, y de antemano, cuantas veces queremos iterar.\nQueremos iterar a trav√©s de todos los elementos de un objeto determinado.\n\nCu√°ndo usar un bucle while.\n\nNo sabemos exactamente cuantas veces queremos iterar.\nQueremos iterar hasta que se cumpla (o se deje de cumplir) una condici√≥n determinada.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "5 - Ejecuci√≥n repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html",
    "href": "teoria/01_programacion_en_python/01_introduccion.html",
    "title": "1 - Introducci√≥n",
    "section": "",
    "text": "Python es un lenguaje de programaci√≥n interpretado, de prop√≥sito general y de alto nivel. Fue creado por Guido Van Rossum y su primera versi√≥n p√∫blica fue en el a√±o 1991.\n\nInterpretado: no requiere que realicemos un paso expl√≠cito de compilaci√≥n a lenguaje de m√°quina antes de ejecutarlo. Adem√°s, se puede ejecutar l√≠nea por l√≠nea.\nProp√≥sito general: no se limita a un tipo de aplicaci√≥n espec√≠fica, es decir, se puede usar para implementar programas en diferentes dominios:\n\nVox populi: No es el mejor en casi nada, pero suficientemente bueno para casi todo.\nAlgunos dominios:\n\nAn√°lisis estad√≠stico y ciencia de datos.\nInteligencia artificial.\nDesarrollo web.\nDesarrollo de videojuegos.\nScripting.\n\n\nAlto nivel: se parece m√°s al lenguaje humano que al lenguaje de las m√°quinas.\n\nAdem√°s‚Ä¶\n\nEs gratis: no requiere pagar licencias para usarlo, tanto a nivel personal como comercial.\nEs de c√≥digo abierto: su c√≥digo fuente est√° disponible p√∫blicamente y puede ser modificado por cualquiera.\nPosee un ecosistema de librer√≠as complet√≠simo: existen miles de paquetes para todo tipo de tareas.\nComunidad: millones de personas lo usan, contribuyen, resuelven dudas y crean contenido, lo que facilita aprender y encontrar ayuda.\n\nPara utilizar Python es necesario instalar un int√©rprete de Python. La versi√≥n oficial puede ser descargada desde python.org. Una vez instalado el int√©rprete, es posible ejecutar scripts de Python y programar en Python de manera interactiva desde la terminal.\nEn esta materia se utiliza un editor de c√≥digo para ciencia de datos llamado Positron. Este editor es desarrollado por Posit, los mismos creadores de RStudio, y permite trabajar tanto con Python como con R.\nLas instrucciones para instalar Python y Positron pueden ser encontradas en Instalaci√≥n de Python y Positron en Windows.\n\n\n\nEmpecemos utilizando a Python como si fuese una calculadora. Para eso vamos a crear un bloque de c√≥digo en la notebook y escribimos algunas cuentas tal como lo hacemos en cualquier calculadora.\n\n2 * 3\n\n6\n\n\nNo tenemos la necesidad de pisar el c√≥digo todo el tiempo. Podemos escribir nuevas celdas de c√≥digo, y as√≠ podemos ir mostrando diferentes c√≥mputos y sus resultados.\n\n100 / 3.5\n\n28.571428571428573\n\n\n\n20 + 5\n\n25\n\n\n\n13 - 3\n\n10\n\n\n\n10 * 5.5\n\n55.0",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "1 - Introducci√≥n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#qu√©-es-python",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#qu√©-es-python",
    "title": "1 - Introducci√≥n",
    "section": "",
    "text": "Python es un lenguaje de programaci√≥n interpretado, de prop√≥sito general y de alto nivel. Fue creado por Guido Van Rossum y su primera versi√≥n p√∫blica fue en el a√±o 1991.\n\nInterpretado: no requiere que realicemos un paso expl√≠cito de compilaci√≥n a lenguaje de m√°quina antes de ejecutarlo. Adem√°s, se puede ejecutar l√≠nea por l√≠nea.\nProp√≥sito general: no se limita a un tipo de aplicaci√≥n espec√≠fica, es decir, se puede usar para implementar programas en diferentes dominios:\n\nVox populi: No es el mejor en casi nada, pero suficientemente bueno para casi todo.\nAlgunos dominios:\n\nAn√°lisis estad√≠stico y ciencia de datos.\nInteligencia artificial.\nDesarrollo web.\nDesarrollo de videojuegos.\nScripting.\n\n\nAlto nivel: se parece m√°s al lenguaje humano que al lenguaje de las m√°quinas.\n\nAdem√°s‚Ä¶\n\nEs gratis: no requiere pagar licencias para usarlo, tanto a nivel personal como comercial.\nEs de c√≥digo abierto: su c√≥digo fuente est√° disponible p√∫blicamente y puede ser modificado por cualquiera.\nPosee un ecosistema de librer√≠as complet√≠simo: existen miles de paquetes para todo tipo de tareas.\nComunidad: millones de personas lo usan, contribuyen, resuelven dudas y crean contenido, lo que facilita aprender y encontrar ayuda.\n\nPara utilizar Python es necesario instalar un int√©rprete de Python. La versi√≥n oficial puede ser descargada desde python.org. Una vez instalado el int√©rprete, es posible ejecutar scripts de Python y programar en Python de manera interactiva desde la terminal.\nEn esta materia se utiliza un editor de c√≥digo para ciencia de datos llamado Positron. Este editor es desarrollado por Posit, los mismos creadores de RStudio, y permite trabajar tanto con Python como con R.\nLas instrucciones para instalar Python y Positron pueden ser encontradas en Instalaci√≥n de Python y Positron en Windows.\n\n\n\nEmpecemos utilizando a Python como si fuese una calculadora. Para eso vamos a crear un bloque de c√≥digo en la notebook y escribimos algunas cuentas tal como lo hacemos en cualquier calculadora.\n\n2 * 3\n\n6\n\n\nNo tenemos la necesidad de pisar el c√≥digo todo el tiempo. Podemos escribir nuevas celdas de c√≥digo, y as√≠ podemos ir mostrando diferentes c√≥mputos y sus resultados.\n\n100 / 3.5\n\n28.571428571428573\n\n\n\n20 + 5\n\n25\n\n\n\n13 - 3\n\n10\n\n\n\n10 * 5.5\n\n55.0",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "1 - Introducci√≥n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#tipos-de-datos",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#tipos-de-datos",
    "title": "1 - Introducci√≥n",
    "section": "Tipos de datos",
    "text": "Tipos de datos\nComo cualquier lenguaje de programaci√≥n, Python ofrece diferentes tipos de datos.\nCada tipo de dato nos ayuda a resolver una tarea distinta. Por ejemplo, si quiero hacer operaciones matem√°ticas voy a necesitar de n√∫meros, pero si quiero escribir un correo electr√≥nico voy a necesitar de texto.\nA continuaci√≥n vamos a introducir los tipos de datos m√°s b√°sicos que Python nos ofrece.\nM√°s adelante tambi√©n veremos otros tipos de datos m√°s complejos que nos van a permitir resolver problemas (much√≠simo) m√°s interesantes.\n\nN√∫meros\nAcabamos de hacer cuentas matem√°ticas somo si tuvieramos una calculadora. Para eso usamos n√∫meros, los conocidos de toda la vida.\nSin notarlo, utilizamos dos tipos de n√∫meros distintos: los n√∫meros de tipo entero (int) y los n√∫meros de tipo flotante (float).\nLo siguiente es un n√∫mero entero:\n\n50\n\n50\n\n\nY el siguiente es un ejemplo de un n√∫mero flotante:\n\n36.8\n\n36.8\n\n\nUtilizando la funci√≥n type() Python nos devuelve el tipo del objeto.\n\ntype(10)\n\nint\n\n\n\ntype(10.5)\n\nfloat\n\n\n\ntype(10.0)\n\nfloat\n\n\n\ntype(10.)\n\nfloat\n\n\n\n\n\n\n\n\nObservaci√≥n üëÄ\n\n\n\nA diferencia de R, Python no es un lenguaje vectorizado. Por lo tanto, los tipos int y float representan valores escalares, no vectores de longitud 1 como ocurre en R.\nEsta observaci√≥n aplica a todos los tipos de datos elementales que vienen a continuaci√≥n.\n\n\n\n\nCadenas de texto\nPara ser una lenguaje de programaci√≥n tan afamado, Python tiene que ser capaz de trabajar con objetos m√°s complejos que los n√∫meros.\nUn ejemplo de esto es el texto, que se representa con un objeto llamado cadena de texto y se construyen utilizando comillas.\nComo en la mayor√≠a de los lenguajes de programaci√≥n, las comillas se ponen al principio y al final del texto e indican el principio y el final de la cadena; estas pueden pueden ser dobles \" o simples '.\n\n\"Programando en Python\"\n\n'Programando en Python'\n\n\n\n'Con comillas simples, tambi√©n.'\n\n'Con comillas simples, tambi√©n.'\n\n\nEn Python no hay diferencia entre usar comillas simples ' o dobles \", pero es importante que el tipo de comilla que se usa para abrir la cadena sea el mismo que se usa para cerrarla.\nCuando imprimimos una cadena, las comillas no se muestran en la salida. Para imprimir cualquier objeto de Python utilizamos la funci√≥n print().\n\nprint('Con comillas simples, ¬°tambi√©n!')\n\nCon comillas simples, ¬°tambi√©n!\n\n\nUna forma un poco m√°s ex√≥tica, pero muy √∫til, de crear cadenas es utilizando comillas triples. Con esta sintaxis, se repiten tres comillas seguidas, lo que permite definir cadenas de texto que ocupan varias l√≠neas.\n\nprint(\"\"\"Se puede escribir texto\nen varias lineas.\n¬°Est√° muy bueno!\"\"\")\n\nSe puede escribir texto\nen varias lineas.\n¬°Est√° muy bueno!\n\n\nOtra manera de escribir texto que abarca m√∫ltiples l√≠neas es usando el car√°cter especial \\n, que representa un salto de l√≠nea.\n\nprint(\"Primera l√≠nea\\nsegunda l√≠nea\\ntercera l√≠nea.\")\n\nPrimera l√≠nea\nsegunda l√≠nea\ntercera l√≠nea.\n\n\nEn cambio, si mostramos una representaci√≥n del texto (sin usar print()), los \\n s√≠ se visualizan.\n\n\"Primera l√≠nea\\nsegunda l√≠nea\\ntercera l√≠nea.\"\n\n'Primera l√≠nea\\nsegunda l√≠nea\\ntercera l√≠nea.'\n\n\n\n\n\n\n\n\n¬°Atenci√≥n! ü§ì\n\n\n\n¬øCu√°l es la diferencia entre usar print() y no usarlo?\n\nCuando usamos print() se imprime el objeto de una manera humanamente legible.\nCuando no lo usamos, se muestra una representaci√≥n del objeto. Esta representaci√≥n tiene que ser lo menos ambigua posible.\n\nPor este motivo es que se muestran las comillas a la hora de representar una cadena.\n\n\n\n\nOtra situaci√≥n en la que usar print() genera una diferencia es cuando se quieren mostrar varios objetos en una notebook. Por ejemplo, comparemos el resultado de los siguientes bloques:\n\n\"mensaje 1\"\n10\n\"mensaje 2\"\n\n'mensaje 2'\n\n\n\nprint(\"mensaje 1\")\nprint(10)\nprint(\"mensaje 2\")\n\nmensaje 1\n10\nmensaje 2\n\n\n\n\nL√≥gicos (o Booleanos)\nComo veremos m√°s adelante, nuestros programas suelen tener que decidir entre diferentes acciones a tomar seg√∫n se cumpla o no cierta condici√≥n.\nPara representar esta situaci√≥n utilizamos un tipo especial de dato conocido como l√≥gico o booleano, que puede tomar √∫nicamente dos valores: True o False.\nSi la condici√≥n se cumple, el resultado ser√° True; de lo contrario, ser√° False.\n\nTrue\n\nTrue\n\n\n\nFalse\n\nFalse\n\n\n\ntype(True)\n\nbool\n\n\n\ntype(False)\n\nbool\n\n\n\n\n\n\n\n\nRese√±a hist√≥rica üìú\n\n\n\nEste tipo de datos se llama Booleano en honor al matem√°tico George Boole.\n\n\n\n\nNulo\nEl valor nulo, llamado None en Python, representa la ausencia de valor o el vac√≠o. Se utiliza habitualmente para indicar que algo no tiene un valor asignado. Si intentamos mostrar el valor de None, veremos que no aparece nada.\n\nNone\n\nEn cambio, si imprimimos el objeto None, vemos el mensaje None.\n\nprint(None)\n\nNone\n\n\n¬øY cu√°l es su tipo?\n\ntype(None)\n\nNoneType\n\n\nSolamente los objetos None son del tipo NoneType.\n\n\n\n\n\n\n¬øPor qu√© existe el valor nulo? ü§î\n\n\n\nMuchas veces nuestro programa, o alguna parte del mismo, realiza una tarea que no devuelve ning√∫n resultado.\nPodr√≠amos ponernos de acuerdo en representar ‚Äúning√∫n resultado‚Äù usando un n√∫mero (e.g., 0), una cadena vac√≠a (\"\"), o algo similar. Pero estos valores representan algo espec√≠fico, no la ausencia total de valor.\nPara expresar claramente que no hay ning√∫n resultado, Python incluye un valor especial llamado None.\n\n\nEjemplos\n\nUn usuario completa un formulario con datos personales, pero algunos campos no son obligatorios y quedan sin completar.\nUna funci√≥n busca un elemento en una lista; cuando no encuentra lo buscado, devuelve un valor especial indicando que el resultado est√° ausente.\n\nEn general, cuando se quiera representar la ausencia de informaci√≥n se utilizar√° None.\n\n\n\n\n\n\nObservaci√≥n üëÄ\n\n\n\nEn R existen dos tipos de datos para representar valores faltantes: NULL y NA. El None de Python equivale a NULL en R, ya que ambos indican ausencia de valor.\nPor otro lado, NA en R representa un valor existente pero desconocido, por ejemplo, porque se ha perdido. Python no ofrece un tipo de dato equivalente de forma nativa, aunque algunas librer√≠as s√≠ lo implementan.\n\n\n\n\nConversi√≥n entre tipos de datos\nQue existan distintos tipos de datos no significa que un objeto de un tipo no pueda ‚Äúconvertirse‚Äù a otro.\nEn muchos casos es posible convertir entre tipos de datos. Por ejemplo, un n√∫mero siempre se puede convertir a una cadena de caracteres, pero no cualquier cadena puede convertirse a un n√∫mero.\nPara convertir un objeto a otro tipo utilizamos funciones con el nombre del tipo al que queremos convertir, como str(), int() o bool(). Estas funciones reciben como argumento el objeto a convertir.\nVeamos algunos ejemplos:\n\nstr(256)\n\n'256'\n\n\n\nstr(None)\n\n'None'\n\n\n\nint(165.5)\n\n165\n\n\n\nint(165.8)\n\n165\n\n\n\nint(\"165\")\n\n165\n\n\n\nfloat(\"165.0\")\n\n165.0\n\n\n\n\nResumen\n\nPython tiene distintos tipos de datos.\nCada tipo de dato es √∫til para resolver diferentes problemas.\n\nA lo largo de la materia veremos much√≠simos ejemplos.\n\nAl principio, tener varios tipos de datos puede parecer complejo.\n\nSin embargo, nos resultar√°n muy naturales a medida que los usemos para resolver problemas concretos.\n\n\n\n\n\n\n\n\n\nTipo de dato\nEjemplos\n\n\n\n\nN√∫meros enteros (int)\n-2, -1, 0, 10, 200\n\n\nN√∫meros de punto flotante (float)\n-200.789, -1.0, 0.0, 17.8\n\n\nCadenas de texto (str)\n\"a\", \"abc\", \"Rosario, Santa Fe\"\n\n\nBooleanos (bool)\nTrue, False\n\n\nValor nulo (NoneType)\nNone",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "1 - Introducci√≥n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#variables",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#variables",
    "title": "1 - Introducci√≥n",
    "section": "Variables",
    "text": "Variables\n¬øEs necesario escribir expl√≠citamente los valores con los que trabajamos cada vez que los usamos? Afortunadamente, la respuesta es no.\nLos lenguajes de programaci√≥n m√°s populares permiten usar variables.\nPodemos pensar las variables como etiquetas o nombres que asignamos a los objetos en nuestro programa.\nUna vez creada una variable con cierto valor, podemos usar directamente su nombre en lugar de volver a escribir el valor completo.\n\nmensaje = \"¬°Hola, curso!\"\nprint(mensaje)\n\n¬°Hola, curso!\n\n\n\nprint(\"¬°Hola, curso!\")\n\n¬°Hola, curso!\n\n\nPara crear una variable se necesita:\n\nEl nombre.\nEl operador de asignaci√≥n.\nEl valor que queremos asignar a la variable.\n\nEn nuestro caso, el nombre de la variable es mensaje y el valor es \"¬°Hola, curso!\".\nLuego, cuando accedemos a la variable mensaje dentro de la funci√≥n print(), Python nos devuelve el valor de la variable, es decir, ¬°Hola, curso!\".\nVeamos otros ejemplos‚Ä¶\n\npi = 3.14159\nfruta_favorita = \"manzana\"\npython_bueno = True\n\nEn el siguiente diagrama se muestra c√≥mo las variables que creamos funcionan simplemente como etiquetas para los valores asignados.\nCada vez que utilizamos una de estas etiquetas, accedemos directamente al valor que representa.\n\n\n\n\n\n\nprint(pi * 10)\n\n31.4159\n\n\n\nfruta_favorita\n\n'manzana'\n\n\n\npython_bueno\n\nTrue\n\n\nLas variables no solo evitan que escribamos repetidamente los mismos valores en nuestro programa, sino que tambi√©n permiten:\n\nGeneralizar el programa\n\nAl cambiar el valor de una variable, todas las partes del programa que la usan se actualizan autom√°ticamente.\n\nMejorar la legibilidad del c√≥digo\n\nSi elegimos nombres claros y descriptivos, el programa ser√° mucho m√°s f√°cil de leer y entender.\n\n\nPor ejemplo, los siguientes bloques de c√≥digo producen el mismo resultado, pero el segundo es mucho m√°s informativo:\n\n1500 * 8\n\n12000\n\n\n\nprecio = 1500\ncantidad = 8\nprecio * cantidad\n\n12000\n\n\n\nNombres permitidos\nNo todos los nombres que imaginemos se pueden utilizar como variables en Python.\nTenemos que tener en cuenta las siguientes reglas. Los nombres de variables‚Ä¶\n\nSolo pueden contener letras, n√∫meros y guiones bajos (_).\nDeben comenzar con una letra o un gui√≥n bajo, pero no con un n√∫mero.\n\nPor ejemplo, mensaje_1 es v√°lido, pero 1_mensaje no lo es.\n\nNo pueden contener espacios.\n\nPor eso usamos fruta_favorita en lugar de fruta favorita.\n\nNo pueden ser palabras reservadas de Python.\n\nLas palabras reservadas se encuentran al final de este apunte.\n\n\nAdem√°s, tambi√©n vale la pena tener presente estos consejos:\n\nUs√° nombres breves pero descriptivos.\n\nnombre es preferible a n.\nfruta_favorita es preferible a frut_fav.\n\nEvit√° utilizar tildes, la letra √± u otros caracteres espec√≠ficos del castellano.\n\n\n\nEliminar variables\nEs posible que, despu√©s de crear nuestras variables y realizar las operaciones necesarias, queramos eliminarlas.\nPara borrar una variable, Python ofrece la sentencia del (del ingl√©s delete, que significa eliminar o borrar).\n\ndel fruta_favorita\n\n\n\nAsignaci√≥n m√∫ltiple\nYa vimos que para asignar (o crear) una variable necesitamos hacer variable = &lt;valor&gt;.\nSi queremos crear varias variables, podemos hacerlo en l√≠neas separadas:\n\npi = 3.1416\ne = 2.7182\n\nprint(pi)\nprint(e)\n\n3.1416\n2.7182\n\n\nUna caracter√≠stica conveniente de Python es que permite asignar m√∫ltiples variables en una misma l√≠nea:\n\npi, e = 3.1416, 2.7182\n\nprint(pi)\nprint(e)\n\n3.1416\n2.7182\n\n\nOtra ventaja es que las variables no tienen que ser del mismo tipo:\n\na, b, c = 100 + 20, \"un mensaje cualquiera\", None\n\nprint(a)\nprint(b)\nprint(c)\n\n120\nun mensaje cualquiera\nNone\n\n\nEsta t√©cnica es √∫til para escribir c√≥digo m√°s conciso, pero no conviene abusar de ella porque puede resultar en c√≥digo poco legible.\n\n\n\n\n\n\nObservaci√≥n üëÄ\n\n\n\nLa vida es m√°s compleja de lo que parece, y los lenguajes de programaci√≥n no son una excepci√≥n.\nEn Python, lo que parece una asignaci√≥n m√∫ltiple de variables es en realidad el uso de una t√©cnica m√°s avanzada llamada unpacking.\nA no desesperarse, m√°s adelante vamos a aprender de qu√© se trata.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "1 - Introducci√≥n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#operadores",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#operadores",
    "title": "1 - Introducci√≥n",
    "section": "Operadores",
    "text": "Operadores\nLos operadores son s√≠mbolos que se utilizan para realizar operaciones o acciones sobre los objetos con los que estamos trabajando.\nHasta ahora, vimos que podemos tener n√∫meros, texto, y otras objetos un poco mas extra√±os como los booleanos e incluso algo que representa a la nada misma.\nA continuaci√≥n, comenzamos a ver algunas de las tareas que podemos hacer con ellos.\n\nOperadores aritm√©ticos\nPython incluye los mismos operadores aritm√©ticos que solemos utilizar en nuestro d√≠a a d√≠a para hacer operaciones matem√°ticas.\nEstos se parecen much√≠simo a los que usamos en una calculadora, por lo que podr√≠amos entenderlo incluso sin saber de Python.\nAlgunos operadores son los siguientes:\n\nSuma (+)\nResta (-)\nMultiplicaci√≥n (*)\nPotencia (**)\nDivisi√≥n (/)\nDivisi√≥n entera (//)\nM√≥dulo (%)\n\n\nSuma (+)\n\n10 + 25\n\n35\n\n\n\n10.0 + 25.0\n\n35.0\n\n\n\n-8 + 12.1\n\n4.1\n\n\nEl operador suma tambi√©n puede ser usado con un solo argumento:\n\n+ 8\n\n8\n\n\nEn este caso no modifica en nada al valor 8.\n\n\n\nResta (-)\n\n11 - 8\n\n3\n\n\n\n100 - 100.0\n\n0.0\n\n\n\n-35 - 28\n\n-63\n\n\nEl operador resta tambi√©n puede ser usado con un solo argumento:\n\n- 7\n\n-7\n\n\n\n\nMultiplicaci√≥n (*) y potencia (**)\n\n21 * 5\n\n105\n\n\n\n21 * 5.0\n\n105.0\n\n\n\n21.0 * 5.0\n\n105.0\n\n\n\n2 ** 3\n\n8\n\n\n\n2 ** 3.0\n\n8.0\n\n\n\n\n\n\n\n\nConclusiones\n\n\n\nPara las operaciones de suma, resta, multiplicaci√≥n y potencia se cumple:\n\nSi ambos valores son enteros, el resultado ser√° un entero.\nSi al menos uno de los valores es flotante, el resultado ser√° flotante.\n\n\n\n\n\nDivisi√≥n (/ y //)\nPython provee dos operadores distintos para calcular el cociente entre dos n√∫meros.\n\nEl operador / que calcula la divisi√≥n flotante.\nEl operador // que calcula la divisi√≥n entera.\n\nEl operador / es el que m√°s se utiliza y siempre devuelve un n√∫mero de tipo flotante.\n\n10 / 5\n\n2.0\n\n\n\n10 / 5.5\n\n1.8181818181818181\n\n\nLa divisi√≥n entera se suele utilizar cuando uno quiere el resultado entero de la divisi√≥n, sin importar si el resto es 0 o no.\n\n10 // 5\n\n2\n\n\n\n10 // 5.5\n\n1.0\n\n\nVeamos los siguientes ejemplos donde comparamos la divisi√≥n flotante con la divisi√≥n entera, utilizando los mismos argumentos.\n\n15 / 4\n\n3.75\n\n\n\n15.0 // 4.0\n\n3.0\n\n\nConclusi√≥n: La divisi√≥n entera no redondea el resultado de la divisi√≥n flotante. M√°s sobre esto debajo.\n\n\nM√≥dulo (%)\nOtro operador relacionado a la divisi√≥n entera es el operador m√≥dulo o resto (%).\nEsta operaci√≥n nos devuelve el resto que se obtiene al realizar la divisi√≥n entera entre dos n√∫meros.\n\n17 % 3\n\n2\n\n\nDebajo se puede ver la relaci√≥n entre la divisi√≥n entera y el m√≥dulo:\n\n\n\n\n\nAunque ahora pueda parecer dif√≠cil encontrar una aplicaci√≥n pr√°ctica para los operadores de divisi√≥n entera // y resto %, m√°s adelante veremos ejemplos donde haremos un uso intensivo de ellos.\n\n\n\n\n\n\nObservaci√≥n üëÄ\n\n\n\nProbablemente en R hayan utilizado principalmente el operador /, que tambi√©n corresponde a la divisi√≥n flotante.\nEn ese lenguaje, los operadores para divisi√≥n entera y resto son %/% y %%, respectivamente.\n\n\n\n\nPrioridad de los operadores\nHasta ahora vimos operaciones bastante sencillas.\nCuando presentamos la suma, realizamos simplemente una suma. Cuando presentamos la multiplicaci√≥n, hicimos solo una multiplicaci√≥n.\nPor supuesto, al momento de hacer c√°lculos podemos combinar los operadores que ya conocemos, de la misma forma en que lo hacemos al resolver cuentas a mano.\nUn punto importante a tener en cuenta es que, al igual que cuando hacemos cuentas a mano, algunas operaciones se resuelven antes que otras, sin importar el orden en que aparecen. Esto ocurre porque algunos operadores tienen mayor prioridad y, por lo tanto, se eval√∫an antes.\nEn el siguiente ejemplo, ¬øpor qu√© se obtienen resultados distintos?\n\n10 - 2 * 4\n\n2\n\n\n\n(10 - 2) * 4\n\n32\n\n\nIndependientemente de que el s√≠mbolo + aparezca antes que el s√≠mbolo * en una expresi√≥n, Python realiza primero la multiplicaci√≥n.\nAl igual que cuando hacemos cuentas a mano, la multiplicaci√≥n tiene mayor prioridad que la suma.\nSi queremos forzar a Python a realizar una operaci√≥n antes que otra, sin importar la prioridad de los operadores, debemos usar par√©ntesis.\nOtro ejemplo es el siguiente‚Ä¶\n\n7 + 8 / 2\n\n11.0\n\n\n\n(7 + 8) / 2\n\n7.5\n\n\nA continuaci√≥n se incluye una tabla con los operadores que vimos y la prioridad que tiene cada uno.\nLos operadores que aparecen m√°s arriba tienen mayor prioridad.\nLos operadores que aparecen en la misma fila tienen el mismo nivel de prioridad y se resuelven seg√∫n el orden en que aparecen en el c√≥digo (de izquierda a derecha).\n\n\n\n\n\n\n\nOperador\nSignificado\n\n\n\n\n()\nAgrupamiento\n\n\n**\nPotencia\n\n\n*, /, //, %\nMultiplicaci√≥n, Divisi√≥n, Divisi√≥n entera, M√≥dulo\n\n\n+, -\nSuma, Resta\n\n\n\nEsta lista es una versi√≥n m√°s sencilla y resumida de la tabla de prioridades de todos los operadores que hay en Python. Una versi√≥n m√°s completa se puede encontrar en Programiz.\n\n\n\nOperadores l√≥gicos\nLos operadores l√≥gicos en Python son tres: not, and y or. Se llaman as√≠ porque combinan expresiones l√≥gicas (o directamente valores l√≥gicos) y devuelven tambi√©n valores l√≥gicos, es decir, del tipo bool, que pueden ser True o False. Estos operadores se utilizan para combinar o invertir condiciones en expresiones l√≥gicas.\n\nNegaci√≥n (not)\nDevuelve el opuesto del valor que le pasamos.\n\nnot False\n\nTrue\n\n\n\nnot True\n\nFalse\n\n\n\n\nConjunci√≥n o intersecci√≥n (and)\nEsta operaci√≥n devuelve True solamente cuando los dos operadores que le pasamos son True.\n\nTrue and True\n\nTrue\n\n\n\nFalse and True\n\nFalse\n\n\n\n\nDisyunci√≥n o uni√≥n (or)\nEsta operaci√≥n devuelve True cuando cualquiera de sus argumentos es True.\n\nTrue or False\n\nTrue\n\n\nSolo devuelve False cuando sus dos argumentos son False.\n\nFalse or False\n\nFalse\n\n\n\n\n\nOperadores de comparaci√≥n\n\nComparaci√≥n por identidad\nPython ofrece dos operadores para verificar si dos objetos son o no el mismo en identidad (es decir, en memoria):\n\nis: devuelve True si ambos operandos son el mismo objeto.\nis not: devuelve True si los operandos no son el mismo objeto.\n\n\nFalse is False\n\nTrue\n\n\n\nFalse is True\n\nFalse\n\n\n\nNone is None\n\nTrue\n\n\nEste tipo de comparaci√≥n es posible porque cada objeto en Python existe en la memoria de la computadora y tiene una identificaci√≥n √∫nica (ID). Para conocer el ID de un objeto, se puede usar la funci√≥n id().\n\nid(False)\n\n94152411564800\n\n\n\nid(False)\n\n94152411564800\n\n\n\nid(None)\n\n94152411476128\n\n\n\n\nComparaci√≥n por valor\nPor otro lado, Python tambi√©n provee operadores para realizar comparaciones entre objetos en t√©rminos de sus valores.\nLos operadores que vemos a continuaci√≥n son los mismos que aprendimos en la secundaria.\n\n\n\n\n\n\n\nOperador\nDescripci√≥n\n\n\n\n\n==\nIgualdad: El resultado es True cuando los dos operandos son iguales.\n\n\n!=\nDesigualdad: El resultado es True si los operandos son distintos.\n\n\n&gt;\nMayor a: El resultado es True si el operando de la izquierda es mayor que el de la derecha.\n\n\n&gt;=\nMayor o igual a: El resultado es True si el operando de la izquierda es mayor o igual que el de la derecha.\n\n\n&lt;\nMenor a: El resultado es True si el operando de la izquierda es menor que el de la derecha.\n\n\n&lt;=\nMenor o igual a: El resultado es True si el operando de la izquierda es menor o igual que el de la derecha.\n\n\n\nAlgunos ejemplos‚Ä¶\n\n10 &gt; 5\n\nTrue\n\n\n\n10 &gt; 5 + 3\n\nTrue\n\n\n\n0 &lt; 0\n\nFalse\n\n\n\n1 &gt;= 1\n\nTrue\n\n\n\n10.0 != 10\n\nFalse\n\n\n\n10.0 == 10\n\nTrue\n\n\nA pesar de que 10.0 es de tipo flotante y 10 es de tipo entero, vemos que la comparaci√≥n de igualdad == dice que son iguales.\nNo siempre que comparemos objetos de distinto tipo va a suceder algo as√≠.\nLa comparaci√≥n de cadenas de texto distingue may√∫sculas de min√∫sculas\n\n\"UNR\" == \"unr\"\n\nFalse\n\n\nEs posible comparar objetos de distinto tipo, como lo vimos en el ejemplo anterior donde comparamos 10 y 10.0.\nSalvo casos particulares, como son los valores num√©ricos, estos objetos son considerados siempre distintos.\n\n\"10\" == 10\n\nFalse\n\n\n\n\"False\" == False\n\nFalse\n\n\nEs posible combinar mas de una comparaci√≥n en la misma l√≠nea.\n\n1 &lt; 2 and 2 &lt; 3\n\nTrue\n\n\nIncluso es posible omitir el operador and y tener una expresi√≥n m√°s clara\n\n1 &lt; 2 &lt; 3\n\nTrue\n\n\n\n-5 &lt; -4 &lt; -3\n\nTrue\n\n\nTambi√©n podemos mezclar not, and y or a gusto.\n\nFalse or not False\n\nTrue\n\n\nY es v√°lido utilizar par√©ntesis para agrupar operaciones.\n\n(False or True) and (True or False)\n\nTrue\n\n\nA continuaci√≥n se incluye una tabla con los operadores de comparaci√≥n y la prioridad que tiene cada uno.\nLos operadores que aparecen m√°s arriba tienen mayor prioridad.\nLos operadores que aparecen en la misma fila tienen el mismo nivel de prioridad y se resuelven seg√∫n el orden en que aparecen en el c√≥digo (de izquierda a derecha).\n\n\n\n\n\n\n\nOperadores\nSignificado\n\n\n\n\n==, !=, &gt;, &gt;=, &lt;, &lt;=, is, is not, in, not in\nComparaciones, identidad, pertenencia\n\n\nnot\nNegaci√≥n\n\n\nand\nConjunci√≥n o intersecci√≥n\n\n\nor\nDisyunci√≥n o uni√≥n\n\n\n\nTodos los operadores de comparaci√≥n tienen menor prioridad que los operadores aritm√©ticos que vimos arriba.\nEn otras palabras, si pegaramos ambas tablas, √©sta √∫ltima quedar√≠a por debajo.\nAnalicemos nuevamente uno de los ejemplos que ya vimos.\n\nnot True and not True\n\nFalse\n\n\nEl operador not tiene mayor prioridad que el operador and porque aparece primero en la tabla.\nEn consecuencia, en el c√≥digo anterior primero se resuelven los not True y luego el and. Esto es lo mismo que hacer\n\nFalse and False\n\nFalse\n\n\n\n\n\n\n\n\nResumen üìù\n\n\n\nExisten dos operadores para comparar igualdad entre dos objetos de Python:\n\n== ‚Üí compara el valor (contenido).\nis ‚Üí compara la identidad (ubicaci√≥n en memoria).",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "1 - Introducci√≥n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#operaciones-con-cadenas-de-caracteres",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#operaciones-con-cadenas-de-caracteres",
    "title": "1 - Introducci√≥n",
    "section": "Operaciones con cadenas de caracteres",
    "text": "Operaciones con cadenas de caracteres\n\nSuma y producto\nAunque al principio pueda parecer extra√±o, en Python es posible usar operadores matem√°ticos con objetos que no son num√©ricos.\nEsto no significa que se puedan aplicar a cualquier objeto, ni que est√©n disponibles todos los operadores en esos casos.\nSin embargo, vale la pena resaltar el uso del operador de suma (+) y producto (*) con las cadenas de caracteres.\nVeamos que pasa si ‚Äúsumamos‚Äù dos cadenas de caracteres:\n\n\"¬øFunciona\" + \"bien?\"\n\n'¬øFuncionabien?'\n\n\n\n\"¬øesto\" + \" tambi√©n \" + \"funciona?\"\n\n'¬øesto tambi√©n funciona?'\n\n\nComo se puede observar, el operador de suma (+) aplicado a cadenas de texto indica concatenaci√≥n: crea una nueva cadena uniendo el contenido de las cadenas originales, en el mismo orden.\nSi la suma tiene sentido para cadenas, entonces el producto tambi√©n deber√≠a tenerlo (al menos con n√∫meros enteros). Veamos un ejemplo:\n\n\"ja\" * 2\n\n'jaja'\n\n\n\n\"ja\" * 4\n\n'jajajaja'\n\n\nDe manera coherente con la definici√≥n de producto para enteros, multiplicar una cadena por un n√∫mero entero N equivale a concatenar esa cadena consigo misma N veces.\n\n\nCadenas formateadas (formatted strings)\nLas cadenas de texto formateadas son de gran utilidad para crear una cadena de texto a partir de otros objetos.\nEn Python se las conoce como f-strings (abreviaci√≥n de formatted-strings) y tienen este nombre porque tenemos que poner una f antes de las comillas.\nEl resultado de una f-string no se diferencia de una cadena de texto com√∫n y corriente.\n\nf\"Un texto cualquiera\"\n\n'Un texto cualquiera'\n\n\nSin embargo, las f-strings nos permiten interpolar cadenas de texto.\n¬øQu√© es interpolar texto?\nVeamos algunos ejemplos.\n\nlenguaje = \"Python\"\nprint(\"Programando en \" + lenguaje)\n\nProgramando en Python\n\n\n\nque = \"bayer\"\ncomo = \"bueno\"\nprint(\"Si es \" + que + \" es \" + como + \".\")\n\nSi es bayer es bueno.\n\n\nEl proceso se vuelve un poco engorroso. Hay que estar atentos a las sumas y los espacios para que el resultado quede formateado de una manera correcta.\nLas f-strings vienen a facilitar este proceso y hacerlo menos tedioso.\nLo que tenemos que hacer es pasar el nombre de la variable entre llaves ({}) en el contenido de la f-string.\n\nprint(f\"Programando en {lenguaje}\")\nprint(f\"Si es {que} es {como}.\")\n\nProgramando en Python\nSi es bayer es bueno.\n\n\nVeamos un ejemplo menos trivial, donde utilizar f-strings reduce la cantidad de c√≥digo y lo hace m√°s claro.\n\nnombre = \"Tom√°s\"\nedad = 29\nciudad = \"Rosario\"\n\nprint(\"Hola, soy \" + nombre + \", tengo \" + str(edad) + \" a√±os y vivo en \" + ciudad + \".\")\n\nHola, soy Tom√°s, tengo 29 a√±os y vivo en Rosario.\n\n\nUtilizando f-strings‚Ä¶\n\nprint(f\"Hola, soy {nombre}, tengo {edad} a√±os y vivo en {ciudad}.\")\n\nHola, soy Tom√°s, tengo 29 a√±os y vivo en Rosario.\n\n\nAdem√°s, no es necesario convertir la variable edad a al tipo str manualmente.\nNo solo podemos utilizar variables dentro de las f-strings, tambi√©n podemos incluir expresiones de Python.\n\nminutos_por_hora = 60\nhoras = 2.7\n\nprint(f\"En {horas} horas hay {horas * minutos_por_hora} minutos.\")\n\nEn 2.7 horas hay 162.0 minutos.\n\n\n\n\nCadenas de texto y sus met√≥dos\n\nnombre = \"Lionel Messi\"\n\nLas cadenas de texto, es decir, los objetos de tipo str, vienen con varias funciones (llamados ‚Äúm√©todos‚Äù) que nos facilitan much√≠simas tareas en la pr√°ctica.\nPor ejemplo, tenemos los m√©todos .upper() y .lower(), que ponen el texto en may√∫scula y en min√∫scula, respectivamente.\n\nprint(nombre.upper())\nprint(nombre.lower())\n\nLIONEL MESSI\nlionel messi\n\n\nTambi√©n tenemos .capitalize(), que pone la primer letra en may√∫scula y el resto en min√∫sculas.\nEstos m√©todos se pueden combinar dentro de una f-string, sin necesidad de modificar los valores de nombre o apellido.\n\nnombre = \"lionel\"\napellido = \"messi\"\nnombre_completo = f\"{nombre.capitalize()} {apellido.capitalize()}\"\nprint(nombre_completo)\n\nLionel Messi\n\n\nOtra opci√≥n es usar .title().\nEste m√©todo pone la primera letra de cada palabra en may√∫sculas y al resto en min√∫sculas.\n\nmensaje = \"mensaje de prueba\"\nprint(mensaje.capitalize())\nprint(mensaje.title())\n\nMensaje de prueba\nMensaje De Prueba\n\n\n\n\nEliminar espacios en blanco\nEs muy com√∫n que en nuestros programas tengamos que lidiar con texto que vienen con espacios en blanco que est√°n dem√°s.\nEl espacio puede estar tanto al principio como al final de una cadena de texto.\nAfortunadamente, Python tambi√©n provee algunos m√©todos que nos permiten eliminar estos espacios con muy poco trabajo.\n\nlenguaje_favorito = \"  python  \"\nlenguaje_favorito\n\n'  python  '\n\n\n.rstrip() elimina los espacios en blanco a la derecha del texto.\n\nlenguaje_favorito.rstrip()\n\n'  python'\n\n\n.lstrip() elimina los espacios en blanco a la izquierda del texto.\n\nlenguaje_favorito.lstrip()\n\n'python  '\n\n\ny .strip() elimina los espacios en blanco a la izquierda y a la derecha del texto.\n\nlenguaje_favorito.strip()\n\n'python'\n\n\n\n\nReemplazar y eliminar caracteres no deseados\nTambi√©n es frecuente que el texto contenga caracteres err√≥neos, o caracteres que simplemente no queremos conservar.\nPara estos casos podemos usar el m√©todo .replace().\nA diferencia de los m√©todos que vimos hasta ahora, .replace() requiere que le pasemos algunos argumentos.\nEl primer valor que le pasamos es el texto que queremos reemplazar y el segundo es el texto de reemplazo.\nPodemos reemplazar caracteres, palabras, o frases enteras.\n\nanimal = \"pato\"\nanimal.replace(\"p\", \"g\")\n\n'gato'\n\n\n\nsaludo = \"Hola Mundo\"\nsaludo.replace(\"Mundo\", \"Curso\")\n\n'Hola Curso'\n\n\nCuando utilizamos el m√©todo .replace() se nos devuelve una nueva cadena de texto.\nEsto nos permite ‚Äúpegar‚Äù o ‚Äúencadenar‚Äù mas de un .replace() a la vez, ya que cada nuevo .replace() se aplica sobre el resultado de la operaci√≥n anterior.\n\nsaludo.replace(\"Mundo\", \"Curso\").replace(\"Hola\", \"Chau\")\n\n'Chau Curso'\n\n\nsaludo.replace(\"Mundo\", \"Curso\") devuelve \"Hola Curso\", al que luego se le aplica .replace(\"Hola\", \"Chau\") y el resultado final es \"Chau Curso\".",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "1 - Introducci√≥n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#ap√©ndice",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#ap√©ndice",
    "title": "1 - Introducci√≥n",
    "section": "Ap√©ndice",
    "text": "Ap√©ndice\n\nPalabras claves y funciones predefinidas\nPython tiene un conjunto de palabras conocidas como keywords que sirven para realizar acciones especificas y que no podemos utilizar como nombres de variables.\nCuando intentemos utilizar una keyword como nombre de variable, obtendremos un error.\nPor otro lado, si intentamos utilizar el nombre de una funci√≥n (o clase) predefinida como nombre de una variable que nosotros creamos, no vamos a obtener un error pero no podremos usar la funci√≥n nuevamente porque la variable ahora representa otra cosa.\n\nPalabras claves\nFalse      await      else       import     pass\nNone       break      except     in         raise\nTrue       class      finally    is         return\nand        continue   for        lambda     try\nas         def        from       nonlocal   while\nassert     del        global     not        with\nasync      elif       if         or         yield\n\n\nFunciones y clases pre-definidas\nabs()          copyright()    getattr()      list()         range()        vars()\nall()          credits()      globals()      locals()       repr()         zip()\nany()          delattr()      hasattr()      map()          reversed()\nascii()        dict()         hash()         max()          round()\nbin()          dir()          help()         memoryview()   set()\nbool()         display()      hex()          min()          setattr()\nbreakpoint()   divmod()       id()           next()         slice()\nbytearray()    enumerate()    input()        object()       sorted()\nbytes()        eval()         int()          oct()          staticmethod()\ncallable()     exec()         isinstance()   open()         str()\nchr()          filter()       issubclass()   ord()          sum()\nclassmethod()  float()        iter()         pow()          super()\ncompile()      format()       len()          print()        tuple()\ncomplex()      frozenset()    license()      property()     type()\n\n\nM√©todos de las cadenas de texto\n\n\n\n\n\n\n\n\n\nM√©todo\nDescripci√≥n\nEjemplo\nResultado\n\n\n\n\n.endswith(sufijo)\nVerifica si termina con el sufijo\n\"file.txt\".endswith(\".txt\")\nTrue\n\n\n.find(x)\nLa posicion de la primera aparici√≥n de x en la cadena (o -1 si no est√°)\n\"Python\".find(\"t\")\n2\n\n\n.index(x)\nLa posicion de la primera aparici√≥n de x en la cadena (error si no est√°)\n\"Python\".index(\"n\")\n5\n\n\n.isalpha()\nVerifica si los caracteres son alfab√©ticos\n\"256\".isalpha()\nFalse\n\n\n.isdigit()\nVerifica si los caracteres son num√©ricos\n\"256\".isdigit()\nTrue\n\n\n.islower()\nVerifica si los caracteres son min√∫sculas\n\"Python\".islower()\nFalse\n\n\n.isupper()\nVerifica si los caracteres son may√∫sculas\n\"Python\".isupper()\nFalse\n\n\n.join(lista)\nUne una lista de cadenas usando la cadena como delimitador\n\" y \".join([\"esto\", \"aquello\"])\n\"esto y aquello\"\n\n\n.lower()\nConvertir a min√∫sculas\n\"Python\".lower()\n\"python\"\n\n\n.replace(viejo, nuevo)\nReemplaza texto\n\"maximo\".replace(\"ax\", \"in\")\n\"minimo\"\n\n\n.split(sep)\nParte la cadena en una lista de subcadenas\n\"esto y aquello\".split(\" y \")\n[\"esto\", \"aquello\"]\n\n\n.startswith(prefijo)\nVerifica si comienza con un prefijo\n\"file.txt\".endswith(\"a\")\nFalse\n\n\n.strip()\nElimina espacios en blanco al inicio o al final\n\" oh la la \".strip()\n\"oh la la\"\n\n\n.upper()\nConvierte a may√∫sculas\n\"Python\".upper()\n\"PYTHON\"",
    "crumbs": [
      "Teor√≠a",
      "U1 - Programaci√≥n en Python",
      "1 - Introducci√≥n"
    ]
  },
  {
    "objectID": "recursos/ejemplos/01_funciones_y_bucles.html",
    "href": "recursos/ejemplos/01_funciones_y_bucles.html",
    "title": "Funciones y bucles: Python vs R",
    "section": "",
    "text": "El siguiente bloque de c√≥digo define una funci√≥n en R:\n\n\nfuncion.R\n\nsumar &lt;- function(a, b) {\n  resultado &lt;- a + b\n  return(resultado)\n}\n\ny el siguiente define una funci√≥n an√°loga en Python:\n\n\nfuncion.py\n\ndef sumar(a, b):\n    resultado = a + b\n    return resultado",
    "crumbs": [
      "Recursos",
      "Ejemplos"
    ]
  },
  {
    "objectID": "recursos/ejemplos/01_funciones_y_bucles.html#funciones",
    "href": "recursos/ejemplos/01_funciones_y_bucles.html#funciones",
    "title": "Funciones y bucles: Python vs R",
    "section": "",
    "text": "El siguiente bloque de c√≥digo define una funci√≥n en R:\n\n\nfuncion.R\n\nsumar &lt;- function(a, b) {\n  resultado &lt;- a + b\n  return(resultado)\n}\n\ny el siguiente define una funci√≥n an√°loga en Python:\n\n\nfuncion.py\n\ndef sumar(a, b):\n    resultado = a + b\n    return resultado",
    "crumbs": [
      "Recursos",
      "Ejemplos"
    ]
  },
  {
    "objectID": "recursos/ejemplos/01_funciones_y_bucles.html#ejecuci√≥n-condicional",
    "href": "recursos/ejemplos/01_funciones_y_bucles.html#ejecuci√≥n-condicional",
    "title": "Funciones y bucles: Python vs R",
    "section": "Ejecuci√≥n condicional",
    "text": "Ejecuci√≥n condicional\nPor otro lado, el siguiente bloque muestra el uso de ejecuci√≥n condicional en R:\n\n\ncondicional.R\n\nx &lt;- 5\n\nif (x &gt; 0) {\n  mensaje &lt;- \"El n√∫mero es positivo\"\n} else {\n  mensaje &lt;- \"El n√∫mero no es positivo\"\n}\n\nprint(mensaje)\n\nY debajo se muestra la versi√≥n an√°loga en Python:\n\n\ncondicional.py\n\nx = 5\n\nif x &gt; 0:\n    mensaje = \"El n√∫mero es positivo\"\nelse:\n    mensaje = \"El n√∫mero no es positivo\"\n\nprint(mensaje)",
    "crumbs": [
      "Recursos",
      "Ejemplos"
    ]
  },
  {
    "objectID": "recursos/ejemplos/01_funciones_y_bucles.html#resumen-de-diferencias",
    "href": "recursos/ejemplos/01_funciones_y_bucles.html#resumen-de-diferencias",
    "title": "Funciones y bucles: Python vs R",
    "section": "Resumen de diferencias",
    "text": "Resumen de diferencias\n\nComunes\n\nUso de bloques:\n\nEn R los bloques de c√≥digo siempre se delimitan con llaves {}.\nEn Python los bloques se definen exclusivamente mediante indentaci√≥n (sin llaves).\n\nIndentaci√≥n:\n\nEn Python la indentaci√≥n es obligatoria y tiene significado sint√°ctico.\nEn R la indentaci√≥n es opcional; sirve √∫nicamente para mejorar la legibilidad.\n\nUso de los dos puntos (:):\n\nEn Python las definiciones de funciones y condiciones terminan con :.\nEn R no se utilizan los dos puntos al final de estas estructuras.\n\n\n\n\nFunciones\n\nForma de definir la funci√≥n:\n\nEn R: sumar &lt;- function(a, b). Se crea la funci√≥n y se asigna a una variable.\nEn Python: def sumar(a, b):. La creaci√≥n de la funci√≥n ya crea la variable.\n\nRetorno de valores:\n\nEn R, aunque es com√∫n usar return(), el resultado de la √∫ltima expresi√≥n se devuelve autom√°ticamente (puede omitirse return).\nEn Python es obligatorio usar return si se desea devolver un valor.\n\n\n\n\nEjecuci√≥n condicional\n\nUso de par√©ntesis en condiciones:\n\nEn R es obligatorio usar par√©ntesis alrededor de la condici√≥n (if (x &gt; 0)).\nEn Python no se usan par√©ntesis (if x &gt; 0:).",
    "crumbs": [
      "Recursos",
      "Ejemplos"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html",
    "title": "U1 - Programaci√≥n en Python",
    "section": "",
    "text": "# √Årea y per√≠metro de un c√≠rculo\ndef calcular_area(radio):\n    pi = 3.14159\n    area = pi * radio ** 2\n    return area\n\ndef calcular_perimetro(radio):\n    pi = 3.14159\n    perimetro = 2 * pi * radio\n    return perimetro\n\ndef calcular_area_y_perimetro(radio):\n    area = calcular_area(radio)\n    perimetro = calcular_perimetro(radio)\n    return area, perimetro\n\ncalcular_area(radio=2.5)\ncalcular_perimetro(radio=2.5)\n\narea, perimetro = calcular_area_y_perimetro(radio=2.5)\nresultados = calcular_area_y_perimetro(radio=2.5)\n\nprint(type(area))\nprint(type(perimetro))\nprint(type(resultados))\nprint(type(resultados[0]))\nprint(type(resultados[1]))",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci√≥n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#√°rea-y-per√≠metro-de-un-c√≠rculo",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#√°rea-y-per√≠metro-de-un-c√≠rculo",
    "title": "U1 - Programaci√≥n en Python",
    "section": "",
    "text": "# √Årea y per√≠metro de un c√≠rculo\ndef calcular_area(radio):\n    pi = 3.14159\n    area = pi * radio ** 2\n    return area\n\ndef calcular_perimetro(radio):\n    pi = 3.14159\n    perimetro = 2 * pi * radio\n    return perimetro\n\ndef calcular_area_y_perimetro(radio):\n    area = calcular_area(radio)\n    perimetro = calcular_perimetro(radio)\n    return area, perimetro\n\ncalcular_area(radio=2.5)\ncalcular_perimetro(radio=2.5)\n\narea, perimetro = calcular_area_y_perimetro(radio=2.5)\nresultados = calcular_area_y_perimetro(radio=2.5)\n\nprint(type(area))\nprint(type(perimetro))\nprint(type(resultados))\nprint(type(resultados[0]))\nprint(type(resultados[1]))",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci√≥n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#promociones",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#promociones",
    "title": "U1 - Programaci√≥n en Python",
    "section": "2 Promociones",
    "text": "2 Promociones\n# Promociones\ndef calcular_precio(monto, medio):\n    if medio == \"efectivo\":\n        monto_final = monto\n    elif medio == \"d√©bito\":\n        monto_final = monto * (1 - 0.1)\n    elif medio == \"cr√©dito\":\n        monto_final = monto * (1 + 0.05)\n    else:\n        print(f\"El medio {medio} es desconocido.\")\n        monto_final = monto\n\n    return monto_final\n\ncalcular_precio(80, \"efectivo\")\ncalcular_precio(80, \"d√©bito\")\ncalcular_precio(80, \"cr√©dito\")\n\n# Extra:\n# Usando valor por defecto 'efectivo'\ndef calcular_precio(monto, medio=\"efectivo\"):\n    if medio == \"efectivo\":\n        monto_final = monto\n    elif medio == \"d√©bito\":\n        monto_final = monto * (1 - 0.1)\n    elif medio == \"cr√©dito\":\n        monto_final = monto * (1 + 0.05)\n    else:\n        print(f\"El medio {medio} es desconocido.\")\n        monto_final = monto\n\n    return monto_final\n\n# Usando valor por defecto None\ndef calcular_precio(monto, medio=None):\n    if medio is None:\n        medio = \"efectivo\"\n\n    if medio == \"efectivo\":\n        monto_final = monto\n    elif medio == \"d√©bito\":\n        monto_final = monto * (1 - 0.1)\n    elif medio == \"cr√©dito\":\n        monto_final = monto * (1 + 0.05)\n    else:\n        print(f\"El medio {medio} es desconocido.\")\n        monto_final = monto\n\n    return monto_final",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci√≥n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#etapas-de-la-vida",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#etapas-de-la-vida",
    "title": "U1 - Programaci√≥n en Python",
    "section": "3 Etapas de la vida",
    "text": "3 Etapas de la vida\n# Etapas de la vida\ndef obtener_etapa(edad):\n    if edad &lt; 2:\n        etapa = \"beb√©\"\n    elif edad &lt; 4:\n        etapa = \"infante\"\n    elif edad &lt; 13:\n        etapa = \"ni√±o/a\"\n    elif edad &lt; 20:\n        etapa = \"adolescente\"\n    elif edad &lt; 65:\n        etapa = \"adulto/a\"\n    else:\n        etapa = \"persona mayor\"\n\n    mensaje = f\"La persona es un/a {etapa}\"\n    print(mensaje)\n\n    return None\n\nobtener_etapa(67)\n\n# Comentarios:\n# 1. Un posible problema con esta implementaci√≥n es que asume que la edad es positiva.\n#    Tambi√©n admite edades irrealmente altas.",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci√≥n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#conteo-de-caracteres",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#conteo-de-caracteres",
    "title": "U1 - Programaci√≥n en Python",
    "section": "4 Conteo de caracteres",
    "text": "4 Conteo de caracteres\n# Conteo de caracteres\ndef contar_caracteres(texto):\n    caracteres = {}\n    for caracter  in texto:\n        # No considerar espacios\n        if caracter == \" \":\n            continue\n\n        # Pasar el caracter a minuscula\n        caracter_minuscula = caracter.lower()\n        if caracter_minuscula not in caracteres:\n            caracteres[caracter_minuscula] = 1\n        else:\n            caracteres[caracter_minuscula] += 1\n\n    return caracteres\n\ncontar_caracteres(\"Ahora es mejor que nunca\")\n\n# Comentarios:\n# 1. Implementacion usando 'in' vs 'not in'\n# 2. ¬øPodr√≠an meter el .lower en otro lado? Si, se podr√≠a pasar el texto a min√∫sculas antes de empezar a iterar.\n# 3. ¬øEn cu√°l implementaci√≥n se realizar√≠a menos trabajo?\n# 4. ¬øPodriamos eliminar el `continue`?\n\n# Moraleja: no hay una √∫nica implementaci√≥n correcta.",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci√≥n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#orden-de-m√©rito",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#orden-de-m√©rito",
    "title": "U1 - Programaci√≥n en Python",
    "section": "5 Orden de m√©rito",
    "text": "5 Orden de m√©rito\n# Orden de m√©rito\nnotas = [\n    (\"Escalada\", 9),\n    (\"Alonso\", 7),\n    (\"P√©rez\", 8),\n    (\"Castro\", 8),\n    (\"Rossini\", 10),\n    (\"Mart√≠nez\", 9),\n    (\"P√©rez\", 6),\n    (\"Riquelme\", 5),\n]\n\n# Parte 1\nnotas_dict = {}\nfor registro in notas:\n    # Opcion 1:\n     notas_dict[registro[0]] = registro[1]\n\n    # Opcion 2:\n    # apellido = registro[0]\n    # nota = registro[1]\n    # notas_dict[apellido] = nota\n\n    # apellido, nota = registro\n    # notas_dict[apellido] = nota\n\n# Pregunta: ¬øQue pasa si hay dos personas con el mismo apellido?\n\n# Parte 2\nnotas_dict = {}\nfor registro in notas:\n    apellido = registro[0]\n    nota = registro[1]\n    if nota not in notas_dict:\n        notas_dict[nota] = [apellido]\n    else:\n        notas_dict[nota].append(apellido)\n        # Otras opciones:\n        # notas_dict[nota] = notas_dict[nota] + [apellido]\n        # notas_dict[nota] = notas_dict[nota].extend([apellido])",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci√≥n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#rendimento-acad√©mico",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#rendimento-acad√©mico",
    "title": "U1 - Programaci√≥n en Python",
    "section": "6 Rendimento acad√©mico",
    "text": "6 Rendimento acad√©mico\n# Rendimento acad√©mico\nnotas = {\n    \"Ana\": [8, 9, 10],\n    \"Luis\": [6, 7, 8, 3, 9],\n    \"Carla\": [10, 9, 10],\n    \"Marcos\": [5, 6],\n    \"Sof√≠a\": [7, 7, 8],\n    \"Pedro\": [6, 4, 5, 6, 3, 8],\n    \"Luc√≠a\": [9, 8, 10, 9]\n}\n\ndef resumir_notas(datos, modo):\n    resultado = {}\n\n    if modo == \"promedio\":\n        for nombre, notas in datos.items():\n            resultado[nombre] = sum(notas) / len(notas)\n    elif modo == \"proporcion\":\n        # NOTE: Esto tal vez sea un poco complicado\n        for nombre, notas in datos.items():\n            n_aprobado = 0\n            for nota in notas:\n                if nota &gt;= 6:\n                    n_aprobado += 1\n            resultado[nombre] = n_aprobado / len(notas)\n\n    else:\n        print(f\"El modo {modo} es desconocido\")\n        return None\n\n    return resultado\n\nresumir_notas(notas, \"promedio\")\nresumir_notas(notas, \"proporcion\")\n\n# ¬øC√≥mo ser√≠a la implementaci√≥n sin .items()?\n# ¬øPodr√≠a escribir un √∫nico for loop? ¬øQu√© cambiar√≠a? ¬øPros y contras?\n# ¬øHay alg√∫n conflicto entre la variable 'notas' del ambiente global y la del ambiente local de\n# la funci√≥n?\n# El c√°lculo de la proporci√≥n se podr√≠a abstraer en una funci√≥n.\n\n# Podr√≠a usarse un \"list comprehension\"\n# len([nota for nota in notas if nota &gt;= 6])\n\n# Podr√≠a usarse un generador:\n# sum(nota &gt;= 6 for nota in notas)",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci√≥n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#√≠ndice-de-precios",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#√≠ndice-de-precios",
    "title": "U1 - Programaci√≥n en Python",
    "section": "7 √çndice de precios",
    "text": "7 √çndice de precios\nipc_2024 = [20.6, 13.2, 11.0, 8.8, 4.2, 4.6, 4.0, 4.2, 3.5, 2.7, 2.4, 2.7]\n\n# Menor y mayor valor\nmin(ipc_2024)\nmax(ipc_2024)\n\n# IPC promedio mensual\nsum(ipc_2024) / len(ipc_2024)\n\n# Mes de mayor inflaci√≥n\nipc_2024.index(max(ipc_2024)) # 0 + 1 -&gt; enero\n\n# Inflaci√≥n mediana\nipc_ordenado = sorted(ipc_2024)\n\n# Opcion 1:\n(ipc_ordenado[5] + ipc_ordenado[6]) * 0.5\n\n# Opcion 2:\nsum(ipc_ordenado[5:7]) * 0.5\n\n# Opcion 3:\nn_inicio = (len(ipc_ordenado) // 2) - 1 # Resto 1 porque Python indexa desde 0\nn_fin = (len(ipc_ordenado) // 2 + 1) -1   # Resto 1 porque Python indexa desde 0\n\n# Sumo 1 porque el slicing no es inclusivo por derecha\nsum(ipc_ordenado[n_inicio:(n_fin + 1)]) * 0.5\n\n# Rango de IPC sin min y max\nipc_ordenado[-1] - ipc_ordenado[0]",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci√≥n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#res√∫menes-estad√≠sticos",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#res√∫menes-estad√≠sticos",
    "title": "U1 - Programaci√≥n en Python",
    "section": "8 Res√∫menes estad√≠sticos",
    "text": "8 Res√∫menes estad√≠sticos\ndef media(x):\n    return sum(x) / len(x)\n\n\ndef rango(x):\n    return max(x) - min(x)\n\n\n# Opcion 1.\ndef varianza(x):\n    x_media = media(x)\n    suma = 0\n    for x_i in x:\n        suma += (x_i - x_media) ** 2\n    return suma / len(x)\n\n\n# Opcion 2. Se podr√≠a usar un list-comprehension tambi√©n.\ndef varianza2(x):\n    x_media = media(x)\n    distancias = []\n    for x_i in x:\n        distancias.append((x_i - x_media) ** 2)\n    return media(distancias)\n\ndef desvio_estandar(x):\n    return varianza(x) ** 0.5\n\n\ndef mediana(x):\n    x_ordenado = sorted(x)\n    n = len(x)\n    mitad = n // 2\n\n    if n % 2 == 1:\n        # Cantidad impar: se toma el elemento del medio\n        mediana = x_ordenado[mitad]\n    else:\n        # Cantidad par: se promedian los dos del medio\n        mediana = (x_ordenado[   - 1] + x_ordenado[mitad]) * 0.5\n\n    return mediana",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci√≥n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#validaci√≥n-de-dni",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#validaci√≥n-de-dni",
    "title": "U1 - Programaci√≥n en Python",
    "section": "9 Validaci√≥n de DNI",
    "text": "9 Validaci√≥n de DNI\ndef validar_dni(dni):\n    # Si no 'dni' tiene puntos, es DNI v√°lido cuando:\n    # - todos los caracteres sean todos d√≠gitos\n    # - la longitud est√© entre 7 y 8\n    if dni.count(\".\") == 0:\n        return dni.isdigit() and 7 &lt;= len(dni) &lt;= 8\n\n    # Si 'dni' tiene puntos, debe tener exactamente 2 puntos.\n    partes = dni.split(\".\")\n    if len(partes) != 3:\n        return False\n\n    # Si alguna de las partes no contiene todos d√≠gitos, no es un DNI v√°lido.\n    # Opcion 1\n    for parte in partes:\n        if not parte.isdigit():\n            return False\n    # Opcion 2\n    # if not all(parte.isdigit() for parte in partes):\n    #     return False\n\n    longitudes_validas = (\n        len(partes[0]) in (1, 2) and\n        len(partes[1]) == 3 and\n        len(partes[2]) == 3\n    )\n\n    return longitudes_validas\n\n\nvalidar_dni(\"40.094.127\")\nvalidar_dni(\"19053512\")\nvalidar_dni(\"6.392.780\")\n\nvalidar_dni(\"40,094,127\")\nvalidar_dni(\"19-053-512\")\nvalidar_dni(\"123456\")\nvalidar_dni(\"40..094127\")\nvalidar_dni(\"40.09412.7\")",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci√≥n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#la-f√≠sica-del-rebote",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#la-f√≠sica-del-rebote",
    "title": "U1 - Programaci√≥n en Python",
    "section": "10 La f√≠sica del rebote",
    "text": "10 La f√≠sica del rebote\naltura_inicial = 100 # metros\nrebote = 3 / 5\n\n# Parte 1 (no es necesario el uso de una variable adicional)\naltura_actual = altura_inicial\nfor i in range(10):\n    altura_actual = altura_actual * rebote\n    print(\"Rebote\", i + 1, \"| Altura:\", round(altura_actual, 4))\n\n# Parte 2\ndef calcular_rebotes(altura_inicial, rebotes_n):\n    alturas = []\n    altura_actual = altura_inicial\n    for _ in range(rebotes_n): # '_' es una convencion cuando la variable de iteraci√≥n no se usa\n        altura_actual = altura_actual * rebote\n        alturas.append(altura_actual)\n\n    return alturas\n\ncalcular_rebotes(100, 10)\n\n\n# Parte 3\ndef calcular_rebotes(altura_inicial, rebotes_n):\n    alturas = []\n    altura_actual = altura_inicial\n    for _ in range(rebotes_n): # '_' es una convencion cuando la variable de iteraci√≥n no se usa\n        altura_actual = altura_actual * rebote\n        alturas.append(altura_actual)\n\n        if altura_actual &lt; 0.01:\n            break\n\n    return alturas\n\ncalcular_rebotes(100, 50)\nlen(calcular_rebotes(100, 50)) # Solo devuelve 19 rebotes\n\n# Se podria conversar si es necesario crear 'altura_actual'\n# Para el caso de las listas una opci√≥n, un poco m√°s rebuscada, es:\n\ndef calcular_rebotes(altura_inicial, rebotes_n):\n    alturas = [altura_inicial * rebote]\n    for i in range(rebotes_n):\n        alturas.append(alturas[i] * rebote)\n\n        if alturas[-1] &lt; 0.01:\n            break\n\n    return alturas\n\ncalcular_rebotes(100, 50)\nlen(calcular_rebotes(100, 50)) # Solo devuelve 19 rebotes",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci√≥n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#un-mont√≥n-de-plata",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#un-mont√≥n-de-plata",
    "title": "U1 - Programaci√≥n en Python",
    "section": "11 Un mont√≥n de plata",
    "text": "11 Un mont√≥n de plata\nbillete_grosor = 0.11 * 0.001  # grosor de un billete en metros\naltura_monumento = 70          # altura en metros\n\ndias = 1\nbilletes_n = 1\nwhile billetes_n * billete_grosor &lt;= altura_monumento:\n    billetes_n = billetes_n * 2\n    dias = dias + 1\n\nprint(\"Se necesitan\", dias, \"dias.\")\nprint(\"La altura de la pila es\", billetes_n * billete_grosor, \"metros.\")\nprint(\"Se colocaron\", billetes_n, \"billetes.\")\n\n\n# Punto extra\ndef calcular_dias(altura_objetivo):\n    billete_grosor = 0.11 * 0.001\n    dias = 1\n    billetes_n = 1\n    while billetes_n * billete_grosor &lt;= altura_objetivo:\n        billetes_n = billetes_n * 2\n        dias = dias + 1\n    return dias\n\ncalcular_dias(0.1)",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci√≥n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#la-conjetura-de-collatz",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#la-conjetura-de-collatz",
    "title": "U1 - Programaci√≥n en Python",
    "section": "12 La conjetura de Collatz",
    "text": "12 La conjetura de Collatz\ndef collatz(n):\n    # Inicializar lista con solo el valor 'n'\n    secuencia = [n]\n    while n != 1:\n        # Numero par\n        if n % 2 == 0:\n            n = n // 2 # Notar uso de divisi√≥n entera\n        # Numero impar\n        else:\n            # ¬øPuede el resultado ser flotante?\n            n = 3 * n + 1\n        secuencia.append(n)\n    return secuencia\n\n\ncollatz(5)\ncollatz(20)\ncollatz(16)\ncollatz(37)\n\n# Para discutir: ¬øPodr√≠a implementarse con un 'while True'? ¬øC√≥mo?",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci√≥n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#adivina-el-n√∫mero",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#adivina-el-n√∫mero",
    "title": "U1 - Programaci√≥n en Python",
    "section": "13 Adivina el n√∫mero",
    "text": "13 Adivina el n√∫mero\n# Correr de la terminal con 'python {nombre_de_programa}.py'\nimport random\n\nprint(\" ======================== Adivina el n√∫mero! ======================== \")\n\nnumero_secreto = random.randint(0, 100)\n\nmensaje = \"Ingresa un numero entero: \"\nconteo = 0\ntope_intentos = 5\nwhile True:\n    numero = int(input(mensaje))\n    conteo += 1\n    if numero &lt; numero_secreto:\n        mensaje = f\"¬°Ups! El numero secreto es mayor a {numero}. Prueba de nuevo: \"\n    elif numero &gt; numero_secreto:\n        mensaje = f\"¬°Ups! El numero secreto es menor a {numero}. Prueba de nuevo: \"\n    else:\n        print(f\"Has ganado, felicitaciones! Te llev√≥ tan solo {conteo} intentos.\")\n        break\n\n    if conteo == (tope_intentos - 1):\n        print(\"¬°Cuidado! Te queda solo un intento.\")\n\n    if conteo &gt;= tope_intentos:\n        print(f\"Has perdido :(. El numero secreto era {numero_secreto}.\")\n        break",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci√≥n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#conteo-de-caracteres-pythonico",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#conteo-de-caracteres-pythonico",
    "title": "U1 - Programaci√≥n en Python",
    "section": "14 Conteo de caracteres Pythonico",
    "text": "14 Conteo de caracteres Pythonico\ndef contar_caracteres(texto):\n    texto = texto.lower() # Pasa a minuscula al principio\n    caracteres = {}\n    for caracter  in texto:\n        # Solo considerar letras del alfabeto\n        if not caracter.isalpha():\n            continue\n\n        # Si el caracter no esta en el diccionario, devuelve 0\n        # Si est√°, devuelve su conteo.\n        # En ambos casos, le suma 1.\n        caracteres[caracter] = caracteres.get(caracter, 0) + 1\n\n    return caracteres\n\ncontar_caracteres(\"Ahora es mejor que nunca\")\ncontar_caracteres(\"Ahora es mejor que nunca!!   +_\")\ncontar_caracteres(\"Ahora es mejor que nunca!!   +_\") == contar_caracteres(\"Ahora es mejor que nunca\")",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci√≥n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#validador-de-contrase√±as",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#validador-de-contrase√±as",
    "title": "U1 - Programaci√≥n en Python",
    "section": "15 Validador de contrase√±as üò±",
    "text": "15 Validador de contrase√±as üò±\nCARACTERES_ESPECIALES = \"@#$%^&*()\"\n\ndef contiene_letra(texto):\n    # True si al menos un caracter es una letra\n    for caracter in texto:\n        if caracter.isalpha():\n            return True\n    return False\n\n\ndef contiene_numero(texto):\n    # True si al menos un caracter es un numero (del sistema decimal)\n    for caracter in texto:\n        if caracter.isdecimal():\n            return True\n    return False\n\n\ndef contiene_especial(texto):\n    # True si al menos un caracter es un numero\n    for caracter in texto:\n        if caracter in CARACTERES_ESPECIALES:\n            return True\n    return False\n\ndef validar_pwd(pwd):\n    errores = []\n\n    if not (8 &lt;= len(pwd) &lt;= 24):\n        errores.append(\"Debe tener entre 8 y 24 caracteres.\")\n\n    if not contiene_letra(pwd):\n        errores.append(\"Debe contener al menos una letra.\")\n    if not contiene_numero(pwd):\n        errores.append(\"Debe contener al menos un n√∫mero.\")\n    if not contiene_especial(pwd):\n        errores.append(\"Debe contener al menos un car√°cter especial '@#$%^&*()'.\")\n\n    caracteres_desconocidos = []\n    for caracter in pwd:\n        # Hablar sobre si es posible simplificar esto\n        if (not caracter.isdecimal()) and (not caracter.isalpha()) and (caracter not in CARACTERES_ESPECIALES):\n            caracteres_desconocidos.append(caracter)\n\n    # Equivale a len(caracteres_desconocidos) &gt; 0\n    if caracteres_desconocidos:\n        errores.append(\n            f\"La contrase√±a contiene los siguientes caracteres desconocidos {caracteres_desconocidos}\"\n        )\n\n    if errores == []:\n        return True\n\n    return errores\n\n\nwhile True:\n    password = input(\"Ingrese una contrase√±a (o ENTER para salir): \")\n    if password == \"\":\n        print(\"Operaci√≥n cancelada.\")\n        break\n\n    resultado = validar_pwd(password)\n\n    # Ac√° NO se puede usar 'if es_valida'.\n    if resultado is True:\n        print(\"Contrase√±a v√°lida.\")\n        break\n\n    print(\"La contrase√±a no es v√°lida:\")\n    for error in resultado:\n        print(\"-\", error)",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci√≥n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#conteo-de-caracteres-ii",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#conteo-de-caracteres-ii",
    "title": "U1 - Programaci√≥n en Python",
    "section": "16 Conteo de caracteres II üò±",
    "text": "16 Conteo de caracteres II üò±\ndef contar_caracteres(texto, orden=\"aparicion\"):\n    texto = texto.lower() # Pasa a minuscula al principio\n    caracteres = {}\n    for caracter  in texto:\n        # Solo considerar letras del alfabeto\n        if not caracter.isalpha():\n            continue\n\n        # Si el caracter no esta en el diccionario, devuelve 0\n        # Si est√°, devuelve su conteo.\n        # En ambos casos, le suma 1.\n        caracteres[caracter] = caracteres.get(caracter, 0) + 1\n\n    if orden == \"aparicion\":\n        salida = caracteres\n    elif orden == \"alfabetico\":\n        salida = {}\n        claves = sorted(caracteres.keys()) # No hace falta el .keys() en realidad\n        for clave in claves:\n            salida[clave] = caracteres[clave]\n    elif orden == \"frecuencia\":\n        salida = {}\n        claves = list(caracteres.keys()) # No hace falta el .keys() en realidad\n        claves_ordenadas = sorted(claves, key=lambda k: caracteres[k], reverse=True)\n        for clave in claves_ordenadas:\n            salida[clave] = caracteres[clave]\n\n    return salida\n\ncontar_caracteres(\"Ahora es mejor que nunca\", \"aparicion\")\ncontar_caracteres(\"Ahora es mejor que nunca\", \"alfabetico\")\ncontar_caracteres(\"Ahora es mejor que nunca\", \"frecuencia\")",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci√≥n en Python"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html",
    "href": "practica/02_programacion_funcional/ejercicios.html",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "",
    "text": "Debajo se muestra un listado de funciones impuras. Analice por qu√© son impuras e implemente alternativas puras (manteniendo su l√≥gica):\nFunci√≥n 1\ncontador = 0\ndef incrementar():\n1    global contador\n    contador += 1\n    return contador\n\n1\n\nLa palabra global es una keyword que indica que se pretende usar y modificar una variable definida fuera del √°mbito de ejecuci√≥n de la funci√≥n.\n\n\nFunci√≥n 2\ndef obtener_hora_actual():\n    import datetime\n    return datetime.datetime.now().hour\nFunci√≥n 3\ndef add_time(time, hours, minutes, seconds):\n1    increment_time(time, hours, minutes, seconds)\n    return time\n\n1\n\nAsuma que esta funci√≥n incrementa a time, que es un objeto datetime, en hours horas, minutes minutos y seconds segundos.\n\n\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nRepresente fechas y horas con el objeto objeto datetime del m√≥dulo est√°ndar datetime. Adem√°s, considere el objeto timedelta del mismo m√≥dulo para luego calcular diferencias. Por ejemplo:\nimport datetime\n\nahora = datetime.datetime.now() # Devuelve un objeto con la fecha y la hora actual\nprint(ahora)\n\nuna_hora_mas_tarde = datetime.timedelta(hours=1, minutes=0, seconds=0)\nprint(ahora + una_hora_mas_tarde)\n2025-08-31 09:48:58.327461\n2025-08-31 10:48:58.327461\n\n\n\nFunci√≥n 4\nhistorial_de_nombres = []\ndef registrar_nombre(nombre):\n    historial_de_nombres.append(nombre)\n    return f\"'{nombre}' ha sido registrado en el historial.\"\nFunci√≥n 5\nLIMITE_MAXIMO = 100\ndef verificar_limite(valor):\n    if valor &gt; LIMITE_MAXIMO:\n        return \"Excede el l√≠mite\"\n    return \"Dentro del l√≠mite\"",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#trasfromando-funciones",
    "href": "practica/02_programacion_funcional/ejercicios.html#trasfromando-funciones",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "",
    "text": "Debajo se muestra un listado de funciones impuras. Analice por qu√© son impuras e implemente alternativas puras (manteniendo su l√≥gica):\nFunci√≥n 1\ncontador = 0\ndef incrementar():\n1    global contador\n    contador += 1\n    return contador\n\n1\n\nLa palabra global es una keyword que indica que se pretende usar y modificar una variable definida fuera del √°mbito de ejecuci√≥n de la funci√≥n.\n\n\nFunci√≥n 2\ndef obtener_hora_actual():\n    import datetime\n    return datetime.datetime.now().hour\nFunci√≥n 3\ndef add_time(time, hours, minutes, seconds):\n1    increment_time(time, hours, minutes, seconds)\n    return time\n\n1\n\nAsuma que esta funci√≥n incrementa a time, que es un objeto datetime, en hours horas, minutes minutos y seconds segundos.\n\n\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nRepresente fechas y horas con el objeto objeto datetime del m√≥dulo est√°ndar datetime. Adem√°s, considere el objeto timedelta del mismo m√≥dulo para luego calcular diferencias. Por ejemplo:\nimport datetime\n\nahora = datetime.datetime.now() # Devuelve un objeto con la fecha y la hora actual\nprint(ahora)\n\nuna_hora_mas_tarde = datetime.timedelta(hours=1, minutes=0, seconds=0)\nprint(ahora + una_hora_mas_tarde)\n2025-08-31 09:48:58.327461\n2025-08-31 10:48:58.327461\n\n\n\nFunci√≥n 4\nhistorial_de_nombres = []\ndef registrar_nombre(nombre):\n    historial_de_nombres.append(nombre)\n    return f\"'{nombre}' ha sido registrado en el historial.\"\nFunci√≥n 5\nLIMITE_MAXIMO = 100\ndef verificar_limite(valor):\n    if valor &gt; LIMITE_MAXIMO:\n        return \"Excede el l√≠mite\"\n    return \"Dentro del l√≠mite\"",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#f√°brica-de-promociones",
    "href": "practica/02_programacion_funcional/ejercicios.html#f√°brica-de-promociones",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "2 F√°brica de promociones",
    "text": "2 F√°brica de promociones\nConsidere el ejercicio Promociones de la Pr√°ctica 1. Utilizando el mismo sistema de descuentos cree la funci√≥n crear_promocion que reciba como argumento el medio de pago y devuelva una funci√≥n que al aplicarse sobre un n√∫mero aplique el descuento (o recargo) que le corresponde a ese medio de pago. Por ejemplo:\npromo_debito = crear_promocion(\"d√©bito\")\nprint(promo_debito(1000))\nprint(promo_debito(2700))\n900\n2430.0\nLuego, cree la funci√≥n crear_promocion_personalizada que recibe el medio de pago y, de manera opcional, el porcentaje de descuento a aplicar. Como resultado devuelve una funci√≥n que al aplicarse sobre un n√∫mero impacta el descuento o recargo correspondiente. Adem√°s, considere que:\n\nSi no se pasa el porcentaje a aplicar, se deben usar los descuentos y recargos detallados en el enunciado del ejercicio en la Pr√°ctica 1.\nCaso contrario, la funci√≥n devuelta debe aplicar ese porcentaje personalizado (e.g., crear_promocion_personalizada(\"d√©bito\", 15) para 15% de descuento).\n\nEjemplo de uso:\npromo_debito = crear_promocion_personalizada(\"d√©bito\", 15)\npromo_debito(1000)\n850",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#bendita-media",
    "href": "practica/02_programacion_funcional/ejercicios.html#bendita-media",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "3 Bendita media",
    "text": "3 Bendita media\nEn Python no existe una funci√≥n built-in que calcule la media de una secuencia de n√∫meros. El objetivo de este ejercicio es implementar una funci√≥n mean que funcione tanto cuando se le pasa un iterable, como cuando se le pasa una cantidad arbitraria de n√∫meros.\nEl argumento es un iterable:\nmean([6.27, 8.11, 7.6, 5.2, 4.8])\nSe pasan una cantidad arbitraria de valores num√©ricos:\nmean(7.3, 8.2, 11.0, 12.5)",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#sucesi√≥n-de-fibonacci",
    "href": "practica/02_programacion_funcional/ejercicios.html#sucesi√≥n-de-fibonacci",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "4 Sucesi√≥n de Fibonacci",
    "text": "4 Sucesi√≥n de Fibonacci\nConsidere la sucesi√≥n que comienza por los n√∫meros 0 y 1. Los siguientes n√∫meros se forman sumando los dos anteriores.\n\\[\n\\{\\;0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, \\cdots\\;\\}\n\\]\nEsta sucesi√≥n se conoce como sucesi√≥n de Fibonacci.\nImplemente una funci√≥n recursiva que tome un n√∫mero natural n como entrada y devuelva el n-√©simo n√∫mero en la sucesi√≥n.",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#pal√≠ndromos-recursivos",
    "href": "practica/02_programacion_funcional/ejercicios.html#pal√≠ndromos-recursivos",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "5 Pal√≠ndromos recursivos",
    "text": "5 Pal√≠ndromos recursivos\nUn pal√≠ndromo es una palabra, frase, n√∫mero o secuencia que se lee igual de izquierda a derecha que de derecha a izquierda. En Argentina, a un n√∫mero de este tipo le decimos le decimos capic√∫a.\nPara comprobar en Python si una cadena es pal√≠ndroma, puede compararse con su versi√≥n invertida, que se construye mediante un slice con paso -1:\nc = \"anilina\"\nc == c[::-1]\nTrue\nTambi√©n podr√≠aimos determinar si una cadena es un pal√≠ndromo de manera recursiva comparando el primer y el √∫ltimo car√°cter:\n\nSi la cadena tiene longitud 0 o 1, se devuelve True.\nSi el primer y el √∫ltimo car√°cter son iguales, se llama recursivamente a la funci√≥n pas√°ndole la cadena excluyendo al primer y √∫ltimo caracter ya comparados. Si son distintos, se devuelve False.\n\nEn otras palabras, la funci√≥n recursiva devolver√° True cuando todas las comparaciones por pares resulten verdaderas y se alcance el caso base: queda un √∫nico car√°cter (longitud impar) o ninguno (longitud par).\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara seleccionar todos los caracteres de una cadena, exceptuando al primero y el √∫ltimo, se puede usar\n\"radar\"[1:-1]\n\"ada\"\n\n\n\n\nPunto extra\nAdapte la funci√≥n para que no considere espacios ni distinga may√∫sculas de min√∫sculas. De este modo, deber√≠a detectar que la siguiente frase es pal√≠ndroma.\npalindromo(\"Anita lava la tina\") # True",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#√°rea-de-aprendizaje",
    "href": "practica/02_programacion_funcional/ejercicios.html#√°rea-de-aprendizaje",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "6 √Årea de aprendizaje",
    "text": "6 √Årea de aprendizaje\nSe cuenta con una lista de tuplas de longitud 2, representando el ancho y alto de distintos rect√°ngulos.\nrectangulos = [\n    (5, 8),\n    (2, 2),\n    (9, 2),\n    (3, 3),\n    (3, 7),\n    (6, 3)\n]\nCree una nueva lista que ordene dichos rect√°ngulos en funci√≥n de su √°rea utilizando la funci√≥n sorted.",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#socios-ordenados",
    "href": "practica/02_programacion_funcional/ejercicios.html#socios-ordenados",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "7 Socios ordenados",
    "text": "7 Socios ordenados\nSe cuenta con la siguiente lista de diccionarios, la cual contiene datos personales sobre miembros de un club de atletismo:\ndatos_socios = [\n    {\"nombre\": \"Bautista Carrara\", \"edad\": 22, \"altura_cm\": 178, \"record_100m\": 13.4},\n    {\"nombre\": \"Valentina Lucci\",  \"edad\": 23, \"altura_cm\": 163, \"record_100m\": 14.2},\n    {\"nombre\": \"Ger√≥nimo Cuesta\",  \"edad\": 26, \"altura_cm\": 170, \"record_100m\": 14.0},\n    {\"nombre\": \"Lucio Borga\",      \"edad\": 28, \"altura_cm\": 186, \"record_100m\": 13.8},\n    {\"nombre\": \"Julia Spoglia\",    \"edad\": 21, \"altura_cm\": 163, \"record_100m\": 11.9},\n    {\"nombre\": \"Soledad Colombo\",  \"edad\": 22, \"altura_cm\": 170, \"record_100m\": 13.5}\n]\nOrdene la lista en base a los r√©cords en la carrera de 100 metros, en forma ascendente.\n\nPunto extra\nImplemente una funci√≥n que tome como argumento una clave de diccionario y devuelva una lista ordenada por los valores de dicha clave. Si el argumento toma el valor \"nombre\", ordene los elementos alfab√©ticamente en base a los apellidos.",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#listado-de-rimas",
    "href": "practica/02_programacion_funcional/ejercicios.html#listado-de-rimas",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "8 Listado de rimas",
    "text": "8 Listado de rimas\nSe tiene la siguiente lista de palabras, la cual se quiere utilizar para formar rimas:\npalabras_a_rimar = [\n    \"actividad\",\n    \"bendici√≥n\",\n    \"cartelera\",\n    \"ciudad\",\n    \"escalera\",\n    \"estaci√≥n\",\n    \"felicidad\",\n    \"funci√≥n\",\n    \"reposera\"\n]\nOrdene la lista en base al orden alfab√©tico del reverso de cada palabra, de modo que las palabras que riman se encuentren juntas.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nSi la lista fuese [\"durazno\", \"kiwi\"], el resultado ser√≠a [\"kiwi\", \"durazno\"], porque \"iwik\" precede a \"onzarud\" en orden alfab√©tico.",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#analistas-de-temperaturas",
    "href": "practica/02_programacion_funcional/ejercicios.html#analistas-de-temperaturas",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "9 Analistas de temperaturas",
    "text": "9 Analistas de temperaturas\nConsidere una lista de temperaturas en grados Celsius sobre la cual se deben aplicar distintas operaciones.\ntemperaturas_celsius = [\n    25.5, 28.0, 19.3, 31.5, 22.8, 17.0, 30.2, 35.6, 14.2,\n    32.4, 22.7, 10.1, 29.5, 33.9, 22.1, 38.9, 18.4, 16.3\n]\n\nEnfoque funcional\n\nConvierta las temperaturas a grados Fahrenheit utilizando map y almacene el resultado en una lista llamada temperaturas_f. Use la f√≥rmula de conversi√≥n: \\[\nF = C \\times \\frac{9}{5} + 32\n\\]\nUtilice filter para seleccionar de la lista anterior las temperaturas que sean mayores a 80¬∞F. Guarde el resultado en una nueva lista. ¬øSe le ocurre una alternativa que no utilice la lista creada en el primer punto?\n\n\n\nEnfoque idiom√°tico\n\nUtilice una list comprehension para obtener una lista de temperaturas en grados Fahrenheit solo cuando para temperaturas mayores a 22 ¬∞C.",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#el-tiempo-vuela",
    "href": "practica/02_programacion_funcional/ejercicios.html#el-tiempo-vuela",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "10 El tiempo vuela",
    "text": "10 El tiempo vuela\nSe quiere medir el tiempo que tarda la computadora en ejecutar distintos bloques de c√≥digo. Para eso, implemente una funci√≥n crear_cronometro que fabrique una funci√≥n cronometro, la cual devuelve el tiempo transcurrido entre su creaci√≥n y la llamada a la funci√≥n. Luego, utilice dos cron√≥metros en paralelo para evaluar el siguiente c√≥digo:\ncronometro1 = crear_cronometro()\n\nfor i in range(10**4):\n    i ** 2 # Calcula el cuadrado de un n√∫mero pero no lo devuelve\n\nprint(f\"El bloque entero tard√≥ {cronometro1()} segundos en ejecutarse.\")\n\ncronometro2 = crear_cronometro()\n\nfor j in range(10**6):\n    j // 2 # Calcula la divisi√≥n entera por 2 pero no la devuelve\n\nprint(f\"El segundo bucle tard√≥ {cronometro2()} segundos en ejecutarse.\")\n\nPunto extra\nModifique el funcionamiento del cron√≥metro para que en cada llamada devuelva el tiempo transcurrido entre la llamada actual y la inmediata anterior (excepto en la primera llamada, que devuelve el tiempo transcurrido desde su creaci√≥n).\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara medir el paso del tiempo en Python podemos usar la funci√≥n time del m√≥dulo hom√≥nimo.\nfrom time import time, sleep\n\ninicio = time()\nsleep(2) # Detiene la ejecuci√≥n por 2 segundos\nprint(time() - inicio) # ~ 2 (segundos)",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#no-perdamos-el-centro",
    "href": "practica/02_programacion_funcional/ejercicios.html#no-perdamos-el-centro",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "11 No perdamos el centro",
    "text": "11 No perdamos el centro\nSuponga el siguiente listado de n√∫meros, que contiene algunos None:\nnumeros = [\n    2.05, 1.09, None, 2.31, 2.28, 0.97, 2.59, 2.72, 0.76, None, 1.88, 2.04, 3.25, 1.88, None\n]\nCalcule la media de los numeros, sin considerar los nulos. Luego, utilizando una list comprehension, obtenga una nueva lista de los valores centrados, conservando los None en las posiciones originales.",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#en-python-es-mejor",
    "href": "practica/02_programacion_funcional/ejercicios.html#en-python-es-mejor",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "12 En Python es mejor",
    "text": "12 En Python es mejor\nConsidere el siguiente programa, que selecciona valores at√≠picos de un listado:\nnumeros = [\n    4.74346239e-01, -2.90877176e-01, -1.44377789e+00, -4.48680759e+01,\n    -1.21249801e+00, -3.32729317e-01,  2.21676912e-01,  1.05599711e+00,\n    -3.62372053e+00, -2.96441579e-01, -4.28304222e+00,  1.55908820e+02,\n    9.00858234e-01, -1.09384173e+00, -1.51083571e+00, -5.38491167e-01,\n    -3.84153084e-02,  1.20393395e+00,  1.82651406e-01,  2.05179405e+00\n]\n\ndef media(x):\n    return sum(x) / len(x)\n\ndef varianza(x):\n    numerador = 0\n    x_media = media(x)\n    for x_i in x:\n        numerador += (x_i - x_media) ** 2\n    return numerador / len(x)\n\nx_media = media(numeros)\nx_desvio = varianza(numeros) ** 0.5\n\nmap_obj = map(lambda x: (x - x_media) / x_desvio, numeros)\nlist(filter(lambda x: abs(x) &gt; 3, map_obj))\nImplemente un programa equivalente haciendo uso de una list comprehension, en vez de map y filter.",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#subiendo-de-rango",
    "href": "practica/02_programacion_funcional/ejercicios.html#subiendo-de-rango",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "13 Subiendo de rango",
    "text": "13 Subiendo de rango\nLa funci√≥n range(start, stop, step) de Python devuelve un objeto que genera una secuencia de n√∫meros desde start (inclusive) hasta stop (exclusive) en incrementos de step unidades. El argumento step, sin embargo, s√≥lo puede ser un n√∫mero entero (excepto cero). Implemente una funci√≥n llamada frange que acepte los mismos argumentos, pudiendo step ser de tipo float. La funci√≥n debe retornar un generador de la secuencia correspondiente.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nUtilice el siguiente ejemplo a modo de control:\nfor i in frange(3, 4, 0.2):\n    print(f\"{i:.2f}\")\n3.00\n3.20\n3.40\n3.60\n3.80\nTenga en cuenta que la precisi√≥n finita de las computadoras puede afectar el comportamiento de su generador.",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#la-cajita-musical",
    "href": "practica/02_programacion_funcional/ejercicios.html#la-cajita-musical",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "14 La cajita musical",
    "text": "14 La cajita musical\nTenemos una caja musical que recita los siguientes versos:\nversos = [\n    \"Tengo que confesar que a veces no me gusta tu forma de ser\",\n    \"Luego te me desapareces y no entiendo muy bien por qu√©\",\n\n    \"No dices nada rom√°ntico cuando llega el atardecer\",\n    \"Te pones de un humor extra√±o con cada luna llena al mes\",\n\n    \"Pero a todo lo dem√°s le gana lo bueno que me das\",\n    \"S√≥lo tenerte cerca, siento que vuelvo a empezar\"\n]\nImplemente una funci√≥n para darle cuerda a la caja musical. En cada llamada debe devolver un verso distinto, hasta agotarlos todos.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nMediante el uso de yield se puede lograr que una funci√≥n se detenga en un punto intermedio y retome desde ese punto en la siguiente llamada.\ndef mostrar_fase():\n    print(\"Inicio\")\n    yield\n    print(\"Medio\")\n    yield\n    print(\"Desenlace\")\n    yield",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#el-mejor-precio",
    "href": "practica/02_programacion_funcional/ejercicios.html#el-mejor-precio",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "15 El mejor precio",
    "text": "15 El mejor precio\nUn supermercado ofrece m√∫ltiples promociones:\n\n15% de descuento los d√≠as lunes y mi√©rcoles.\n10% de descuento en compras con monto superior a $50.000.\n20% de descuento a clientes mayores de 65 a√±os.\n\nPara determinar la promoci√≥n a aplicar, el supermercado utiliza un programa con la siguiente estructura:\ndef promo_dia_semana(compra):\n    \"\"\"Aplica un 15% de descuento si la compra se realiza un lunes o mi√©rcoles.\"\"\"\n    return None # hay que implementar esta funci√≥n\n\ndef promo_monto_grande(compra):\n    \"\"\"Aplica un 10% de descuento si la compra tiene un monto superior a $50.000.\"\"\"\n    return None # hay que implementar esta funci√≥n\n\ndef promo_edad(compra):\n    \"\"\"Aplica un 20% de descuento si el cliente tiene 65 a√±os o m√°s.\"\"\"\n    return None # hay que implementar esta funci√≥n\n\npromos = [promo_dia_semana, promo_monto_grande, promo_edad]\n\ndef mejor_promo(compra):\n    \"\"\"Construye diccionario con el monto luego de aplicar la mejor promoci√≥n.\n\n    Esta funci√≥n devuelve un diccionario con el monto original, el monto final, y el descuento\n    aplicado.\n    \"\"\"\n    # Obtener el multiplicador del mayor descuento\n    multiplicador = sorted([promo(compra) for promo in promos])[0]\n\n    return {\n        \"monto_original\": compra[\"monto\"],\n        \"monto_final\": compra[\"monto\"] * multiplicador,\n        \"descuento\": f\"{round((1 - multiplicador) * 100)}%\"\n    }\n\nejemplo_compra = {\"dia\": \"mi√©rcoles\", \"edad_cliente\": 42, \"monto\": 66420}\nmejor_promo(ejemplo_compra)\n# {'monto_original': 66420, 'monto_final': 56457.0, 'descuento': '15%'}\nEl problema con esta implementaci√≥n es que, cada vez que se a√±ade o elimina una promoci√≥n, el cambio debe llevarse a cabo tanto en la funci√≥n de la promoci√≥n como en la lista de promociones. Para evitar el trabajo duplicado, implemente los siguientes cambios:\n\nDefina primero la lista promos, la cual comienza estando vac√≠a.\nDefina un decorador promo que a√±ade una funci√≥n a la lista promos antes de ejecutarla.\nImplemente las tres funciones de promoci√≥n y dec√≥relas con el decorador del paso anterior.",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#bromas-pesadas",
    "href": "practica/02_programacion_funcional/ejercicios.html#bromas-pesadas",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "16 Bromas pesadas üò±",
    "text": "16 Bromas pesadas üò±\nNuestro amigo programador est√° armando una p√°gina web, con una funci√≥n que saluda a los nuevos usuarios por su nombre cuando se registran. Nosotros queremos gastarle una broma a nuestro amigo, metiendo en su c√≥digo un decorador que haga que su funci√≥n corra normalmente excepto cada n-√©sima corrida, fallando silenciosamente (no imprime nada). El valor n es un n√∫mero entero de nuestra elecci√≥n.\n@romper_cada(3)\ndef saludar(nombre):\n  print(f\"¬°Hola, {nombre}!\")\n\nsaludar(\"Carlos\")     # \"¬°Hola, Carlos!\"\nsaludar(\"Mar√≠a Luz\")  # \"¬°Hola, Mar√≠a Luz!\"\nsaludar(\"Mirna\")      # Nada (la funci√≥n devuelve None)\nsaludar(\"Diego\")      # \"¬°Hola, Diego!\"\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara crear un decorador que reciba argumentos, podemos crear una f√°brica de decoradores:\ndef mi_decorador(n):\n    def decorar(funcion):\n        print(f\"Ejecutando decorador con argumento {n}\")\n        return funcion\n    return decorar\n\n@mi_decorador(7)\ndef imprimir(mensaje):\n    print(mensaje)\n\nimprimir(\"Hola mundo\")\n# &gt; Ejecutando decorador con argumento 7\n# &gt; Hola mundo",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#pipelines-de-procesamiento",
    "href": "practica/02_programacion_funcional/ejercicios.html#pipelines-de-procesamiento",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "17 Pipelines de procesamiento üò±",
    "text": "17 Pipelines de procesamiento üò±\nEste ejercicio tiene como objetivo implementar un sistema de preprocesamiento para una lista de diccionarios, donde cada diccionario representa una fila con sus columnas como pares clave‚Äìvalor. Un conjunto de datos de ejemplo es el siguiente:\ndatos = [\n    {\"edad\": 20, \"ingresos\": 2000},\n    {\"edad\": 30, \"ingresos\": 3000},\n    {\"edad\": None, \"ingresos\": 2500},\n    {\"edad\": 40, \"ingresos\": None},\n    {\"edad\": 25, \"ingresos\": 4000},\n]\nEl primer paso consiste en definir tres funciones:\n\neliminar_nulos: elimina las filas con al menos un valor None.\ncalcular_log: que calcula el logaritmo en base 10 para los valores de la variable indicada.\nfiltrar: recibe el listado, el nombre de una columna y una funci√≥n booleana que se aplica para determinar que registros se conservan.\n\nQue deben funcionar como se muestra en los ejemplos:\neliminar_nulos(datos)\n[\n    {\"edad\": 20, \"ingresos\": 2000},\n    {\"edad\": 30, \"ingresos\": 3000},\n    {\"edad\": 25, \"ingresos\": 4000},\n]\ncalcular_log(datos, \"ingresos\")\n[\n    {\"edad\": 20, \"ingresos\": 3.301},\n    {\"edad\": 30, \"ingresos\": 3.477},\n    {\"edad\": None, \"ingresos\": 3.397},\n    {\"edad\": 40, \"ingresos\": None},\n    {\"edad\": 25, \"ingresos\": 3.602},\n]\nfiltrar(datos, \"edad\", lambda e: e &gt; 25)\n[\n    {\"edad\": 30, \"ingresos\": 3000},\n    {\"edad\": 40, \"ingresos\": None},\n]\nEn el segundo paso, se debe implementar una funci√≥n crear_pipeline, que recibe una cantidad arbitraria de funciones de procesamiento, junto a sus argumentos, y debe devolver una funci√≥n que, al pasarle un listado de datos, los aplica de manera secuencial y devuelve un conjunto de datos procesado. Por ejemplo:\npipeline = crear_pipeline(\n    {\"fun\": eliminar_nulos, \"kwargs\": {}},\n    {\"fun\": calcular_log, \"kwargs\": {\"var_name\": \"ingresos\"}},\n    {\"fun\": filtrar, \"kwargs\": {\"var_name\": edad, \"key\": lambda e: e &gt; 25}}\n)\npipeline(datos)\n[{\"edad\": 30, \"ingresos\": 3.477}]",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#espacio-o-tiempo",
    "href": "practica/02_programacion_funcional/ejercicios.html#espacio-o-tiempo",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "18 ¬øEspacio o tiempo? ‚è≥",
    "text": "18 ¬øEspacio o tiempo? ‚è≥\nSuponga que trabaja en el equipo de an√°lisis de datos de un e-commerce y suponga que recibe un listado ventas del √∫ltimo mes. Deber√° extraer informaci√≥n clave de esos datos utilizando dos maneras distintas de resolver cada tarea.\n1. Preparaci√≥n de los datos\nPara empezar, use la siguiente funci√≥n que genera datos de ejemplo de ventas de distinto tama√±o:\nimport random\n\nCATEGORIAS = (\"electr√≥nica\", \"hogar\", \"accesorios\", \"deportes\")\n\ndef generar_ventas(n=100_000, seed=None):\n    \"\"\"Generar datos de ventas.\n\n    Parameters\n    ----------\n    n : int\n        Cantidad de ventas a simular.\n    seed : int, optional\n        Semilla para el generador de n√∫meros aleatorios. Por defecto, `None`.\n\n    Returns\n    -------\n    list[dict]\n        Listado de ventas.\n        Cada venta es un diccionario con claves `\"id\"`, `\"precio\"` y `\"categoria\"`.\n    \"\"\"\n    rng = random.Random(seed)\n    ventas = []\n    for i in range(1, n + 1):\n        ventas.append(\n            {\n                \"id\": f\"P{i+1:06d}\",\n                \"precio\": round(rng.uniform(5.0, 500.0), 2),\n                \"categoria\": CATEGORIAS[i % len(CATEGORIAS)],\n            }\n        )\n    return ventas\nGenere un conjunto de datos con 100,000 ventas:\nventas = generar_ventas(n=100_000, seed=1234)\n2. Implementaci√≥n de operaciones\nRealice dos operaciones sobre este conjunto de datos, cada una en dos variantes.\n\nCalcular precios con IVA (21%):\n\nVersi√≥n A. Use una list comprehension para crear una nueva lista llamada precios_con_iva_1 que contenga todos los precios con el 21 % de IVA ya calculado.\nVersi√≥n B. Use una expresi√≥n generadora para crear un objeto precios_con_iva_2 que represente la operaci√≥n, pero sin calcular ni almacenar los resultados todav√≠a.\n\nFiltrar ventas de ‚Äúelectr√≥nica‚Äù:\n\nVersi√≥n A. Use una list comprehension para crear una nueva lista llamada electronica_1 que contenga todas las ventas de la categor√≠a ‚Äúelectr√≥nica‚Äù.\nVersi√≥n B. Use una expresi√≥n generadora para crear un objeto electronica_2 que represente el filtro, sin materializar la lista.\n\n\n3. An√°lisis y comparaci√≥n\n\nCalcule el total de las ventas de electr√≥nica usando sum() en ambas variantes (electronica_1 y electronica_2).\nPara cada operaci√≥n, antes y despu√©s de aplicar sum(), mida el tiempo de ejecuci√≥n y el uso de memoria del objeto. Para el tiempo, podr√≠a usar time.time() del m√≥dulo time; para la memoria, sys.getsizeof() del m√≥dulo sys. Registre los resultados (si no observa diferencias claras, duplique n al generar el dataset).\n\n4. Reutilizaci√≥n del objeto\n\nIntente calcular el total de ventas de electr√≥nica una segunda vez para ambos objetos (electronica_1 y electronica_2).\nObserve qu√© sucede en cada caso. ¬øQu√© objeto puede volver a usarse y cu√°l no?\n\n5. Preguntas para reflexi√≥n\n\n¬øQu√© diferencias fundamentales encontr√≥ entre las dos maneras de procesar los datos? Considere cu√°ndo se realiza la operaci√≥n, el uso de memoria y el tiempo de ejecuci√≥n.\n¬øQu√© ocurri√≥ cuando intent√≥ recorrer o usar el mismo resultado dos veces?\n¬øSe comportaron de la misma manera la lista generada y el objeto generador? ¬øPor qu√© cree que sucede esto?\n¬øEn qu√© situaciones elegir√≠a un enfoque u otro? D√© un ejemplo de un escenario donde la ejecuci√≥n A sea mejor y otro donde la B resulte m√°s eficiente.",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/autoevaluacion.html",
    "href": "practica/02_programacion_funcional/autoevaluacion.html",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "",
    "text": "¬øPor qu√© decimos que fun es una funci√≥n con efectos secundarios?\ndef fun():\n    global x\n    x = 10\n    return x\n¬øCu√°l es el problema con la siguiente funci√≥n? Explore el resultado de las llamadas que se incluyen luego de la definici√≥n.\ndef agregar_usuario(usuario, listado=[]):\n    listado.append(usuario)\n    return listado\n\nbase1 = agregar_usuario(\"Adri√°n\")\nbase2 = agregar_usuario(\"Daniela\")\nExplore el contenido y la identidad de base1 y base2. Si es necesario, utilice alg√∫n agente de IA para explorar en qu√© parte de la definici√≥n de la funci√≥n se esconde una trampa.\n\n\n\n\n\n¬øPor qu√© la siguiente definici√≥n devuelve un error?\nlambda x: return x + 1\n¬øQu√© hacen los siguientes bloques de c√≥digo?\n(lambda x, y: x + y)(1, 5)\n(lambda f, x: f(x + 10))(lambda y: y * 5, 2)\n¬øQu√© devuelve la siguiente llamada? ¬øPor qu√©?\n(lambda x: print(x))(1)\nAyuda: asigne el resultado a una variable y explore el valor de esa variable.\n\n\n\n\n\n¬øCu√°l es el valor de args en la siguiente llamada? ¬øPor qu√©?\n def fun(x, *args):\n     return x + 10\n\n fun(128)\n¬øY el valor de kwargs debajo?\ndef fun(x, **kwargs):\n    return x + 11\n\nfun(128)\nLos siguientes intentos por definir una funci√≥n arrojan un error. Investigue por qu√© y reflexione sobre el sentido de los errores.\ndef fun(**kwargs, x, y):\n    return x + y\ndef fun(**kwargs, *args):\n    return sum(args)\nCualquier llamada a la siguiente funci√≥n que solo pase argumentos posicionales va a resultar en un error. ¬øPor qu√©? ¬øC√≥mo habr√≠a que llamarla para que no resulte en un error?\ndef fun(*args, x, y):\n    return sum(args), x + y\n\n\n\n\n\nEjecute el siguiente bloque de c√≥digo e inspeccione el objeto que devuelven las sucesivas llamadas realizadas. Analice por qu√© ocurre este comportamiento y piense qu√© tipo de funcionalidades podr√≠an aprovechar un mecanismo similar.\ndef fabrica():\n    cosas = []\n    def fun(elemento):\n        cosas.append(elemento)\n        return cosas\n    return fun\n\nf = fabrica()\nf(128)\nf(256)\nf(1024)\nAyuda: Compare el ID de los objetos devueltos en cada llamada. ¬øPodr√≠a observar el mismo comportamiento si en vez de usar una lista para cosas se usara una tupla?",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/autoevaluacion.html#funciones",
    "href": "practica/02_programacion_funcional/autoevaluacion.html#funciones",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "",
    "text": "¬øPor qu√© decimos que fun es una funci√≥n con efectos secundarios?\ndef fun():\n    global x\n    x = 10\n    return x\n¬øCu√°l es el problema con la siguiente funci√≥n? Explore el resultado de las llamadas que se incluyen luego de la definici√≥n.\ndef agregar_usuario(usuario, listado=[]):\n    listado.append(usuario)\n    return listado\n\nbase1 = agregar_usuario(\"Adri√°n\")\nbase2 = agregar_usuario(\"Daniela\")\nExplore el contenido y la identidad de base1 y base2. Si es necesario, utilice alg√∫n agente de IA para explorar en qu√© parte de la definici√≥n de la funci√≥n se esconde una trampa.\n\n\n\n\n\n¬øPor qu√© la siguiente definici√≥n devuelve un error?\nlambda x: return x + 1\n¬øQu√© hacen los siguientes bloques de c√≥digo?\n(lambda x, y: x + y)(1, 5)\n(lambda f, x: f(x + 10))(lambda y: y * 5, 2)\n¬øQu√© devuelve la siguiente llamada? ¬øPor qu√©?\n(lambda x: print(x))(1)\nAyuda: asigne el resultado a una variable y explore el valor de esa variable.\n\n\n\n\n\n¬øCu√°l es el valor de args en la siguiente llamada? ¬øPor qu√©?\n def fun(x, *args):\n     return x + 10\n\n fun(128)\n¬øY el valor de kwargs debajo?\ndef fun(x, **kwargs):\n    return x + 11\n\nfun(128)\nLos siguientes intentos por definir una funci√≥n arrojan un error. Investigue por qu√© y reflexione sobre el sentido de los errores.\ndef fun(**kwargs, x, y):\n    return x + y\ndef fun(**kwargs, *args):\n    return sum(args)\nCualquier llamada a la siguiente funci√≥n que solo pase argumentos posicionales va a resultar en un error. ¬øPor qu√©? ¬øC√≥mo habr√≠a que llamarla para que no resulte en un error?\ndef fun(*args, x, y):\n    return sum(args), x + y\n\n\n\n\n\nEjecute el siguiente bloque de c√≥digo e inspeccione el objeto que devuelven las sucesivas llamadas realizadas. Analice por qu√© ocurre este comportamiento y piense qu√© tipo de funcionalidades podr√≠an aprovechar un mecanismo similar.\ndef fabrica():\n    cosas = []\n    def fun(elemento):\n        cosas.append(elemento)\n        return cosas\n    return fun\n\nf = fabrica()\nf(128)\nf(256)\nf(1024)\nAyuda: Compare el ID de los objetos devueltos en cada llamada. ¬øPodr√≠a observar el mismo comportamiento si en vez de usar una lista para cosas se usara una tupla?",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/autoevaluacion.html#recursi√≥n",
    "href": "practica/02_programacion_funcional/autoevaluacion.html#recursi√≥n",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "2 Recursi√≥n",
    "text": "2 Recursi√≥n\n\n¬øCu√°l de las siguientes funciones es recursiva?\ndef f(x):\n    return x + 1\n\ndef g(x):\n    return f(x)\n\ndef h(x):\n    return h(x - 1)\n¬øQu√© son el caso base y el caso recursivo?\n¬øPor qu√© toda recursi√≥n necesita un caso base?\n¬øQu√© pasa si una funci√≥n recursiva nunca llega al caso base?\nReflexione sobre ventajas y desventajas de la recursi√≥n.",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/autoevaluacion.html#funciones-de-orden-superior",
    "href": "practica/02_programacion_funcional/autoevaluacion.html#funciones-de-orden-superior",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "3 Funciones de orden superior",
    "text": "3 Funciones de orden superior\n\nExplique por qu√© el primer print muestra 10 y el segundo falla:\nfrom functools import partial\n\ndef suma(x, y):\n    return x + y\n\nsuma2 = partial(suma, 10, 0)\nprint(suma2())\nprint(suma2(10))\n¬øCu√°l de las siguientes funciones es de orden superior?\ndef f(x):\n    return x + 1\n\ndef g(fn, x):\n    return fn(x)\n\ndef h():\n    return f\n¬øCu√°l de las siguientes funciones de Python es de orden superior?\n\nsum\nmax\nmin\nsorted\nprint\nfunctools.partial\n\n¬øQu√© hace la funci√≥n fun? ¬øQu√© condicion debe cumplir f respecto de sus valores de entrada y salida?\ndef fun(f, x):\n    return f(f(x))\n¬øPara qu√© sirve la funci√≥n definida debajo?\ndef fun(f, g):\n    return lambda x: f(g(x))\n¬øQu√© tipo de funci√≥n se necesita pasar a filter?\n¬øCu√°l es el resultado de la √∫ltima l√≠nea de c√≥digo? ¬øPor qu√©?\nfilter_obj = filter(lambda x: x &gt; 2, range(5))\nlist(filter_obj) # Primera conversi√≥n a lista\nlist(filter_obj) # Segunda conversi√≥n a lista\nAyuda: Para comprender lo que sucede en este ejercicio es necesario estar familiarizados con los generadores.\n¬øCu√°l implementaci√≥n es m√°s eficiente desde el punto de vista del consumo de memoria? ¬øPor qu√©?\nimpares = list(filter(lambda x: x % 2, range(1_000)))\nimpares_al_cubo = list(map(lambda x: x ** 3, impares))\nimpares_al_cubo = list(map(lambda x: x ** 3, filter(lambda x: x % 2, range(1_000))))\nAyuda: Nuevamente, es necesario estar familiarizados con los generadores para responder a esta pregunta.\n¬øCu√°l es el resultado de la reducci√≥n debajo? ¬øPor qu√©?\nfrom functools import reduce\nreduce(lambda x, y: x + [y], range(3), [])\nAyuda: reduce ejecuta la funci√≥n que se le pasa solamente 3 veces. Podr√≠a resultar de ayuda enumerar cada una de las llamadas manualmente.",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/autoevaluacion.html#comprehensions",
    "href": "practica/02_programacion_funcional/autoevaluacion.html#comprehensions",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "4 Comprehensions",
    "text": "4 Comprehensions\n\n¬øQu√© diferencia hay entre las siguientes dos l√≠neas de c√≥digo? Asuma que f es una funci√≥n y xs es una secuencia.\nmap(f, xs)\n[f(x) for x in xs]\n¬øCu√°l es el resultado de esta expresi√≥n?\n[x for x in \"hola\" if x != \"o\"]\nEscriba una list comprehension para obtener una lista con la primera letra de cada palabra.\npalabras = [\"hola\", \"mundo\", \"python\"]\nEscriba una list comprehension que reemplace los None por un -1.\ndatos = [1, None, 3, None, 5]\nConvierta este bucle en una list comprehension.\nresultado = []\nfor x in range(5):\n    if x % 2 != 0:\n        resultado.append(x)\n¬øEs posible que una list comprehension devuelva una lista vac√≠a? ¬øCu√°ndo?\nConstruya una √∫nica list comprehension que realice lo mismo que el siguiente bloque:\ndef f(x):\n    return 10 / x\n\ndef g(x):\n    return x != 0\n\nnumeros = [1, 0, -1, 0, 2, 0, -2, 0, 3, 0, -3]\nlist(map(f, filter(g, numeros)))",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/autoevaluacion.html#generadores",
    "href": "practica/02_programacion_funcional/autoevaluacion.html#generadores",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "5 Generadores",
    "text": "5 Generadores\n\n¬øQu√© diferencia a una funci√≥n regular de una funci√≥n generadora?\n¬øEn qu√© momento se ejecuta el cuerpo de una funci√≥n generadora? ¬øSiempre se ejecuta todo?\n¬øC√≥mo se puede obtener una lista a partir de un generador? ¬øCu√°ntas veces se puede realizar esa operaci√≥n sobre el mismo generador?\n¬øQu√© ventaja tiene un generador frente a una lista?\n¬øQu√© significa que un generador sea perezoso?\n¬øQu√© pasa si se llama a next sobre un generador m√°s veces que la cantidad de yield en √©l?\n¬øQu√© se obtiene en el siguiente bloque de c√≥digo?\ndef f():\n    yield 1\n    yield 2\n\ngen = f()\nprint(list(gen))\n¬øQu√© pasa si se corre next(gen) a continuaci√≥n?\n¬øQu√© se imprime en pantalla?\nprint((x * 2 for x in [1, 2, 3]))\n¬øPor qu√© es posible implementar un bucle infinito dentro de un generador?\n¬øCu√°ntas veces es posible llamar a next sobre el generador g?\ndef fun():\n    yield 1\n    return 2\n    yield 3\n\ng = fun()",
    "crumbs": [
      "Pr√°ctica",
      "U2 - Programaci√≥n funcional",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html",
    "href": "practica/01_programacion_en_python/ejercicios.html",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "",
    "text": "Escriba una funci√≥n en Python que reciba el radio de un c√≠rculo y devuelva su √°rea. Luego, escriba otra funci√≥n que tambi√©n reciba el radio de un c√≠rculo, pero devuelva su per√≠metro. Finalmente, escriba una tercera funci√≥n que reciba el radio de un c√≠rculo y devuelva tanto el √°rea como el per√≠metro.\nUna vez que haya implementado todas las funciones, analice la diferencia entre:\narea, perimetro = calcular_area_y_perimetro(radio=5)\ny\nresultados = calcular_area_y_perimetro(radio=5)\nConsidere el tipo de las variables area, perimetro y resultados.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\n\\[\n\\begin{aligned}\nA &= \\pi \\cdot r^2 \\\\\nP &= 2 \\cdot \\pi \\cdot r\n\\end{aligned}\n\\]",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#√°rea-y-per√≠metro-de-un-c√≠rculo",
    "href": "practica/01_programacion_en_python/ejercicios.html#√°rea-y-per√≠metro-de-un-c√≠rculo",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "",
    "text": "Escriba una funci√≥n en Python que reciba el radio de un c√≠rculo y devuelva su √°rea. Luego, escriba otra funci√≥n que tambi√©n reciba el radio de un c√≠rculo, pero devuelva su per√≠metro. Finalmente, escriba una tercera funci√≥n que reciba el radio de un c√≠rculo y devuelva tanto el √°rea como el per√≠metro.\nUna vez que haya implementado todas las funciones, analice la diferencia entre:\narea, perimetro = calcular_area_y_perimetro(radio=5)\ny\nresultados = calcular_area_y_perimetro(radio=5)\nConsidere el tipo de las variables area, perimetro y resultados.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\n\\[\n\\begin{aligned}\nA &= \\pi \\cdot r^2 \\\\\nP &= 2 \\cdot \\pi \\cdot r\n\\end{aligned}\n\\]",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#promociones",
    "href": "practica/01_programacion_en_python/ejercicios.html#promociones",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "2 Promociones",
    "text": "2 Promociones\nEscriba una funci√≥n llamada calcular_precio que reciba dos argumentos: el monto total de una compra y el medio de pago utilizado.\nEl medio de pago puede ser \"efectivo\", \"d√©bito\" o \"cr√©dito\", y seg√∫n el caso se aplicar√° una modificaci√≥n sobre el monto:\n\nSi el medio de pago es \"efectivo\", el monto no se modifica.\nSi es \"d√©bito\", se aplica un descuento del 10% sobre el monto.\nSi es \"cr√©dito\", se aplica un recargo del 5% sobre el monto.\n\nLa funci√≥n debe retornar el monto final a pagar, con el descuento o recargo aplicado seg√∫n corresponda.\n\nPunto extra\nModifique la funci√≥n de modo tal que no sea necesario especificar el medio de pago. En tal caso, el medio de pago se asume \"efectivo\". Ayuda: asigne un valor por defecto al argumento medio. Considere una implementaci√≥n donde este sea \"efectivo\" y otra donde sea None.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#etapas-de-la-vida",
    "href": "practica/01_programacion_en_python/ejercicios.html#etapas-de-la-vida",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "3 Etapas de la vida",
    "text": "3 Etapas de la vida\nImplemente una funci√≥n que reciba una edad y devuelva un mensaje que indique la etapa de la vida correspondiente.\nUtilice una cadena de condicionales if-elif-else para clasificar la edad en alguno de los siguientes grupos:\n\nMenor a 2 a√±os: beb√©.\nEntre 2 (inclusive) y 4 a√±os: infante.\nEntre 4 (inclusive) y 13 a√±os: ni√±o/a.\nEntre 13 (inclusive) y 20 a√±os: adolescente.\nEntre 20 (inclusive) y 65 a√±os: adulto/a.\n65 a√±os o m√°s: persona mayor.\n\nLa funci√≥n debe imprimir un mensaje del tipo: \"La persona es un/a &lt;etapa&gt;\".",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres",
    "href": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "4 Conteo de caracteres",
    "text": "4 Conteo de caracteres\nEscriba una funci√≥n que reciba una cadena de texto y devuelva un diccionario que indique cu√°ntas veces aparece cada caracter en la cadena. La funci√≥n no debe diferenciar entre may√∫sculas y min√∫sculas y debe ignorar espacios. Utilice el siguiente ejemplo como validaci√≥n:\ncontar_caracteres(\"Ahora es mejor que nunca\")\n# {\"a\": 3, \"h\": 1, \"o\": 2, \"r\": 2, \"e\": 3, \"s\": 1, \"m\": 1, \"j\": 1, \"q\": 1, \"u\": 2, \"n\": 2, \"c\": 1}\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara saltear pasos de un bucle cuando se encuentra un espacio se puede utilizar la sentencia continue.\nfor i in ...:\n    # ... &lt;- Se ejecuta en todas las iteraciones\n    if condicion_de_salto:\n        continue\n    # ... &lt;- Se ejecuta en las iteraciones 'condicion_de_salto' es False",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#orden-de-m√©rito",
    "href": "practica/01_programacion_en_python/ejercicios.html#orden-de-m√©rito",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "5 Orden de m√©rito",
    "text": "5 Orden de m√©rito\nSe cuenta con una lista de tuplas que contienen las notas del examen final de Programaci√≥n 2 para un conjunto de alumnos:\nnotas = [\n    (\"Escalada\", 9),\n    (\"Alonso\", 7),\n    (\"P√©rez\", 8),\n    (\"Castro\", 8),\n    (\"Rossini\", 10),\n    (\"Mart√≠nez\", 9),\n    (\"P√©rez\", 6),\n    (\"Riquelme\", 5),\n]\n\nEscriba un programa que a partir de notas genere un diccionario donde las claves se corresponden con los apellidos y los valores con las notas del examen final.\nEscriba un programa que a partir de notas genere un diccionario donde las claves son las notas y el valor asociado sea una lista con los apellidos de quienes tuvieron esa nota.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#rendimento-acad√©mico",
    "href": "practica/01_programacion_en_python/ejercicios.html#rendimento-acad√©mico",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "6 Rendimento acad√©mico",
    "text": "6 Rendimento acad√©mico\nSe cuenta con el siguiente diccionario que asocia nombres de estudiantes con una lista de sus calificaciones:\nnotas = {\n    \"Ana\": [8, 9, 10],\n    \"Luis\": [6, 7, 8, 3, 9],\n    \"Carla\": [10, 9, 10],\n    \"Marcos\": [5, 6],\n    \"Sof√≠a\": [7, 7, 8],\n    \"Pedro\": [6, 4, 5, 6, 3, 8],\n    \"Luc√≠a\": [9, 8, 10, 9]\n}\nImplemente una funci√≥n que resuma el rendimiento acad√©mico de los estudiantes. La funci√≥n debe recibir el diccionario de notas y un argumento adicional llamado modo. Seg√∫n el valor de modo, se debe devolver un nuevo diccionario con la siguiente informaci√≥n:\n\nSi modo es \"promedio\", se debe devolver el promedio de notas por estudiante.\nSi modo es \"proporcion\", se debe devolver la proporci√≥n de ex√°menes aprobados por estudiante (se considera aprobado todo valor mayor o igual a 6).",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#√≠ndice-de-precios",
    "href": "practica/01_programacion_en_python/ejercicios.html#√≠ndice-de-precios",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "7 √çndice de precios",
    "text": "7 √çndice de precios\nSe cuenta con la serie mensual del √çndice de Precios al Consumidor (IPC) del a√±o 2024:\nipc_2024 = [20.6, 13.2, 11.0, 8.8, 4.2, 4.6, 4.0, 4.2, 3.5, 2.7, 2.4, 2.7]\nRealice los siguientes c√°lculos y an√°lisis:\n\nDetermine el menor y el mayor √≠ndice reportado durante el a√±o.\nCalcule el IPC promedio mensual del 2024.\nEncuentre la diferencia entre el IPC m√≠nimo y m√°ximo del a√±o.\n\n¬øEn qu√© mes se registr√≥ la inflaci√≥n m√°s alta?\n\nCalcule la inflaci√≥n mediana del 2024.\n¬øC√≥mo podr√≠a calcular el rango del IPC (diferencia entre el valor m√°ximo y m√≠nimo) sin usar las funciones min() ni max()?",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#res√∫menes-estad√≠sticos",
    "href": "practica/01_programacion_en_python/ejercicios.html#res√∫menes-estad√≠sticos",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "8 Res√∫menes estad√≠sticos",
    "text": "8 Res√∫menes estad√≠sticos\nCree funciones que, dada una lista de n√∫meros, calculen los siguientes res√∫menes estad√≠sticos:\n\nLa media \\[\n\\text{media}(X) = \\frac{1}{n}\\sum_{i=1}^n{x_i}\n\\]\nEl rango \\[\n\\text{rango}(X) = \\text{max}(X) - \\text{min}(X)\n\\]\nLa varianza \\[\n\\text{var}(X) = \\frac{1}{n}\\sum_{i=1}^n{(x_i - \\bar{x})^2}\n\\]\nEl desv√≠o est√°ndar \\[\n\\text{sd}(X) = \\sqrt{\\text{var}(X)}\n\\]\nLa mediana \\[\n\\begin{array}{lr}\n\\text{mediana}(X) = x_{(\\frac{n + 1}{2})} & \\text{Si } n \\text{ es impar} \\\\\n\\text{mediana}(X) = \\frac{x_{(\\frac{n}{2})} + x_{(\\frac{n}{2}+1)}}{2} & \\text{Si } n \\text{ es par}\n\\end{array}\n\\]\ndonde los \\(x_{(i)}\\) est√°n ordenados de manera ascendente.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#validaci√≥n-de-dni",
    "href": "practica/01_programacion_en_python/ejercicios.html#validaci√≥n-de-dni",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "9 Validaci√≥n de DNI",
    "text": "9 Validaci√≥n de DNI\nCrear una funci√≥n que dada una cadena de caracteres verifique si se corresponde con un DNI.\nSi es un DNI, devolver True. Caso contrario, devolver False.\nA tener en cuenta:\n\nAlgunos ejemplos de DNI v√°lidos\n\n40.094.127\n19053512\n6.392.780\n\nDNI no v√°lidos\n\n40,094,127\n19-053-512\n123456",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#la-f√≠sica-del-rebote",
    "href": "practica/01_programacion_en_python/ejercicios.html#la-f√≠sica-del-rebote",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "10 La f√≠sica del rebote",
    "text": "10 La f√≠sica del rebote\nUna pelota de goma es lanzada desde una altura inicial de 100 metros. Cada vez que toca el suelo, rebota alcanzando una altura equivalente a 3/5 de la altura desde la que cay√≥.\nEscriba un programa que imprima una tabla mostrando las alturas alcanzadas por la pelota en cada uno de sus primeros 10 rebotes.\nLuego, implemente este programa como una funci√≥n que reciba dos par√°metros:\n\nAltura inicial desde la que se lanza la pelota.\nCantidad de rebotes que se desea calcular.\n\nLa funci√≥n debe devolver una lista con las alturas alcanzadas en cada rebote.\n\nPunto extra\nModifique la funci√≥n para que considere un rebote como ‚Äúsignificativo‚Äù solo si la altura alcanzada es mayor o igual a un valor m√≠nimo especificado (por ejemplo, 1 cent√≠metro).\nSi la pelota no alcanza esta altura m√≠nima en alg√∫n rebote, se considera que ha completado su trayectoria y queda quieta. En este caso, la funci√≥n debe devolver √∫nicamente los valores correspondientes a los ‚Äúrebotes significativos‚Äù.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#un-mont√≥n-de-plata",
    "href": "practica/01_programacion_en_python/ejercicios.html#un-mont√≥n-de-plata",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "11 Un mont√≥n de plata",
    "text": "11 Un mont√≥n de plata\nUna ma√±ana pon√©s un billete en la vereda al lado del Monumento a la Bandera. A partir de ah√≠, cada d√≠a vas y duplic√°s la cantidad de billetes, apil√°ndolos prolijamente. ¬øCu√°nto tiempo pasa antes de que la pila de billetes sea m√°s alta que la del Monumento?\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nAlgunas constantes √∫tiles para resolver el problema:\nbillete_grosor = 0.11 * 0.001  # grosor de un billete en metros\naltura_monumento = 70          # altura en metros\nSugerencia: Usar un bucle while para realizar el c√°lculo.\n\n\n\n\nPunto extra\nEscribe una funci√≥n que permita determinar la cantidad de d√≠as necesarios para superar cualquier altura arbitraria.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#la-conjetura-de-collatz",
    "href": "practica/01_programacion_en_python/ejercicios.html#la-conjetura-de-collatz",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "12 La conjetura de Collatz",
    "text": "12 La conjetura de Collatz\nLa conjetura de Collatz dice:\n\nSi tomamos un n√∫mero natural cualquiera, su secuencia de Collatz termina llegando siempre al n√∫mero 1.\n\nSecuencia de Collatz:\n\nSi el n√∫mero es par, se divide entre 2.\nSi el n√∫mero es impar, se multiplica por 3 y se le suma 1.\n\n\\[\nf(n) =\n\\begin{cases}\n    \\displaystyle \\frac{n}{2} & \\text{si } n \\text{ es par,} \\\\ \\\\\n    3n + 1 & \\text{si } n \\text{ es impar.}\n\\end{cases}\n\\]\nEscribir una funci√≥n que calcule la secuencia de Collatz para un n√∫mero natural cualquiera.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\n\nUtilizar bucle while.\nEl bucle debe correr solo cuando el valor de la secuencia sigue siendo mayor a 1. Si es 1, hay que frenar.\nInsertar los elementos de la secuencia en una lista.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#adivina-el-n√∫mero",
    "href": "practica/01_programacion_en_python/ejercicios.html#adivina-el-n√∫mero",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "13 Adivina el n√∫mero",
    "text": "13 Adivina el n√∫mero\nEscriba un programa que implemente el cl√°sico juego ‚ÄúAdivina el n√∫mero‚Äù. El programa debe:\n\nTener un n√∫mero secreto (entero) que el usuario debe adivinar.\nSolicitar al usuario que ingrese un n√∫mero.\nSi el n√∫mero ingresado no coincide con el n√∫mero secreto:\n\nInformar si el n√∫mero ingresado es mayor o menor que el n√∫mero secreto.\nPedir al usuario que intente nuevamente.\n\nSi el usuario adivina el n√∫mero, el programa debe terminar mostrando un mensaje de felicitaciones.\n\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara generar n√∫meros aleatorios enteros en un rango dado puede utilizar randint() del m√≥dulo random:\nimport random\nrandom.randint(-100,¬†100)     # Genera un n√∫mero aleatorio entre -100 y 100\n\n\n\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nEl programa que resuelve este problema realiza una cantidad de iteraciones que se desconoce al momento de escribirlo. La soluci√≥n t√≠pica a este tipo de problema involucra el uso de while True junto a la sentencia break.\nwhile True:\n    # realizar alguna accion\n    if condicion_de_salida:\n        break\n\n\n\n\nPunto extra\nImplemente una versi√≥n de este programa donde el usuario cuenta con 10 intentos.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres-pythonico",
    "href": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres-pythonico",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "14 Conteo de caracteres Pythonico",
    "text": "14 Conteo de caracteres Pythonico\nLos diccionarios en Python cuentan con un m√©todo .get() que devuelve el valor asociado a una clave. Este m√©todo permite pasarle un segundo argumento con un valor que se devuelve cuando no se encuentra un elemento asociado a la clave que le pasamos. Por ejemplo:\nd = {\"a\": 1, \"b\": 20}\nd.get(\"b\", 0)\n20\nd.get(\"c\", 0)\n0\nModifique la funci√≥n contar_caracteres del ejercicio Conteo de caracteres utilizando el metodo .get() para obtener una implementaci√≥n m√°s sencilla. As√≠, deber√≠a poder eliminar el bloque if.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#validador-de-contrase√±as",
    "href": "practica/01_programacion_en_python/ejercicios.html#validador-de-contrase√±as",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "15 Validador de contrase√±as üò±",
    "text": "15 Validador de contrase√±as üò±\nEscriba un programa que solicite al usuario una contrase√±a y verifique que cumpla con las siguientes condiciones:\n\nDebe tener entre de 8 y 24 caracteres.\nDebe incluir letras, n√∫meros y caracteres especiales (@#$%^&*()).\n\nSi la contrase√±a no es v√°lida, el programa debe informar al usuario qu√© condici√≥n no se cumple y permitirle ingresar una nueva contrase√±a. El proceso se repite hasta que el usuario ingrese una contrase√±a v√°lida o decida no continuar.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres-ii",
    "href": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres-ii",
    "title": "üõ†Ô∏è Ejercicios",
    "section": "16 Conteo de caracteres II üò±",
    "text": "16 Conteo de caracteres II üò±\nAgregue a la funci√≥n contar_frecuencias del ejercicio Conteo de caracteres un argumento llamado orden que admita los valores \"aparicion\", \"alfabetico\" y \"frecuencia\".\nEste argumento debe permitir ordenar las claves del diccionario resultante seg√∫n el siguiente criterio:\n\n\"aparicion\": mantiene el orden en que las palabras aparecen por primera vez en la lista original.\n\"alfabetico\": ordena las palabras alfab√©ticamente.\n\"frecuencia\": ordena las palabras por su frecuencia, de mayor a menor.",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "üõ†Ô∏è Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html",
    "href": "practica/01_programacion_en_python/autoevaluacion.html",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "",
    "text": "¬øQu√© valor contiene la variable contador luego de ejecutar el siguiente c√≥digo?\ncontador = 20\ncontador + 1\nComplete la siguiente tabla indicando si el nombre es v√°lido para una variable de Python.\n\n\n\nNombre\n¬øV√°lido?\nJustificaci√≥n\n\n\n\n\nbalance\n\n\n\n\nbalanceActual\n\n\n\n\nbalance-actual\n\n\n\n\nbalance actual\n\n\n\n\nbalance_actual\n\n\n\n\nmis.datos\n\n\n\n\n0cuenta\n\n\n\n\ncuenta0\n\n\n\n\n_cuenta\n\n\n\n\nSPAM\n\n\n\n\ncantidad$",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#variables",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#variables",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "",
    "text": "¬øQu√© valor contiene la variable contador luego de ejecutar el siguiente c√≥digo?\ncontador = 20\ncontador + 1\nComplete la siguiente tabla indicando si el nombre es v√°lido para una variable de Python.\n\n\n\nNombre\n¬øV√°lido?\nJustificaci√≥n\n\n\n\n\nbalance\n\n\n\n\nbalanceActual\n\n\n\n\nbalance-actual\n\n\n\n\nbalance actual\n\n\n\n\nbalance_actual\n\n\n\n\nmis.datos\n\n\n\n\n0cuenta\n\n\n\n\ncuenta0\n\n\n\n\n_cuenta\n\n\n\n\nSPAM\n\n\n\n\ncantidad$",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#n√∫meros",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#n√∫meros",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "2 N√∫meros",
    "text": "2 N√∫meros\n\n¬øCu√°l es el tipo de 10 / 2? ¬øPor qu√©?\n¬øCu√°l es el tipo de 5 * 2? ¬øPor qu√©?\n¬øPor qu√© 5 == 5.0 es True?",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#booleanos",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#booleanos",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "3 Booleanos",
    "text": "3 Booleanos\n\n¬øCu√°l es el resultado de las siguientes expresiones? ¬øPor qu√©?\nFalse or not False\nnot (True and True)\nnot True and True\n\"True\" != True\n10 &gt; 5 + 3\nNone is None\nFalse is False\nEjecute l√≠nea por l√≠nea los siguientes bloques y analice los resultados.\nint(True) * 50\nTrue * 50\n1 is True\nbool(1) is True\nid(True)\nid(bool(1))\nid(bool(1024))\n¬øCu√°les son los 3 operadores booleanos?",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#cadenas-de-caracteres",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#cadenas-de-caracteres",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "4 Cadenas de caracteres",
    "text": "4 Cadenas de caracteres\n\n¬øPor qu√© la siguiente comparaci√≥n resulta en True?\n\"spam\" + \"spamspam\" == \"spam\" * 3\n¬øPor qu√© la siguiente expresi√≥n resulta en un error? ¬øC√≥mo se puede arreglar?\n\"Me com√≠ \" + 6 + \" panchos.\"\n¬øEncuentra algo extra√±o en la siguiente expresi√≥n? ¬øC√≥mo la mejorar√≠a?\nmateria = \"Programaci√≥n 2\"\nprint(\"¬°Sean bienvenidos a la materia {materia}!\")\nExplique por qu√© es redundante utilizar str() en el siguiente bloque de c√≥digo:\nx, y = 10, 20\nprint(f\"La suma de {str(x)} y {str(y)} es: {str(x + y)}.\")\nConsidere el siguiente bloque de c√≥digo:\nmensaje = \"Hola, ¬øc√≥mo estes?\"\nmensaje[-3] = \"√°\"\n\n¬øCu√°l es la intenci√≥n detr√°s del programa?\n¬øPor qu√© no funciona?\n¬øC√≥mo podr√≠a arreglarlo? Alerta: la soluci√≥n no es muy elegante.\n\n¬øCu√°l es el resultado de list(\"abcdefgh\")? ¬øPor qu√©?\n¬øPor qu√© set(\"abcde\") es distinto de {\"abcde\"}?",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#funciones",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#funciones",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "5 Funciones",
    "text": "5 Funciones\n\n¬øCu√°l es la diferencia entre una funci√≥n y una llamada a funci√≥n?\n¬øCu√°l es el valor que devuelve una funci√≥n que no tiene return?\n¬øCu√°ndo se ejecuta el c√≥digo dentro de una funci√≥n: cuando la funci√≥n se define o cuando se la llama? Considere la siguiente funci√≥n:\ndef suma(x, y):\n    print(100 / 0)\n    return x + y\nLuego, ejecute el siguiente bloque:\nsuma(2, 4)",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#listas",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#listas",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "6 Listas",
    "text": "6 Listas\n\n¬øQu√© es []? ¬øCu√°l es el resultado de len([])?\n¬øPor qu√© la siguiente expresi√≥n resulta en False? Ayuda: use la funci√≥n id().\n[] is []\n¬øPor qu√© se obtiene un error en el siguiente bloque de c√≥digo?\nl = []\nl[0]\nSi [0][0] devuelve 0, ¬øpor qu√© [1][1] no devuelve [1]?\n¬øCu√°l es el valor de x en el siguiente bloque de c√≥digo? ¬øPor qu√©?\nl = [\"hola\", \"hola hola\", \"hasta luego\"]\nx = l.remove(\"hola\")\n¬øC√≥mo le asignar√≠a el valor \"hola\" como el tercer valor en una lista almacenada en una variable llamada cosas? Asuma que cosas contiene [2, 4, 6, 8, 10].\nAsuma que letras contiene la lista [\"a\", \"b\", \"c\", \"d\"]:\n\n¬øA qu√© eval√∫a letras[-1]?\n¬øA qu√© eval√∫a letras[:2]?\n¬øA qu√© eval√∫a letras[int(int('3' * 2) // 11)]? ¬øEs necesario usar dos veces int()?\n\nAsuma que bartulos contiene la lista [3.14, \"casa\", 11, \"casa\", True]:\n\n¬øA qu√© eval√∫a bartulos.index(\"casa\")? ¬øPor qu√©?\n¬øC√≥mo queda la lista en bartulos despu√©s de ejecutar bartulos.append(99)?\n¬øC√≥mo queda la lista en bartulos despu√©s de ejecutar bartulos.remove(\"casa\"') ?¬øPor qu√©?\n\n¬øCu√°les son los operadores para la concatenaci√≥n y la replicaci√≥n de listas?\n¬øCu√°l es la diferencia entre los m√©todos append() e insert() de las listas?\n¬øCu√°les son dos formas de eliminar valores de una lista?\nEl siguiente bloque de c√≥digo imprime ['a', 'b', True, 30]. ¬øPor qu√©?\ncosas = [\"a\", \"b\", True]\nbartulos = cosas\nbartulos.append(20 + 10)\nprint(cosas)\nConsidere el siguiente bloque de c√≥digo:\nmarcas = [\"Milka\", \"Cofler\", \"√Åguila\", \"Cadbury\", \"Lindt\", \"Toblerone\", \"After Eight\"]\nmarcas[2:5]\nque correctamente muestra [\"√Åguila\", \"Cadbury\", \"Lindt\"]. ¬øPor qu√© el siguiente bloque de c√≥digo no funciona?\nmarcas = [\"Milka\", \"Cofler\", \"√Åguila\", \"Cadbury\", \"Lindt\", \"Toblerone\", \"After Eight\"]\nindices = 2:5\nmarcas[indices]",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#tuplas",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#tuplas",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "7 Tuplas",
    "text": "7 Tuplas\n\n¬øPor qu√© la tupla no implementa un m√©todo similar al m√©todo .extend() de las listas?\nLas tuplas de Python son conocidas por ser inmutables. Por ejemplo, el siguiente bloque de c√≥digo resulta en un error:\ntupla = (1, 2, 3)\ntupla[1] = 10\nSin embargo, el siguiente bloque no arroja ning√∫n error y pareciera que se logra modificar la tupla exitosamente:\nbartulos = [\"Hola\", 10, None]\ntupla = (1, bartulos, 3)\n\ntupla[1].append(\"¬°Sorpesa!\")\n\nprint(tupla)\n¬øQu√© pas√≥?",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#diccionarios",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#diccionarios",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "8 Diccionarios",
    "text": "8 Diccionarios\n\n¬øC√≥mo se escribe en c√≥digo un diccionario vac√≠o?\n¬øC√≥mo se ve un diccionario que tiene la clave \"cosa\" y el valor 15?\n¬øCu√°l es la principal diferencia entre un diccionario y una lista?\n¬øQu√© ocurre si se intenta acceder a bartulos[\"cosa\"] cuando bartulos es {\"coso\": 100}?\nSi un diccionario est√° almacenado en bartulos, ¬øcu√°l es la diferencia entre las siguientes expresiones?\n\"cosa\" in bartulos\n\"cosa\" in bartulos.keys()\nSuponga el diccionario datos = {\"nombre\": \"Juan\"}. ¬øPor qu√© la siguiente expresi√≥n resulta en False?\n\"Juan\" in datos",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#control-de-flujo",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#control-de-flujo",
    "title": "ü™û Autoevaluaci√≥n",
    "section": "9 Control de flujo",
    "text": "9 Control de flujo\n\n9.1 Condicionales\n\nExplique qu√© es una condici√≥n y en qu√© situaciones se utilizar√≠a.\nIdentifique los tres bloques de c√≥digo en el siguiente ejemplo:\ncodigo = 0\n\nif codigo == 10:\n    print(\"mensaje 1\")\n    if codigo &gt; 5:\n        print(\"mensaje 2\")\n    else:\n        print(\"mensaje alternativo\")\n    print(\"mensaje final\")\n\nprint(\"Fin del programa\")\n¬øTienen sentido las comparaciones utilizadas?\n¬øCu√°l es el problema con el siguiente programa? Proponga una soluci√≥n.\nnumero = 10\nif numero &lt; 0:\n    print(f\"El numero {numero} es negativo\")\nelif numero &lt; -5:\n    print(f\"El numero {numero} es menor a -5\")\nelif numero &gt; 0:\n    print(f\"El numero {numero} es positivo\")\nelse:\n    print(f\"El numero {numero} es 0\")\n\n\n\n9.2 Bucles\n\nConsidere el siguiente programa:\nfor i in range(10):\n    print(i)\nEscriba un programa que realice la misma tarea utilizando un bucle while.\n¬øCu√°l es la diferencia entre range(10), range(0, 10) y range(0, 10, 1) en un bucle for?\nSuponga que numeros es una lista que contiene numeros enteros, ¬øen qu√© se diferencian los siguientes bloques de c√≥digo?\nfor i in numeros:\n    if i % 2 == 0:\n        break\n    print(i)\nfor i in numeros:\n    if i % 2 == 0:\n        continue\n    print(i)\n¬øEs posible re-escribir el siguiente bloque de c√≥digo usando while True? ¬øQu√© modificaciones habr√≠a que hacer?\nsuma = 0\ni = 0\nwhile suma &lt;= limite:\n    suma += numeros[i]\n    i += 1",
    "crumbs": [
      "Pr√°ctica",
      "U1 - Programaci√≥n en Python",
      "ü™û Autoevaluaci√≥n"
    ]
  }
]