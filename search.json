[
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html",
    "href": "trabajos_practicos/trabajo_grupal.html",
    "title": "Trabajo pr치ctico grupal",
    "section": "",
    "text": "El objetivo de este trabajo pr치ctico es implementar un decorador en Python que permita monitorear la ejecuci칩n de funciones y luego utilizarlo en un programa que realiza operaciones de ordenamiento\nMonitorear la ejecuci칩n del c칩digo es una tarea fundamental en el desarrollo de software: permite detectar cuellos de botella de rendimiento, identificar funciones costosas y generar registros 칰tiles para el debugging o auditor칤a.\nIncorporar herramientas de monitoreo desde etapas tempranas del desarrollo favorece la escritura de c칩digo m치s eficiente, mantenible y confiable.",
    "crumbs": [
      "Trabajos Pr치cticos",
      "Trabajo pr치ctico grupal"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html#objetivo",
    "href": "trabajos_practicos/trabajo_grupal.html#objetivo",
    "title": "Trabajo pr치ctico grupal",
    "section": "",
    "text": "El objetivo de este trabajo pr치ctico es implementar un decorador en Python que permita monitorear la ejecuci칩n de funciones y luego utilizarlo en un programa que realiza operaciones de ordenamiento\nMonitorear la ejecuci칩n del c칩digo es una tarea fundamental en el desarrollo de software: permite detectar cuellos de botella de rendimiento, identificar funciones costosas y generar registros 칰tiles para el debugging o auditor칤a.\nIncorporar herramientas de monitoreo desde etapas tempranas del desarrollo favorece la escritura de c칩digo m치s eficiente, mantenible y confiable.",
    "crumbs": [
      "Trabajos Pr치cticos",
      "Trabajo pr치ctico grupal"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html#decorador-monitor",
    "href": "trabajos_practicos/trabajo_grupal.html#decorador-monitor",
    "title": "Trabajo pr치ctico grupal",
    "section": "2 Decorador monitor",
    "text": "2 Decorador monitor\nEl decorador a implementar se llamar치 monitor y deber치 ser capaz de registrar informaci칩n sobre cada ejecuci칩n de la funci칩n decorada. Su interfaz contar치 con los siguientes argumentos:\n\nfuncion: la funci칩n decorada o None. Por defecto, ser치 None. Su valor ser치 distinto None solo cuando se use el decorador sin argumentos.\nconsola (bool): indica si los mensajes se muestran por consola. Por defecto es True.\narchivo (str o None): nombre del archivo donde se escribir치n los mensajes de monitoreo. Por defecto es None. En ese caso, no se guarda ning칰n archivo.\nformato (str): cadena de formato que determina c칩mo se construye el mensaje de monitoreo.\n\n\n2.1 Componentes del formato\nLa cadena de formato puede incluir los siguientes componentes:\n\n{tiempo}: fecha y hora de la llamada en formato YYYY-MM-DD HH:mm:ss.mss, donde mss son tres d칤gitos para los milisegundos.\n{funcion}: nombre de la funci칩n.\n{modulo}: nombre del m칩dulo donde se define la funci칩n.\n{duracion}: duraci칩n total de la ejecuci칩n en milisegundos.\n\nEl formato por defecto es:\nformato = \"({tiempo}) {funcion} demor칩 {duracion} milisegundos.\"\n\n\n2.2 Ejemplos de formato\nformato = \"({tiempo}) {funcion} demor칩 {duracion} milisegundos.\"\n# (2025-10-08 11:54:12.123) fun demor칩 735 milisegundos.\n\nformato = \"({tiempo}) {modulo}::{funcion} demor칩 {duracion} milisegundos.\"\n# (2025-10-08 11:54:12.123) __main__::fun demor칩 735 milisegundos.\n\n\n2.3 Ejemplos de @monitor\n# Ejemplo 1: comportamiento por defecto\n@monitor\ndef fun(x, y):\n    return x + y\n\n# Ejemplo 2: uso de archivo de registros\n@monitor(archivo=\"registros.log\")\ndef fun(x, y, z):\n    return x ** y * z\n\n# Ejemplo 3: uso de formato alternativo\nformato = \"({tiempo}) {modulo}::{funcion} demor칩 {duracion} milisegundos.\"\n@monitor(archivo=\"registros.log\", formato=formato)\ndef fun(a, b):\n    return list(range(a, b))",
    "crumbs": [
      "Trabajos Pr치cticos",
      "Trabajo pr치ctico grupal"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html#aplicaci칩n-monitoreo-de-algoritmos-de-ordenamiento",
    "href": "trabajos_practicos/trabajo_grupal.html#aplicaci칩n-monitoreo-de-algoritmos-de-ordenamiento",
    "title": "Trabajo pr치ctico grupal",
    "section": "3 Aplicaci칩n: monitoreo de algoritmos de ordenamiento",
    "text": "3 Aplicaci칩n: monitoreo de algoritmos de ordenamiento\nPara comprobar el correcto funcionamiento del decorador, se deben decorar las funciones merge_sort y bubble_sort, ambas encargadas de ordenar listas de n칰meros de menor a mayor.\n\n3.1 Implementaci칩n de los algoritmos\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if arr[j] &gt; arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n    return arr\n\ndef _merge_sort(arr):\n    if len(arr) &lt;= 1:\n        return arr\n\n    mitad = len(arr) // 2\n    izquierda = _merge_sort(arr[:mitad])\n    derecha = _merge_sort(arr[mitad:])\n\n    return merge(izquierda, derecha)\n\ndef merge(izquierda, derecha):\n    resultado = []\n    i = 0\n    j = 0\n\n    while i &lt; len(izquierda) and j &lt; len(derecha):\n        if izquierda[i] &lt; derecha[j]:\n            resultado.append(izquierda[i])\n            i += 1\n        else:\n            resultado.append(derecha[j])\n            j += 1\n\n    resultado.extend(izquierda[i:])\n    resultado.extend(derecha[j:])\n\n    return resultado\n\ndef merge_sort(arr):\n    return _merge_sort(arr)\n\n\n3.2 Generaci칩n de datos de prueba\nPara generar secuencias de n칰meros aleatorios se utilizar치 la funci칩n crear_numeros:\nimport random\n\ndef crear_numeros(n):\n    return [random.random() for _ in range(n)]",
    "crumbs": [
      "Trabajos Pr치cticos",
      "Trabajo pr치ctico grupal"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html#ejecuci칩n-del-programa",
    "href": "trabajos_practicos/trabajo_grupal.html#ejecuci칩n-del-programa",
    "title": "Trabajo pr치ctico grupal",
    "section": "4 Ejecuci칩n del programa",
    "text": "4 Ejecuci칩n del programa\nFinalmente, se debe implementar un script llamado programa.py que se ejecute desde la terminal. Este programa generar치 secuencias aleatorias de diferentes tama침os, las ordenar치 utilizando ambos algoritmos y registrar치 el monitoreo correspondiente.\nEjemplo de ejecuci칩n:\npython programa.py -n 100 1000 5000 10000 -s monitoreo.log -v\n\nCon -n se especifica una lista de tama침os de secuencias a generar.\nCon -s se indica el nombre del archivo donde se deben guardar los mensajes de monitoreo.\n\nSi no se especifica, no se guardan los mensajes en ning칰n archivo.\n\nCon -v se indica que se muestren los mensajes de monitoreo en la consola.",
    "crumbs": [
      "Trabajos Pr치cticos",
      "Trabajo pr치ctico grupal"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html#entregable",
    "href": "trabajos_practicos/trabajo_grupal.html#entregable",
    "title": "Trabajo pr치ctico grupal",
    "section": "5 Entregable",
    "text": "5 Entregable\nLa entrega de este trabajo pr치ctico debe consistir exclusivamente en un archivo .zip que contiene los siguientes archivos, con estos nombres y contenidos exactos:\n\nmonitor.py: contiene la implementaci칩n del decorador monitor y las funciones auxiliares necesarias para su funcionamiento.\nprograma.py: contiene las funciones de ordenamiento (merge_sort y bubble_sort) y la implementaci칩n de la interfaz de l칤nea de comandos (CLI) que admite los argumentos -n, -s y -v.\nsalida.log: archivo generado al ejecutar el programa con el siguiente comando:\npython programa.py -n 100 1000 5000 10000 -s salida.log -v\n\nNo se deben incluir archivos adicionales ni con nombres distintos a los especificados.\nEl nombre del archivo .zip debe seguir el formato G{n}_{Apellido1}_{Apellido2}_{Apellido3}.zip, donde:\n\n{n} es el n칰mero de grupo asignado.\n{Apellido1}, {Apellido2}, {Apellido3} son los apellidos de los integrantes del grupo.\n\nPor ejemplo, G1_Demicco_Gonzalez_Messi.zip.",
    "crumbs": [
      "Trabajos Pr치cticos",
      "Trabajo pr치ctico grupal"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html#evaluaci칩n",
    "href": "trabajos_practicos/trabajo_grupal.html#evaluaci칩n",
    "title": "Trabajo pr치ctico grupal",
    "section": "6 Evaluaci칩n",
    "text": "6 Evaluaci칩n\nLa evaluaci칩n contempla no solo la correcta ejecuci칩n del programa, sino tambi칠n la calidad del c칩digo desarrollado, considerando aspectos como la organizaci칩n, claridad, robustez y el uso de estructuras de datos y algoritmos apropiados\nAdem치s, el programa ser치 ejecutado desde la l칤nea de comandos con otros valores de entrada para verificar su correcto funcionamiento en diferentes situaciones.",
    "crumbs": [
      "Trabajos Pr치cticos",
      "Trabajo pr치ctico grupal"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html#ayuda",
    "href": "trabajos_practicos/trabajo_grupal.html#ayuda",
    "title": "Trabajo pr치ctico grupal",
    "section": "7 Ayuda",
    "text": "7 Ayuda\n\nDado que el decorador tiene que poder usarse de las siguientes dos maneras:\n@monitor\ndef f(...):\n    ...\n\n@monitor(archivo=\"registros.log\")\ndef f(...):\n    ...\nser치 necesario inspeccionar si el argumento funcion de monitor es una funci칩n o no. Para ello, puede usar:\nif callable(funcion):\n    # accion\nConsidere el m칠todo .format de las cadenas de caracteres para usar el formato pasado al decorador.\nPuede ser 칰til tener presente que la decoraci칩n @monitor no es la 칰nica forma de obtener una funci칩n a partir de otra funci칩n.\nAlgunos enlaces 칰tiles:\n\nUso de c칩digo externo\nScripting\nLectura y escritura de archivos\nDecoradores\nF치brica de decoradores",
    "crumbs": [
      "Trabajos Pr치cticos",
      "Trabajo pr치ctico grupal"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programaci칩n II",
    "section": "",
    "text": "Programaci칩n II\n\n\n  Ciclo de Formaci칩n T칠cnica - Estad칤stica y Ciencia de Datos\n  Facultad de Ciencias Econ칩micas y Estad칤stica (UNR)\n  2춿 Cuatrimestre 2025"
  },
  {
    "objectID": "index.html#docentes",
    "href": "index.html#docentes",
    "title": "Programaci칩n II",
    "section": "Docentes",
    "text": "Docentes\n\n\nTom치s Capretto\n\n  tomas.capretto@fcecon.unr.edu.ar \n\n\n\nLuciano Anselmino\n\n  luciano.anselmino@fcecon.unr.edu.ar \n\n\n\nJoaqu칤n Bermejo\n\n  joaquin.bermejo@fcecon.unr.edu.ar \n\n\n\nDolores Sollberger\n\n  dolores.sollberger@fcecon.unr.edu.ar"
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html",
    "title": "U1 - Programaci칩n en Python",
    "section": "",
    "text": "# 츼rea y per칤metro de un c칤rculo\ndef calcular_area(radio):\n    pi = 3.14159\n    area = pi * radio ** 2\n    return area\n\ndef calcular_perimetro(radio):\n    pi = 3.14159\n    perimetro = 2 * pi * radio\n    return perimetro\n\ndef calcular_area_y_perimetro(radio):\n    area = calcular_area(radio)\n    perimetro = calcular_perimetro(radio)\n    return area, perimetro\n\ncalcular_area(radio=2.5)\ncalcular_perimetro(radio=2.5)\n\narea, perimetro = calcular_area_y_perimetro(radio=2.5)\nresultados = calcular_area_y_perimetro(radio=2.5)\n\nprint(type(area))\nprint(type(perimetro))\nprint(type(resultados))\nprint(type(resultados[0]))\nprint(type(resultados[1]))",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci칩n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#치rea-y-per칤metro-de-un-c칤rculo",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#치rea-y-per칤metro-de-un-c칤rculo",
    "title": "U1 - Programaci칩n en Python",
    "section": "",
    "text": "# 츼rea y per칤metro de un c칤rculo\ndef calcular_area(radio):\n    pi = 3.14159\n    area = pi * radio ** 2\n    return area\n\ndef calcular_perimetro(radio):\n    pi = 3.14159\n    perimetro = 2 * pi * radio\n    return perimetro\n\ndef calcular_area_y_perimetro(radio):\n    area = calcular_area(radio)\n    perimetro = calcular_perimetro(radio)\n    return area, perimetro\n\ncalcular_area(radio=2.5)\ncalcular_perimetro(radio=2.5)\n\narea, perimetro = calcular_area_y_perimetro(radio=2.5)\nresultados = calcular_area_y_perimetro(radio=2.5)\n\nprint(type(area))\nprint(type(perimetro))\nprint(type(resultados))\nprint(type(resultados[0]))\nprint(type(resultados[1]))",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci칩n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#promociones",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#promociones",
    "title": "U1 - Programaci칩n en Python",
    "section": "2 Promociones",
    "text": "2 Promociones\n# Promociones\ndef calcular_precio(monto, medio):\n    if medio == \"efectivo\":\n        monto_final = monto\n    elif medio == \"d칠bito\":\n        monto_final = monto * (1 - 0.1)\n    elif medio == \"cr칠dito\":\n        monto_final = monto * (1 + 0.05)\n    else:\n        print(f\"El medio {medio} es desconocido.\")\n        monto_final = monto\n\n    return monto_final\n\ncalcular_precio(80, \"efectivo\")\ncalcular_precio(80, \"d칠bito\")\ncalcular_precio(80, \"cr칠dito\")\n\n# Extra:\n# Usando valor por defecto 'efectivo'\ndef calcular_precio(monto, medio=\"efectivo\"):\n    if medio == \"efectivo\":\n        monto_final = monto\n    elif medio == \"d칠bito\":\n        monto_final = monto * (1 - 0.1)\n    elif medio == \"cr칠dito\":\n        monto_final = monto * (1 + 0.05)\n    else:\n        print(f\"El medio {medio} es desconocido.\")\n        monto_final = monto\n\n    return monto_final\n\n# Usando valor por defecto None\ndef calcular_precio(monto, medio=None):\n    if medio is None:\n        medio = \"efectivo\"\n\n    if medio == \"efectivo\":\n        monto_final = monto\n    elif medio == \"d칠bito\":\n        monto_final = monto * (1 - 0.1)\n    elif medio == \"cr칠dito\":\n        monto_final = monto * (1 + 0.05)\n    else:\n        print(f\"El medio {medio} es desconocido.\")\n        monto_final = monto\n\n    return monto_final",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci칩n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#etapas-de-la-vida",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#etapas-de-la-vida",
    "title": "U1 - Programaci칩n en Python",
    "section": "3 Etapas de la vida",
    "text": "3 Etapas de la vida\n# Etapas de la vida\ndef obtener_etapa(edad):\n    if edad &lt; 2:\n        etapa = \"beb칠\"\n    elif edad &lt; 4:\n        etapa = \"infante\"\n    elif edad &lt; 13:\n        etapa = \"ni침o/a\"\n    elif edad &lt; 20:\n        etapa = \"adolescente\"\n    elif edad &lt; 65:\n        etapa = \"adulto/a\"\n    else:\n        etapa = \"persona mayor\"\n\n    mensaje = f\"La persona es un/a {etapa}\"\n    print(mensaje)\n\n    return None\n\nobtener_etapa(67)\n\n# Comentarios:\n# 1. Un posible problema con esta implementaci칩n es que asume que la edad es positiva.\n#    Tambi칠n admite edades irrealmente altas.",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci칩n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#conteo-de-caracteres",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#conteo-de-caracteres",
    "title": "U1 - Programaci칩n en Python",
    "section": "4 Conteo de caracteres",
    "text": "4 Conteo de caracteres\n# Conteo de caracteres\ndef contar_caracteres(texto):\n    caracteres = {}\n    for caracter  in texto:\n        # No considerar espacios\n        if caracter == \" \":\n            continue\n\n        # Pasar el caracter a minuscula\n        caracter_minuscula = caracter.lower()\n        if caracter_minuscula not in caracteres:\n            caracteres[caracter_minuscula] = 1\n        else:\n            caracteres[caracter_minuscula] += 1\n\n    return caracteres\n\ncontar_caracteres(\"Ahora es mejor que nunca\")\n\n# Comentarios:\n# 1. Implementacion usando 'in' vs 'not in'\n# 2. 쯇odr칤an meter el .lower en otro lado? Si, se podr칤a pasar el texto a min칰sculas antes de empezar a iterar.\n# 3. 쮼n cu치l implementaci칩n se realizar칤a menos trabajo?\n# 4. 쯇odriamos eliminar el `continue`?\n\n# Moraleja: no hay una 칰nica implementaci칩n correcta.",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci칩n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#orden-de-m칠rito",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#orden-de-m칠rito",
    "title": "U1 - Programaci칩n en Python",
    "section": "5 Orden de m칠rito",
    "text": "5 Orden de m칠rito\n# Orden de m칠rito\nnotas = [\n    (\"Escalada\", 9),\n    (\"Alonso\", 7),\n    (\"P칠rez\", 8),\n    (\"Castro\", 8),\n    (\"Rossini\", 10),\n    (\"Mart칤nez\", 9),\n    (\"P칠rez\", 6),\n    (\"Riquelme\", 5),\n]\n\n# Parte 1\nnotas_dict = {}\nfor registro in notas:\n    # Opcion 1:\n     notas_dict[registro[0]] = registro[1]\n\n    # Opcion 2:\n    # apellido = registro[0]\n    # nota = registro[1]\n    # notas_dict[apellido] = nota\n\n    # apellido, nota = registro\n    # notas_dict[apellido] = nota\n\n# Pregunta: 쯈ue pasa si hay dos personas con el mismo apellido?\n\n# Parte 2\nnotas_dict = {}\nfor registro in notas:\n    apellido = registro[0]\n    nota = registro[1]\n    if nota not in notas_dict:\n        notas_dict[nota] = [apellido]\n    else:\n        notas_dict[nota].append(apellido)\n        # Otras opciones:\n        # notas_dict[nota] = notas_dict[nota] + [apellido]\n        # notas_dict[nota] = notas_dict[nota].extend([apellido])",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci칩n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#rendimento-acad칠mico",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#rendimento-acad칠mico",
    "title": "U1 - Programaci칩n en Python",
    "section": "6 Rendimento acad칠mico",
    "text": "6 Rendimento acad칠mico\n# Rendimento acad칠mico\nnotas = {\n    \"Ana\": [8, 9, 10],\n    \"Luis\": [6, 7, 8, 3, 9],\n    \"Carla\": [10, 9, 10],\n    \"Marcos\": [5, 6],\n    \"Sof칤a\": [7, 7, 8],\n    \"Pedro\": [6, 4, 5, 6, 3, 8],\n    \"Luc칤a\": [9, 8, 10, 9]\n}\n\ndef resumir_notas(datos, modo):\n    resultado = {}\n\n    if modo == \"promedio\":\n        for nombre, notas in datos.items():\n            resultado[nombre] = sum(notas) / len(notas)\n    elif modo == \"proporcion\":\n        # NOTE: Esto tal vez sea un poco complicado\n        for nombre, notas in datos.items():\n            n_aprobado = 0\n            for nota in notas:\n                if nota &gt;= 6:\n                    n_aprobado += 1\n            resultado[nombre] = n_aprobado / len(notas)\n\n    else:\n        print(f\"El modo {modo} es desconocido\")\n        return None\n\n    return resultado\n\nresumir_notas(notas, \"promedio\")\nresumir_notas(notas, \"proporcion\")\n\n# 쮺칩mo ser칤a la implementaci칩n sin .items()?\n# 쯇odr칤a escribir un 칰nico for loop? 쯈u칠 cambiar칤a? 쯇ros y contras?\n# 쮿ay alg칰n conflicto entre la variable 'notas' del ambiente global y la del ambiente local de\n# la funci칩n?\n# El c치lculo de la proporci칩n se podr칤a abstraer en una funci칩n.\n\n# Podr칤a usarse un \"list comprehension\"\n# len([nota for nota in notas if nota &gt;= 6])\n\n# Podr칤a usarse un generador:\n# sum(nota &gt;= 6 for nota in notas)",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci칩n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#칤ndice-de-precios",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#칤ndice-de-precios",
    "title": "U1 - Programaci칩n en Python",
    "section": "7 칈ndice de precios",
    "text": "7 칈ndice de precios\nipc_2024 = [20.6, 13.2, 11.0, 8.8, 4.2, 4.6, 4.0, 4.2, 3.5, 2.7, 2.4, 2.7]\n\n# Menor y mayor valor\nmin(ipc_2024)\nmax(ipc_2024)\n\n# IPC promedio mensual\nsum(ipc_2024) / len(ipc_2024)\n\n# Mes de mayor inflaci칩n\nipc_2024.index(max(ipc_2024)) # 0 + 1 -&gt; enero\n\n# Inflaci칩n mediana\nipc_ordenado = sorted(ipc_2024)\n\n# Opcion 1:\n(ipc_ordenado[5] + ipc_ordenado[6]) * 0.5\n\n# Opcion 2:\nsum(ipc_ordenado[5:7]) * 0.5\n\n# Opcion 3:\nn_inicio = (len(ipc_ordenado) // 2) - 1 # Resto 1 porque Python indexa desde 0\nn_fin = (len(ipc_ordenado) // 2 + 1) -1   # Resto 1 porque Python indexa desde 0\n\n# Sumo 1 porque el slicing no es inclusivo por derecha\nsum(ipc_ordenado[n_inicio:(n_fin + 1)]) * 0.5\n\n# Rango de IPC sin min y max\nipc_ordenado[-1] - ipc_ordenado[0]",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci칩n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#res칰menes-estad칤sticos",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#res칰menes-estad칤sticos",
    "title": "U1 - Programaci칩n en Python",
    "section": "8 Res칰menes estad칤sticos",
    "text": "8 Res칰menes estad칤sticos\ndef media(x):\n    return sum(x) / len(x)\n\n\ndef rango(x):\n    return max(x) - min(x)\n\n\n# Opcion 1.\ndef varianza(x):\n    x_media = media(x)\n    suma = 0\n    for x_i in x:\n        suma += (x_i - x_media) ** 2\n    return suma / len(x)\n\n\n# Opcion 2. Se podr칤a usar un list-comprehension tambi칠n.\ndef varianza2(x):\n    x_media = media(x)\n    distancias = []\n    for x_i in x:\n        distancias.append((x_i - x_media) ** 2)\n    return media(distancias)\n\ndef desvio_estandar(x):\n    return varianza(x) ** 0.5\n\n\ndef mediana(x):\n    x_ordenado = sorted(x)\n    n = len(x)\n    mitad = n // 2\n\n    if n % 2 == 1:\n        # Cantidad impar: se toma el elemento del medio\n        mediana = x_ordenado[mitad]\n    else:\n        # Cantidad par: se promedian los dos del medio\n        mediana = (x_ordenado[   - 1] + x_ordenado[mitad]) * 0.5\n\n    return mediana",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci칩n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#validaci칩n-de-dni",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#validaci칩n-de-dni",
    "title": "U1 - Programaci칩n en Python",
    "section": "9 Validaci칩n de DNI",
    "text": "9 Validaci칩n de DNI\ndef validar_dni(dni):\n    # Si no 'dni' tiene puntos, es DNI v치lido cuando:\n    # - todos los caracteres sean todos d칤gitos\n    # - la longitud est칠 entre 7 y 8\n    if dni.count(\".\") == 0:\n        return dni.isdigit() and 7 &lt;= len(dni) &lt;= 8\n\n    # Si 'dni' tiene puntos, debe tener exactamente 2 puntos.\n    partes = dni.split(\".\")\n    if len(partes) != 3:\n        return False\n\n    # Si alguna de las partes no contiene todos d칤gitos, no es un DNI v치lido.\n    # Opcion 1\n    for parte in partes:\n        if not parte.isdigit():\n            return False\n    # Opcion 2\n    # if not all(parte.isdigit() for parte in partes):\n    #     return False\n\n    longitudes_validas = (\n        len(partes[0]) in (1, 2) and\n        len(partes[1]) == 3 and\n        len(partes[2]) == 3\n    )\n\n    return longitudes_validas\n\n\nvalidar_dni(\"40.094.127\")\nvalidar_dni(\"19053512\")\nvalidar_dni(\"6.392.780\")\n\nvalidar_dni(\"40,094,127\")\nvalidar_dni(\"19-053-512\")\nvalidar_dni(\"123456\")\nvalidar_dni(\"40..094127\")\nvalidar_dni(\"40.09412.7\")",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci칩n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#la-f칤sica-del-rebote",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#la-f칤sica-del-rebote",
    "title": "U1 - Programaci칩n en Python",
    "section": "10 La f칤sica del rebote",
    "text": "10 La f칤sica del rebote\naltura_inicial = 100 # metros\nrebote = 3 / 5\n\n# Parte 1 (no es necesario el uso de una variable adicional)\naltura_actual = altura_inicial\nfor i in range(10):\n    altura_actual = altura_actual * rebote\n    print(\"Rebote\", i + 1, \"| Altura:\", round(altura_actual, 4))\n\n# Parte 2\ndef calcular_rebotes(altura_inicial, rebotes_n):\n    alturas = []\n    altura_actual = altura_inicial\n    for _ in range(rebotes_n): # '_' es una convencion cuando la variable de iteraci칩n no se usa\n        altura_actual = altura_actual * rebote\n        alturas.append(altura_actual)\n\n    return alturas\n\ncalcular_rebotes(100, 10)\n\n\n# Parte 3\ndef calcular_rebotes(altura_inicial, rebotes_n):\n    alturas = []\n    altura_actual = altura_inicial\n    for _ in range(rebotes_n): # '_' es una convencion cuando la variable de iteraci칩n no se usa\n        altura_actual = altura_actual * rebote\n        alturas.append(altura_actual)\n\n        if altura_actual &lt; 0.01:\n            break\n\n    return alturas\n\ncalcular_rebotes(100, 50)\nlen(calcular_rebotes(100, 50)) # Solo devuelve 19 rebotes\n\n# Se podria conversar si es necesario crear 'altura_actual'\n# Para el caso de las listas una opci칩n, un poco m치s rebuscada, es:\n\ndef calcular_rebotes(altura_inicial, rebotes_n):\n    alturas = [altura_inicial * rebote]\n    for i in range(rebotes_n):\n        alturas.append(alturas[i] * rebote)\n\n        if alturas[-1] &lt; 0.01:\n            break\n\n    return alturas\n\ncalcular_rebotes(100, 50)\nlen(calcular_rebotes(100, 50)) # Solo devuelve 19 rebotes",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci칩n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#un-mont칩n-de-plata",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#un-mont칩n-de-plata",
    "title": "U1 - Programaci칩n en Python",
    "section": "11 Un mont칩n de plata",
    "text": "11 Un mont칩n de plata\nbillete_grosor = 0.11 * 0.001  # grosor de un billete en metros\naltura_monumento = 70          # altura en metros\n\ndias = 1\nbilletes_n = 1\nwhile billetes_n * billete_grosor &lt;= altura_monumento:\n    billetes_n = billetes_n * 2\n    dias = dias + 1\n\nprint(\"Se necesitan\", dias, \"dias.\")\nprint(\"La altura de la pila es\", billetes_n * billete_grosor, \"metros.\")\nprint(\"Se colocaron\", billetes_n, \"billetes.\")\n\n\n# Punto extra\ndef calcular_dias(altura_objetivo):\n    billete_grosor = 0.11 * 0.001\n    dias = 1\n    billetes_n = 1\n    while billetes_n * billete_grosor &lt;= altura_objetivo:\n        billetes_n = billetes_n * 2\n        dias = dias + 1\n    return dias\n\ncalcular_dias(0.1)",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci칩n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#la-conjetura-de-collatz",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#la-conjetura-de-collatz",
    "title": "U1 - Programaci칩n en Python",
    "section": "12 La conjetura de Collatz",
    "text": "12 La conjetura de Collatz\ndef collatz(n):\n    # Inicializar lista con solo el valor 'n'\n    secuencia = [n]\n    while n != 1:\n        # Numero par\n        if n % 2 == 0:\n            n = n // 2 # Notar uso de divisi칩n entera\n        # Numero impar\n        else:\n            # 쯇uede el resultado ser flotante?\n            n = 3 * n + 1\n        secuencia.append(n)\n    return secuencia\n\n\ncollatz(5)\ncollatz(20)\ncollatz(16)\ncollatz(37)\n\n# Para discutir: 쯇odr칤a implementarse con un 'while True'? 쮺칩mo?",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci칩n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#adivina-el-n칰mero",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#adivina-el-n칰mero",
    "title": "U1 - Programaci칩n en Python",
    "section": "13 Adivina el n칰mero",
    "text": "13 Adivina el n칰mero\n# Correr de la terminal con 'python {nombre_de_programa}.py'\nimport random\n\nprint(\" ======================== Adivina el n칰mero! ======================== \")\n\nnumero_secreto = random.randint(0, 100)\n\nmensaje = \"Ingresa un numero entero: \"\nconteo = 0\ntope_intentos = 5\nwhile True:\n    numero = int(input(mensaje))\n    conteo += 1\n    if numero &lt; numero_secreto:\n        mensaje = f\"춰Ups! El numero secreto es mayor a {numero}. Prueba de nuevo: \"\n    elif numero &gt; numero_secreto:\n        mensaje = f\"춰Ups! El numero secreto es menor a {numero}. Prueba de nuevo: \"\n    else:\n        print(f\"Has ganado, felicitaciones! Te llev칩 tan solo {conteo} intentos.\")\n        break\n\n    if conteo == (tope_intentos - 1):\n        print(\"춰Cuidado! Te queda solo un intento.\")\n\n    if conteo &gt;= tope_intentos:\n        print(f\"Has perdido :(. El numero secreto era {numero_secreto}.\")\n        break",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci칩n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#conteo-de-caracteres-pythonico",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#conteo-de-caracteres-pythonico",
    "title": "U1 - Programaci칩n en Python",
    "section": "14 Conteo de caracteres Pythonico",
    "text": "14 Conteo de caracteres Pythonico\ndef contar_caracteres(texto):\n    texto = texto.lower() # Pasa a minuscula al principio\n    caracteres = {}\n    for caracter  in texto:\n        # Solo considerar letras del alfabeto\n        if not caracter.isalpha():\n            continue\n\n        # Si el caracter no esta en el diccionario, devuelve 0\n        # Si est치, devuelve su conteo.\n        # En ambos casos, le suma 1.\n        caracteres[caracter] = caracteres.get(caracter, 0) + 1\n\n    return caracteres\n\ncontar_caracteres(\"Ahora es mejor que nunca\")\ncontar_caracteres(\"Ahora es mejor que nunca!!   +_\")\ncontar_caracteres(\"Ahora es mejor que nunca!!   +_\") == contar_caracteres(\"Ahora es mejor que nunca\")",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci칩n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#validador-de-contrase침as",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#validador-de-contrase침as",
    "title": "U1 - Programaci칩n en Python",
    "section": "15 Validador de contrase침as 游땸",
    "text": "15 Validador de contrase침as 游땸\nCARACTERES_ESPECIALES = \"@#$%^&*()\"\n\ndef contiene_letra(texto):\n    # True si al menos un caracter es una letra\n    for caracter in texto:\n        if caracter.isalpha():\n            return True\n    return False\n\n\ndef contiene_numero(texto):\n    # True si al menos un caracter es un numero (del sistema decimal)\n    for caracter in texto:\n        if caracter.isdecimal():\n            return True\n    return False\n\n\ndef contiene_especial(texto):\n    # True si al menos un caracter es un numero\n    for caracter in texto:\n        if caracter in CARACTERES_ESPECIALES:\n            return True\n    return False\n\ndef validar_pwd(pwd):\n    errores = []\n\n    if not (8 &lt;= len(pwd) &lt;= 24):\n        errores.append(\"Debe tener entre 8 y 24 caracteres.\")\n\n    if not contiene_letra(pwd):\n        errores.append(\"Debe contener al menos una letra.\")\n    if not contiene_numero(pwd):\n        errores.append(\"Debe contener al menos un n칰mero.\")\n    if not contiene_especial(pwd):\n        errores.append(\"Debe contener al menos un car치cter especial '@#$%^&*()'.\")\n\n    caracteres_desconocidos = []\n    for caracter in pwd:\n        # Hablar sobre si es posible simplificar esto\n        if (not caracter.isdecimal()) and (not caracter.isalpha()) and (caracter not in CARACTERES_ESPECIALES):\n            caracteres_desconocidos.append(caracter)\n\n    # Equivale a len(caracteres_desconocidos) &gt; 0\n    if caracteres_desconocidos:\n        errores.append(\n            f\"La contrase침a contiene los siguientes caracteres desconocidos {caracteres_desconocidos}\"\n        )\n\n    if errores == []:\n        return True\n\n    return errores\n\n\nwhile True:\n    password = input(\"Ingrese una contrase침a (o ENTER para salir): \")\n    if password == \"\":\n        print(\"Operaci칩n cancelada.\")\n        break\n\n    resultado = validar_pwd(password)\n\n    # Ac치 NO se puede usar 'if es_valida'.\n    if resultado is True:\n        print(\"Contrase침a v치lida.\")\n        break\n\n    print(\"La contrase침a no es v치lida:\")\n    for error in resultado:\n        print(\"-\", error)",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci칩n en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#conteo-de-caracteres-ii",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#conteo-de-caracteres-ii",
    "title": "U1 - Programaci칩n en Python",
    "section": "16 Conteo de caracteres II 游땸",
    "text": "16 Conteo de caracteres II 游땸\ndef contar_caracteres(texto, orden=\"aparicion\"):\n    texto = texto.lower() # Pasa a minuscula al principio\n    caracteres = {}\n    for caracter  in texto:\n        # Solo considerar letras del alfabeto\n        if not caracter.isalpha():\n            continue\n\n        # Si el caracter no esta en el diccionario, devuelve 0\n        # Si est치, devuelve su conteo.\n        # En ambos casos, le suma 1.\n        caracteres[caracter] = caracteres.get(caracter, 0) + 1\n\n    if orden == \"aparicion\":\n        salida = caracteres\n    elif orden == \"alfabetico\":\n        salida = {}\n        claves = sorted(caracteres.keys()) # No hace falta el .keys() en realidad\n        for clave in claves:\n            salida[clave] = caracteres[clave]\n    elif orden == \"frecuencia\":\n        salida = {}\n        claves = list(caracteres.keys()) # No hace falta el .keys() en realidad\n        claves_ordenadas = sorted(claves, key=lambda k: caracteres[k], reverse=True)\n        for clave in claves_ordenadas:\n            salida[clave] = caracteres[clave]\n\n    return salida\n\ncontar_caracteres(\"Ahora es mejor que nunca\", \"aparicion\")\ncontar_caracteres(\"Ahora es mejor que nunca\", \"alfabetico\")\ncontar_caracteres(\"Ahora es mejor que nunca\", \"frecuencia\")",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programaci칩n en Python"
    ]
  },
  {
    "objectID": "recursos/tutoriales/tutorial_03.html",
    "href": "recursos/tutoriales/tutorial_03.html",
    "title": "Arreglos manuales",
    "section": "",
    "text": "En este mini-tutorial se muestra como implementar un arreglo como estructura de dato sin utilizar las listas de Python. De este modo, tendremos que implementar nuestros propios m칠todos para leer, insertar, buscar y eliminar valores. Adem치s, tambi칠n tendremos que crear y administrar el bloque de memoria donde se almacenan los valores de manera manual. Utilizaremos el modulo est치ndar ctypes para crear un bloque de memoria contigua que contiene objetos de Python.\nimport ctypes\n\nclass Array:\n    \"\"\"Implementaci칩n b치sica de un array con ctypes.\"\"\"\n    def __init__(self, *args):\n        n = len(args)\n        self._n = n\n        self._capacidad = n * 2\n        self._elementos = self._crear_bloque_memoria(self._capacidad)\n        # &lt;1&gt; Reservamos un bloque de memoria contigua para 'self._capacidad' elementos\n\n        # Guardar los valores pasados en el bloque de memoria `_elementos`\n        for i in range(n):\n            self._elementos[i] = args[i]\n\n\n    def _crear_bloque_memoria(self, capacidad):\n        \"\"\"Crear un nuevo bloque de memoria contigua para `capacidad` objetos.\"\"\"\n        return (capacidad * ctypes.py_object)()\n\n\n    def _cambiar_capacidad(self, nueva_capacidad):\n        \"\"\"Copiar los datos a un nuevo bloque de memoria con otra capacidad (mayor).\"\"\"\n        if nueva_capacidad &lt; self._capacidad:\n            raise ValueError(\n                \"La nueva capacidad no puede ser menor que la anterior \"\n                f\"({nueva_capacidad} &lt; {self._capacidad}).\"\n            )\n\n        # Crear nuevo bloque de memoria\n        nuevos_elementos = self._crear_bloque_memoria(nueva_capacidad)\n\n        # Copiar elementos del bloque de memoria actual al nuevo\n        for i in range(self._n):\n            nuevos_elementos[i] = self._elementos[i]\n\n        # Sobreescribir el bloque de memoria actual y actualizar la capacidad\n        self._elementos = nuevos_elementos\n        self._capacidad = nueva_capacidad\n\n    def __len__(self):\n        # Permite llamar len(objeto) para obtener su longitud\n        return self._n\n\n    # Escribir\n    def write(self, indice, valor):\n        \"\"\"Escribir un valor en una posici칩n arbitraria\"\"\"\n        if not 0 &lt;= indice &lt;= self._n:\n            raise IndexError(\"칈ndice fuera de rango\")\n        self._elementos[indice] = valor\n\n    # Lectura\n    def get(self, indice):\n        \"\"\"Obtener elemento en una posici칩n determinada del arreglo.\"\"\"\n        if not 0 &lt;= indice &lt;= self._n:\n            raise IndexError(\"칈ndice fuera de rango\")\n        return self._elementos[indice]\n\n    # Inserci칩n\n    def insert(self, indice, valor):\n        \"\"\"Insertar elemento en una posici칩n, desplazando los siguientes.\"\"\"\n        if not 0 &lt;= indice &lt;= self._n:\n            raise IndexError(\"칈ndice fuera de rango\")\n\n        # Si no hay espacio, se duplica la capacidad\n        if self._n == self._capacidad:\n            self._cambiar_capacidad(2 * self._capacidad)\n\n        # Desplazar elementos hacia la derecha\n        for i in range(self._n, indice, -1):\n            self._elementos[i] = self._elementos[i - 1]\n\n        # Insertar elemento en la posici칩n deseada\n        self._elementos[indice] = valor\n\n        # Incrementar el conteo que mide la longitud del arreglo\n        self._n += 1\n\n    # B칰squeda\n    def index(self, valor):\n        \"\"\"Busca y devuelve la posici칩n donde se encuentra un valor en el array.\"\"\"\n        # Inspeccionar elementos uno a uno, hasta que se encuentre un valor igual a `valor`.\n        for i in range(self._n):\n            if self._elementos[i] == valor:\n                return i\n        return None\n\n    # Eliminaci칩n\n    ## Por 칤ndice\n    def pop(self, indice=None):\n        \"\"\"Elimina y devuelve el elemento en `indice` (por defecto, el 칰ltimo).\"\"\"\n        if self._n == 0:\n            raise IndexError(\"No se puede usar .pop en un arreglo vac칤o\")\n\n        if indice is None:\n            indice = self._n - 1\n\n        if not 0 &lt;= indice &lt; self._n:\n            raise IndexError(\"칈ndice fuera de rango\")\n\n        valor = self._elementos[indice]\n\n        # Desplazar hacia la izquierda los elementos posteriores al eliminado\n        for i in range(indice, self._n - 1):\n            self._elementos[i] = self._elementos[i + 1]\n\n        # Borrar referencia al 칰ltimo elemento y decrementar conteo\n        self._elementos[self._n - 1] = None\n        self._n -= 1\n\n        return valor\n\n    ## Por valor\n    def remove(self, valor):\n        \"\"\"Elimina la primera ocurrencia de `valor` en el array.\"\"\"\n        indice = self.index(valor)\n        if indice is not None:\n            # Desplazar hacia la izquierda los elementos posteriores al eliminado\n            for i in range(indice, self._n - 1):\n                self._elementos[i] = self._elementos[i + 1]\n\n            # Borrar referencia al 칰ltimo elemento y decrementar conteo\n            self._elementos[self._n - 1] = None\n            self._n -= 1\n            return None\n\n        raise ValueError(f\"{valor} no est치 en el array\")\n\n    def __repr__(self):\n        elementos = [str(self._elementos[i]) for i in range(self._n)]\n        return f\"Array({', '.join(elementos)})\"\nPodemos crear un arreglo con 3 n칰meros\narray = Array(10, 20, 30)\nprint(len(array))\nprint(array)\n3\nArray(10, 20, 30)\nUsamos .get para obtener el valor en una posici칩n:\narray.get(2)\n30\nSi queremos sobreescribir el valor en una posici칩n, usamos .write:\narray.write(2, 150)\narray\nArray(10, 20, 150)\nSi usamos .get con un 칤ndice fuera del rango, obtenemos un error:\narray.get(5)\nIndexError: 칈ndice fuera de rango\nSe pueden extraer elementos por posici칩n con .pop, que por defecto elimina y devuelve el valor en la 칰ltima posici칩n:\narray.pop()\n150\nY vemos que ahora se tiene un arreglo de longitud 2\nprint(len(array))\narray\n2\nArray(10, 20)\nTambi칠n es posible insertar elementos en una posici칩n determinada, lo que expande el arreglo:\narray.insert(1, 128)\narray.insert(1, 128)\narray\nArray(10, 128, 128, 20)\nY, finalmente, tambi칠n es posible eliminar elementos por valor:\narray.remove(10)\narray\nArray(128, 128, 20)\nSi inspeccionamos los detalles internos, como la capacidad del bloque de memoria reservado, tenemos:\narray._capacidad\n6\nAl insertar valores de forma tal que superamos la capacidad, vemos que esta se duplica:\narray.insert(0, 1)\narray.insert(0, 10)\narray.insert(0, 100)\narray.insert(0, 1000)\narray\nArray(1000, 100, 10, 1, 128, 128, 20)\narray._capacidad\n12",
    "crumbs": [
      "Recursos",
      "Tutoriales",
      "Arreglos manuales"
    ]
  },
  {
    "objectID": "recursos/tutoriales/tutorial_04.html",
    "href": "recursos/tutoriales/tutorial_04.html",
    "title": "Contenedores",
    "section": "",
    "text": "El objetivo de este mini-tutorial es implementar un contenedor de datos en Python para mostrar como funcionan los m칠todos __getitem__, __setitem__ e __iter__.\nDado un objeto obj, estos m칠todos especiales se llaman al ejecutarse las siguientes operaciones:\nobj[2]             # obj.__getitem__(2)\nobj[1] = 'cosa'    # obj.__setitem__(1, 'cosa')\niter(obj)          # obj.__iter__(), devuelve un iterador\nEste 칰ltimo se llama de manera impl칤cita cuando se recorre el contenedor con un bucle, po ejemplo:\nfor x in obj:\n    print(x)\nSupongamos que queremos implementar un contenedor que autom치ticamente convierte a todos sus elementos en cadenas de texto. Una implementaci칩n posible es la siguiente:\nclass ContenedorTexto:\n    def __init__(self, *valores):\n        self._datos = [str(x) for x in valores]\n\n    def __getitem__(self, indice):\n        return self._datos[indice]\n\n    def __setitem__(self, indice, valor):\n        self._datos[indice] = str(valor)\n\n    def __iter__(self):\n        return iter(self._datos)\nLuego, podemos utilizarla. Primero, creamos un objeto y accedemos al elemento 0:\ncontenedor = ContenedorTexto(22.1, 195, 13)\ncontenedor[0] # (por debajo, esto ejecuta `__getitem__(0)`)\n# '22.1'\nVemos que efectivamente es de tipo str, aunque hayamos pasado un float.\ntype(contenedor[0])\n# str\nComo el contenedor soparta el m칠todo __setitem__, podemos escribir valores en el contenedor:\ncontenedor[1] = 212 # (ejecuta `__setitem__(1, 212)`)\ncontenedor[1], type(contenedor[1])\n# ('212', str)\nFinalmente, podemos iterar a trav칠s de los elementos de nuestro contenedor:\nfor x in contenedor: # (necesita `__iter__()` para darle el iterador al 'for')\n    print(type(x), x)\n# &lt;class 'str'&gt; 22.1\n# &lt;class 'str'&gt; 212\n# &lt;class 'str'&gt; 13\nOtra opci칩n para el m칠todo __iter__ es implementar un generador manualmente:\n    def __iter__(self):\n        for x in self._datos:\n            yield x\nEn este caso no es necesario porque la lista, que es el tipo de datos de self._datos, soporta la funci칩n iter para devolver un iterable.",
    "crumbs": [
      "Recursos",
      "Tutoriales",
      "Contenedores"
    ]
  },
  {
    "objectID": "recursos/ejemplos/01_funciones_y_bucles.html",
    "href": "recursos/ejemplos/01_funciones_y_bucles.html",
    "title": "Funciones y bucles: Python vs R",
    "section": "",
    "text": "El siguiente bloque de c칩digo define una funci칩n en R:\n\n\nfuncion.R\n\nsumar &lt;- function(a, b) {\n  resultado &lt;- a + b\n  return(resultado)\n}\n\ny el siguiente define una funci칩n an치loga en Python:\n\n\nfuncion.py\n\ndef sumar(a, b):\n    resultado = a + b\n    return resultado",
    "crumbs": [
      "Recursos",
      "Ejemplos"
    ]
  },
  {
    "objectID": "recursos/ejemplos/01_funciones_y_bucles.html#funciones",
    "href": "recursos/ejemplos/01_funciones_y_bucles.html#funciones",
    "title": "Funciones y bucles: Python vs R",
    "section": "",
    "text": "El siguiente bloque de c칩digo define una funci칩n en R:\n\n\nfuncion.R\n\nsumar &lt;- function(a, b) {\n  resultado &lt;- a + b\n  return(resultado)\n}\n\ny el siguiente define una funci칩n an치loga en Python:\n\n\nfuncion.py\n\ndef sumar(a, b):\n    resultado = a + b\n    return resultado",
    "crumbs": [
      "Recursos",
      "Ejemplos"
    ]
  },
  {
    "objectID": "recursos/ejemplos/01_funciones_y_bucles.html#ejecuci칩n-condicional",
    "href": "recursos/ejemplos/01_funciones_y_bucles.html#ejecuci칩n-condicional",
    "title": "Funciones y bucles: Python vs R",
    "section": "Ejecuci칩n condicional",
    "text": "Ejecuci칩n condicional\nPor otro lado, el siguiente bloque muestra el uso de ejecuci칩n condicional en R:\n\n\ncondicional.R\n\nx &lt;- 5\n\nif (x &gt; 0) {\n  mensaje &lt;- \"El n칰mero es positivo\"\n} else {\n  mensaje &lt;- \"El n칰mero no es positivo\"\n}\n\nprint(mensaje)\n\nY debajo se muestra la versi칩n an치loga en Python:\n\n\ncondicional.py\n\nx = 5\n\nif x &gt; 0:\n    mensaje = \"El n칰mero es positivo\"\nelse:\n    mensaje = \"El n칰mero no es positivo\"\n\nprint(mensaje)",
    "crumbs": [
      "Recursos",
      "Ejemplos"
    ]
  },
  {
    "objectID": "recursos/ejemplos/01_funciones_y_bucles.html#resumen-de-diferencias",
    "href": "recursos/ejemplos/01_funciones_y_bucles.html#resumen-de-diferencias",
    "title": "Funciones y bucles: Python vs R",
    "section": "Resumen de diferencias",
    "text": "Resumen de diferencias\n\nComunes\n\nUso de bloques:\n\nEn R los bloques de c칩digo siempre se delimitan con llaves {}.\nEn Python los bloques se definen exclusivamente mediante indentaci칩n (sin llaves).\n\nIndentaci칩n:\n\nEn Python la indentaci칩n es obligatoria y tiene significado sint치ctico.\nEn R la indentaci칩n es opcional; sirve 칰nicamente para mejorar la legibilidad.\n\nUso de los dos puntos (:):\n\nEn Python las definiciones de funciones y condiciones terminan con :.\nEn R no se utilizan los dos puntos al final de estas estructuras.\n\n\n\n\nFunciones\n\nForma de definir la funci칩n:\n\nEn R: sumar &lt;- function(a, b). Se crea la funci칩n y se asigna a una variable.\nEn Python: def sumar(a, b):. La creaci칩n de la funci칩n ya crea la variable.\n\nRetorno de valores:\n\nEn R, aunque es com칰n usar return(), el resultado de la 칰ltima expresi칩n se devuelve autom치ticamente (puede omitirse return).\nEn Python es obligatorio usar return si se desea devolver un valor.\n\n\n\n\nEjecuci칩n condicional\n\nUso de par칠ntesis en condiciones:\n\nEn R es obligatorio usar par칠ntesis alrededor de la condici칩n (if (x &gt; 0)).\nEn Python no se usan par칠ntesis (if x &gt; 0:).",
    "crumbs": [
      "Recursos",
      "Ejemplos"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html",
    "href": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html",
    "title": "3 - Funciones de orden superior",
    "section": "",
    "text": "Las funciones de orden superior son una herramienta muy importante en la programaci칩n funcional. A lo largo de esta unidad, trabajaremos con las siguientes variedades de funciones de orden superior:\n\nFunciones que aceptan funciones como argumentos.\nFunciones que devuelven una funci칩n como resultado.\nFunciones que aceptan funciones como argumentos y devuelven una funci칩n como resultado.\n\nEn este cap칤tulo comenzamos enfoc치ndonos en las funciones de orden superior m치s elementales: map, filter y reduce; todas ellas reciben funciones como argumentos. Luego, aprenderemos sobre las comprehensions, que constituyen la alternativa moderna y Pythonica a las funciones mencionadas anteriormente. Finalmente, trabajaremos con funciones que devuelven funciones cuando exploremos evaluaci칩n parcial de funciones y el uso de decoradores.",
    "crumbs": [
      "Teor칤a",
      "U2 - Programaci칩n Funcional",
      "3 - Funciones de orden superior"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#introducci칩n",
    "href": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#introducci칩n",
    "title": "3 - Funciones de orden superior",
    "section": "",
    "text": "Las funciones de orden superior son una herramienta muy importante en la programaci칩n funcional. A lo largo de esta unidad, trabajaremos con las siguientes variedades de funciones de orden superior:\n\nFunciones que aceptan funciones como argumentos.\nFunciones que devuelven una funci칩n como resultado.\nFunciones que aceptan funciones como argumentos y devuelven una funci칩n como resultado.\n\nEn este cap칤tulo comenzamos enfoc치ndonos en las funciones de orden superior m치s elementales: map, filter y reduce; todas ellas reciben funciones como argumentos. Luego, aprenderemos sobre las comprehensions, que constituyen la alternativa moderna y Pythonica a las funciones mencionadas anteriormente. Finalmente, trabajaremos con funciones que devuelven funciones cuando exploremos evaluaci칩n parcial de funciones y el uso de decoradores.",
    "crumbs": [
      "Teor칤a",
      "U2 - Programaci칩n Funcional",
      "3 - Funciones de orden superior"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#pilares-fundamentales",
    "href": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#pilares-fundamentales",
    "title": "3 - Funciones de orden superior",
    "section": "Pilares fundamentales",
    "text": "Pilares fundamentales\nLas funciones map, filter y reduce son funciones de orden superior fundamentales en la programaci칩n funcional. Act칰an como primitivas b치sicas para procesar y transformar secuencias, y muchas otras operaciones funcionales pueden construirse a partir de ellas o expresarse en t칠rminos de estas.\nLas primeras dos, map y filter, est치n disponibles por defecto en nuestra sesi칩n de Python (ya que son funciones built-in), mientras que a reduce la tenemos que importar desde el m칩dulo est치ndar functools.\n\nMap\nSupongamos que tenemos una secuencia de palabras y queremos invertir el orden de los caracteres de cada una. Para ello, vamos a rebanadar cada cadena desde el principio al final usando un paso de -1. Por ejemplo:\n\n\"cosa\"[::-1]\n\n'asoc'\n\n\nSi quisi칠ramos obtener una lista con las palabras invertidas, podr칤amos crear una nueva lista, recorrer la original con un bucle for, invertir cada palabra y guardarla en la lista nueva.\n\npalabras = [\"hola\", \"mate\", \"somos\",\" libro\", \"conocer\", \"anilina\", \"programa\"]\npalabras_invertidas = []\n\nfor palabra in palabras:\n    palabras_invertidas.append(palabra[::-1])\n\nprint(\"Palabras originales:\", palabras, \"\\n\", sep=\"\\n\")\nprint(\"Palabras invertidas:\", palabras_invertidas, sep=\"\\n\")\n\nPalabras originales:\n['hola', 'mate', 'somos', ' libro', 'conocer', 'anilina', 'programa']\n\n\nPalabras invertidas:\n['aloh', 'etam', 'somos', 'orbil ', 'reconoc', 'anilina', 'amargorp']\n\n\nLa alternativa funcional consiste en utilizar map para aplicar una funci칩n a cada palabra de la secuencia. En este caso, aplicamos la funci칩n invertir, que invierte los caracteres de una palabra, a cada elemento de la lista palabras.\n\ndef invertir(x):\n    return x[::-1]\n\nlist(map(invertir, palabras))\n\n['aloh', 'etam', 'somos', 'orbil ', 'reconoc', 'anilina', 'amargorp']\n\n\nAs칤, se obtiene una nueva lista con las palabras invertidas, sin necesidad de iterar manualmente con un bucle for.\nSi quisi칠ramos que el programa fuese a칰n m치s conciso, podr칤amos usar una funci칩n an칩nima en vez de una funci칩n regular:\n\nlist(map(lambda x: x[::-1], palabras))\n\n['aloh', 'etam', 'somos', 'orbil ', 'reconoc', 'anilina', 'amargorp']\n\n\n\n\n\n\n\n\nEl objeto map 游댌\n\n\n\nEn el ejemplo anterior usamos list para convertir el resultado de map en una lista. Este paso, que puede parecer innecesario, es fundamental si queremos obtener una lista como resultado final. De lo contrario, la llamada a map devuelve un objeto de tipo map.\nmap(lambda x: x[::-1], palabras)\n&lt;map object at 0x7fd2fc1ad360&gt;\nEste objeto, perezoso e iterable, puede recorrerse o convertirse en otras colecciones como listas, tuplas o conjuntos:\nlist(map(lambda x: x[::-1], palabras))\n['aloh', 'etam', 'somos', 'orbil ', 'reconoc', 'anilina', 'amargorp']\n\n\n\nmap con datos complejos\nEn el ejemplo anterior se us칩 map sobre una secuencia simple de cadenas de texto. Sin embargo, eso no implica que su uso se limite a casos sencillos.\nSupongamos ahora que tenemos una lista anidada de n칰meros, es decir, una lista que contiene otras listas con valores num칠ricos:\n\nventas = [\n    [22.5, 9.3, 11.0],\n    [5.4, 22.5],\n    [3.0, 3.0, 12.9, 7.5],\n]\n\nSi queremos calcular el total de cada sublista, podemos combinar map con la funci칩n sum. Esto aplica sum a cada elemento de la lista ventas, generando como resultado una nueva lista con los totales de cada sublista.\n\nlist(map(sum, ventas))\n\n[42.8, 27.9, 26.4]\n\n\nDe manera similar, se puede obtener el m칤nimo, el m치ximo, la media u otra medida de inter칠s aplicando la funci칩n correspondiente a cada sublista.\nUsando una combinaci칩n m치s compleja de maps y expresiones lambda, se puede determinar cu치les sublistas de ventas contienen al menos un valor mayor a 20.\n\nlist(\n    map(\n        lambda sublista: any(map(lambda x: x &gt; 20,  sublista)),\n        ventas\n    )\n)\n\n[True, True, False]\n\n\nComo puede observarse, un programa que utiliza map junto con expresiones lambda puede volverse dif칤cil de leer y comprender r치pidamente, especialmente a medida que la l칩gica se vuelve m치s compleja.\nPara finalizar este listado de ejemplos, observemos uno donde se crea un diccionario a partir del map, en vez de una lista.\nSe cuenta con una lista de diccionarios. Cada diccionario contiene el nombre y las calificaciones de una persona. Nuestro objetivo es obtener un nuevo diccionario que tenga por claves al nombre de la persona, y por valor a la nota promedio.\n\nnotas = [\n    {\n        \"nombre\": \"Mariano\",\n        \"notas\": [6, 9, 9, 8]\n    },\n    {\n        \"nombre\": \"Daniela\",\n        \"notas\": [6, 7, 7, 8]\n    },\n    {\n        \"nombre\": \"Sof칤a\",\n        \"notas\": [8, 6, 9, 8]\n    },\n]\n\nSin utilizar un enfoque funcional, una soluci칩n posible es la siguiente:\n\ndef media(x):\n    return sum(x) / len(x)\n\npromedios = {}\n\nfor datum in notas:\n    promedios[datum[\"nombre\"]] = media(datum[\"notas\"])\n\npromedios\n\n{'Mariano': 8.0, 'Daniela': 7.0, 'Sof칤a': 7.75}\n\n\nEn cambio, utilizando map:\n\ndict(map(lambda datum: (datum[\"nombre\"], media(datum[\"notas\"])), notas))\n\n{'Mariano': 8.0, 'Daniela': 7.0, 'Sof칤a': 7.75}\n\n\nLa clave est치 en notar que la expresi칩n lambda devuelve una tupla de dos elementos, donde el primero es el nombre y el segundo, la nota promedio. A partir de estos pares (str, float), dict puede construir directamente un diccionario con los str en las claves y los float en los valores.\n\n\nmap con m칰ltiples iterabes\nHasta ahora hemos utilizado map con funciones que se aplican sobre los elementos de un 칰nico iterable. Sin embargo, map tambi칠n acepta m칰ltiples iterables y los recorre en paralelo, lo que la convierte en una funci칩n vari치dica. De este modo, se puede usar map para aplicar funciones que toman m치s de un argumento.\nSupongamos que queremos redondear un listado de n칰meros utilizando diferentes niveles de precisi칩n. Para redondear un 칰nico n칰mero podemos usar directamente round:\n\nround(29.12951138, 4)\n\n29.1295\n\n\nSi quisi칠ramos redonear m칰ltiples n칰meros en una lista, usando el mismo nivel de precisi칩n, podemos usar map y round:\n\nnumeros = [\n    30.60726375,\n    78.12297368,\n    61.94972186,\n    68.78842783,\n    55.60016942,\n    94.9760221,\n    90.41151716,\n    38.72727347,\n    21.30193307,\n    66.39407577\n]\nlist(map(lambda x: round(x, 3), numeros))\n\n[30.607, 78.123, 61.95, 68.788, 55.6, 94.976, 90.412, 38.727, 21.302, 66.394]\n\n\n쯏 si quisi칠ramos aplicar diferentes niveles de precisi칩n a cada n칰mero? Para ello, tambi칠n podemos usar map. Definimos una funci칩n que reciba dos argumentos y luego iteramos en paralelo sobre dos iterables: uno con los n칰meros y otro con las precisiones correspondientes.\n\nprecisiones = [2, 2, 3, 3, 4, 4, 5, 5, 2, 2]\nlist(map(lambda x, y: round(x, y), numeros, precisiones))\n\n[30.61, 78.12, 61.95, 68.788, 55.6002, 94.976, 90.41152, 38.72727, 21.3, 66.39]\n\n\n\n\n\n\n\n\n쯈u칠 pasa si un iterable es m치s corto que el otro? 游뱂\n\n\n\nCuando se recorren m칰ltiples iterables con map, la iteraci칩n se detiene tan pronto como se agota el iterable m치s corto. Por ejemplo, si tenemos 10 n칰meros pero solo 5 precisiones, map aplicar치 la funci칩n 칰nicamente a los primeros 5 pares de elementos:\nprecisiones = [1, 2, 3, 4, 5]\nlist(map(lambda x, y: round(x, y), numeros, precisiones))\n[30.6, 78.12, 61.95, 68.7884, 55.60017]\n\n\n\n\n\nFilter\nfilter se utiliza para seleccionar 닲, m치s precisamente, filtrar elementos de un iterable seg칰n el resultado de aplicar una funci칩n. A diferencia de map, la funci칩n usada por filter se aplica sobre los elementos de un solo iterable y debe devolver un valor booleano. El resultado es un nuevo iterable que contiene 칰nicamente los elementos para los que la funci칩n retorna True.\nComo ejemplo del uso de filter, vamos a seleccionar las notas menores a 6 a partir de una lista de calificaciones.\n\nnotas = [6, 9, 6, 5, 7, 4, 5, 8, 3, 10, 9, 4, 7, 8]\nlist(filter(lambda x: x &lt; 6, notas))\n\n[5, 4, 5, 3, 4]\n\n\nDe este modo, resulta sencillo calcular el promedio de las notas de aquellos que no aprobaron:\n\nmedia(list(filter(lambda x: x &lt; 6, notas)))\n\n4.2\n\n\nRetomando el ejemplo del listado de palabras que se quer칤an invertir, se podr칤a usar filter para seleccionar solo aquellas palabras que sean pal칤ndromos, es decir, capic칰a.\n\npalabras = [\"hola\", \"mate\", \"somos\",\" libro\", \"conocer\", \"anilina\", \"programa\"]\ncapicuas = list(filter(lambda p: p[::-1] == p, palabras))\ncapicuas\n\n['somos', 'anilina']\n\n\nNaturalmente, filter tambi칠n puede utilizarse para filtrar objetos m치s complejos. Por ejemplo, si tenemos una lista de diccionarios con informaci칩n de estudiantes (nombre, ciudad de origen, edad y fecha de inscripci칩n), podemos usar filter para seleccionar aquellos que cumplan una o m치s condiciones. En ese caso, el valor booleano que devuelve la funci칩n se construye combinando condiciones mediante operadores l칩gicos como and.\n\ndatos = [\n    {\"nombre\": \"Agustina\", \"ciudad\": \"Casilda\", \"edad\": 18, \"inscripcion\": 2025},\n    {\"nombre\": \"Emiliano\", \"ciudad\": \"Rosario\", \"edad\": 21, \"inscripcion\": 2024},\n    {\"nombre\": \"David\", \"ciudad\": \"Pergamino\", \"edad\": 19, \"inscripcion\": 2024},\n    {\"nombre\": \"Julieta\", \"ciudad\": \"Rosario\", \"edad\": 19, \"inscripcion\": 2025},\n    {\"nombre\": \"Victoria\", \"ciudad\": \"Cha침ar Ladeado\", \"edad\": 18, \"inscripcion\": 2025},\n    {\"nombre\": \"Fernando\", \"ciudad\": \"Rosario\", \"edad\": 20, \"inscripcion\": 2024},\n    {\"nombre\": \"Mateo\", \"ciudad\": \"P칠rez\", \"edad\": 23, \"inscripcion\": 2025},\n    {\"nombre\": \"Luc칤a\", \"ciudad\": \"Rosario\", \"edad\": 22, \"inscripcion\": 2022},\n    {\"nombre\": \"Joaqu칤n\", \"ciudad\": \"Casilda\", \"edad\": 19, \"inscripcion\": 2025},\n    {\"nombre\": \"Micaela\", \"ciudad\": \"Rosario\", \"edad\": 18, \"inscripcion\": 2024},\n]\n\nlist(filter(lambda x: x[\"ciudad\"] == \"Rosario\" and x[\"inscripcion\"] == 2025, datos))\n\n[{'nombre': 'Julieta', 'ciudad': 'Rosario', 'edad': 19, 'inscripcion': 2025}]\n\n\n\n\nReduce\nLa funci칩n reduce permite reducir una secuencia a un 칰nico valor aplicando de forma sucesiva una funci칩n de dos argumentos sobre sus elementos.\nPara utilizarla, es necesario importarla desde el m칩dulo est치ndar functools:\n\nfrom functools import reduce\n\nreduce aplica la funci칩n acumulando resultados de a pares, desde el primer elemento hasta el 칰ltimo. Por ejemplo:\nreduce(lambda x, y: x + y, [1, 2, 3, 4, 5])\nequivale a:\n((((1 + 2) + 3) + 4) + 5)\nEn este caso, es simplemente una forma m치s rebuscada de escribir sum([1, 2, 3, 4, 5]) en Python.\nPara entender c칩mo funciona el proceso de acumulaci칩n en reduce, podemos definir una funci칩n que imprima los valores de sus argumentos en cada paso:\n\ndef sumar(x, y):\n    print(f\"x={x}, y={y}\")\n    return x + y\n\nreduce(sumar, [1, 2, 3, 4, 5])\n\nx=1, y=2\nx=3, y=3\nx=6, y=4\nx=10, y=5\n\n\n15\n\n\nEn la primera llamada, x e y son los dos primeros elementos de la secuencia. En la segunda, x es el resultado de la llamada anterior, e y es el siguiente elemento de la secuencia. Este proceso contin칰a hasta que se recorre toda la lista. En resumen:\n\nx representa el valor acumulado hasta el momento, e\ny es el nuevo elemento a combinar.\n\nAs칤, reduce va aplicando la funci칩n paso a paso, acumulando resultados hasta obtener un 칰nico valor final.\nMuchas operaciones comunes, como sumas, productos, m칤nimos o m치ximos, pueden expresarse mediante reducciones. Por ejemplo, es posible calcular el factorial de un n칰mero utilizando una reduce:\n\ndef factorial(n):\n    return reduce(lambda x, y: x * y, range(1, n + 1))\n\nfactorial(5)\n\n120\n\n\nLa reducci칩n mediante la multiplicaci칩n de dos n칰meros, aplicada a la secuencia del 1 al n, da como resultado el factorial de n.\nFinalmente, podemos ver que combinando una funci칩n que devuelve el mayor de dos n칰meros y una reducci칩n, es posible obtener el m치ximo de una secuencia.\n\ndef mayor(x, y):\n    if x &gt; y:\n        return x\n    return y\n\nreduce(mayor, [23, 49, 6, 32, 101, 9])\n\n101\n\n\nVale la pena mencionar que reduce acepta un tercer argumento opcional, que especifica el valor inicial de la reducci칩n. Este valor se utiliza como punto de partida antes de procesar los elementos del iterable.\n\ndef sumar(x, y):\n    print(f\"x={x}, y={y}\")\n    return x + y\n\nreduce(sumar, [1, 2, 3, 4, 5], 20)\n\nx=20, y=1\nx=21, y=2\nx=23, y=3\nx=26, y=4\nx=30, y=5\n\n\n35\n\n\n\n\n\n\n\n\nExpresiones condicionales 游游땸\n\n\n\nLa reducci칩n anterior puede expresarse de forma m치s concisa utilizando expresiones condicionales:\nreduce(lambda x, y: x if x &gt; y else y, [23, 49, 6, 32, 101, 9])\nEstas expresiones permiten simplificar asignaciones condicionales. Por ejemplo, el siguiente bloque:\nif x &gt; y:\n    valor = x\nelse:\n    valor = y\npuede escribirse de manera m치s compacta as칤:\nvalor = x if x &gt; y else y\nEn t칠rminos generales, la sintaxis es:\n&lt;valor_si_verdadero&gt; if &lt;condici칩n&gt; else &lt;valor_si_falso&gt;\n\n\n\n\nResumen\nEl siguiente bloque de c칩digo resume el funcionamiento de map, filter y reduce.\n\nnumeros = [1, 2, 3, 4, 5]\n\n# Map: Aplicar una funci칩n a cada elemento de un iterable\ncuadrados = list(map(lambda x: x**2, numeros))\nprint(\"Map [cuadrados]:\", cuadrados)\n\n# Filter: Devuelve el subconjunto de elementos para los que la funci칩n devuelve True\npares = list(filter(lambda x: x % 2 == 0, numeros))\nprint(\"Filter [pares]:\", pares)\n\n# Reduce: Aplica una funci칩n de dos argumentos de manera acumulativa a los elementos de una secuencia\nproducto = reduce(lambda x, y: x * y, numeros)\nprint(\"Reduce [producto]:\", producto)\n\nMap [cuadrados]: [1, 4, 9, 16, 25]\nFilter [pares]: [2, 4]\nReduce [producto]: 120\n\n\n\nMap y filter como casos particulares de reduce 游땸\nPor otro lado, algo menos evidente es que tanto map como filter pueden verse como casos particulares de reduce.\nEsta aplicaci칩n de map:\n\nlist(map(lambda x: x * 2, range(10)))\n\n[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n\n\nPuede ser reproducida con el siguiente uso de reduce:\n\ndef dup(x):\n    return x * 2\n\nreduce(lambda seq, x: seq + [dup(x)], range(10), [])\n\n[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n\n\nY el siguiente uso de filter\n\nlist(filter(lambda x: x % 2 == 1, range(10)))\n\n[1, 3, 5, 7, 9]\n\n\nSe puede expresar tambi칠n con reduce:\n\ndef es_impar(x):\n    return x % 2 == 1\n\nreduce(lambda seq, x: seq + [x] if es_impar(x) else seq, range(10), [])\n\n[1, 3, 5, 7, 9]\n\n\nEstas expresiones con reduce() son complejas, pero ilustran claramente el poder de la funci칩n: cualquier operaci칩n que pueda definirse a partir de una combinaci칩n sucesiva de elementos puede, al menos en principio, expresarse como una reducci칩n, aunque no siempre sea la forma m치s clara o recomendada de hacerlo.",
    "crumbs": [
      "Teor칤a",
      "U2 - Programaci칩n Funcional",
      "3 - Funciones de orden superior"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#comprehensions",
    "href": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#comprehensions",
    "title": "3 - Funciones de orden superior",
    "section": "Comprehensions",
    "text": "Comprehensions\nCuando usamos map y filter obtenemos objetos especiales: map devuelve un objeto de tipo map, y filter devuelve un objeto de tipo filter. Estos objetos son iterables y perezosos, lo que significa que no realizan ninguna operaci칩n hasta que se los recorre o convierte en una colecci칩n, como una lista. Por eso, si queremos ver directamente el resultado de una transformaci칩n o filtrado, necesitamos envolverlos con list():\nnumeros = [1, 2, 3]\nlist(map(lambda x: x * 2, numeros))          #  [2, 4, 6]\nlist(filter(lambda x: x % 2 == 0, numeros))  #  [2]\nAunque map y filter siguen siendo completamente v치lidos y 칰tiles, hoy en d칤a se consideran formas anticuadas o menos idiom치ticas de construir listas transformadas o filtradas en Python.\nLa alternativa moderna y, en general preferida, son las comprensiones de listas (del ingl칠s, list comprehensions), que permiten expresar las mismas ideas de forma m치s clara y legible:\n\nnumeros = list(range(11))\n[x * 2 for x in numeros] # Reemplaza a list(map(...))\n\n[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n\n\n\n[x for x in numeros if x % 2 == 0] # Reemplaza a list(filter(...))\n\n[0, 2, 4, 6, 8, 10]\n\n\n\nComprehension como reemplazo de map\nSupongamos que tenemos una lista de n칰meros y queremos restarles su media.\nUna forma de hacerlo utilizando un bucle for es:\n\nvector = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]\n\nmedia = media(vector)\nvector_centrado = []\nfor x in vector:\n    vector_centrado.append(x - media)\n\nvector_centrado\n\n[-4.5, -3.5, -2.5, -1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5]\n\n\nSi, en cambio, decidimos usar map, podemos hacer:\n\nlist(map(lambda x: x - media, vector))\n\n[-4.5, -3.5, -2.5, -1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5]\n\n\nFinalmente, se puede obtener el mismo resultado usando una list comprehension:\n\n[x - media for x in vector]\n\n[-4.5, -3.5, -2.5, -1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5]\n\n\nLa sintaxis general de una list comprehension que aplica una transformaci칩n sobre los elementos de un iterable es:\n[&lt;expresi칩n&gt; for elemento in iterable]\nComo se observa en el ejemplo anterior, lo que aparece en la parte izquierda como &lt;expresi칩n&gt; no tiene por qu칠 ser una llamada a una funci칩n; puede ser cualquier expresi칩n v치lida que produzca un resultado. Es decir, una operaci칩n matem치tica, un formateo de texto, la construcci칩n de una estructura de datos, una llamada a una funci칩n, etc.\n\n\nComprehension como reemplazo de filter\nAhora veamos con mayor detalle c칩mo funciona una list comprehension que reemplaza al uso de filter. Para eso, retomemos el ejemplo de las palabras capic칰a.\n\npalabras = [\"hola\", \"mate\", \"somos\",\" libro\", \"conocer\", \"anilina\", \"programa\"]\n\nInicialmente, podemos construir un listado de palabras capic칰a usando un bucle for.\n\ncapicuas = []\nfor palabra in palabras:\n    if palabra == palabra[::-1]:\n        capicuas.append(palabra)\ncapicuas\n\n['somos', 'anilina']\n\n\nLuego, podemos construir el listado de palabras capic칰a usando la funci칩n de orden superior filter.\n\nlist(filter(lambda x: x == x[::-1], palabras))\n\n['somos', 'anilina']\n\n\nY finalmente, se puede obtener exactamente el mismo resultado mediante una list comprehension.\n\n[palabra for palabra in palabras if palabra == palabra[::-1]]\n\n['somos', 'anilina']\n\n\nLa sintaxis general de una list comprehension que filtra los elementos de un iterable es:\n[elemento for elemento in iterable if &lt;expresi칩n_l칩gica&gt;]\nAl igual que en la list comprehension que aplica funciones a todos los ementos, &lt;expresi칩n_l칩gica&gt; puede ser cualquier expresi칩n de Python que devuelva un valor True o False, o que pueda interpretarse como tal.\nTambi칠n podr칤a usarse una list comprehension que transforme elementos filtrados de un iterable:\n[&lt;expresi칩n&gt; for elemento in iterable if &lt;expresi칩n_l칩gica&gt;]\nPor ejemplo:\n\n# Multiplica por 2 a los numeros impares de `range(5)`\n[x * 2 for x in range(5) if x % 2]\n\n[2, 6]\n\n\n\n\n\n\n\n\nComprehensions con expresiones condicionales 游땸\n\n\n\nLa estructura general:\n[elemento for elemento in iterable if &lt;expresi칩n_l칩gica&gt;]\npuede modificarse cuando se desea evaluar una expresi칩n en caso de que se cumpla una condici칩n y otra distinta si no se cumple. Para ello, se usa una expresi칩n condicional directamente en la parte izquierda de la comprensi칩n:\n[&lt;expresi칩n_si_verdadero&gt; if &lt;condici칩n&gt; else &lt;expresi칩n_si_falso&gt; for elemento in iterable]\nPor ejemplo:\nnumeros = [1, 2, 3, 4, 5]\n[f\"{x} es par\" if x % 2 == 0 else f\"{x} es impar\" for x in numeros]\n['1 es impar', '2 es par', '3 es impar', '4 es par', '5 es impar']\n\n\n\n\n\n\n\n\nDictionary comprehensions 游땸游땸\n\n\n\nLas comprensiones en Python no est치n limitadas a listas. Este patr칩n tambi칠n puede utilizarse para construir otras estructuras de datos como diccionarios, conjuntos e incluso generadores (estructura que veremos m치s adelante).\nPor ejemplo, una comprensi칩n de diccionario permite crear un dict a partir de una secuencia de pares clave-valor:\ndef media(x):\n    return sum(x) / len(x)\n\ndatos = [\n    (\"Marcos\", (4, 8, 9, 9)),\n    (\"Joaqu칤n\", (10, 8, 8, 7)),\n    (\"Luj치n\", (10, 9, 9, 10)),\n]\n\n{nombre: media(notas) for nombre, notas in datos}\n{'Marcos': 7.5, 'Joaqu칤n': 8.25, 'Luj치n': 9.5}",
    "crumbs": [
      "Teor칤a",
      "U2 - Programaci칩n Funcional",
      "3 - Funciones de orden superior"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#evaluaci칩n-parcial-de-funciones",
    "href": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#evaluaci칩n-parcial-de-funciones",
    "title": "3 - Funciones de orden superior",
    "section": "Evaluaci칩n parcial de funciones",
    "text": "Evaluaci칩n parcial de funciones\nEn Fundamentos comenzamos a trabajar con function factories, es decir, con funciones que definen y devuelven funciones. El ejemplo que vimos consist칤a en la funci칩n crear_multiplicador que recib칤a un m칰ltiplo y devolv칤a una funci칩n de un argumento que al llamarla realizaba la multiplcaci칩n. As칤, era posible crear funciones para duplicar, triplicar, cuadruplicar, etc.\n\ndef crear_multiplicador(x):\n    def interna(y):\n        return y * x\n    return interna\n\nduplicar = crear_multiplicador(2)\ntriplicar = crear_multiplicador(3)\n\nprint(duplicar(10), triplicar(22))\n\n20 66\n\n\nAhora bien, esta no es la 칰nica forma de crear funciones que multipliquen dos numeros dejando uno de sus argumentos fijo.\nUna alternativa consiste en crear una funci칩n general de multiplicaci칩n y usar partial del m칩dulo functools para obtener una versi칩n de la misma con alguno de sus argumentos fijados.\n\ndef multiplicar(x, y):\n    return x * y\n\nmultiplicar(7, 8)\n\n56\n\n\n\nfrom functools import partial\n\ncuadruplicar = partial(multiplicar, 4)\ncuadruplicar(2)\n\n8\n\n\nEn esencia, partial toma una funci칩n y fija algunos de sus par치metros, devolviendo una nueva funci칩n con argumentos ya establecidos. Dicho de otro modo, partial produce una funci칩n parcialmente evaluada, de ah칤 su nombre.\nDe un modo similar, se podr칤an crear funciones de potencia a partir de una funci칩n gen칠rica.\n\ndef potencia(x, n):\n    return x ** n\n\ncuadrado = partial(potencia, n=2)\ncubo = partial(potencia, n=3)\n\nprint(cuadrado(5), cubo(9))\n\n25 729\n\n\nMediante un ejemplo podemos ver que partial tambi칠n permite fijar m치s de un par치metro. Supongamos que tenemos una lista de n칰meros que queremos estandarizar; es decir, restarles la media y dividir cada valor por el desv칤o.\n\nnums = [\n    4.74346239e-01, -2.90877176e-01, -1.44377789e+00, -4.48680759e+01,\n    -1.21249801e+00, -3.32729317e-01,  2.21676912e-01,  1.05599711e+00,\n    -3.62372053e+00, -2.96441579e-01, -4.28304222e+00,  1.55908820e+02,\n    9.00858234e-01, -1.09384173e+00, -1.51083571e+00, -5.38491167e-01,\n    -3.84153084e-02,  1.20393395e+00,  1.82651406e-01,  2.05179405e+00\n]\n\ndef media(x):\n    return sum(x) / len(x)\n\ndef varianza(x):\n    numerador = 0\n    x_media = media(x)\n    for x_i in x:\n        numerador += (x_i - x_media) ** 2\n    return numerador / len(x)\n\nestandarizar = partial(\n1    lambda x, media, desvio: (x - media) / desvio,\n2    media=media(nums),\n    desvio=varianza(nums) ** 0.5\n)\n\n\n1\n\nDefinimos una funci칩n lambda que implementa la estandarizaci칩n. Esta funci칩n recibe el valor a estandarizar, la media y el desv칤o correspondientes.\n\n2\n\nCalculamos la media y el desv칤o de la lista, y luego los pasamos a partial como par치metros a fijar.\n\n\n\n\nDe esta manera, obtenemos la funci칩n estandarizar, que al recibir un n칰mero le resta la media y lo divide por el desv칤o calculado a partir de nums.\n\nestandarizar(nums[0])\n\n-0.12933243764138067\n\n\nY, si queremos estandarizar toda la secuencia, podemos usar una list comprehension.\n\n[estandarizar(num) for num in nums]\n\n[-0.12933243764138067,\n -0.1506204085674334,\n -0.18269328610772323,\n -1.390726359064761,\n -0.17625924440864513,\n -0.15178470535100874,\n -0.13636151853677025,\n -0.1131513242720763,\n -0.24333773925841856,\n -0.1507752062996549,\n -0.2616795995472022,\n 4.1947440261328905,\n -0.11746717741646615,\n -0.1729583111265218,\n -0.1845587869464874,\n -0.1575088536123251,\n -0.1435970990449382,\n -0.10903582664474336,\n -0.13744718034588063,\n -0.08544896194045284]\n\n\n\n\n\n\n\n\nArgumentos posicionales y nombrados 游댝游낑勇끂n\n\n\npartial puede utilizarse para fijar tanto argumentos posicionales como nombrados. Cuando recibe argumentos posicionales, estos se transmiten a la funci칩n original en el mismo orden; mientras que, si se le pasan argumentos nombrados, se reenv칤an como tales.\nPor ejemplo, las siguientes llamadas a partial generan funciones equivalentes:\ndef prod(x, y):\n    return x * y\n\npartial(prod, 5)     # 5 * y\npartial(prod, x=5)   # 5 * y\npartial(prod, y=5)   # x * 5",
    "crumbs": [
      "Teor칤a",
      "U2 - Programaci칩n Funcional",
      "3 - Funciones de orden superior"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#decoradores",
    "href": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#decoradores",
    "title": "3 - Funciones de orden superior",
    "section": "Decoradores",
    "text": "Decoradores\nEn Ciudadanos de primera clase aprendimos que las funciones son un objeto como cualquier otro. Por eso, ya no nos sorprende que puedan pasarse como argumento a otra funci칩n o devolverse como resultado de otra funci칩n.\nAhora vamos a explorar un tipo de funciones que son muy 칰tiles en Python: los decoradores.\nLos decoradores son funciones que 란nvuelven o 란ncapsulan funciones y modifican su comportamiento.\nEmpecemos con un ejemplo: la funci칩n decorador recibe una funci칩n fun, define una funci칩n envoltura que contiene una llamada a fun y la devuelve.\n\ndef decorador(fun):\n\n    def envoltura():\n        print(\"Antes de llamar a la funci칩n...\")\n        fun()\n        print(\"Listo, ya se llam칩 a la funci칩n.\")\n\n    return envoltura\n\nPara mostrar el funcionamiento del decorador, definamos una funci칩n muy sencilla, que simplemente imprime un saludo.\n\ndef decir_hola():\n    print(\"춰Hola hola!\")\n\ndecir_hola()\n\n춰Hola hola!\n\n\nAhora, invocamos a decorador pasandole la funci칩n decir_hola y obtenemos una nueva una funci칩n.\nPodemos ver que esta nueva funci칩n es la funci칩n envoltura definida dentro del decorador.\n\nnueva = decorador(decir_hola)\nnueva\n\n&lt;function __main__.decorador.&lt;locals&gt;.envoltura()&gt;\n\n\nAntes de ejecutar la funci칩n nueva, intentemos anticipar qu칠 va a ocurrir cuando la llamemos.\nAl invocar nueva, se ejecutar치n las siguientes tres l칤neas de c칩digo:\n1print(\"Antes de llamar a la funci칩n...\")\n2fun()\n3print(\"Listo, ya se llam칩 a la funci칩n.\")\n\n1\n\nLa primera l칤nea contiene directamente un print, por lo que podemos anticipar que lo primero que vamos a ver es un mensaje que dice \"Antes de llamar a la funci칩n...\".\n\n2\n\nLa segunda l칤nea contiene una llamada a la funci칩n fun. Esta es la funci칩n que le pasamos a decorador al momento de crear nueva, es decir, es la funci칩n decir_hola.\nPor lo tanto, habr치 un segundo mensaje que dice \"춰Hola hola!\".\n\n3\n\nFinalmente, se ejecuta la tercera l칤nea, y como vemos que es un print, sabemos que vamos a ver un mensaje que dice \"Listo, ya se llam칩 a la funci칩n.\".\n\n\n\nnueva()\n\nAntes de llamar a la funci칩n...\n춰Hola hola!\nListo, ya se llam칩 a la funci칩n.\n\n\nEn este ejemplo vemos que el decorador 란nvuelve o 란ncapsula a la funci칩n decir_hola. Gracias a esto, la funci칩n decorada ya no se ejecuta como antes, sino que ahora tambi칠n imprime mensajes antes y despu칠s de realizar la tarea en su definici칩n original.\n\nDecoradores que reciben argumentos\nSi intentamos pasarle argumentos a la funci칩n nueva, obtendremos un error. Este error no se debe a que la funci칩n decorada, decir_hola, no acepte par치metros, sino a que la funci칩n que devuelve el decorador, envoltura, no est치 preparada para recibirlos.\nAhora bien, si queremos que nuestra funci칩n de envoltura pueda transmitir argumentos a la funci칩n decorada, necesitamos un mecanismo flexible. No podemos conocer de antemano qu칠 par치metros recibir치 la funci칩n a decorar, justamente porque no sabemos cu치l ser치 esa funci칩n.\nLa soluci칩n es definir envoltura de manera que acepte una cantidad arbitraria de argumentos posicionales y nombrados. De esta forma, podemos propagar todos esos argumentos a la funci칩n decorada sin importar cu치les sean.\n\ndef decorador(fun):\n\n1    def envoltura(*args, **kwargs):\n        if args:\n            print(\"Argumentos posicionales:\", args)\n        if kwargs:\n            print(\"Argumentos nombrados:\", kwargs)\n2        fun(*args, **kwargs)\n\n    return envoltura\n\ndef potencia(x, n):\n    return x ** n\n\npotencia = decorador(potencia)\n\n\n1\n\nenvoltura recibe una cantidad arbitraria de argumentos posicionales y nombrados.\n\n2\n\nCuando se llama a fun, se le pasan todos los argumentos posicionales y nombrados recibidos.\n\n\n\n\n\npotencia(5, 3)\n\nArgumentos posicionales: (5, 3)\n\n\n\npotencia(5, n=3)\n\nArgumentos posicionales: (5,)\nArgumentos nombrados: {'n': 3}\n\n\n\npotencia(x=5, n=3)\n\nArgumentos nombrados: {'x': 5, 'n': 3}\n\n\nEl ejemplo muestra que el decorador imprime los argumentos de la funci칩n original, tanto posicionales como nombrados, siempre que se le haya pasado alguno.\n\n\nDecoradores que devuelven valores\nSi bien el decorador anterior funcionaba correctamente con funciones que reciben tanto argumentos posicionales como nombrados, no vemos que la funci칩n decorada devuelva la potencia calculada. Para que eso ocurra, la envoltura no solo tiene que llamar a fun, sino tambi칠n retornar lo que esta retorne.\n\ndef decorador(fun):\n\n    def envoltura(*args, **kwargs):\n        if args:\n            print(\"Argumentos posicionales:\", args)\n        if kwargs:\n            print(\"Argumentos nombrados:\", kwargs)\n1        return fun(*args, **kwargs)\n\n    return envoltura\n\ndef potencia(x, n):\n    return x ** n\n\n\n1\n\nGracias a esta l칤nea, la funci칩n envoltura retorna lo que sea que fun retorne.\n\n\n\n\n\npotencia = decorador(potencia)\npotencia(x=5, n=3)\n\nArgumentos nombrados: {'x': 5, 'n': 3}\n\n\n125\n\n\n\n\nAz칰car sint치ctico\nDado que los decoradores cumplen un rol muy importante en la programaci칩n con Python, el lenguaje ofrece una sintaxis especial para aplicarlos directamente al momento de definir una funci칩n.\nPara ello, basta con escribir @&lt;nombre_decorador&gt; en la l칤nea anterior a la definici칩n de la funci칩n. Por ejemplo:\n\n@decorador\ndef producto(x, y):\n    return x * y\n\nproducto(3, 7)\n\nArgumentos posicionales: (3, 7)\n\n\n21\n\n\n\nproducto(x=3, y=7)\n\nArgumentos nombrados: {'x': 3, 'y': 7}\n\n\n21\n\n\nDe esta manera, no es necesario incluir l칤neas adicionales del estilo:\ndef funcion(...):\n    ...\n    return ...\n\nfuncion = decorador(funcion)\nA este tipo de atajos sint치cticos que brinda el lenguaje se los conoce como az칰car sint치ctico (del ingl칠s, syntax sugar).\n\n\nEjemplo: medir tiempo de ejecuci칩n\nHasta ahora, los ejemplos que vimos fueron un tanto artificiales, pensados 칰nicamente para mostrar qu칠 son los decoradores y c칩mo se utilizan. A continuaci칩n, presentamos un ejemplo m치s cercano a un uso pr치ctico.\nEl decorador timer imprime el tiempo de ejecuci칩n que le toma a una funci칩n. Luego, lo aplicamos para comparar los tiempos entre la funci칩n built-in max y otra implementaci칩n que obtiene el m치ximo mediante una reducci칩n.\n\nimport time\n\ndef timer(fun):\n    def envoltura(*args, **kwargs):\n        inicio = time.time()\n        resultado = fun(*args, **kwargs)\n        fin = time.time()\n        print(f\"{fun.__name__} demor칩 {fin - inicio:6f} segundos\")\n        return resultado\n    return envoltura\n\n\ndef mayor(x, y):\n    if x &gt; y:\n        return x\n    return y\n\n@timer\ndef maximo_reduce(x):\n    return reduce(mayor, x)\n\n@timer\ndef maximo_builtin(x):\n    return max(x)\n\n\nlista = list(range(1_000_000))\n\nmaximo_reduce(lista)\n\nmaximo_reduce demor칩 0.044118 segundos\n\n\n999999\n\n\n\nmaximo_builtin(lista)\n\nmaximo_builtin demor칩 0.017050 segundos\n\n\n999999",
    "crumbs": [
      "Teor칤a",
      "U2 - Programaci칩n Funcional",
      "3 - Funciones de orden superior"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/02_recursion.html",
    "href": "teoria/02_programacion_funcional/02_recursion.html",
    "title": "2 - Recursi칩n",
    "section": "",
    "text": "En el apunte anterior vimos que en Python las funciones son ciudadanos de primera clase. Esto significa que una funci칩n es un objeto, al igual que un n칰mero, una cadena de texto o incluso un diccionario anidado con una estructura bastante enredada. Gracias a esto, no solo podemos inspeccionar sus atributos o hacer que una funci칩n llame a otras, sino que tambi칠n es posible que una funci칩n cree y retorne nuevas funciones.\nAdem치s de los casos ya mencionados, tambi칠n es posible que una funci칩n se llame a s칤 misma. Es decir, que en el cuerpo de la definici칩n de esa funci칩n se incluya una llamada a la funci칩n que se est치 definiendo (游뱚). A este tipo de funciones se las llama recursivas, y la t칠cnica en s칤 recibe el nombre de recursi칩n.\nAunque pueda sonar extra침o que una funci칩n se invoque a s칤 misma, en programaci칩n existen problemas para los que funciones recursivas resultan una soluci칩n natural y efectiva.",
    "crumbs": [
      "Teor칤a",
      "U2 - Programaci칩n Funcional",
      "2 - Recursi칩n"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/02_recursion.html#introducci칩n",
    "href": "teoria/02_programacion_funcional/02_recursion.html#introducci칩n",
    "title": "2 - Recursi칩n",
    "section": "",
    "text": "En el apunte anterior vimos que en Python las funciones son ciudadanos de primera clase. Esto significa que una funci칩n es un objeto, al igual que un n칰mero, una cadena de texto o incluso un diccionario anidado con una estructura bastante enredada. Gracias a esto, no solo podemos inspeccionar sus atributos o hacer que una funci칩n llame a otras, sino que tambi칠n es posible que una funci칩n cree y retorne nuevas funciones.\nAdem치s de los casos ya mencionados, tambi칠n es posible que una funci칩n se llame a s칤 misma. Es decir, que en el cuerpo de la definici칩n de esa funci칩n se incluya una llamada a la funci칩n que se est치 definiendo (游뱚). A este tipo de funciones se las llama recursivas, y la t칠cnica en s칤 recibe el nombre de recursi칩n.\nAunque pueda sonar extra침o que una funci칩n se invoque a s칤 misma, en programaci칩n existen problemas para los que funciones recursivas resultan una soluci칩n natural y efectiva.",
    "crumbs": [
      "Teor칤a",
      "U2 - Programaci칩n Funcional",
      "2 - Recursi칩n"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/02_recursion.html#cuenta-regresiva",
    "href": "teoria/02_programacion_funcional/02_recursion.html#cuenta-regresiva",
    "title": "2 - Recursi칩n",
    "section": "Cuenta regresiva",
    "text": "Cuenta regresiva\nSupongamos que queremos crear una funci칩n que imprima una cuenta regresiva desde un n칰mero entero dado hasta el 0. Es decir, la funci칩n se deber칤a comportar de la siguiente manera:\nregresiva(3)\n3\n2\n1\n0\nregresiva(5)\n5\n4\n3\n2\n1\n0\nUna implementaci칩n no recursiva es la siguiente, basada en un bucle while:\ndef regresiva(n):\n    while n &gt; 0:\n        print(n)\n        n = n - 1\nOtra alternativa, que usa un bucle for y un range es:\ndef regresiva(n):\n    for i in range(n, -1, -1):\n        print(i)\nAmbas implementaciones resultan en funciones que se comportan correctamente y producen el resultado deseado.\nSin embargo, existe una alternativa recursiva para obtener la secuencia de n칰meros deseados.\n\ndef regresiva(i):\n    print(i)\n1    if i &gt; 0:\n        regresiva(i - 1)\n2    else:\n        return\n\n\n1\n\nEl caso recursivo: Es la condici칩n donde la funci칩n se llama a s칤 misma. En este caso, regresiva vuelve a llamarse a s칤 misma solo cuando el n칰mero impreso sea mayor que 0. La llamada se hace pasando como argumento el valor i - 1, lo que nos acerca progresivamente al caso base.\n\n2\n\nEl caso base: Es la condici칩n que detiene la recursi칩n. Cuando se cumple, la funci칩n devuelve un valor sin volver a llamarse a s칤 misma, lo que evita que la ejecuci칩n contin칰e de manera infinita.\n\n\n\n\nAmbos casos trabajan en conjunto. Por un lado, el caso recursivo es la parte de la funci칩n que se llama a s칤 misma, pero con una entrada modificada que se acerca progresivamente al caso base. Por el otro, el caso base es la condici칩n que detiene las llamadas recursivas, representando la versi칩n m치s simple del problema que puede ser resuelta directamente.\n\nregresiva(3)\n\n3\n2\n1\n0\n\n\n\nregresiva(5)\n\n5\n4\n3\n2\n1\n0\n\n\n\n\n\n\n\n\nVersi칩n con return impl칤cito\n\n\n\nLa funci칩n recursiva regresiva usa return para terminar su ejecuci칩n devolviendo un None impl칤cito en el caso base. Otra forma de implementar la misma funci칩n es omitiendo el return:\ndef regresiva(i):\n    print(i)\n    if i &gt; 0:\n1        regresiva(i - 1)\n2\n\n1\n\nEsta l칤nea marca el caso recursivo y es id칠ntica a la anterior.\n\n2\n\nAc치 no se usa return para devolver None, directamente no se escribe nada. El efecto es el mismo y constituye el caso base. En Python, si una funci칩n no incluye ning칰n return, se comporta como si al final hubiera un return o return None, es decir, la funci칩n termina y devuelve None.\n\n\n\n\n\nVersi칩n comentada\nPara entender mejor el funcionamiento de la funci칩n recursiva progresiva, se pueden incorporar unos print en el cuerpo de la misma. En el ejemplo de abajo se muestra un print justo cuando la funci칩n es llamada, y otro cuando la funci칩n vuelve a invocarse a s칤 misma.\ndef regresiva(i):\n    print(f\"regresiva({i})\")\n    print(i)\n    if i &gt; 0:\n        print(f\"regresiva({i}) --&gt; regresiva({i -1})\")\n        regresiva(i - 1)\n\nregresiva(2)\n1regresiva(2)\n22\n3regresiva(2) --&gt; regresiva(1)\n4regresiva(1)\n51\n6regresiva(1) --&gt; regresiva(0)\n7regresiva(0)\n80\n\n1\n\nSe ejecuta regresiva con i = 2\n\n2\n\nregresiva(2) imprime 2\n\n3\n\nregresiva(2) llama a regresiva(1)\n\n4\n\nSe ejecuta regresiva con i = 1\n\n5\n\nregresiva(1) imprime 1\n\n6\n\nregresiva(1) llama a regresiva(0)\n\n7\n\nSe ejecuta regresiva con i = 0\n\n8\n\nregresiva(0) imprime 0\n\n\n\n\n춰Qu칠 no falte el caso base!\nCuando escribimos una funci칩n recursiva es fundamental implementar el caso base, que determina la condici칩n donde la funci칩n deja de llamarse a s칤 misma y comienza a devolver un valor.\nDebajo se muestra una implementaci칩n incorrecta de la funci칩n regresiva como funci칩n recursiva. La misma tiene el caso recursivo, donde la funci칩n se llama a s칤 misma, pero le falta el caso base, que es el que detiene esa cadena de llamadas. Como resultado, la funci칩n sigue contando n칰meros, incluso negativos, y Python termina frenando la ejecuci칩n con un RecursionError. Este error aperece cuando la profundidad de la pila de llamadas recursivas supera un l칤mite predeterminado y, como regla general, indica que hay un problema en nuestra recursi칩n.\ndef regresiva(i):\n    print(i)\n    regresiva(i - 1)\n\nregresiva(1)\n\n1\n0\n-1\n-2\n...\n-988\n-989\nTraceback (most recent call last):\n  File \"&lt;python-input-5&gt;\", line 1, in &lt;module&gt;\n    regresiva(1)\n    ~~~~~~~~~^^^\n  File \"&lt;python-input-2&gt;\", line 3, in regresiva\n    regresiva(i - 1)\n    ~~~~~~~~~^^^^^^^\n  File \"&lt;python-input-2&gt;\", line 3, in regresiva\n    regresiva(i - 1)\n    ~~~~~~~~~^^^^^^^\n  File \"&lt;python-input-2&gt;\", line 3, in regresiva\n    regresiva(i - 1)\n    ~~~~~~~~~^^^^^^^\n  [Previous line repeated 988 more times]\nRecursionError: maximum recursion depth exceeded",
    "crumbs": [
      "Teor칤a",
      "U2 - Programaci칩n Funcional",
      "2 - Recursi칩n"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/02_recursion.html#factorial",
    "href": "teoria/02_programacion_funcional/02_recursion.html#factorial",
    "title": "2 - Recursi칩n",
    "section": "Factorial",
    "text": "Factorial\nUn ejemplo cl치sico para estudiar c칩mo funciona la recursi칩n en programaci칩n es el c치lculo del factorial. El factorial de un n칰mero positivo \\(n\\) se define como:\n\\[\nn! = n \\times (n - 1) \\times (n - 2) \\times \\cdots \\times 2 \\times 1\n\\]\nEs decir, el factorial de un n칰mero es el producto de todos los enteros desde \\(1\\) hasta \\(n\\). Por convenci칩n, adem치s, se establece que \\(0! = 1\\).\nUna forma de calcular el factorial de un n칰mero sin recurrir a la recursi칩n es la siguiente:\n\ndef factorial(n):\n    resultado = 1\n    for i in range(2, n + 1):\n        resultado = resultado * i\n    return resultado\n\nfactorial(6)\n\n720\n\n\nSin embargo, y dado que el factorial admite la siguiente expresi칩n como funci칩n recursiva,\n\\[\nn! = \\begin{cases}\n1 & \\text{para } n = 0 \\text{ o } n = 1 \\\\\nn \\times (n - 1)! & \\text {para } n \\ge 2\n\\end{cases}\n\\]\nse puede implementar en Python de la siguiente manera:\n\ndef factorial(n):\n    if n &lt;= 1:\n1        return 1\n    else:\n2        return n * factorial(n - 1)\n\n\n1\n\nCaso base.\n\n2\n\nCaso recursivo. La funci칩n hace uso del resultado que ella misma produce.\n\n\n\n\nPodemos ver algunos ejemplos:\n\nprint(\"factorial(1):\", factorial(1))\nprint(\"factorial(0):\", factorial(0))\nprint(\"factorial(6):\", factorial(6))\nprint(\"factorial(10):\", factorial(10))\n\nfactorial(1): 1\nfactorial(0): 1\nfactorial(6): 720\nfactorial(10): 3628800\n\n\n\nVersi칩n comentada\nLa funci칩n regresiva nos sirvi칩 como primera aproximaci칩n a la recursi칩n. Sin embargo, en ella, no se hace uso del resultado que la misma funci칩n produce. En cambio, con factorial s칤 se utiliza el valor producido en el caso recursivo, lo que la vuelve m치s interesante para analizar c칩mo se van encadenando los distintos pasos.\n\ndef factorial(n):\n    print(f\"factorial({n})\")\n    if n &lt;= 1:\n        salida = 1\n    else:\n        print(f\"factorial({n}) -&gt; factorial({n - 1})\")\n        salida = n * factorial(n - 1)\n\n    print(f\"&gt; factorial({n}) devuelve {salida}\")\n    return salida\n\nfactorial(4)\n\nfactorial(4)\nfactorial(4) -&gt; factorial(3)\nfactorial(3)\nfactorial(3) -&gt; factorial(2)\nfactorial(2)\nfactorial(2) -&gt; factorial(1)\nfactorial(1)\n&gt; factorial(1) devuelve 1\n&gt; factorial(2) devuelve 2\n&gt; factorial(3) devuelve 6\n&gt; factorial(4) devuelve 24\n\n\n24\n\n\nEl proceso arranca con la llamada a factorial(4). Para calcular su resultado, la funci칩n necesita antes el valor de factorial(3). Esa, a su vez, depende de factorial(2), que depende de factorial(1). Finalmente, cuando llegamos a factorial(1), entramos en el caso base, que devuelve un resultado sin hacer m치s llamadas.\nPor eso primero vemos c칩mo se acumula la pila de llamadas, que crece paso a paso hasta llegar al caso base. Reci칠n ah칤 comienza el camino de regreso: cada llamada se va resolviendo, utilizando el valor devuelto por la llamada anterior, hasta llegar de nuevo a factorial(4), donde se completa el c치lculo y obtenemos el resultado final.",
    "crumbs": [
      "Teor칤a",
      "U2 - Programaci칩n Funcional",
      "2 - Recursi칩n"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/02_recursion.html#letra-chica",
    "href": "teoria/02_programacion_funcional/02_recursion.html#letra-chica",
    "title": "2 - Recursi칩n",
    "section": "Letra chica",
    "text": "Letra chica\nCada vez que una funci칩n se invoca a s칤 misma, crea un nuevo contexto de ejecuci칩n (con sus propias variables locales y el punto al que debe regresar) y lo apila sobre el anterior en una estructura que se llama pila de llamadas (del ingl칠s, call stack). Por lo tanto, cuando llamamos a factorial(4), apilamos cuatro contextos de ejecuci칩n distintos, uno por cada llamada que va quedando pendiente, antes de empezar a devolver resultados.\nEste apilamiento no es gratis, consume memoria de nuestra computadora. Aunque para factorial(4) el consumo de memoria es insignificante, si intent치ramos calcular un factorial muy grande, la pila podr칤a crecer hasta agotar la cantidad de memoria disponible en nuestra computadora. Para evitar que las funciones recursivas causen una falla estrepitosa, Python establece un l칤mite en la profundidad de la recursi칩n. Al alcanzarlo, el int칠rprete se detiene con la excepci칩n RecursionError que nos proteje de una ejecuci칩n recursiva infinita o excesivamente profunda.\nDado su potencial alto consumo de memoria y la sobrecarga que genera gestionar la pila de llamadas, una implementaci칩n recursiva no suele ser la m치s eficiente. De hecho, su equivalente iterativo suele ser m치s eficiente y adem치s evita los riesgos asociados al desbordamiento de la pila. Sin embargo, el principal valor de la recursi칩n reside en la claridad conceptual para modelar problemas de naturaleza inherentemente recursiva.",
    "crumbs": [
      "Teor칤a",
      "U2 - Programaci칩n Funcional",
      "2 - Recursi칩n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/07_scripting.html",
    "href": "teoria/01_programacion_en_python/07_scripting.html",
    "title": "7 - Scripting",
    "section": "",
    "text": "En programaci칩n, un script es un archivo de texto que contiene una secuencia l칩gica de pasos que se pueden ejecutar para realizar una tarea espec칤fica, ya sea simple o compleja. Esta serie de pasos suele expresarse en un lenguaje de scripting, un lenguaje de programaci칩n que permite manipular, personalizar y automatizar tareas.\nA diferencia de los programas compilados, los scripts suelen interpretarse en tiempo de ejecuci칩n. Es decir, un int칠rprete se encarga de leer, procesar y ejecutar cada instrucci칩n en orden.\nEn el caso de Python, un script es un archivo con extensi칩n .py que puede automatizar procesos, analizar datos, crear aplicaciones o pr치cticamente cualquier otra tarea que el lenguaje permita. El int칠rprete de Python ejecuta el c칩digo l칤nea por l칤nea, lo que facilita probar, modificar y reutilizar el programa de manera 치gil\nDebido a su uso frecuente para desarrollar scripts, Python es conocido tambi칠n como un lenguaje de scripting, aunque en la pr치ctica su uso sea mucho m치s amplio.",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "7 - _Scripting_"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/07_scripting.html#qu칠-es-un-script",
    "href": "teoria/01_programacion_en_python/07_scripting.html#qu칠-es-un-script",
    "title": "7 - Scripting",
    "section": "",
    "text": "En programaci칩n, un script es un archivo de texto que contiene una secuencia l칩gica de pasos que se pueden ejecutar para realizar una tarea espec칤fica, ya sea simple o compleja. Esta serie de pasos suele expresarse en un lenguaje de scripting, un lenguaje de programaci칩n que permite manipular, personalizar y automatizar tareas.\nA diferencia de los programas compilados, los scripts suelen interpretarse en tiempo de ejecuci칩n. Es decir, un int칠rprete se encarga de leer, procesar y ejecutar cada instrucci칩n en orden.\nEn el caso de Python, un script es un archivo con extensi칩n .py que puede automatizar procesos, analizar datos, crear aplicaciones o pr치cticamente cualquier otra tarea que el lenguaje permita. El int칠rprete de Python ejecuta el c칩digo l칤nea por l칤nea, lo que facilita probar, modificar y reutilizar el programa de manera 치gil\nDebido a su uso frecuente para desarrollar scripts, Python es conocido tambi칠n como un lenguaje de scripting, aunque en la pr치ctica su uso sea mucho m치s amplio.",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "7 - _Scripting_"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/07_scripting.html#script-vs-m칩dulo",
    "href": "teoria/01_programacion_en_python/07_scripting.html#script-vs-m칩dulo",
    "title": "7 - Scripting",
    "section": "Script vs m칩dulo",
    "text": "Script vs m칩dulo\nPython es un lenguaje de programaci칩n interpretado, y por ello sus programas suelen denominarse scripts. Sin embargo, no siempre es correcto usar este t칠rmino. Si bien muchos programas en Python consisten en instrucciones destinadas a resolver tareas puntuales, otros programas tienen por objetivo principal implementar herramientas que luego van a ser utilizadas por otros programas.\nUn programa de Python puede denominarse script o m칩dulo. El prop칩sito del c칩digo en un archivo de texto .py es lo que determina si lo llamamos de una manera o de la otra. Cuando un archivo contiene c칩digo ejecutable cuyo fin es realizar una tarea espec칤fica, se lo considera script. En cambio, cuando el archivo est치 dise침ado para ser importado y utilizado desde otro programa de Python, se lo denomina m칩dulo.\nEn s칤ntesis, la principal diferencia entre un m칩dulo y un script es que los m칩dulos almacenan c칩digo importable mientras que los scripts contienen c칩digo ejecutable.",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "7 - _Scripting_"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/07_scripting.html#script-y-m칩dulo",
    "href": "teoria/01_programacion_en_python/07_scripting.html#script-y-m칩dulo",
    "title": "7 - Scripting",
    "section": "Script y m칩dulo",
    "text": "Script y m칩dulo\nPython es un lenguaje tan flexible que un mismo programa puede funcionar como script y como m칩dulo al mismo tiempo. Esto ocurre cuando el archivo define herramientas reutilizables (por ejemplo, funciones o clases) y, adem치s, incluye c칩digo que se ejecuta directamente al correrlo desde la l칤nea de comandos.\nPara ilustrarlo, consideremos un peque침o programa en Python que solicita una fecha al usuario y luego indica cu치ntos d칤as faltan para llegar a ella:\n\n\ncalcular_dias.py\n\nfrom datetime import datetime\n\ndef diferencia_dias(fecha_str):\n    fecha = datetime.strptime(fecha_str, \"%Y-%m-%d\").date()\n    hoy = datetime.today().date()\n    diferencia = (fecha - hoy).days\n    return diferencia\n\nfecha_str = input(\"Ingres치 una fecha (formato AAAA-MM-DD): \")\ndiferencia = diferencia_dias(fecha_str)\n\nif diferencia &gt; 0:\n    print(f\"Faltan {diferencia} d칤as para el {fecha_str}.\")\nelif diferencia == 0:\n    print(\"춰La fecha es hoy!\")\nelse:\n    print(f\"Esa fecha ya pas칩 hace {-diferencia} d칤as.\")\n\nDebajo se muestra una animaci칩n de la ejecuci칩n de este script en la terminal:\n\n\n\n\n\nAhora, supongamos que queremos importar la funci칩n diferencia_dias en otro programa de Python.\n\n\n\n\n\nCuando importamos una funci칩n del m칩dulo calcular_dias, observamos que Python tambi칠n ejecuta la parte del programa que solicita una fecha y muestra cu치ntos d칤as faltan para alcanzarla.\nEsto ocurre porque, al importar un m칩dulo (o cualquier objeto definido en 칠l), Python ejecuta todo el c칩digo del archivo de principio a fin, sin importar qu칠 elementos en particular estemos importando.\nPara evitar este comportamiento no deseado, y permitir que un mismo archivo pueda funcionar tanto como m칩dulo reutilizable como script ejecutable, se encapsula la parte que debe ejecutarse solo al correr el archivo directamente dentro del siguiente bloque:\nif __name__ == \"__main__\":\n    # c칩digo ejecutable\nCon esta estructura, el c칩digo dentro de ese bloque se ejecutar치 칰nicamente cuando el archivo se ejecute directamente como programa, y no cuando se lo importe desde otro m칩dulo.\nDe esta manera, nuestro programa actualizado quedar칤a as칤:\n\n\ncalcular_dias.py\n\nfrom datetime import datetime\n\ndef diferencia_dias(fecha_str):\n    fecha = datetime.strptime(fecha_str, \"%Y-%m-%d\").date()\n    hoy = datetime.today().date()\n    diferencia = (fecha - hoy).days\n    return diferencia\n\nif __name__ == \"__main__\":\n    fecha_str = input(\"Ingres치 una fecha (formato AAAA-MM-DD): \")\n    diferencia = diferencia_dias(fecha_str)\n\n    if diferencia &gt; 0:\n        print(f\"Faltan {diferencia} d칤as para el {fecha_str}.\")\n    elif diferencia == 0:\n        print(\"춰La fecha es hoy!\")\n    else:\n        print(f\"Esa fecha ya pas칩 hace {-diferencia} d칤as.\")\n\nAhora, cuando se importa cualquier objeto desde calcular_dias, Python no ejecuta la parte del programa que interact칰a con el usuario.\n\n\n\n\n\n\n\n\n\n\n\nLa variable especial __name__ 游낑勇끂n\n\n\nLa variable __name__ es una variable especial que indica el nombre del m칩dulo actual. Cuando un archivo Python se ejecuta directamente, __name__ toma el valor \"__main__\", lo que indica que es el m칩dulo principal. En cambio, si el archivo se importa como un m칩dulo en otro script, __name__ contendr치 el nombre del archivo (sin la extensi칩n .py).",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "7 - _Scripting_"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/07_scripting.html#clis-con-argparse",
    "href": "teoria/01_programacion_en_python/07_scripting.html#clis-con-argparse",
    "title": "7 - Scripting",
    "section": "CLIs con argparse",
    "text": "CLIs con argparse\nargparse es un m칩dulo de la librer칤a est치ndar de Python que sirve para crear interfaces de l칤nea de comandos (CLIs, por sus siglas en ingl칠s).\nCon este m칩dulo se pueden definir qu칠 argumentos y opciones acepta nuestra programa. Luego, Python se encargar치 de:\n\nLeerlos desde la terminal al ejecutar el script.\nConvertirlos al tipo de dato indicado (int, float, str, etc.).\nValidarlos seg칰n las reglas definidas.\nGenerar un mensaje de ayuda (--help) sin que tengamos que hacer nada.\n\n\nEjemplo: saludos personalizados\nEl siguiente programa recibe el nombre de una persona como argumento obligatorio y, de manera opcional, la cantidad de veces que se la debe saludar.\nimport argparse\n\nparser = argparse.ArgumentParser(description=\"Saluda a una persona\")\nparser.add_argument(\"nombre\", help=\"El nombre de la persona\") # Argumento posicional\nparser.add_argument(\"--veces\", type=int, default=1, help=\"Cu치ntas veces saludar\") # Argumento nombrado\n\nargs = parser.parse_args()\n\nfor _ in range(args.veces):\n    print(f\"춰Hola, {args.nombre}!\")\nLuego, en la terminal:\npython hola.py Tom치s\n춰Hola, Tom치s!\nY si usamos el argumento --veces:\npython hola.py Tom치s --veces 3\n춰Hola, Tom치s!\n춰Hola, Tom치s!\n춰Hola, Tom치s!\nLa ayuda se puede ver de la siguiente manera:\npython hola.py --help\nusage: hola.py [-h] [--veces VECES] nombre\n\nSaluda a una persona\n\npositional arguments:\n  nombre         El nombre de la persona\n\noptions:\n  -h, --help     show this help message and exit\n  --veces VECES  Cu치ntas veces saludar\nSi usamos un valor de tipo err칩neo para --veces, obtenemos un error informativo de manera autom치tica:\npython hola.py Tom치s --veces 3.5\n\nusage: hola.py [-h] [--veces VECES] nombre\nhola.py: error: argument --veces: invalid int value: '3.5'\n\n\n\n\n\n\n\ninput() vs argparse\n\n\n\nTanto input() como ArgumentParser de argparse permiten pasar datos a nuestro script. La diferencia entre ellos es que input() se usa para pedir datos mientras corre el programa, mientras que el m칩dulo argparse se usa apra pedir datos al momento de ejecutar el programa desde al terminal.",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "7 - _Scripting_"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html",
    "title": "5 - Ejecuci칩n repetitiva",
    "section": "",
    "text": "Anteriormente aprendimos a crear objetos que contienen otros objetos (listas, tuplas y diccionarios).\nCuando quer칤amos realizar una acci칩n con cada uno de los objetos que estos conten칤an, ten칤amos que escribir el mismo c칩digo para acceder a cada uno de ellos de a uno.\nPor ejemplo, supongamos que tenemos un listado con nombres de nuestros amigos y queremos ponerlos a todos en may칰sculas:\n\nnombres = [\"julieta\", \"facundo\", \"emiliano\", \"lorenzo\", \"victoria\"]\nprint(\"Nombres originales:\")\nprint(nombres)\n\nnombres[0] = nombres[0].upper()\nnombres[1] = nombres[1].upper()\nnombres[2] = nombres[2].upper()\nnombres[3] = nombres[3].upper()\nnombres[4] = nombres[4].upper()\n\nprint(\"\\nNombres modificados:\")\nprint(nombres)\n\nNombres originales:\n['julieta', 'facundo', 'emiliano', 'lorenzo', 'victoria']\n\nNombres modificados:\n['JULIETA', 'FACUNDO', 'EMILIANO', 'LORENZO', 'VICTORIA']\n\n\nVemos que realizamos exactamente la misma acci칩n con cada nombre en la lista 쯅o estar칤a bueno poder automatizarlo?\nY para eso, en esta secci칩n vamos a aprender sobre bucles.",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "5 - Ejecuci칩n repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#introducci칩n",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#introducci칩n",
    "title": "5 - Ejecuci칩n repetitiva",
    "section": "",
    "text": "Anteriormente aprendimos a crear objetos que contienen otros objetos (listas, tuplas y diccionarios).\nCuando quer칤amos realizar una acci칩n con cada uno de los objetos que estos conten칤an, ten칤amos que escribir el mismo c칩digo para acceder a cada uno de ellos de a uno.\nPor ejemplo, supongamos que tenemos un listado con nombres de nuestros amigos y queremos ponerlos a todos en may칰sculas:\n\nnombres = [\"julieta\", \"facundo\", \"emiliano\", \"lorenzo\", \"victoria\"]\nprint(\"Nombres originales:\")\nprint(nombres)\n\nnombres[0] = nombres[0].upper()\nnombres[1] = nombres[1].upper()\nnombres[2] = nombres[2].upper()\nnombres[3] = nombres[3].upper()\nnombres[4] = nombres[4].upper()\n\nprint(\"\\nNombres modificados:\")\nprint(nombres)\n\nNombres originales:\n['julieta', 'facundo', 'emiliano', 'lorenzo', 'victoria']\n\nNombres modificados:\n['JULIETA', 'FACUNDO', 'EMILIANO', 'LORENZO', 'VICTORIA']\n\n\nVemos que realizamos exactamente la misma acci칩n con cada nombre en la lista 쯅o estar칤a bueno poder automatizarlo?\nY para eso, en esta secci칩n vamos a aprender sobre bucles.",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "5 - Ejecuci칩n repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#qu칠-son-los-bucles",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#qu칠-son-los-bucles",
    "title": "5 - Ejecuci칩n repetitiva",
    "section": "쯈u칠 son los bucles?",
    "text": "쯈u칠 son los bucles?\nLos bucles son una estrcutura de los lenguajes de programaci칩n que nos permite repetir la ejecuci칩n de c칩digo de manera autom치tica.\nEn otras palabras, los bucles hacen que sea muy f치cil ejecutar el mismo bloque de c칩digo una y otra vez.\nA la repetici칩n del mismo bloque de c칩digo una y otra vez le decimos iteraci칩n. Entonces, los bucles nos ayudan a iterar.\nEn Python tenemos dos tipos de bucles:\n\nEl bucle for (for-loop).\nEl bucle while (while-loop).\n\nLa diferencia entre este tipo de bucles es que con el for conocemos la cantidad de iteraciones que vamos a realizar de antemano.\nEn cambio, con el while no conocemos la cantidad de iteraciones que vamos a realizar de antemano.\nVeamos el ejemplo anterior pero utilizando un bucle for. En este caso, generamos una nueva lista llamada nombres_modificados donde vamos a almacenar los nombres modificados.\n\nnombres = [\"julieta\", \"facundo\", \"emiliano\", \"mariana\", \"victoria\"]\nnombres_modificados = []\n\n# Bucle for\nfor nombre in nombres:\n    nombres_modificados.append(nombre.upper())\n\nprint(\"Nombres originales:\")\nprint(nombres)\n\nprint(\"\\nNombres modificados:\")\nprint(nombres_modificados)\n\nNombres originales:\n['julieta', 'facundo', 'emiliano', 'mariana', 'victoria']\n\nNombres modificados:\n['JULIETA', 'FACUNDO', 'EMILIANO', 'MARIANA', 'VICTORIA']",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "5 - Ejecuci칩n repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#el-bucle-for",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#el-bucle-for",
    "title": "5 - Ejecuci칩n repetitiva",
    "section": "El bucle for",
    "text": "El bucle for\n\nPresentaci칩n\nEn un bucle for encontramos los siguientes componentes.\n\nLa palabra clave for\nEl nombre de una variable que se usa para iterar (variable de iteraci칩n)\nLa palabra clave in\nEl objeto sobre el cual iteramos, seguido por :\nEn la siguiente linea y con indentaci칩n, el bloque de c칩digo a ejecutar\n\n\n\n\n\n\nEn Python, al igual que en las sentencias if, else y otras estructuras de control, los dos puntos (:) se utilizan para indicar el comienzo de un bloque de c칩digo, y la indentaci칩n define el contenido de ese bloque. Nunca se emplean llaves {} como en otros lenguajes.\nEn el caso de un bucle for, se declara una variable que va tomando, en cada iteraci칩n, uno de los valores del iterable que se est치 recorriendo. Por ejemplo, si el iterable contiene 10 objetos, el bucle ejecutar치 10 iteraciones y la variable de iteraci칩n (por convenci칩n llamada i, aunque puede tener cualquier nombre) ir치 adoptando esos valores, uno por uno.\n\n\nEjemplos\nDado que a iterar se aprende iterando, veamos algunos ejemplos:\n\nfor i in [3, 1, 2]:\n    print(f\"El n칰mero es {i}.\")\n\nEl n칰mero es 3.\nEl n칰mero es 1.\nEl n칰mero es 2.\n\n\nTambi칠n podemos ordenar los valores de la lista sobre la que iteramos:\n\nfor i in sorted([3, 1, 2]):\n    print(f\"El n칰mero es {i}.\")\n\nEl n칰mero es 1.\nEl n칰mero es 2.\nEl n칰mero es 3.\n\n\nPero no es necesario iterar sobre listas. De hecho, podemos iterar sobre cualquier secuencia, por ejemplo, una tupla:\n\nfor i in (3, 1, 2):\n    print(f\"El n칰mero es {i}.\")\n\nEl n칰mero es 3.\nEl n칰mero es 1.\nEl n칰mero es 2.\n\n\n\nfor i in sorted((3, 1, 2)):\n    print(f\"El n칰mero es {i}.\")\n\nEl n칰mero es 1.\nEl n칰mero es 2.\nEl n칰mero es 3.\n\n\nE incluso una cadena de caracteres:\n\nfor c in \"Hola Curso\":\n    print(c)\n\nH\no\nl\na\n \nC\nu\nr\ns\no\n\n\n\n\n\n\n\n\nVariable de iteraci칩n\n\n\n\nEl nombre de la variable que se usa para iterar es arbitrario. Sin embargo, es recomendable no utilizar el mismo nombre que el de otra variable en nuestro programa. Por ejemplo:\ni = 1\nfor i in [1, 2, 3]:\n    print(i)\nprint(i)\n1\n2\n3\n3\nLa variable de iteraci칩n i va pisando su valor y cualquier valor que esta pudo haber tenido antes.\nAs칤, luego de la finalizar el bucle, el valor de i es 3.\n\n\nLos bucles permiten generar nuevos objetos de forma autom치tica.\nEn el siguiente ejemplo, partimos de una lista con cadenas que pueden contener n칰meros o letras. Mediante un for, crearemos tres listas: una con los n칰meros, otra con el texto y una tercera con los elementos que no sean ninguno de los dos.\n\nlista_original = [\"1\", \"@\", \"x\", \"y\", \"?\", \"3\", \"4\", \"7\", \"f\", \"l\", \"9\", \"10\", \"!\"]\n\n\n# Crear tres listas vac칤as (que contienen los diferentes tipos de datos)\nnumeros = []\ntexto = []\notros = []\n\n# Iterar a traves de los valores de la lista original\nfor valor in lista_original:\n    # Si es num칠rico, lo agregamos en la lista 'numeros'\n    if valor.isnumeric():\n        numeros.append(valor)\n    # Sino es num칠rico, pregunto si es alfab칠tico (o una letra del abecedario)\n    elif valor.isalpha():\n        texto.append(valor)\n    # Caso contrario, lo metemos en la lista de otros\n    else:\n        print(f\"La cadena '{valor}' no es ni num칠rica ni alfab칠tica.\")\n        otros.append(valor)\n\nprint(lista_original)\nprint(numeros)\nprint(texto)\nprint(otros)\n\nLa cadena '@' no es ni num칠rica ni alfab칠tica.\nLa cadena '?' no es ni num칠rica ni alfab칠tica.\nLa cadena '!' no es ni num칠rica ni alfab칠tica.\n['1', '@', 'x', 'y', '?', '3', '4', '7', 'f', 'l', '9', '10', '!']\n['1', '3', '4', '7', '9', '10']\n['x', 'y', 'f', 'l']\n['@', '?', '!']\n\n\n\n\nCrear listas num칠ricas con range().\nPython provee una funci칩n llamada range() que hace que sea muy f치cil generar una secuencia de n칰meros. Por ejemplo, podemos usar range() para imprimir una serie de n칰meros.\n\nfor i in range(1, 5):\n    print(i)\n\n1\n2\n3\n4\n\n\nrange() funciona de manera similar a los slices, es decir, no incluye el l칤mite superior. Adem치s, si se usa con un solo argumento, es equivalente a range(0, numero).\n\nfor i in range(5):\n    print(i)\n\n0\n1\n2\n3\n4\n\n\nUna forma 칰til de entender range(n) es verlo como la creaci칩n de una secuencia con los primeros n n칰meros, comenzando desde 0.\n\nx = range(5)\nprint(x)\nprint(type(x))\n\nrange(0, 5)\n&lt;class 'range'&gt;\n\n\nPodemos obtener una lista a partir de un range usando la funci칩n list().\n\nlist(x)\n\n[0, 1, 2, 3, 4]\n\n\nY, por qu칠 no, una tupla tambi칠n.\n\ntuple(x)\n\n(0, 1, 2, 3, 4)\n\n\nrange() admite un tercer argumento opcional que especifica el paso entre valores. Por defecto es 1. Veamos algunos ejemplos:\nLista de n칰meros entre 0 y 10 (no inclusivo), avanzando de a 2 en cada paso.\n\nlist(range(0, 10, 2))\n\n[0, 2, 4, 6, 8]\n\n\nIntento de lista de n칰meros entre 10 y 0 (no inclusivo).\n\nlist(range(10, 0))\n\n[]\n\n\nVemos que el resultado no es el esperado. Esto se debe a que el paso es por defecto 1 y es imposible recorrer desde el 10 al 0 sumando de a 1. Si cambiamos el paso a -1, funciona correctamente:\n\nlist(range(10, 0, -1))\n\n[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n\n\n\n\n쯉obre qu칠 cosas podemos iterar en un bucle for?\nRecordemos el diagrama que vimos anteriormente뵢n\n\n\n\n\nEn naranja tenemos resaltado iterable. Pero, 쯤u칠 significa que un objeto sea iterable?\n\nQue podemos iterar a trav칠s de el.\nQue podemos recorrerlo elemento por elemento.\nQue puede devolver sus elementos de a uno a la vez.\n\nDe manera similar a las secuencias, el t칠rmino iterable describe una categor칤a de tipos de datos. De hecho, todas las secuencias son iterables (por eso podemos recorrer listas, tuplas y cadenas), pero no es requisito ser una secuencia para ser iterable. Por ejemplo, los diccionarios no son secuencias y, sin embargo, pueden recorrerse porque implementan un m칠todo para entregar sus elementos de uno en uno.\n\nfor i in {\"a\": 1, \"b\": 2}:\n    print(i)\n\na\nb",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "5 - Ejecuci칩n repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#el-bucle-while",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#el-bucle-while",
    "title": "5 - Ejecuci칩n repetitiva",
    "section": "El bucle while",
    "text": "El bucle while\nEn un bucle while encontramos los siguientes componentes.\n\nLa palabra clave while.\nUna condici칩n, es decir, una expresi칩n que se eval칰a a True o False, seguido por los dos puntos :.\nEn la siguiente linea y con indentaci칩n, el bloque de c칩digo a ejecutar.\n\n\n\n\n\n\n\nnumero = 0\nwhile numero &lt; 5:\n    numero += 1 # Abreviaci칩n de x = x + 1\n    print(f\"El numero es {numero}\")\n\nEl numero es 1\nEl numero es 2\nEl numero es 3\nEl numero es 4\nEl numero es 5\n\n\n\n\n\n\n\nAnalicemos el diagrama:\n\nMientras numero &lt; 5 sea True, Python ejecutar치 el cuerpo del bucle completo.\nEn la primera iteraci칩n, numero es 0.\n\nComo 0 es menor a 5, Python imprime el n칰mero y luego le agrega 1, haciendo que el n칰mero sea 1.\n\nEn la segunda iteraci칩n, numero es 1.\n\nComo 1 es menor a 5, Python imprime el n칰mero y luego le agrega 1, haciendo que el n칰mero sea 2.\n\n\nEl proceso contin칰a hasta que numero deja de ser menor que 5, momento en el que el bucle se detiene.\n\n\n\n\n\n\nBucles infinitos 鮫쮪잺\n\n\n\nVeamos el siguiente ejemplo:\nx = 0\nwhile x &lt; 5:\n    print(x)\nSi ejecutamos este c칩digo, Python nunca detendr치 su ejecuci칩n. Esto sucede porque el valor de x nunca cambia, por lo que la condici칩n x &lt; 5 es siempre verdadera. Este es un caso t칤pico de bucle infinito, algo que puede ocurrir con cualquier while, y en particular con while True si no incluimos una forma de salir del bucle (por ejemplo, con break).\nSi entramos en un bucle infinito, la 칰nica forma de detenerlo es interrumpir la ejecuci칩n manualmente:\n\nEn la terminal: CTRL + C\nEn un editor de c칩digo: usar el bot칩n de interrupci칩n\n\n\n\n\nLa sentencia break\nPython provee la sentencia break que sirve para terminar un bucle (for o while) de manera anticipada.\nVeamos algunos ejemplos de uso.\n\nwhile True:\n    print(\"춰Hola!\")\n    break\n\n춰Hola!\n\n\nEn el ejemplo anterior, la condici칩n del bucle era True, lo que implicar칤a una ejecuci칩n infinita. Sin embargo, al final de la primera iteraci칩n encontramos un break, que fuerza la salida del bucle. De forma similar, podemos reescribir el primer while utilizando esta estructura alternativa.\n\nnumero = 0\nwhile True:\n    if numero &gt;= 5:\n        break\n    numero += 1\n    print(f\"El numero es {numero}\")\n\nEl numero es 1\nEl numero es 2\nEl numero es 3\nEl numero es 4\nEl numero es 5\n\n\n\nnumero = 0\nwhile True:\n    numero += 1\n    print(f\"El numero es {numero}\")\n    if numero &gt;= 5:\n        break\n\nEl numero es 1\nEl numero es 2\nEl numero es 3\nEl numero es 4\nEl numero es 5\n\n\nSupongamos que queremos sumar los valores de una lista hasta que se cumpla cierta condici칩n, por ejemplo, que el total sea mayor o igual a 20.\nSi partimos de una lista de n칰meros cualquiera, no sabemos de antemano cu치ntos elementos ser치 necesario sumar. Sin embargo, esto no ser치 un problema si utilizamos la estructura while en combinaci칩n con la sentencia break.\n\nsuma = 0\numbral = 20\nvalores = [3, 5, 4, 4, 5, 5, 3, 5, 2, 7]\n\nwhile valores:\n    suma += valores.pop(0)\n    print(suma)\n    if suma &gt;= umbral:\n        break\n\n3\n8\n12\n16\n21\n\n\n\nvalores # valores que no se sumaron\n\n[5, 3, 5, 2, 7]\n\n\nEn el bloque de c칩digo anterior puede llamar la atenci칩n el uso de\nwhile valores:\nEl bucle while valores: se ejecuta mientras la lista tenga elementos. En cada iteraci칩n, .pop(0) extrae el primer elemento, se suma a suma y se imprime el total acumulado. Si en alg칰n momento suma alcanza o supera el umbral, se ejecuta break para detener el bucle aunque a칰n queden elementos en la lista. Si la lista se vac칤a antes de llegar al umbral, el bucle tambi칠n finaliza autom치ticamente gracias a la condici칩n while valores:.\nUn ejemplo m치s conciso es el siguiente:\n\nif [1, 2, 3]:\n    print(\"Bloque 'if'\")\nelse:\n    print(\"Bloque 'else'\")\n\nBloque 'if'\n\n\n\nif []:\n    print(\"Bloque 'if'\")\nelse:\n    print(\"Bloque 'else'\")\n\nBloque 'else'\n\n\nAhora supongamos que tenemos una lista de n칰meros aleatorios que representan alg칰n conteo.\nEstamos interesados en la cantidad de extracciones que se necesitaron hasta que el conteo supere cierto umbral, por ejemplo, 30.\n\nnumeros_aleatorios = [\n    5, 7, 6, 4, 2, 2, 5, 3, 6, 4, 4, 6, 3, 6, 1,\n    3, 3, 1, 9, 5, 5, 6, 5, 1, 7, 3, 3, 1, 3, 4\n]\n\numbral = 30\n\n# Inicializamos suma y cantidad de iteraciones en 0\nsuma = 0\niteraciones = 0\n\n# Mientras la lista no est칠 vac칤a\nwhile numeros_aleatorios:\n    # Agregamos 1 al conteo de iteraciones realizadas\n    iteraciones += 1\n\n    # Extraemos el primer n칰mero de la lista y lo sumamos a la suma\n    suma += numeros_aleatorios.pop(0)\n\n    # Si la suma es mayor o igual al umbral, dejamos de iterar\n    if suma &gt;= umbral:\n        break\n\nif suma &gt;= umbral:\n    print(f\"Se super칩 el umbral de {umbral} en la iteraci칩n {iteraciones}, sumando {suma}.\")\nelse:\n    print(f\"La suma de los elementos de la lista no llega a superar {umbral}\")\n\nSe super칩 el umbral de 30 en la iteraci칩n 7, sumando 31.\n\n\n\nSolicitar valores de entrada al usuario\nPython provee una funci칩n llamada input() que sirve para solicitar al usuario que ingrese un valor.\n\nEl argumento es el mensaje que se mostrar치 en pantalla.\nEl tipo de dato que se devuelve es str.\n\n\nnombre = input(\"Ingresa tu nombre: \")\nprint(f\"El nombre ingresado es '{nombre}'\")\n\nEl nombre ingresado es 'Tomi'\n\n\nEsta funcion combinada con el bucle while nos permite generar programas interactivos que solicitan entrada al usuario hasta que se cumple una condici칩n. Por ejemplo, supongamos que queremos solicitar una contrase침a que tenga 8 caracteres o m치s.\n\nwhile True:\n    pwd = input(\"Ingrese su contrase침a: \")\n    if len(pwd) &gt;= 8:\n        print(\"춰Muchas gracias!\")\n        break\n    else:\n        print(f\"La contrase침a '{pwd}' es corta\")\nprint(f\"La contrase침a ingresada es '{pwd}'\")\n\nLa contrase침a '' es corta\nLa contrase침a 'prueba' es corta\n춰Muchas gracias!\nLa contrase침a ingresada es 'prueba 2'\n\n\n\n\n\nLa sentencia continue\nAs칤 como tenemos la sentencia break que le dice a Python que interrumpa la ejecuci칩n de un bucle, tenemos la sentencia continue que le dice que pase a la siguiente iteraci칩n sin ejecutar el c칩digo a continuaci칩n de la misma.\nCuando un programa se encuentra con continue se procede a la siguiente iteraci칩n del bucle, re-evaluando la condici칩n del while de ser necesario.\nEn el siguiente ejemplo tenemos una lista con n칰meros del 1 al 10 y queremos sumar solamente los n칰meros pares.\n\n# Crear lista del 1 al 10\nnumeros = list(range(1, 11))\nprint(numeros)\n\nsuma = 0\nwhile numeros:\n    numero = numeros.pop(0)\n    if numero % 2 != 0:\n        continue\n    suma += numero\n    print(\"Sumando el numero\", numero)\n\nprint(\"La suma es\", suma)\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nSumando el numero 2\nSumando el numero 4\nSumando el numero 6\nSumando el numero 8\nSumando el numero 10\nLa suma es 30\n\n\nEn este programa, si numero % 2 != 0, el continue le indica a Python que debe pasar a la siguiente iteraci칩n sin evaluar lo que hay debajo. Por lo tanto, cuando el n칰mero es impar, no se ejecuta ni la suma ni el print.\nEste problema se puede resolver tambi칠n utilizando un bucle for en vez de un bucle while.\n\nnumeros = list(range(1, 11))\nsuma = 0\nfor numero in numeros:\n    if numero % 2 != 0:\n        continue\n    suma += numero\n    print(\"Sumando el numero\", numero)\nprint(\"La suma es\", suma)\n\nSumando el numero 2\nSumando el numero 4\nSumando el numero 6\nSumando el numero 8\nSumando el numero 10\nLa suma es 30",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "5 - Ejecuci칩n repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#conclusi칩n",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#conclusi칩n",
    "title": "5 - Ejecuci칩n repetitiva",
    "section": "Conclusi칩n",
    "text": "Conclusi칩n\nCu치ndo usar un bucle for.\n\nSabemos exactamente, y de antemano, cuantas veces queremos iterar.\nQueremos iterar a trav칠s de todos los elementos de un objeto determinado.\n\nCu치ndo usar un bucle while.\n\nNo sabemos exactamente cuantas veces queremos iterar.\nQueremos iterar hasta que se cumpla (o se deje de cumplir) una condici칩n determinada.",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "5 - Ejecuci칩n repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html",
    "href": "teoria/01_programacion_en_python/02_funciones.html",
    "title": "2 - Funciones",
    "section": "",
    "text": "Una funci칩n puede pensarse como un 랈ini-programa dentro de un programa m치s grande. Su prop칩sito es cumplir una tarea u objetivo espec칤fico, de forma independiente del resto del c칩digo.\nEl uso de funciones tiene varias ventajas:\n\nReutilizaci칩n de c칩digo: se define una sola vez y se ejecuta cuando sea necesario.\nMejor organizaci칩n: dividen el programa en partes m치s f치ciles de leer y mantener.\nModularidad: permiten construir programas como bloques independientes que pueden combinarse entre s칤 (춰funciones dentro de funciones!).\n\nConsideremos el siguiente caso donde se busca calcuar el precio final de un producto, considerando impuestos y descuentos.\n\nprecio_base = 800   # Precio del producto ($800)\nimpuesto = 0.21     # Impuesto (21%)\ndescuento = 0.10    # Descuento (10%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n871.2\n\n\n쯈u칠 pasa si queremos calcular el precio final para otros productos con diferentes precios, impuestos o descuentos?\nUna opci칩n es repetir el c칩digo tantas veces como sea necesario뵢n\nprecio_base = 500   # Precio del producto ($500)\nimpuesto = 0.105    # Impuesto (10.5%)\ndescuento = 0.0     # Descuento (0%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n552.5\n\n\n\nprecio_base = 2000  # Precio del producto ($2000)\nimpuesto = 0.21     # Impuesto (21%)\ndescuento = 0.20    # Descuento (20%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n1936.0\n\n\nOtra opci칩n, mucho mas conveniente, es utilizar funciones.\n\ndef calcular_precio(precio_base, impuesto, descuento):\n    resultado = precio_base * (1 + impuesto) * (1 - descuento)\n    return resultado\n\nLuego, para utilizar la funci칩n simplemente la llamamos (o invocamos).\n\ncalcular_precio(800, 0.21, 0.10)\n\n871.2\n\n\nTambi칠n es posible indicar los valores de los argumentos utilizando sus nombres.\n\ncalcular_precio(precio_base=2000, impuesto=0.21, descuento=0.20)\n\n1936.0",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#qu칠-es-una-funci칩n",
    "href": "teoria/01_programacion_en_python/02_funciones.html#qu칠-es-una-funci칩n",
    "title": "2 - Funciones",
    "section": "",
    "text": "Una funci칩n puede pensarse como un 랈ini-programa dentro de un programa m치s grande. Su prop칩sito es cumplir una tarea u objetivo espec칤fico, de forma independiente del resto del c칩digo.\nEl uso de funciones tiene varias ventajas:\n\nReutilizaci칩n de c칩digo: se define una sola vez y se ejecuta cuando sea necesario.\nMejor organizaci칩n: dividen el programa en partes m치s f치ciles de leer y mantener.\nModularidad: permiten construir programas como bloques independientes que pueden combinarse entre s칤 (춰funciones dentro de funciones!).\n\nConsideremos el siguiente caso donde se busca calcuar el precio final de un producto, considerando impuestos y descuentos.\n\nprecio_base = 800   # Precio del producto ($800)\nimpuesto = 0.21     # Impuesto (21%)\ndescuento = 0.10    # Descuento (10%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n871.2\n\n\n쯈u칠 pasa si queremos calcular el precio final para otros productos con diferentes precios, impuestos o descuentos?\nUna opci칩n es repetir el c칩digo tantas veces como sea necesario뵢n\nprecio_base = 500   # Precio del producto ($500)\nimpuesto = 0.105    # Impuesto (10.5%)\ndescuento = 0.0     # Descuento (0%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n552.5\n\n\n\nprecio_base = 2000  # Precio del producto ($2000)\nimpuesto = 0.21     # Impuesto (21%)\ndescuento = 0.20    # Descuento (20%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n1936.0\n\n\nOtra opci칩n, mucho mas conveniente, es utilizar funciones.\n\ndef calcular_precio(precio_base, impuesto, descuento):\n    resultado = precio_base * (1 + impuesto) * (1 - descuento)\n    return resultado\n\nLuego, para utilizar la funci칩n simplemente la llamamos (o invocamos).\n\ncalcular_precio(800, 0.21, 0.10)\n\n871.2\n\n\nTambi칠n es posible indicar los valores de los argumentos utilizando sus nombres.\n\ncalcular_precio(precio_base=2000, impuesto=0.21, descuento=0.20)\n\n1936.0",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#definici칩n-de-funciones",
    "href": "teoria/01_programacion_en_python/02_funciones.html#definici칩n-de-funciones",
    "title": "2 - Funciones",
    "section": "Definici칩n de funciones",
    "text": "Definici칩n de funciones\nAnalicemos las diferentes partes que forman la definici칩n de una funci칩n en Python:\n\n\n\n\n\n\nLa palabra clave def:\n\nMarca el inicio de la definici칩n de una funci칩n.\nEs una palabra reservada (keyword).\n\nEl nombre de la funci칩n:\n\nDebe seguir las mismas reglas que los nombres de las variables.\n\nLos argumentos de la funci칩n, dentro de par칠ntesis:\n\nSe separan por comas y pueden ser 0 o m치s.\n\nLos dos puntos (:):\n\nIndican el final de la l칤nea de definici칩n y el inicio del bloque de c칩digo.\n\nEl bloque de c칩digo, que es el cuerpo de la funci칩n:\n\nEs el c칩digo que se ejecuta cada vez que llamamos a la funci칩n.\n\nLa sentencia return que indica el resultado que devuelve la funci칩n.\n\nLuego del return viene el valor o nombre de la variable a devolver.\nEs opcional (ya vamos a ver ejemplos).\n\n\n\n\n\n\n\n\nObservaci칩n 游\n\n\n\nEn R se tiene que asignar de manera expl칤cita una funci칩n a una variable. Por ejemplo:\nsumar &lt;- function(x, y) {\n    return(x + y)\n}\nEn cambio, en Python, la sentencia def define la funci칩n y le asigna un nombre en un mismo paso.",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#ejemplos",
    "href": "teoria/01_programacion_en_python/02_funciones.html#ejemplos",
    "title": "2 - Funciones",
    "section": "Ejemplos",
    "text": "Ejemplos\n\n1. Suma de n칰meros\nComencemos con una funci칩n super sencilla. La misma se llama sumar, recibe dos argumentos x e y, y devuelve la suma de ambos.\n\ndef sumar(x, y):\n    return x + y\n\n\nsumar(15, 21.9)\n\n36.9\n\n\n\ntype(sumar(15, 21.9))\n\nfloat\n\n\nEl valor que devuelve puede ser tratado como cualquier valor en Python. Por ejemplo, se lo puede asignar a una variable.\n\nresultado = sumar(10, 11)\nresultado\n\n21\n\n\nY el valor de esa variable puede ser luego pasado a una nueva llamada a sumar() (o a cualquier otra funci칩n).\n\nsumar(resultado, 2.55)\n\n23.55\n\n\nIncluso es posible pasar expresiones y llamadas a funciones a la hora de pasar un argumento:\n\nsumar(sumar(1, 2), 3)\n\n6\n\n\nEn la l칤nea sumar(sumar(1, 2), 3), Python comienza evaluando la funci칩n sumar(). Pero para poder hacerlo, primero necesita conocer los valores de los argumentos. Al revisar el primer argumento, detecta que no es un valor directamente, sino otra llamada a la funci칩n sumar(1, 2), por lo que la eval칰a primero. El resultado de esa operaci칩n es 3, que se toma como valor del primer argumento de la llamada externa. El segundo argumento ya est치 dado: tambi칠n es 3. Entonces, Python invoca la funci칩n sumar() con los argumentos 3 y 3, cuyo resultado es 6. Finalmente, ese valor se muestra en pantalla.\n\n\n2. Saludo personalizado\nOtro ejemplo sencillo consiste en una funci칩n que recibe un nombre e imprime un saludo en pantalla.\n\ndef saludar(nombre):\n    print(\"Hola\", nombre)\n\n\nsaludar(\"Pablo\")\n\nHola Pablo\n\n\nEsta funci칩n no devuelve un resultado, sino que utiliza el argumento recibido para mostrar un mensaje en pantalla.\n\nsaludar(\"Juan\" + \" Manuel\")\n\nHola Juan Manuel\n\n\n\n\n3. Sin par치metros\nY podemos tener funciones que no utilicen ning칰n argumento.\n\ndef decir_hola():\n    print(\"춰Hola!\")\n\n\ndecir_hola()\ndecir_hola()\ndecir_hola()\n\n춰Hola!\n춰Hola!\n춰Hola!\n\n\n\n\n4. Devoluci칩n de m칰ltiples valores\nEn Python, las funciones pueden devolver m칰ltiples valores separ치ndolos por comas en la sentencia return. Por ejemplo:\n\ndef potencias(x):\n    cuadrado = x ** 2\n    cubo = x ** 3\n    return cuadrado, cubo\n\npotencias(2)\n\n(4, 8)\n\n\nEl resultado de este tipo de funciones puede ser asignado a m칰ltiples variables. De esta forma, podemos obtener el cuadrado y el cubo de un n칰mero con una sola llamada a una funci칩n.\n\ncuadrado, cubo = potencias(8)\nprint(cuadrado)\nprint(cubo)\n\n64\n512\n\n\n\n\n\n\n\n\nObservaci칩n 游\n\n\n\nAl igual que en la asignaci칩n m칰ltiple de variables, lo que parece ser una funci칩n que devuelve m칰ltiples objetos es en realidad una funci칩n que devuelve un 칰nico objeto llamado tupla (de tipo tuple) que permite la t칠cnica de unpacking.\nNo te preocupes, m치s adelante vamos a ver bien c칩mo funciona.",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#diagrama-de-una-funci칩n",
    "href": "teoria/01_programacion_en_python/02_funciones.html#diagrama-de-una-funci칩n",
    "title": "2 - Funciones",
    "section": "Diagrama de una funci칩n",
    "text": "Diagrama de una funci칩n\n\n\n\n\n\nAlgunos efectos colaterales pueden ser:\n\nImprimir un texto o un gr치fico.\nCambiar el valor de una variable global.\nCrear, eliminar o modificar un archivo de la computadora.\n\n\n\n\n\n\n\n쯇uedo devolver una salida y generar efectos colaterales a la vez? 游뱂\n\n\n\nUna funci칩n en Python puede realizar m칰ltiples tareas, como devolver un valor e imprimir un mensaje en pantalla.\nPor ejemplo:\ndef producto(x, y):\n    resultado = x * y\n    print(\"El producto es\", resultado)\n    return resultado\nLa funci칩n producto() no solo calcula y devuelve el resultado de multiplicar x por y, sino que adem치s muestra un mensaje por pantalla.\nSin embargo, en general no es una buena pr치ctica combinar tareas distintas dentro de una misma funci칩n, especialmente si son de distinta naturaleza (como devolver un valor y causar un efecto colateral). Esto puede dificultar la reutilizaci칩n y el mantenimiento del c칩digo.",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#argumentos-nombrados-y-posicionales",
    "href": "teoria/01_programacion_en_python/02_funciones.html#argumentos-nombrados-y-posicionales",
    "title": "2 - Funciones",
    "section": "Argumentos nombrados y posicionales",
    "text": "Argumentos nombrados y posicionales\nAl definir una funci칩n, debemos darle un nombre a cada uno de los argumentos que va a recibir.\nAl llamar a la funci칩n, podemos pasar los valores de dos formas: por posici칩n o por nombre.\nPor ejemplo, las siguientes llamadas a la funci칩n sumar() son equivalentes:\n\nsumar(x = 10, y = 15)\n\n25\n\n\n\nsumar(10, 15)\n\n25\n\n\nSi utilizamos los nombres para pasar los argumentos no hace falta que est칠n en el mismo orden que en la definici칩n de la funci칩n.\n\nsumar(y = 15, x = 10)\n\n25\n\n\n춰Que sea posible no significa que sea una buena pr치ctica!",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#ausencia-de-return",
    "href": "teoria/01_programacion_en_python/02_funciones.html#ausencia-de-return",
    "title": "2 - Funciones",
    "section": "Ausencia de return",
    "text": "Ausencia de return\nLa funci칩n sumar() termina con la siguiente l칤nea:\n    return x + y\nEs decir, utiliza la sentencia return para devolver un valor.\nPor otro lado, la funci칩n saludar() termina con un print() y no tiene ning칰n return.\n    print(\"Hola\", nombre)\n\nresultado = sumar(1, 2)\nresultado\n\n3\n\n\n\nsaludo = saludar(\"Juan\")\n\nHola Juan\n\n\n\n쮺u치l es el valor de la variable saludo?\n쯇or qu칠?\n쯊iene sentido?\n\n\nprint(saludo)\n\nNone\n\n\nEn Python no existe el concepto de return impl칤cito.\nSi queremos que una funci칩n devuelva un valor, es necesario usar la instrucci칩n return de forma expl칤cita.\nEn caso de no hacerlo, la funci칩n devuelve autom치ticamente None.",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#argumentos-por-defecto",
    "href": "teoria/01_programacion_en_python/02_funciones.html#argumentos-por-defecto",
    "title": "2 - Funciones",
    "section": "Argumentos por defecto",
    "text": "Argumentos por defecto\nCuando definimos una funci칩n podemos determinar valores por defecto para uno o m치s par치metros.\nSi cuando llamamos a la funci칩n le pasamos un valor a ese par치metro, se utiliza el valor que pasamos. Sino, se usa el valor por defecto.\nEsta pr치ctica es 칰til para simplificar las llamadas que realizamos a una funci칩n.\nSupongamos la siguiente funci칩n describir_mascota() que tiene los par치metros nombre y tipo\n\ndef describir_mascota(nombre, tipo):\n    print(\"Tengo un\", tipo)\n    print(\"Y su nombre es\", nombre)\n\ndescribir_mascota(\"Bruno\", \"perro\")\n\nTengo un perro\nY su nombre es Bruno\n\n\nAhora, hacemos que el par치metro tipo sea por defecto igual a \"perro\".\n\ndef describir_mascota(nombre, tipo=\"perro\"):\n    print(\"Tengo un\", tipo)\n    print(\"Y su nombre es\", nombre)\n\nDe este modo, es posible llamar a la funci칩n solamente pasando valores para aquellos par치metros sin valor por defecto:\n\ndescribir_mascota(\"Bruno\")\n\nTengo un perro\nY su nombre es Bruno\n\n\nComo es de esperar, tambi칠n es posible pasar valores distintos a los establecidos por defecto:\n\ndescribir_mascota(\"Nemo\", \"pez\")\n\nTengo un pez\nY su nombre es Nemo",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html",
    "href": "teoria/01_programacion_en_python/01_introduccion.html",
    "title": "1 - Introducci칩n",
    "section": "",
    "text": "Python es un lenguaje de programaci칩n interpretado, de prop칩sito general y de alto nivel. Fue creado por Guido Van Rossum y su primera versi칩n p칰blica fue en el a침o 1991.\n\nInterpretado: no requiere que realicemos un paso expl칤cito de compilaci칩n a lenguaje de m치quina antes de ejecutarlo. Adem치s, se puede ejecutar l칤nea por l칤nea.\nProp칩sito general: no se limita a un tipo de aplicaci칩n espec칤fica, es decir, se puede usar para implementar programas en diferentes dominios:\n\nVox populi: No es el mejor en casi nada, pero suficientemente bueno para casi todo.\nAlgunos dominios:\n\nAn치lisis estad칤stico y ciencia de datos.\nInteligencia artificial.\nDesarrollo web.\nDesarrollo de videojuegos.\nScripting.\n\n\nAlto nivel: se parece m치s al lenguaje humano que al lenguaje de las m치quinas.\n\nAdem치s뵢n\nEs gratis: no requiere pagar licencias para usarlo, tanto a nivel personal como comercial.\nEs de c칩digo abierto: su c칩digo fuente est치 disponible p칰blicamente y puede ser modificado por cualquiera.\nPosee un ecosistema de librer칤as complet칤simo: existen miles de paquetes para todo tipo de tareas.\nComunidad: millones de personas lo usan, contribuyen, resuelven dudas y crean contenido, lo que facilita aprender y encontrar ayuda.\n\nPara utilizar Python es necesario instalar un int칠rprete de Python. La versi칩n oficial puede ser descargada desde python.org. Una vez instalado el int칠rprete, es posible ejecutar scripts de Python y programar en Python de manera interactiva desde la terminal.\nEn esta materia se utiliza un editor de c칩digo para ciencia de datos llamado Positron. Este editor es desarrollado por Posit, los mismos creadores de RStudio, y permite trabajar tanto con Python como con R.\nLas instrucciones para instalar Python y Positron pueden ser encontradas en Instalaci칩n de Python y Positron en Windows.\n\n\n\nEmpecemos utilizando a Python como si fuese una calculadora. Para eso vamos a crear un bloque de c칩digo en la notebook y escribimos algunas cuentas tal como lo hacemos en cualquier calculadora.\n\n2 * 3\n\n6\n\n\nNo tenemos la necesidad de pisar el c칩digo todo el tiempo. Podemos escribir nuevas celdas de c칩digo, y as칤 podemos ir mostrando diferentes c칩mputos y sus resultados.\n\n100 / 3.5\n\n28.571428571428573\n\n\n\n20 + 5\n\n25\n\n\n\n13 - 3\n\n10\n\n\n\n10 * 5.5\n\n55.0",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "1 - Introducci칩n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#qu칠-es-python",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#qu칠-es-python",
    "title": "1 - Introducci칩n",
    "section": "",
    "text": "Python es un lenguaje de programaci칩n interpretado, de prop칩sito general y de alto nivel. Fue creado por Guido Van Rossum y su primera versi칩n p칰blica fue en el a침o 1991.\n\nInterpretado: no requiere que realicemos un paso expl칤cito de compilaci칩n a lenguaje de m치quina antes de ejecutarlo. Adem치s, se puede ejecutar l칤nea por l칤nea.\nProp칩sito general: no se limita a un tipo de aplicaci칩n espec칤fica, es decir, se puede usar para implementar programas en diferentes dominios:\n\nVox populi: No es el mejor en casi nada, pero suficientemente bueno para casi todo.\nAlgunos dominios:\n\nAn치lisis estad칤stico y ciencia de datos.\nInteligencia artificial.\nDesarrollo web.\nDesarrollo de videojuegos.\nScripting.\n\n\nAlto nivel: se parece m치s al lenguaje humano que al lenguaje de las m치quinas.\n\nAdem치s뵢n\nEs gratis: no requiere pagar licencias para usarlo, tanto a nivel personal como comercial.\nEs de c칩digo abierto: su c칩digo fuente est치 disponible p칰blicamente y puede ser modificado por cualquiera.\nPosee un ecosistema de librer칤as complet칤simo: existen miles de paquetes para todo tipo de tareas.\nComunidad: millones de personas lo usan, contribuyen, resuelven dudas y crean contenido, lo que facilita aprender y encontrar ayuda.\n\nPara utilizar Python es necesario instalar un int칠rprete de Python. La versi칩n oficial puede ser descargada desde python.org. Una vez instalado el int칠rprete, es posible ejecutar scripts de Python y programar en Python de manera interactiva desde la terminal.\nEn esta materia se utiliza un editor de c칩digo para ciencia de datos llamado Positron. Este editor es desarrollado por Posit, los mismos creadores de RStudio, y permite trabajar tanto con Python como con R.\nLas instrucciones para instalar Python y Positron pueden ser encontradas en Instalaci칩n de Python y Positron en Windows.\n\n\n\nEmpecemos utilizando a Python como si fuese una calculadora. Para eso vamos a crear un bloque de c칩digo en la notebook y escribimos algunas cuentas tal como lo hacemos en cualquier calculadora.\n\n2 * 3\n\n6\n\n\nNo tenemos la necesidad de pisar el c칩digo todo el tiempo. Podemos escribir nuevas celdas de c칩digo, y as칤 podemos ir mostrando diferentes c칩mputos y sus resultados.\n\n100 / 3.5\n\n28.571428571428573\n\n\n\n20 + 5\n\n25\n\n\n\n13 - 3\n\n10\n\n\n\n10 * 5.5\n\n55.0",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "1 - Introducci칩n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#tipos-de-datos",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#tipos-de-datos",
    "title": "1 - Introducci칩n",
    "section": "Tipos de datos",
    "text": "Tipos de datos\nComo cualquier lenguaje de programaci칩n, Python ofrece diferentes tipos de datos.\nCada tipo de dato nos ayuda a resolver una tarea distinta. Por ejemplo, si quiero hacer operaciones matem치ticas voy a necesitar de n칰meros, pero si quiero escribir un correo electr칩nico voy a necesitar de texto.\nA continuaci칩n vamos a introducir los tipos de datos m치s b치sicos que Python nos ofrece.\nM치s adelante tambi칠n veremos otros tipos de datos m치s complejos que nos van a permitir resolver problemas (much칤simo) m치s interesantes.\n\nN칰meros\nAcabamos de hacer cuentas matem치ticas somo si tuvieramos una calculadora. Para eso usamos n칰meros, los conocidos de toda la vida.\nSin notarlo, utilizamos dos tipos de n칰meros distintos: los n칰meros de tipo entero (int) y los n칰meros de tipo flotante (float).\nLo siguiente es un n칰mero entero:\n\n50\n\n50\n\n\nY el siguiente es un ejemplo de un n칰mero flotante:\n\n36.8\n\n36.8\n\n\nUtilizando la funci칩n type() Python nos devuelve el tipo del objeto.\n\ntype(10)\n\nint\n\n\n\ntype(10.5)\n\nfloat\n\n\n\ntype(10.0)\n\nfloat\n\n\n\ntype(10.)\n\nfloat\n\n\n\n\n\n\n\n\nObservaci칩n 游\n\n\n\nA diferencia de R, Python no es un lenguaje vectorizado. Por lo tanto, los tipos int y float representan valores escalares, no vectores de longitud 1 como ocurre en R.\nEsta observaci칩n aplica a todos los tipos de datos elementales que vienen a continuaci칩n.\n\n\n\n\nCadenas de texto\nPara ser una lenguaje de programaci칩n tan afamado, Python tiene que ser capaz de trabajar con objetos m치s complejos que los n칰meros.\nUn ejemplo de esto es el texto, que se representa con un objeto llamado cadena de texto y se construyen utilizando comillas.\nComo en la mayor칤a de los lenguajes de programaci칩n, las comillas se ponen al principio y al final del texto e indican el principio y el final de la cadena; estas pueden pueden ser dobles \" o simples '.\n\n\"Programando en Python\"\n\n'Programando en Python'\n\n\n\n'Con comillas simples, tambi칠n.'\n\n'Con comillas simples, tambi칠n.'\n\n\nEn Python no hay diferencia entre usar comillas simples ' o dobles \", pero es importante que el tipo de comilla que se usa para abrir la cadena sea el mismo que se usa para cerrarla.\nCuando imprimimos una cadena, las comillas no se muestran en la salida. Para imprimir cualquier objeto de Python utilizamos la funci칩n print().\n\nprint('Con comillas simples, 춰tambi칠n!')\n\nCon comillas simples, 춰tambi칠n!\n\n\nUna forma un poco m치s ex칩tica, pero muy 칰til, de crear cadenas es utilizando comillas triples. Con esta sintaxis, se repiten tres comillas seguidas, lo que permite definir cadenas de texto que ocupan varias l칤neas.\n\nprint(\"\"\"Se puede escribir texto\nen varias lineas.\n춰Est치 muy bueno!\"\"\")\n\nSe puede escribir texto\nen varias lineas.\n춰Est치 muy bueno!\n\n\nOtra manera de escribir texto que abarca m칰ltiples l칤neas es usando el car치cter especial \\n, que representa un salto de l칤nea.\n\nprint(\"Primera l칤nea\\nsegunda l칤nea\\ntercera l칤nea.\")\n\nPrimera l칤nea\nsegunda l칤nea\ntercera l칤nea.\n\n\nEn cambio, si mostramos una representaci칩n del texto (sin usar print()), los \\n s칤 se visualizan.\n\n\"Primera l칤nea\\nsegunda l칤nea\\ntercera l칤nea.\"\n\n'Primera l칤nea\\nsegunda l칤nea\\ntercera l칤nea.'\n\n\n\n\n\n\n\n\n춰Atenci칩n! 游뱁\n\n\n\n쮺u치l es la diferencia entre usar print() y no usarlo?\n\nCuando usamos print() se imprime el objeto de una manera humanamente legible.\nCuando no lo usamos, se muestra una representaci칩n del objeto. Esta representaci칩n tiene que ser lo menos ambigua posible.\n\nPor este motivo es que se muestran las comillas a la hora de representar una cadena.\n\n\n\n\nOtra situaci칩n en la que usar print() genera una diferencia es cuando se quieren mostrar varios objetos en una notebook. Por ejemplo, comparemos el resultado de los siguientes bloques:\n\n\"mensaje 1\"\n10\n\"mensaje 2\"\n\n'mensaje 2'\n\n\n\nprint(\"mensaje 1\")\nprint(10)\nprint(\"mensaje 2\")\n\nmensaje 1\n10\nmensaje 2\n\n\n\n\nL칩gicos (o Booleanos)\nComo veremos m치s adelante, nuestros programas suelen tener que decidir entre diferentes acciones a tomar seg칰n se cumpla o no cierta condici칩n.\nPara representar esta situaci칩n utilizamos un tipo especial de dato conocido como l칩gico o booleano, que puede tomar 칰nicamente dos valores: True o False.\nSi la condici칩n se cumple, el resultado ser치 True; de lo contrario, ser치 False.\n\nTrue\n\nTrue\n\n\n\nFalse\n\nFalse\n\n\n\ntype(True)\n\nbool\n\n\n\ntype(False)\n\nbool\n\n\n\n\n\n\n\n\nRese침a hist칩rica 游닆\n\n\n\nEste tipo de datos se llama Booleano en honor al matem치tico George Boole.\n\n\n\n\nNulo\nEl valor nulo, llamado None en Python, representa la ausencia de valor o el vac칤o. Se utiliza habitualmente para indicar que algo no tiene un valor asignado. Si intentamos mostrar el valor de None, veremos que no aparece nada.\n\nNone\n\nEn cambio, si imprimimos el objeto None, vemos el mensaje None.\n\nprint(None)\n\nNone\n\n\n쯏 cu치l es su tipo?\n\ntype(None)\n\nNoneType\n\n\nSolamente los objetos None son del tipo NoneType.\n\n\n\n\n\n\n쯇or qu칠 existe el valor nulo? 游뱂\n\n\n\nMuchas veces nuestro programa, o alguna parte del mismo, realiza una tarea que no devuelve ning칰n resultado.\nPodr칤amos ponernos de acuerdo en representar 랉ing칰n resultado usando un n칰mero (e.g., 0), una cadena vac칤a (\"\"), o algo similar. Pero estos valores representan algo espec칤fico, no la ausencia total de valor.\nPara expresar claramente que no hay ning칰n resultado, Python incluye un valor especial llamado None.\n\n\nEjemplos\n\nUn usuario completa un formulario con datos personales, pero algunos campos no son obligatorios y quedan sin completar.\nUna funci칩n busca un elemento en una lista; cuando no encuentra lo buscado, devuelve un valor especial indicando que el resultado est치 ausente.\n\nEn general, cuando se quiera representar la ausencia de informaci칩n se utilizar치 None.\n\n\n\n\n\n\nObservaci칩n 游\n\n\n\nEn R existen dos tipos de datos para representar valores faltantes: NULL y NA. El None de Python equivale a NULL en R, ya que ambos indican ausencia de valor.\nPor otro lado, NA en R representa un valor existente pero desconocido, por ejemplo, porque se ha perdido. Python no ofrece un tipo de dato equivalente de forma nativa, aunque algunas librer칤as s칤 lo implementan.\n\n\n\n\nConversi칩n entre tipos de datos\nQue existan distintos tipos de datos no significa que un objeto de un tipo no pueda 띾onvertirse a otro.\nEn muchos casos es posible convertir entre tipos de datos. Por ejemplo, un n칰mero siempre se puede convertir a una cadena de caracteres, pero no cualquier cadena puede convertirse a un n칰mero.\nPara convertir un objeto a otro tipo utilizamos funciones con el nombre del tipo al que queremos convertir, como str(), int() o bool(). Estas funciones reciben como argumento el objeto a convertir.\nVeamos algunos ejemplos:\n\nstr(256)\n\n'256'\n\n\n\nstr(None)\n\n'None'\n\n\n\nint(165.5)\n\n165\n\n\n\nint(165.8)\n\n165\n\n\n\nint(\"165\")\n\n165\n\n\n\nfloat(\"165.0\")\n\n165.0\n\n\n\n\nResumen\n\nPython tiene distintos tipos de datos.\nCada tipo de dato es 칰til para resolver diferentes problemas.\n\nA lo largo de la materia veremos much칤simos ejemplos.\n\nAl principio, tener varios tipos de datos puede parecer complejo.\n\nSin embargo, nos resultar치n muy naturales a medida que los usemos para resolver problemas concretos.\n\n\n\n\n\n\n\n\n\nTipo de dato\nEjemplos\n\n\n\n\nN칰meros enteros (int)\n-2, -1, 0, 10, 200\n\n\nN칰meros de punto flotante (float)\n-200.789, -1.0, 0.0, 17.8\n\n\nCadenas de texto (str)\n\"a\", \"abc\", \"Rosario, Santa Fe\"\n\n\nBooleanos (bool)\nTrue, False\n\n\nValor nulo (NoneType)\nNone",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "1 - Introducci칩n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#variables",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#variables",
    "title": "1 - Introducci칩n",
    "section": "Variables",
    "text": "Variables\n쮼s necesario escribir expl칤citamente los valores con los que trabajamos cada vez que los usamos? Afortunadamente, la respuesta es no.\nLos lenguajes de programaci칩n m치s populares permiten usar variables.\nPodemos pensar las variables como etiquetas o nombres que asignamos a los objetos en nuestro programa.\nUna vez creada una variable con cierto valor, podemos usar directamente su nombre en lugar de volver a escribir el valor completo.\n\nmensaje = \"춰Hola, curso!\"\nprint(mensaje)\n\n춰Hola, curso!\n\n\n\nprint(\"춰Hola, curso!\")\n\n춰Hola, curso!\n\n\nPara crear una variable se necesita:\n\nEl nombre.\nEl operador de asignaci칩n.\nEl valor que queremos asignar a la variable.\n\nEn nuestro caso, el nombre de la variable es mensaje y el valor es \"춰Hola, curso!\".\nLuego, cuando accedemos a la variable mensaje dentro de la funci칩n print(), Python nos devuelve el valor de la variable, es decir, 춰Hola, curso!\".\nVeamos otros ejemplos뵢n\npi = 3.14159\nfruta_favorita = \"manzana\"\npython_bueno = True\n\nEn el siguiente diagrama se muestra c칩mo las variables que creamos funcionan simplemente como etiquetas para los valores asignados.\nCada vez que utilizamos una de estas etiquetas, accedemos directamente al valor que representa.\n\n\n\n\n\n\nprint(pi * 10)\n\n31.4159\n\n\n\nfruta_favorita\n\n'manzana'\n\n\n\npython_bueno\n\nTrue\n\n\nLas variables no solo evitan que escribamos repetidamente los mismos valores en nuestro programa, sino que tambi칠n permiten:\n\nGeneralizar el programa\n\nAl cambiar el valor de una variable, todas las partes del programa que la usan se actualizan autom치ticamente.\n\nMejorar la legibilidad del c칩digo\n\nSi elegimos nombres claros y descriptivos, el programa ser치 mucho m치s f치cil de leer y entender.\n\n\nPor ejemplo, los siguientes bloques de c칩digo producen el mismo resultado, pero el segundo es mucho m치s informativo:\n\n1500 * 8\n\n12000\n\n\n\nprecio = 1500\ncantidad = 8\nprecio * cantidad\n\n12000\n\n\n\nNombres permitidos\nNo todos los nombres que imaginemos se pueden utilizar como variables en Python.\nTenemos que tener en cuenta las siguientes reglas. Los nombres de variables뵢n\nSolo pueden contener letras, n칰meros y guiones bajos (_).\nDeben comenzar con una letra o un gui칩n bajo, pero no con un n칰mero.\n\nPor ejemplo, mensaje_1 es v치lido, pero 1_mensaje no lo es.\n\nNo pueden contener espacios.\n\nPor eso usamos fruta_favorita en lugar de fruta favorita.\n\nNo pueden ser palabras reservadas de Python.\n\nLas palabras reservadas se encuentran al final de este apunte.\n\n\nAdem치s, tambi칠n vale la pena tener presente estos consejos:\n\nUs치 nombres breves pero descriptivos.\n\nnombre es preferible a n.\nfruta_favorita es preferible a frut_fav.\n\nEvit치 utilizar tildes, la letra 침 u otros caracteres espec칤ficos del castellano.\n\n\n\nEliminar variables\nEs posible que, despu칠s de crear nuestras variables y realizar las operaciones necesarias, queramos eliminarlas.\nPara borrar una variable, Python ofrece la sentencia del (del ingl칠s delete, que significa eliminar o borrar).\n\ndel fruta_favorita\n\n\n\nAsignaci칩n m칰ltiple\nYa vimos que para asignar (o crear) una variable necesitamos hacer variable = &lt;valor&gt;.\nSi queremos crear varias variables, podemos hacerlo en l칤neas separadas:\n\npi = 3.1416\ne = 2.7182\n\nprint(pi)\nprint(e)\n\n3.1416\n2.7182\n\n\nUna caracter칤stica conveniente de Python es que permite asignar m칰ltiples variables en una misma l칤nea:\n\npi, e = 3.1416, 2.7182\n\nprint(pi)\nprint(e)\n\n3.1416\n2.7182\n\n\nOtra ventaja es que las variables no tienen que ser del mismo tipo:\n\na, b, c = 100 + 20, \"un mensaje cualquiera\", None\n\nprint(a)\nprint(b)\nprint(c)\n\n120\nun mensaje cualquiera\nNone\n\n\nEsta t칠cnica es 칰til para escribir c칩digo m치s conciso, pero no conviene abusar de ella porque puede resultar en c칩digo poco legible.\n\n\n\n\n\n\nObservaci칩n 游\n\n\n\nLa vida es m치s compleja de lo que parece, y los lenguajes de programaci칩n no son una excepci칩n.\nEn Python, lo que parece una asignaci칩n m칰ltiple de variables es en realidad el uso de una t칠cnica m치s avanzada llamada unpacking.\nA no desesperarse, m치s adelante vamos a aprender de qu칠 se trata.",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "1 - Introducci칩n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#operadores",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#operadores",
    "title": "1 - Introducci칩n",
    "section": "Operadores",
    "text": "Operadores\nLos operadores son s칤mbolos que se utilizan para realizar operaciones o acciones sobre los objetos con los que estamos trabajando.\nHasta ahora, vimos que podemos tener n칰meros, texto, y otras objetos un poco mas extra침os como los booleanos e incluso algo que representa a la nada misma.\nA continuaci칩n, comenzamos a ver algunas de las tareas que podemos hacer con ellos.\n\nOperadores aritm칠ticos\nPython incluye los mismos operadores aritm칠ticos que solemos utilizar en nuestro d칤a a d칤a para hacer operaciones matem치ticas.\nEstos se parecen much칤simo a los que usamos en una calculadora, por lo que podr칤amos entenderlo incluso sin saber de Python.\nAlgunos operadores son los siguientes:\n\nSuma (+)\nResta (-)\nMultiplicaci칩n (*)\nPotencia (**)\nDivisi칩n (/)\nDivisi칩n entera (//)\nM칩dulo (%)\n\n\nSuma (+)\n\n10 + 25\n\n35\n\n\n\n10.0 + 25.0\n\n35.0\n\n\n\n-8 + 12.1\n\n4.1\n\n\nEl operador suma tambi칠n puede ser usado con un solo argumento:\n\n+ 8\n\n8\n\n\nEn este caso no modifica en nada al valor 8.\n\n\n\nResta (-)\n\n11 - 8\n\n3\n\n\n\n100 - 100.0\n\n0.0\n\n\n\n-35 - 28\n\n-63\n\n\nEl operador resta tambi칠n puede ser usado con un solo argumento:\n\n- 7\n\n-7\n\n\n\n\nMultiplicaci칩n (*) y potencia (**)\n\n21 * 5\n\n105\n\n\n\n21 * 5.0\n\n105.0\n\n\n\n21.0 * 5.0\n\n105.0\n\n\n\n2 ** 3\n\n8\n\n\n\n2 ** 3.0\n\n8.0\n\n\n\n\n\n\n\n\nConclusiones\n\n\n\nPara las operaciones de suma, resta, multiplicaci칩n y potencia se cumple:\n\nSi ambos valores son enteros, el resultado ser치 un entero.\nSi al menos uno de los valores es flotante, el resultado ser치 flotante.\n\n\n\n\n\nDivisi칩n (/ y //)\nPython provee dos operadores distintos para calcular el cociente entre dos n칰meros.\n\nEl operador / que calcula la divisi칩n flotante.\nEl operador // que calcula la divisi칩n entera.\n\nEl operador / es el que m치s se utiliza y siempre devuelve un n칰mero de tipo flotante.\n\n10 / 5\n\n2.0\n\n\n\n10 / 5.5\n\n1.8181818181818181\n\n\nLa divisi칩n entera se suele utilizar cuando uno quiere el resultado entero de la divisi칩n, sin importar si el resto es 0 o no.\n\n10 // 5\n\n2\n\n\n\n10 // 5.5\n\n1.0\n\n\nVeamos los siguientes ejemplos donde comparamos la divisi칩n flotante con la divisi칩n entera, utilizando los mismos argumentos.\n\n15 / 4\n\n3.75\n\n\n\n15.0 // 4.0\n\n3.0\n\n\nConclusi칩n: La divisi칩n entera no redondea el resultado de la divisi칩n flotante. M치s sobre esto debajo.\n\n\nM칩dulo (%)\nOtro operador relacionado a la divisi칩n entera es el operador m칩dulo o resto (%).\nEsta operaci칩n nos devuelve el resto que se obtiene al realizar la divisi칩n entera entre dos n칰meros.\n\n17 % 3\n\n2\n\n\nDebajo se puede ver la relaci칩n entre la divisi칩n entera y el m칩dulo:\n\n\n\n\n\nAunque ahora pueda parecer dif칤cil encontrar una aplicaci칩n pr치ctica para los operadores de divisi칩n entera // y resto %, m치s adelante veremos ejemplos donde haremos un uso intensivo de ellos.\n\n\n\n\n\n\nObservaci칩n 游\n\n\n\nProbablemente en R hayan utilizado principalmente el operador /, que tambi칠n corresponde a la divisi칩n flotante.\nEn ese lenguaje, los operadores para divisi칩n entera y resto son %/% y %%, respectivamente.\n\n\n\n\nPrioridad de los operadores\nHasta ahora vimos operaciones bastante sencillas.\nCuando presentamos la suma, realizamos simplemente una suma. Cuando presentamos la multiplicaci칩n, hicimos solo una multiplicaci칩n.\nPor supuesto, al momento de hacer c치lculos podemos combinar los operadores que ya conocemos, de la misma forma en que lo hacemos al resolver cuentas a mano.\nUn punto importante a tener en cuenta es que, al igual que cuando hacemos cuentas a mano, algunas operaciones se resuelven antes que otras, sin importar el orden en que aparecen. Esto ocurre porque algunos operadores tienen mayor prioridad y, por lo tanto, se eval칰an antes.\nEn el siguiente ejemplo, 쯣or qu칠 se obtienen resultados distintos?\n\n10 - 2 * 4\n\n2\n\n\n\n(10 - 2) * 4\n\n32\n\n\nIndependientemente de que el s칤mbolo + aparezca antes que el s칤mbolo * en una expresi칩n, Python realiza primero la multiplicaci칩n.\nAl igual que cuando hacemos cuentas a mano, la multiplicaci칩n tiene mayor prioridad que la suma.\nSi queremos forzar a Python a realizar una operaci칩n antes que otra, sin importar la prioridad de los operadores, debemos usar par칠ntesis.\nOtro ejemplo es el siguiente뵢n\n7 + 8 / 2\n\n11.0\n\n\n\n(7 + 8) / 2\n\n7.5\n\n\nA continuaci칩n se incluye una tabla con los operadores que vimos y la prioridad que tiene cada uno.\nLos operadores que aparecen m치s arriba tienen mayor prioridad.\nLos operadores que aparecen en la misma fila tienen el mismo nivel de prioridad y se resuelven seg칰n el orden en que aparecen en el c칩digo (de izquierda a derecha).\n\n\n\n\n\n\n\nOperador\nSignificado\n\n\n\n\n()\nAgrupamiento\n\n\n**\nPotencia\n\n\n*, /, //, %\nMultiplicaci칩n, Divisi칩n, Divisi칩n entera, M칩dulo\n\n\n+, -\nSuma, Resta\n\n\n\nEsta lista es una versi칩n m치s sencilla y resumida de la tabla de prioridades de todos los operadores que hay en Python. Una versi칩n m치s completa se puede encontrar en Programiz.\n\n\n\nOperadores l칩gicos\nLos operadores l칩gicos en Python son tres: not, and y or. Se llaman as칤 porque combinan expresiones l칩gicas (o directamente valores l칩gicos) y devuelven tambi칠n valores l칩gicos, es decir, del tipo bool, que pueden ser True o False. Estos operadores se utilizan para combinar o invertir condiciones en expresiones l칩gicas.\n\nNegaci칩n (not)\nDevuelve el opuesto del valor que le pasamos.\n\nnot False\n\nTrue\n\n\n\nnot True\n\nFalse\n\n\n\n\nConjunci칩n o intersecci칩n (and)\nEsta operaci칩n devuelve True solamente cuando los dos operadores que le pasamos son True.\n\nTrue and True\n\nTrue\n\n\n\nFalse and True\n\nFalse\n\n\n\n\nDisyunci칩n o uni칩n (or)\nEsta operaci칩n devuelve True cuando cualquiera de sus argumentos es True.\n\nTrue or False\n\nTrue\n\n\nSolo devuelve False cuando sus dos argumentos son False.\n\nFalse or False\n\nFalse\n\n\n\n\n\nOperadores de comparaci칩n\n\nComparaci칩n por identidad\nPython ofrece dos operadores para verificar si dos objetos son o no el mismo en identidad (es decir, en memoria):\n\nis: devuelve True si ambos operandos son el mismo objeto.\nis not: devuelve True si los operandos no son el mismo objeto.\n\n\nFalse is False\n\nTrue\n\n\n\nFalse is True\n\nFalse\n\n\n\nNone is None\n\nTrue\n\n\nEste tipo de comparaci칩n es posible porque cada objeto en Python existe en la memoria de la computadora y tiene una identificaci칩n 칰nica (ID). Para conocer el ID de un objeto, se puede usar la funci칩n id().\n\nid(False)\n\n94152411564800\n\n\n\nid(False)\n\n94152411564800\n\n\n\nid(None)\n\n94152411476128\n\n\n\n\nComparaci칩n por valor\nPor otro lado, Python tambi칠n provee operadores para realizar comparaciones entre objetos en t칠rminos de sus valores.\nLos operadores que vemos a continuaci칩n son los mismos que aprendimos en la secundaria.\n\n\n\n\n\n\n\nOperador\nDescripci칩n\n\n\n\n\n==\nIgualdad: El resultado es True cuando los dos operandos son iguales.\n\n\n!=\nDesigualdad: El resultado es True si los operandos son distintos.\n\n\n&gt;\nMayor a: El resultado es True si el operando de la izquierda es mayor que el de la derecha.\n\n\n&gt;=\nMayor o igual a: El resultado es True si el operando de la izquierda es mayor o igual que el de la derecha.\n\n\n&lt;\nMenor a: El resultado es True si el operando de la izquierda es menor que el de la derecha.\n\n\n&lt;=\nMenor o igual a: El resultado es True si el operando de la izquierda es menor o igual que el de la derecha.\n\n\n\nAlgunos ejemplos뵢n\n10 &gt; 5\n\nTrue\n\n\n\n10 &gt; 5 + 3\n\nTrue\n\n\n\n0 &lt; 0\n\nFalse\n\n\n\n1 &gt;= 1\n\nTrue\n\n\n\n10.0 != 10\n\nFalse\n\n\n\n10.0 == 10\n\nTrue\n\n\nA pesar de que 10.0 es de tipo flotante y 10 es de tipo entero, vemos que la comparaci칩n de igualdad == dice que son iguales.\nNo siempre que comparemos objetos de distinto tipo va a suceder algo as칤.\nLa comparaci칩n de cadenas de texto distingue may칰sculas de min칰sculas\n\n\"UNR\" == \"unr\"\n\nFalse\n\n\nEs posible comparar objetos de distinto tipo, como lo vimos en el ejemplo anterior donde comparamos 10 y 10.0.\nSalvo casos particulares, como son los valores num칠ricos, estos objetos son considerados siempre distintos.\n\n\"10\" == 10\n\nFalse\n\n\n\n\"False\" == False\n\nFalse\n\n\nEs posible combinar mas de una comparaci칩n en la misma l칤nea.\n\n1 &lt; 2 and 2 &lt; 3\n\nTrue\n\n\nIncluso es posible omitir el operador and y tener una expresi칩n m치s clara\n\n1 &lt; 2 &lt; 3\n\nTrue\n\n\n\n-5 &lt; -4 &lt; -3\n\nTrue\n\n\nTambi칠n podemos mezclar not, and y or a gusto.\n\nFalse or not False\n\nTrue\n\n\nY es v치lido utilizar par칠ntesis para agrupar operaciones.\n\n(False or True) and (True or False)\n\nTrue\n\n\nA continuaci칩n se incluye una tabla con los operadores de comparaci칩n y la prioridad que tiene cada uno.\nLos operadores que aparecen m치s arriba tienen mayor prioridad.\nLos operadores que aparecen en la misma fila tienen el mismo nivel de prioridad y se resuelven seg칰n el orden en que aparecen en el c칩digo (de izquierda a derecha).\n\n\n\n\n\n\n\nOperadores\nSignificado\n\n\n\n\n==, !=, &gt;, &gt;=, &lt;, &lt;=, is, is not, in, not in\nComparaciones, identidad, pertenencia\n\n\nnot\nNegaci칩n\n\n\nand\nConjunci칩n o intersecci칩n\n\n\nor\nDisyunci칩n o uni칩n\n\n\n\nTodos los operadores de comparaci칩n tienen menor prioridad que los operadores aritm칠ticos que vimos arriba.\nEn otras palabras, si pegaramos ambas tablas, 칠sta 칰ltima quedar칤a por debajo.\nAnalicemos nuevamente uno de los ejemplos que ya vimos.\n\nnot True and not True\n\nFalse\n\n\nEl operador not tiene mayor prioridad que el operador and porque aparece primero en la tabla.\nEn consecuencia, en el c칩digo anterior primero se resuelven los not True y luego el and. Esto es lo mismo que hacer\n\nFalse and False\n\nFalse\n\n\n\n\n\n\n\n\nResumen 游닇\n\n\n\nExisten dos operadores para comparar igualdad entre dos objetos de Python:\n\n==  compara el valor (contenido).\nis  compara la identidad (ubicaci칩n en memoria).",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "1 - Introducci칩n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#operaciones-con-cadenas-de-caracteres",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#operaciones-con-cadenas-de-caracteres",
    "title": "1 - Introducci칩n",
    "section": "Operaciones con cadenas de caracteres",
    "text": "Operaciones con cadenas de caracteres\n\nSuma y producto\nAunque al principio pueda parecer extra침o, en Python es posible usar operadores matem치ticos con objetos que no son num칠ricos.\nEsto no significa que se puedan aplicar a cualquier objeto, ni que est칠n disponibles todos los operadores en esos casos.\nSin embargo, vale la pena resaltar el uso del operador de suma (+) y producto (*) con las cadenas de caracteres.\nVeamos que pasa si 랍umamos dos cadenas de caracteres:\n\n\"쮽unciona\" + \"bien?\"\n\n'쮽uncionabien?'\n\n\n\n\"쯘sto\" + \" tambi칠n \" + \"funciona?\"\n\n'쯘sto tambi칠n funciona?'\n\n\nComo se puede observar, el operador de suma (+) aplicado a cadenas de texto indica concatenaci칩n: crea una nueva cadena uniendo el contenido de las cadenas originales, en el mismo orden.\nSi la suma tiene sentido para cadenas, entonces el producto tambi칠n deber칤a tenerlo (al menos con n칰meros enteros). Veamos un ejemplo:\n\n\"ja\" * 2\n\n'jaja'\n\n\n\n\"ja\" * 4\n\n'jajajaja'\n\n\nDe manera coherente con la definici칩n de producto para enteros, multiplicar una cadena por un n칰mero entero N equivale a concatenar esa cadena consigo misma N veces.\n\n\nCadenas formateadas (formatted strings)\nLas cadenas de texto formateadas son de gran utilidad para crear una cadena de texto a partir de otros objetos.\nEn Python se las conoce como f-strings (abreviaci칩n de formatted-strings) y tienen este nombre porque tenemos que poner una f antes de las comillas.\nEl resultado de una f-string no se diferencia de una cadena de texto com칰n y corriente.\n\nf\"Un texto cualquiera\"\n\n'Un texto cualquiera'\n\n\nSin embargo, las f-strings nos permiten interpolar cadenas de texto.\n쯈u칠 es interpolar texto?\nVeamos algunos ejemplos.\n\nlenguaje = \"Python\"\nprint(\"Programando en \" + lenguaje)\n\nProgramando en Python\n\n\n\nque = \"bayer\"\ncomo = \"bueno\"\nprint(\"Si es \" + que + \" es \" + como + \".\")\n\nSi es bayer es bueno.\n\n\nEl proceso se vuelve un poco engorroso. Hay que estar atentos a las sumas y los espacios para que el resultado quede formateado de una manera correcta.\nLas f-strings vienen a facilitar este proceso y hacerlo menos tedioso.\nLo que tenemos que hacer es pasar el nombre de la variable entre llaves ({}) en el contenido de la f-string.\n\nprint(f\"Programando en {lenguaje}\")\nprint(f\"Si es {que} es {como}.\")\n\nProgramando en Python\nSi es bayer es bueno.\n\n\nVeamos un ejemplo menos trivial, donde utilizar f-strings reduce la cantidad de c칩digo y lo hace m치s claro.\n\nnombre = \"Tom치s\"\nedad = 29\nciudad = \"Rosario\"\n\nprint(\"Hola, soy \" + nombre + \", tengo \" + str(edad) + \" a침os y vivo en \" + ciudad + \".\")\n\nHola, soy Tom치s, tengo 29 a침os y vivo en Rosario.\n\n\nUtilizando f-strings뵢n\nprint(f\"Hola, soy {nombre}, tengo {edad} a침os y vivo en {ciudad}.\")\n\nHola, soy Tom치s, tengo 29 a침os y vivo en Rosario.\n\n\nAdem치s, no es necesario convertir la variable edad a al tipo str manualmente.\nNo solo podemos utilizar variables dentro de las f-strings, tambi칠n podemos incluir expresiones de Python.\n\nminutos_por_hora = 60\nhoras = 2.7\n\nprint(f\"En {horas} horas hay {horas * minutos_por_hora} minutos.\")\n\nEn 2.7 horas hay 162.0 minutos.\n\n\n\n\nCadenas de texto y sus met칩dos\n\nnombre = \"Lionel Messi\"\n\nLas cadenas de texto, es decir, los objetos de tipo str, vienen con varias funciones (llamados 랈칠todos) que nos facilitan much칤simas tareas en la pr치ctica.\nPor ejemplo, tenemos los m칠todos .upper() y .lower(), que ponen el texto en may칰scula y en min칰scula, respectivamente.\n\nprint(nombre.upper())\nprint(nombre.lower())\n\nLIONEL MESSI\nlionel messi\n\n\nTambi칠n tenemos .capitalize(), que pone la primer letra en may칰scula y el resto en min칰sculas.\nEstos m칠todos se pueden combinar dentro de una f-string, sin necesidad de modificar los valores de nombre o apellido.\n\nnombre = \"lionel\"\napellido = \"messi\"\nnombre_completo = f\"{nombre.capitalize()} {apellido.capitalize()}\"\nprint(nombre_completo)\n\nLionel Messi\n\n\nOtra opci칩n es usar .title().\nEste m칠todo pone la primera letra de cada palabra en may칰sculas y al resto en min칰sculas.\n\nmensaje = \"mensaje de prueba\"\nprint(mensaje.capitalize())\nprint(mensaje.title())\n\nMensaje de prueba\nMensaje De Prueba\n\n\n\n\nEliminar espacios en blanco\nEs muy com칰n que en nuestros programas tengamos que lidiar con texto que vienen con espacios en blanco que est치n dem치s.\nEl espacio puede estar tanto al principio como al final de una cadena de texto.\nAfortunadamente, Python tambi칠n provee algunos m칠todos que nos permiten eliminar estos espacios con muy poco trabajo.\n\nlenguaje_favorito = \"  python  \"\nlenguaje_favorito\n\n'  python  '\n\n\n.rstrip() elimina los espacios en blanco a la derecha del texto.\n\nlenguaje_favorito.rstrip()\n\n'  python'\n\n\n.lstrip() elimina los espacios en blanco a la izquierda del texto.\n\nlenguaje_favorito.lstrip()\n\n'python  '\n\n\ny .strip() elimina los espacios en blanco a la izquierda y a la derecha del texto.\n\nlenguaje_favorito.strip()\n\n'python'\n\n\n\n\nReemplazar y eliminar caracteres no deseados\nTambi칠n es frecuente que el texto contenga caracteres err칩neos, o caracteres que simplemente no queremos conservar.\nPara estos casos podemos usar el m칠todo .replace().\nA diferencia de los m칠todos que vimos hasta ahora, .replace() requiere que le pasemos algunos argumentos.\nEl primer valor que le pasamos es el texto que queremos reemplazar y el segundo es el texto de reemplazo.\nPodemos reemplazar caracteres, palabras, o frases enteras.\n\nanimal = \"pato\"\nanimal.replace(\"p\", \"g\")\n\n'gato'\n\n\n\nsaludo = \"Hola Mundo\"\nsaludo.replace(\"Mundo\", \"Curso\")\n\n'Hola Curso'\n\n\nCuando utilizamos el m칠todo .replace() se nos devuelve una nueva cadena de texto.\nEsto nos permite 랋egar o 란ncadenar mas de un .replace() a la vez, ya que cada nuevo .replace() se aplica sobre el resultado de la operaci칩n anterior.\n\nsaludo.replace(\"Mundo\", \"Curso\").replace(\"Hola\", \"Chau\")\n\n'Chau Curso'\n\n\nsaludo.replace(\"Mundo\", \"Curso\") devuelve \"Hola Curso\", al que luego se le aplica .replace(\"Hola\", \"Chau\") y el resultado final es \"Chau Curso\".",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "1 - Introducci칩n"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#ap칠ndice",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#ap칠ndice",
    "title": "1 - Introducci칩n",
    "section": "Ap칠ndice",
    "text": "Ap칠ndice\n\nPalabras claves y funciones predefinidas\nPython tiene un conjunto de palabras conocidas como keywords que sirven para realizar acciones especificas y que no podemos utilizar como nombres de variables.\nCuando intentemos utilizar una keyword como nombre de variable, obtendremos un error.\nPor otro lado, si intentamos utilizar el nombre de una funci칩n (o clase) predefinida como nombre de una variable que nosotros creamos, no vamos a obtener un error pero no podremos usar la funci칩n nuevamente porque la variable ahora representa otra cosa.\n\nPalabras claves\nFalse      await      else       import     pass\nNone       break      except     in         raise\nTrue       class      finally    is         return\nand        continue   for        lambda     try\nas         def        from       nonlocal   while\nassert     del        global     not        with\nasync      elif       if         or         yield\n\n\nFunciones y clases pre-definidas\nabs()          copyright()    getattr()      list()         range()        vars()\nall()          credits()      globals()      locals()       repr()         zip()\nany()          delattr()      hasattr()      map()          reversed()\nascii()        dict()         hash()         max()          round()\nbin()          dir()          help()         memoryview()   set()\nbool()         display()      hex()          min()          setattr()\nbreakpoint()   divmod()       id()           next()         slice()\nbytearray()    enumerate()    input()        object()       sorted()\nbytes()        eval()         int()          oct()          staticmethod()\ncallable()     exec()         isinstance()   open()         str()\nchr()          filter()       issubclass()   ord()          sum()\nclassmethod()  float()        iter()         pow()          super()\ncompile()      format()       len()          print()        tuple()\ncomplex()      frozenset()    license()      property()     type()\n\n\nM칠todos de las cadenas de texto\n\n\n\n\n\n\n\n\n\nM칠todo\nDescripci칩n\nEjemplo\nResultado\n\n\n\n\n.endswith(sufijo)\nVerifica si termina con el sufijo\n\"file.txt\".endswith(\".txt\")\nTrue\n\n\n.find(x)\nLa posicion de la primera aparici칩n de x en la cadena (o -1 si no est치)\n\"Python\".find(\"t\")\n2\n\n\n.index(x)\nLa posicion de la primera aparici칩n de x en la cadena (error si no est치)\n\"Python\".index(\"n\")\n5\n\n\n.isalpha()\nVerifica si los caracteres son alfab칠ticos\n\"256\".isalpha()\nFalse\n\n\n.isdigit()\nVerifica si los caracteres son num칠ricos\n\"256\".isdigit()\nTrue\n\n\n.islower()\nVerifica si los caracteres son min칰sculas\n\"Python\".islower()\nFalse\n\n\n.isupper()\nVerifica si los caracteres son may칰sculas\n\"Python\".isupper()\nFalse\n\n\n.join(lista)\nUne una lista de cadenas usando la cadena como delimitador\n\" y \".join([\"esto\", \"aquello\"])\n\"esto y aquello\"\n\n\n.lower()\nConvertir a min칰sculas\n\"Python\".lower()\n\"python\"\n\n\n.replace(viejo, nuevo)\nReemplaza texto\n\"maximo\".replace(\"ax\", \"in\")\n\"minimo\"\n\n\n.split(sep)\nParte la cadena en una lista de subcadenas\n\"esto y aquello\".split(\" y \")\n[\"esto\", \"aquello\"]\n\n\n.startswith(prefijo)\nVerifica si comienza con un prefijo\n\"file.txt\".endswith(\"a\")\nFalse\n\n\n.strip()\nElimina espacios en blanco al inicio o al final\n\" oh la la \".strip()\n\"oh la la\"\n\n\n.upper()\nConvierte a may칰sculas\n\"Python\".upper()\n\"PYTHON\"",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "1 - Introducci칩n"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/02_estructuras_lineales.html",
    "href": "teoria/04_estructuras_y_algoritmos/02_estructuras_lineales.html",
    "title": "2 - Estructuras lineales",
    "section": "",
    "text": "En el apunte anterior exploramos algunas estructuras de datos basadas en arreglos y analizamos su desempe침o al realizar distintas operaciones.\nSin embargo, el desempe침o no es el 칰nico factor a considerar al elegir una estructura de datos. En muchos casos, se eligen ciertas estructuras porque permiten escribir un c칩digo m치s simple y f치cil de leer.\nEn este apunte nos enfocaremos en las siguientes estructuras:\n\nPilas\nColas\nListas enlazadas\nListas doblemente enlazadas\n\nEstas estructuras pertenecen a la categor칤a de estructuras lineales. Las estructuras de datos lineales son aquellas en las que los elementos est치n organizados uno detr치s de otro, formando una secuencia. Cada elemento (excepto el primero y el 칰ltimo) tiene un predecesor y un sucesor.\nAdem치s, aprenderemos a distinguir entre un tipo de dato abstracto y una estructura de datos concreta.",
    "crumbs": [
      "Teor칤a",
      "U4 - Estructuras de Datos y Algoritmos",
      "2 - Estructuras lineales"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/02_estructuras_lineales.html#introducci칩n",
    "href": "teoria/04_estructuras_y_algoritmos/02_estructuras_lineales.html#introducci칩n",
    "title": "2 - Estructuras lineales",
    "section": "",
    "text": "En el apunte anterior exploramos algunas estructuras de datos basadas en arreglos y analizamos su desempe침o al realizar distintas operaciones.\nSin embargo, el desempe침o no es el 칰nico factor a considerar al elegir una estructura de datos. En muchos casos, se eligen ciertas estructuras porque permiten escribir un c칩digo m치s simple y f치cil de leer.\nEn este apunte nos enfocaremos en las siguientes estructuras:\n\nPilas\nColas\nListas enlazadas\nListas doblemente enlazadas\n\nEstas estructuras pertenecen a la categor칤a de estructuras lineales. Las estructuras de datos lineales son aquellas en las que los elementos est치n organizados uno detr치s de otro, formando una secuencia. Cada elemento (excepto el primero y el 칰ltimo) tiene un predecesor y un sucesor.\nAdem치s, aprenderemos a distinguir entre un tipo de dato abstracto y una estructura de datos concreta.",
    "crumbs": [
      "Teor칤a",
      "U4 - Estructuras de Datos y Algoritmos",
      "2 - Estructuras lineales"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/02_estructuras_lineales.html#pilas",
    "href": "teoria/04_estructuras_y_algoritmos/02_estructuras_lineales.html#pilas",
    "title": "2 - Estructuras lineales",
    "section": "Pilas",
    "text": "Pilas\nUna pila es una colecci칩n de objetos con ciertas restricciones para su inserci칩n y eliminaci칩n. Para entender su funcionamiento, podemos imaginar una pila de cajas como la siguiente:\n\n\n\n\n\nLa primera caja que se coloc칩 en la pila es la roja, luego la amarilla, la verde y finalmente la naranja. Si quisi칠ramos leer el contenido de una caja o extraer una de ellas, no podr칤amos elegir una cualquiera: habr칤a que empezar desde la parte superior, con la que fue agregada m치s recientemente. Del mismo modo, si quisi칠ramos insertar una nueva caja, tambi칠n deber칤amos hacerlo en la cima de la pila.\nEn computaci칩n, se dice que la pila es una colecci칩n de objetos que se insertan y extraen siguiendo el principio last-in, first-out (LIFO), que significa que 란l 칰ltimo en entrar es el primero en salir.\nPodemos imaginar un brazo mec치nico que permite leer, quitar o agregar cajas en la pila:\n\n\n\n\n\nEn la computadora, podr칤amos representar una pila de la siguiente manera:\n\n\n\n\n\ndonde cada caja representa un objeto en memoria. Como ninguna celda tiene propiedades especiales, utilizamos el mismo color para todas:\n\n\n\n\n\n\nLectura\nComo ya adelantamos, solo es posible interactuar con el objeto en la cima de la pila. Por lo tanto, solo es posible leer el valor al inicio de la pila, independientemente de que se extraiga o no. Si quisieramos leer un valor posterior, primero deber칤amos extraer los valores que est치n por encima de el.\n\n\nInserci칩n\nPara insertar un valor en la pila, tambi칠n tenemos que respetar la restricci칩n de que solo podemos modificarla desde la cima. Por lo tanto, si queremos agregar un elemento, tenemos que hacerlo encima de todos los otros elementos.\n\n\n\n\n\n\n\n\n\n\n\n\nEliminaci칩n\nLa eliminaci칩n de elementos de la pila tambi칠n tiene que seguir su orden natural: solo podemos eliminar elementos en la cima.\nLa siguiente figura representa la eliminaci칩n de Objeto Y de la pila.\n\n\n\n\n\nY a continuaci칩n se representa la eliminaci칩n de m칰ltiples elementos:\n\n\n\n\n\n\n\nImplementaci칩n\nEn la pr치ctica, no existe una pila de celdas de memoria con la que trabajemos directamente. Formalmente, una pila es un tipo de dato abstracto que define un m칠todo para insertar objetos en la cima y otro para extraerlos desde la cima.\nPara utilizar una pila en un programa, necesitamos una implementaci칩n concreta de la misma, la cual se apoya en otras estructuras de datos.\nUna forma de implementar una pila es a partir de un arreglo al que se le imponen ciertas restricciones. Por ejemplo, podemos crear una clase Pila que, internamente, almacene los valores utilizando una lista de Python.\nPara entender la relaci칩n entre la pila y el arreglo subyacente, se puede imaginar que la pila se rota o se tumba horizontalmente. El elemento en la cima de la pila corresponder치 al 칰ltimo elemento del arreglo, y la base de la pila al primer elemento del arreglo.\n\n\n\n\n\nQue solo interactuemos con la cima de pila implica que solo interactuamos con la cola del arreglo.\n\n\n\n\n\nCuando insertamos un elemento, lo hacemos al final del arreglo, extendiendo su longitud:\n\n\n\n\n\nY cuando se elimina un elemento, tambi칠n lo hacemos al final del arreglo, lo que reduce su longitud:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFinalmente, tenemos nuestra implementaci칩n en Python:\n\nclass Pila:\n    def __init__(self):\n1        self._datos = []\n\n2    def insertar(self, element):\n        self._datos.append(element)\n\n3    def extraer(self):\n        if len(self._datos) &gt; 0:\n            return self._datos.pop()\n        return None\n\n4    def leer(self):\n        if len(self._datos) &gt; 0:\n            return self._datos[-1]\n        return None\n\n    @property\n    def vacia(self):\n        return len(self._datos) == 0\n\n\n1\n\nInternamente, las pilas utilizan un arreglo 랋rotegido para almacenar los datos.\n\n2\n\nPara insertar un elemento, solo se necesita el valor a agregar, no su posici칩n, ya que siempre se incorpora en la cima de la pila (es decir, al final del arreglo interno).\n\n3\n\nAl extraer un elemento, tampoco se requiere indicar la posici칩n, ya que siempre se remueve el 칰ltimo elemento ingresado, el que se encuentra en la cima de la pila.\n\n4\n\nEl m칠todo leer permite consultar el valor en la cima sin retirarlo.\n\n\n\n\n\n\nAplicaciones\n\nInvertir orden\nGracias al protocolo LIFO, una pila puede servir para invertir el orden de los datos.\nPor ejemplo, si apilamos los valores 1, 2 y 3 en ese orden, al desapilarlos los obtendremos en orden inverso: 3, 2 y 1.\nEsta idea se puede usar en muchos casos. Por ejemplo, podr칤amos querer imprimir las l칤neas de un archivo en orden inverso para mostrar un conjunto de datos en orden descendente en lugar de ascendente.\nPara hacerlo, basta con leer cada l칤nea, apilarla en la pila y luego imprimirlas en el orden en que se van desapilando.\n\ndef invertir_archivo(origen, destino):\n    pila = Pila()\n\n    with open(origen) as archivo_origen:\n        for linea in archivo_origen:\n            pila.insertar(linea.rstrip(\"\\n\"))\n\n    with open(destino, \"w\") as archivo_destino:\n        while not pila.vacia:\n            archivo_destino.write(pila.extraer() + \"\\n\")\n\nSi tenemos el siguiente archivo con un extracto de la letra de Tu misterioso alguien de Miranda!:\n\n\noriginal.txt\n\n쯈ui칠n es tu nuevo amor?\n쯊u nueva ocupaci칩n?\n쯊u misterioso alguien?\n\ny ejecutamos la funci칩n de esta manera:\ninvertir_archivo(\"original.txt\", \"invertido.txt\")\nLuego tenemos:\n\n\noriginal.txt\n\n쯊u misterioso alguien?\n쯊u nueva ocupaci칩n?\n쯈ui칠n es tu nuevo amor?\n\n\n\nVerificar de par칠ntesis y corchetes\nOtra aplicaci칩n de las pilas est치 relacionada con la verificaci칩n de par칠ntesis y corchetes en expresiones matem치ticas. Estos s칤mbolos se utilizan para agrupar partes de una expresi칩n y, por lo general, para modificar el orden en que se eval칰an los operadores.\nPara que una expresi칩n sea v치lida, cada par칠ntesis (o corchete) que abre un grupo ( debe tener su correspondiente cierre ). Sin embargo, un simple conteo de par칠ntesis no es suficiente: la siguiente expresi칩n contiene la misma cantidad de par칠ntesis de apertura y de cierre, y aun as칤 es incorrecta.\n1 +) (3 * 5()\nLa funci칩n verificar_agrupamientos se vale de una pila para verificar que los par칠ntesis y corchetes se utilizan correctamente.\n\ndef verificar_agrupamientos(expr):\n    apertura = \"([\"\n    cierre = \")]\"\n\n    pila = Pila()\n\n    for caracter in expr:\n        if caracter in apertura:\n            pila.insertar(caracter)\n        elif caracter in cierre:\n            if pila.vacia: # Nada con que emparejarlo\n                return False\n\n            if cierre.index(caracter) != apertura.index(pila.extraer()): # Mismatch\n                return False\n\n    return pila.vacia\n\nLa funci칩n recorre la secuencia original de izquierda a derecha utilizando una pila pila para facilitar la verificaci칩n de los s칤mbolos de agrupaci칩n.\nCada vez que se encuentra un s칤mbolo de apertura, lo apilamos en pila. Y cuando se encuentra un s칤mbolo de cierre, desapilamos un elemento de pila (si no est치 vac칤a) y verificamos que ambos s칤mbolos formen un par v치lido.\nSi al llegar al final de la expresi칩n la pila est치 vac칤a, significa que la expresi칩n est치 correctamente balanceada. De lo contrario, debe haber quedado en la pila un s칤mbolo de apertura sin su correspondiente cierre.\n\nverificar_agrupamientos(\"(3 + (4 * 5))\")\n\nTrue\n\n\n\nverificar_agrupamientos(\"[3 + (4 * 5)]\")\n\nTrue\n\n\n\nverificar_agrupamientos(\"(3 + (4 * 5)\")\n\nFalse\n\n\n\nverificar_agrupamientos(\"(3 + [(4 * 5)\")\n\nFalse",
    "crumbs": [
      "Teor칤a",
      "U4 - Estructuras de Datos y Algoritmos",
      "2 - Estructuras lineales"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/02_estructuras_lineales.html#colas",
    "href": "teoria/04_estructuras_y_algoritmos/02_estructuras_lineales.html#colas",
    "title": "2 - Estructuras lineales",
    "section": "Colas",
    "text": "Colas\nLa cola es otra estructura de datos fundamental, un pariente cercano de la pila. Al igual que ella, la cola es una colecci칩n ordenada de objetos. Sin embargo, los objetos se insertan y se extraen siguiendo el principio first in, first out (FIFO), es decir, el primero en entrar es el primero en salir.\nPara familiarizarnos con esta estructura, podemos imaginar una fila de personas esperando para entrar a un banco, como se muestra en la imagen:\n\n\n\n\n\nLos primeros en haber llegado son los primeros en entrar al banco, mientras que quienes llegan despu칠s se ubican al final de la cola y deben esperar a que ingresen quienes estan delante suyo para ingresar.\nEsta estructura tiene numerosas aplicaciones pr치cticas. En la vida real, restaurantes, tiendas, plataformas de ventas de entradas y otros procesan solicitudes siguiendo el principio FIFO. En los sistemas inform치ticos, como impresoras en red o servidores web, las peticiones tambi칠n se atienden en orden de llegada. En todos estos casos, utilizar una cola es una forma natural y l칩gica de organizar las solicitudes.\n\nImplementaci칩n\nLas colas son un tipo de dato abstracto, ya que definen c칩mo deben comportarse, pero no c칩mo se implementan. Para utilizarlas en un programa necesitamos una implementaci칩n concreta.\nUna forma de hacerlo es mediante un arreglo restringido, donde solo se puede extraer el elemento del frente (칤ndice 0) y agregar nuevos elementos al final (칤ndice n).\n\n\n\n\n\nCuando se desea insertar un nuevo elemento en la estructura de datos, siempre se hace al final.\n\n\n\n\n\nSi luego se desea agregar otro elemento, simplemente se repite el proceso.\n\n\n\n\n\nPor el contrario, a la hora de extraer un elemento, solo se puede realizar desde el frente de la cola:\n\n\n\n\n\n\n\n\n\n\nUna implementaci칩n en Python de la cola basada en arreglos es la siguiente:\n\nclass Cola:\n    def __init__(self):\n        self._datos = []\n\n    def insertar(self, element): # enqueue\n        self._datos.append(element)\n\n    def extraer(self): # dequeue\n        if len(self._datos) &gt; 0:\n            return self._datos.pop(0)\n        return None\n\n    def leer(self):\n        if len(self._datos) &gt; 0:\n            return self._datos[0]\n        return None\n\n    @property\n    def vacia(self):\n        return len(self._datos) == 0\n    \n    def __len__(self):\n        return len(self._datos)\n\nDel mismo modo que la clase Pila, la clase Cola utiliza un arreglo interno llamado _datos para almacenar los valores. Tambi칠n define m칠todos para insertar y extraer elementos, con la diferencia de que la extracci칩n se realiza desde el frente y no desde la parte posterior, siguiendo el principio FIFO (first in, first out), es decir, el primero en entrar es el primero en salir.\n\n\nAplicaciones\n\n\n\n\nCola de impresi칩n\n\ncola_impresion = Cola()\ncola_impresion.insertar(\"documento1.pdf\")\ncola_impresion.insertar(\"documento2.docx\")\ncola_impresion.insertar(\"documento3.xlsx\")\n\nwhile not cola_impresion.vacia:\n    print(f\"Imprimiendo {cola_impresion.extraer()}...\")\n\ncola_impresion.vacia\n\nImprimiendo documento1.pdf...\nImprimiendo documento2.docx...\nImprimiendo documento3.xlsx...\n\n\nTrue\n\n\n\n\nAtenci칩n de llamadas 游빌\nEl siguiente programa contiene un ejemplo m치s realista donde se usa una cola como estructura de datos para una gestionar llamadas en espera.\ndef simular_centro_de_llamadas(tiempo_total=15):\n    cola = Cola()\n    nombres = [\"Ana\", \"Bruno\", \"Carla\", \"Dami치n\", \"Eva\"]\n\n    tiempo_inicial = time.time()\n\n    while time.time() - tiempo_inicial &lt; tiempo_total:\n        accion = random.random()\n        ahora = datetime.now().strftime(\"%H:%M:%S\")\n\n        # Simula la llegada de una llamada, con 50% de probabilidad\n        if accion &lt; 0.5:\n            llamada = {\"cliente\": random.choice(nombres), \"hora\": ahora}\n            cola.insertar(llamada)\n            print(f\"[{ahora}] Nueva llamada de {llamada['cliente']}\")\n            print(f\"     Llamadas en espera: {len(cola)}\")\n        # Simula la atenci칩n de una llamada, con 40% de probabilidad\n        elif accion &lt; 0.9 and not cola.vacia:\n            llamada = cola.extraer()\n            print(f\"[{ahora}]  Atendiendo a {llamada['cliente']} (recibida a las {llamada['hora']})\")\n            print(f\"     Quedan {len(cola)} llamadas en espera\")\n        # Caso contrario, no se hace nada\n        else:\n            print(f\"[{ahora}] Sin actividad...\")\n        \n        # Controla la velocidad de la simulaci칩n\n        time.sleep(random.uniform(1, 2))\n\n    print(\"\\nFin de la simulaci칩n.\")\n\nif __name__ == \"__main__\":\n    simular_centro_de_llamadas()\n\n\n\n\n\n\n\n\nPor qu칠 usar estructuras de datos restringidas\nSi para implementar una pila necesitamos restringir un arreglo, 쯣or qu칠 no usamos directamente un arreglo en vez de una pila?, 쯦iene alguna ventaja usar la pila?\nLas estructuras de datos restringidas, como la pila y la cola, son importantes por varias razones.\nEn primer lugar, usar estructuras de datos restringidas ayuda a evitar errores. Por ejemplo, el algoritmo de verificaci칩n de par칠ntesis y corchetes solo funciona si los elementos se eliminan desde la cima. Si utilizaramos una lista de Python, podr칤amos cometer variados errores. En cambio, al usar una pila, que restringe las operaciones que podemos realizar, autom치ticamente se previenen usos incorrectos.\nEn segundo lugar, estas estructuras restringidas proporcionan un modelo mental claro para resolver ciertos problemas. La pila introduce el principio last in, first out (LIFO), 란l 칰ltimo en entrar es el primero en salir, que puede aplicarse para resolver una amplia variedad de problemas, como el del verificador mencionado antes.\nFinalmente, la familiaridad con la naturaleza LIFO de las pilas hace que el c칩digo sea m치s legible y predecible para otros desarrolladores: cuando alguien ve una pila, sabe que el proceso sigue una l칩gica LIFO.",
    "crumbs": [
      "Teor칤a",
      "U4 - Estructuras de Datos y Algoritmos",
      "2 - Estructuras lineales"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/02_estructuras_lineales.html#listas-enlazadas",
    "href": "teoria/04_estructuras_y_algoritmos/02_estructuras_lineales.html#listas-enlazadas",
    "title": "2 - Estructuras lineales",
    "section": "Listas enlazadas",
    "text": "Listas enlazadas\nEn esta secci칩n vamos a introducir una estructura de datos llamada lista enlazada (linked list), que constituye una alternativa a las secuencias basadas en arreglos, como la lista de Python. Tanto las listas enlazadas como los arreglos mantienen los elementos en un cierto orden, pero lo hacen siguiendo distintas estrategias.\nPor un lado, un arreglo almacena los datos en una regi칩n contigua de memoria, lo que permite acceder r치pidamente a cualquier elemento mediante su 칤ndice y facilita operaciones matem치ticas vectorizadas. Sin embargo, este dise침o puede volver poco eficientes tareas como la inserci칩n o la eliminaci칩n de elementos.\nPor el otro, una lista enlazada se apoya en una estructura llamada nodo, que le permite distribuir los distintos elementos de la secuencia en diferentes ubicaciones de la memoria y modificarlos o reorganizarlos con mayor flexibilidad.\n\nEl nodo\nEn una lista enlazada, cada nodo representa un elemento de la lista. Aunque los nodos no se almacenen en posiciones contiguas de memoria, la computadora puede reconstruir el orden de la secuencia porque cada nodo no solo guarda un valor, sino que tambi칠n una referencia al siguiente. Estos enlaces entre nodos son los que dan nombre a esta estructura de datos: lista enlazada.\n\n\n\n\n\nPara representar estos nodos podemos crear una clase Nodo, que define objetos que contienen un atributo para el valor y otro para la referencia al siguiente nodo de la lista.\n\nclass Nodo:\n    def __init__(self, valor):\n        self.valor = valor\n        self.siguiente = None\n    \n    def __repr__(self):\n        return f\"Nodo({self.valor})\"\n\nNodo(75)\n\nNodo(75)\n\n\nPodemos instanciar m칰ltiples nodos y enlazarlos entre s칤, para luego recorrerlos de la forma en que lo har칤a una lista enlazada.\n\nnodo1 = Nodo(1)\nnodo2 = Nodo(2)\nnodo3 = Nodo(3)\nnodo4 = Nodo(4)\n\n# Enlazar nodos\nnodo1.siguiente = nodo2\nnodo2.siguiente = nodo3\nnodo3.siguiente = nodo4  \n\n# Recorrer e imprimir la lista enlazada\nactual = nodo1\nwhile actual:\n    print(actual, end=\" -&gt; \")\n    actual = actual.siguiente\nprint(\"None\")\n\nNodo(1) -&gt; Nodo(2) -&gt; Nodo(3) -&gt; Nodo(4) -&gt; None\n\n\nComo se puede observar, aunque los nodos sean independientes y puedan almacenarse en cualquier lugar de la memoria, los enlaces entre ellos permiten construir una secuencia ordenada.\n\n\nImplementaci칩n b치sica\nLo 칰nico que se necesita para implementar una lista enlazada a partir de un conjunto de nodos es la direcci칩n de memoria donde comienza la lista enlazada, es decir, donde se ubica el primer nodo. Como cada nodo guarda un enlace al nodo siguiente, basta con seguir esos enlaces uno a uno para reconstruir toda la secuencia.\n\nclass ListaEnlazada:\n    def __init__(self, primer_nodo=None):\n        self.primer_nodo = primer_nodo\n\nlista = ListaEnlazada(nodo1)\n\nEl diagrama de abajo representa la lista enlazada que acabamos de crear. Cada nodo contiene un valor y una referencia al siguiente nodo en la secuencia. Estas referencias son los enlaces que conectan los nodos y dan forma a la estructura.\n\n\n\n\n\nEl segundo diagrama muestra c칩mo se ver칤a esa misma lista en la memoria. Los valores resaltados en rojo representan los nodos, que, como puede observarse, se encuentran dispersos en distintas ubicaciones.\n\n\n\n\n\n\n\nLectura\nDada una direcci칩n de memoria, la lectura es una operaci칩n de tiempo constante, \\(O(1)\\). No importa en qu칠 lugar de la memoria se encuentre esa direcci칩n, la lectura siempre tarda lo mismo.\nCuando trabajamos con un arreglo contiguo, vimos que pod칤amos determinar la direcci칩n de cualquier elemento a partir de la direcci칩n base y el 칤ndice solicitado. En cambio, en una lista enlazada, los nodos no est치n almacenados contiguamente en memoria, por lo que ya no podemos usar esa estrategia.\nSupongamos que queremos leer el valor en el 칤ndice 3 de una lista enlazada. Nuestro programa solo conoce la direcci칩n del primer nodo de la secuencia. Para ubicar el nodo en el 칤ndice 3, debe recorrer la lista pasando por todos los nodos intermedios, saltando de uno a otro a trav칠s de sus enlaces, hasta llegar al nodo correspondiente y devolver su valor.\nGr치ficamente, el proceso se ve de la siguiente manera:\n\n\n\n\n\nSi tenemos una lista enlazada de \\(N\\) elementos y queremos leer el elemento en la 칰ltima posici칩n, la operaci칩n nos llevar치 \\(N\\) pasos. Por lo tanto, a diferencia de la lectura en un arreglo contiguo, que es de orden \\(O(1)\\), la lectura en una lista enlazada es de orden \\(O(N)\\).\nPero no nos desmotivemos, no son todas p치lidas con esta estructura de datos. As칤 como presenta esta limitaci칩n, pronto descubriremos tambi칠n sus puntos fuertes.\nMientras tanto, concluimos la secci칩n con una implementaci칩n en Python del m칠todo de lectura.\n    def leer(self, indice):\n1        nodo_actual = self.primer_nodo\n        indice_actual = 0\n\n2        while indice_actual &lt; indice:\n3            nodo_actual = nodo_actual.siguiente\n            indice_actual += 1\n\n4            if nodo_actual is None:\n                return None\n\n5        return nodo_actual.valor\n\n1\n\nSe comienza a recorrer la lista desde el primer nodo, que se encuentra en el 칤ndice 0.\n\n2\n\nSe recorre la lista enlazada hasta llegar al 칤ndice deseado.\n\n3\n\nEn cada paso, se avanza nodo a nodo, accediendo al siguiente e incrementando el valor del 칤ndice.\n\n4\n\nSi en alg칰n momento el nodo obtenido es None, significa que la lista no tiene tantos elementos como el 칤ndice solicitado. En ese caso se devuelve None, aunque tambi칠n podr칤a lanzarse un IndexError.\n\n5\n\nEn este punto se sabe que se ha llegado al nodo del 칤ndice solicitado, y se devuelve su valor.\n\n\n\n\nB칰squeda\nYa sabemos que la b칰squeda es una operaci칩n estrechamente relacionada con la lectura: en lugar de tomar un 칤ndice y devolver un valor, toma un valor y devuelve su 칤ndice (si es que el valor se encuentra en la secuencia).\nSi trabajamos con un arreglo contiguo, la b칰squeda lineal es de orden \\(O(N)\\). En una lista enlazada, la b칰squeda tambi칠n es de orden \\(O(N)\\), ya que el proceso es similar al de la lectura.\nLa b칰squeda se comienza explorando el primer nodo, con un acumulador de 칤ndice inicializado en 0. En cada paso, se compara el valor del nodo con el valor buscado:\n\nSi son distintos, se avanza al siguiente nodo y se incrementa el acumulador.\nSi son iguales, se devuelve el valor del 칤ndice.\n\nSi no existe un siguiente nodo, es decir, si se llega al final de la lista, significa que el valor buscado no se encuentra en la secuencia.\nEl proceso se puede representar de la siguiente manera:\n\n\n\n\n\nUna implementaci칩n para el m칠todo de b칰squeda en nuestra clase es la siguiente:\n    def buscar(self, valor):\n1        nodo_actual = self.primer_nodo\n        indice_actual = 0\n\n2        while True:\n3            if nodo_actual.valor == valor:\n                return indice_actual\n            nodo_actual = nodo_actual.siguiente\n\n4            if nodo_actual is None:\n                break\n            indice_actual += 1\n\n5        return None\n\n1\n\nSe inicia el recorrido desde el primer nodo de la lista, comenzando con el 칤ndice 0.\n\n2\n\nSe itera hasta que el bloque ejecute un return o un break\n\n3\n\nEn cada iteraci칩n, se compara el valor almacenado en el nodo actual con el valor buscado. Si el valor coincide, se devuelve el 칤ndice correspondiente y la b칰squeda termina. Si no coincide, se avanza al siguiente nodo.\n\n4\n\nSi el siguiente nodo es None, significa que se lleg칩 al final de la lista sin encontrar el valor, se termina el bucle. Caso contrario, se incrementa el 칤ndice en 1 y se ejecuta el bucle desde el iniciio.\n\n5\n\nEn este punto se sabe que el valor no se encuentra en la lista y se devuelve None. Podr칤a lanzarse un ValueError.\n\n\n\n\nInserci칩n\nHasta ahora, el desempe침o de las listas enlazadas es igual o peor que el de un arreglo contiguo. Son menos eficientes para leer e igual de eficientes para buscar.\nSin embargo, cuando consideramos la inserci칩n, nuestra percepci칩n sobre esta estructura comienza a cambiar. En un arreglo contiguo, el peor escenario ocurre al insertar al principio, ya que es necesario desplazar todos los elementos una celda a la derecha. En cambio, en una lista enlazada, insertar un elemento al inicio requiere un solo paso, por lo que es una operaci칩n de orden \\(O(1)\\).\nPara insertar un elemento al inicio de una lista enlazada, solo es necesario crear un nuevo nodo y enlazarlo con el nodo que era el primero antes de la inserci칩n. Adem치s, debemos actualizar la referencia al primer nodo dentro del objeto de tipo ListaEnlazada para que apunte al nuevo nodo.\n\n\n\n\n\nSi se desea insertar un elemento en una posici칩n interna de la lista, en teor칤a la operaci칩n de inserci칩n en s칤 misma lleva solo un paso, ya que no es necesario mover elementos, solo se requiere actualizar los enlaces entre nodos.\nEl siguiente diagrama muestra la inserci칩n del valor 2.5 entre el 2 y el 3 en nuestra lista enlazada. Se crea un nuevo nodo que apunta a la ubicaci칩n del tercer elemento y se modifica el enlace del segundo elemento para que apunte al nuevo nodo.\n\n\n\n\n\nSin embargo, antes de poder realizar este cambio de enlaces, es necesario encontrar los nodos involucrados, lo que requiere recorrer la lista desde el inicio. Si queremos insertar el valor 2.5 en el 칤ndice 2, es necesario realizar la b칰squeda que describe el diagrama debajo.\n\n\n\n\n\nUna vez identificados los nodos involucrados, se actualizan sus enlaces. La inserci칩n no requiere mover valores en memoria, pero s칤 es necesario recorrer la lista desde el principio para los nodos que deben ser actualizados.\nLuego de la inserci칩n, los elementos de la lista quedan distribuidos en memoria como se muestra en el siguiente diagrama:\n\n\n\n\n\nFinalmente, el peor de los escenarios se da cuando se desea insertar un elemento al final de la lista. Para ello hay que atravesar \\(N\\) elementos hasta encontrar el 칰ltimo. Una vez all칤, se actualiza su enlace para que apunte a la direcci칩n del nodo creado para el nuevo valor.\n\n\n\n\n\nEl m칠todo de inserci칩n para nuestra clase ListaEnlazada es el siguiente:\ndef insertar(self, indice, valor):\n1    nodo_nuevo = Nodo(valor)\n\n2    if indice == 0:\n        nodo_nuevo.siguiente = self.primer_nodo\n        self.primer_nodo = nodo_nuevo\n        return None\n\n3    nodo_actual = self.primer_nodo\n    indice_actual = 0\n\n4    while indice_actual &lt; (indice - 1):\n        nodo_actual = nodo_actual.siguiente\n        indice_actual += 1\n        nodo_nuevo.siguiente = nodo_actual.siguiente\n        nodo_actual.siguiente = nodo_nuevo\n\n1\n\nSe crea un nuevo nodo con el valor recibido.\n\n2\n\nSi el 칤ndice es 0, significa que el nuevo nodo debe insertarse al inicio de la lista. En ese caso, se enlaza el nuevo nodo al antiguo primer nodo y el nuevo nodo se convierte en el primer nodo de la lista\n\n3\n\nSi no se trata del primer nodo, se inicia un recorrido desde el comienzo de la lista, con el 칤ndice actual igual a 0.\n\n4\n\nSe avanza nodo a nodo hasta llegar al nodo anterior a la posici칩n donde se desea insertar. Una vez all칤, se ajustan las referencias: el nuevo nodo apunta al siguiente del nodo actual, y el nodo actual pasa a apuntar al nuevo nodo.\n\n\n\n\nEliminaci칩n\nEn una lista enlazada, la eliminaci칩n tiene mucho en com칰n con la inserci칩n. Primero, eliminar un elemento no requiere mover valores en memoria, sino simplemente actualizar los enlaces entre nodos. Segundo, la eliminaci칩n al inicio de la lista es muy eficiente; basta con hacer que primer_nodo apunte al segundo nodo. Por 칰ltimo, cuando la eliminaci칩n no ocurre al principio, es necesario recorrer la lista hasta encontrar los nodos cuyos enlaces deben modificarse.\nEl siguiente diagrama muestra la eliminaci칩n de un nodo intermedio en la secuencia. Para realizarla se cambia el enlace del nodo anterior para que apunte al nodo siguiente. Opcionalmente, puede eliminarse tambi칠n el enlace del nodo que fue removido.\n\n\n\n\n\nEn Python, tenemos:\ndef eliminar(self, indice):\n1    if indice == 0:\n        self.primer_nodo = self.primer_nodo.siguiente\n        return None\n\n2    nodo_actual = self.primer_nodo\n    indice_actual = 0\n\n3    while indice_actual &lt; (indice - 1):\n        nodo_actual = nodo_actual.siguiente\n        indice_actual += 1\n\n4    nodo_siguiente_al_eliminado = nodo_actual.siguiente.siguiente\n    nodo_actual.siguiente = nodo_siguiente_al_eliminado\n\n1\n\nSi el 칤ndice es 0, significa que se debe eliminar el primer nodo de la lista. En ese caso, solo es necesario actualizar la referencia primer_nodo para que apunte al segundo nodo, descartando as칤 el primero.\n\n2\n\nSi no se trata del primer nodo, se inicia el recorrido desde el comienzo de la lista, con el 칤ndice actual igual a 0.\n\n3\n\nSe avanza nodo a nodo hasta llegar al nodo anterior al que se desea eliminar.\n\n4\n\nUna vez all칤, se actualizan las referencias para que el nodo actual apunte al nodo siguiente del que ser치 eliminado, de modo que el nodo en la posici칩n indicada quede desconectado de la lista.\n\n\n\n\nEnlazando las partes\nSi juntamos todos los m칠todos definidos, podemos reimplementar nuestra lista enlazada junto a todas las funcionalidades necesarias.\n\nclass ListaEnlazada:\n    def __init__(self, primer_nodo=None):\n        self.primer_nodo = primer_nodo\n\n    def leer(self, indice):\n        nodo_actual = self.primer_nodo\n        indice_actual = 0\n\n        while indice_actual &lt; indice:\n            nodo_actual = nodo_actual.siguiente\n            indice_actual += 1\n\n            if nodo_actual is None:\n                return None\n\n        return nodo_actual.valor\n\n    def buscar(self, valor):\n        nodo_actual = self.primer_nodo\n        indice_actual = 0\n\n        while True:\n            if nodo_actual.valor == valor:\n                return indice_actual\n\n            nodo_actual = nodo_actual.siguiente\n            if nodo_actual is None:\n                break\n            indice_actual += 1\n\n        return None\n\n    def insertar(self, indice, valor):\n        nodo_nuevo = Nodo(valor)\n\n        if indice == 0:\n            nodo_nuevo.siguiente = self.primer_nodo\n            self.primer_nodo = nodo_nuevo\n            return None\n\n        nodo_actual = self.primer_nodo\n        indice_actual = 0\n\n        while indice_actual &lt; (indice - 1):\n            nodo_actual = nodo_actual.siguiente\n            indice_actual += 1\n            nodo_nuevo.siguiente = nodo_actual.siguiente\n            nodo_actual.siguiente = nodo_nuevo\n\n    def eliminar(self, indice):\n        if indice == 0:\n            self.primer_nodo = self.primer_nodo.next_node\n            return None\n\n        nodo_actual = self.primer_nodo\n        indice_actual = 0\n\n        while indice_actual &lt; (indice - 1):\n            nodo_actual = nodo_actual.siguiente\n            indice_actual += 1\n\n        nodo_siguiente_al_eliminado = nodo_actual.siguiente.siguiente\n        nodo_actual.siguiente = nodo_siguiente_al_eliminado\n\n\n\nAn치lisis de la eficiencia\nLa siguiente tabla resume la eficiencia de los arreglos y las listas enlazadas para realizar las operaciones analizadas:\n\n\n\n\n\n\n\n\nOperaci칩n\nArreglo\nLista enlazada\n\n\n\n\nLectura\n\\(O(1)\\)\n\\(O(N)\\)\n\n\nB칰squeda\n\\(O(N)\\)\n\\(O(N)\\)\n\n\nInserci칩n\n\\(O(N)\\) (\\(O(1)\\) al final)\n\\(O(N)\\) (\\(O(1)\\) al inicio)\n\n\nEliminaci칩n\n\\(O(N)\\) (\\(O(1)\\) al final)\n\\(O(N)\\) (\\(O(1)\\) al inicio)\n\n\n\nA simple vista, las listas enlazadas no parecen ofrecer grandes ventajas en cuanto a complejidad temporal. Tienen un rendimiento similar al de los arreglos en b칰squeda, inserci칩n y eliminaci칩n, y son m치s lentas para la lectura. Entonces, 쯣or qu칠 las usariamos?\nLa clave est치 en que los pasos de inserci칩n y eliminaci칩n en s칤 mismos son operaciones de orden \\(O(1)\\). Es cierto que esto solo ocurre cuando ya conocemos el nodo correcto, por ejemplo, al insertar o eliminar al comienzo, pero hay situaciones en las que ese nodo ya est치 accesible por otro motivo dentro del programa.\nPor ejemplo, si tenemos que eliminar elementos err칩neos de una secuencia, tendremos que recorrerla completa tanto si usamos un arreglo como una lista enlazada. La diferencia est치 en el costo de cada eliminaci칩n. En una lista enlazada, basta con actualizar los enlaces, sin mover valores en memoria. En cambio, en un arreglo, cada vez que se elimina un elemento es necesario desplazar todos los elementos posteriores, lo que hace el proceso m치s costoso.",
    "crumbs": [
      "Teor칤a",
      "U4 - Estructuras de Datos y Algoritmos",
      "2 - Estructuras lineales"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/02_estructuras_lineales.html#listas-doblemente-enlazadas",
    "href": "teoria/04_estructuras_y_algoritmos/02_estructuras_lineales.html#listas-doblemente-enlazadas",
    "title": "2 - Estructuras lineales",
    "section": "Listas doblemente enlazadas",
    "text": "Listas doblemente enlazadas\nExisten varios tipos de listas enlazadas. La que vimos hasta ahora es la lista enlazada simple, o cl치sica, donde cada nodo tiene una referencia al nodo siguiente.\nOtra variante es la lista doblemente enlazada, en la que cada nodo mantiene dos referencias: una al nodo anterior y otra al siguiente. En este caso, el primer nodo tiene la referencia anterior vac칤a, y el 칰ltimo nodo tiene la referencia siguiente vac칤a. A su vez, la clase mantiene referencias al primer y al 칰ltimo nodo de la lista.\n\nclass Nodo:\n    def __init__(self, valor):\n        self.valor = valor\n        self.anterior = None\n        self.siguiente = None\n\n\nclass ListaDoblementeEnlazada:\n    def __init__(self, primer_nodo=None, ultimo_nodo=None):\n        self.primer_nodo = primer_nodo\n        self.ultimo_nodo = ultimo_nodo\n\nComo una lista doblemente enlazada siempre conoce la posici칩n de su primer y 칰ltimo nodo, puede acceder a cualquiera de ellos en un solo paso. Adem치s, as칤 como en una lista enlazada simple podemos leer, insertar o eliminar al inicio en tiempo constante, en una lista doblemente enlazada podemos hacerlo tambi칠n al final, con la misma eficiencia.\n\n\n\n\n\n\nAplicaciones\n\nPilas como una lista enlazada\nLas pilas tambi칠n pueden implementarse de forma muy eficiente utilizando una lista enlazada. En este caso, basta con mantener una referencia al primer nodo de la lista, que representar치 la parte superior de la pila. Tanto la inserci칩n de un nuevo elemento, como la eliminaci칩n del elemento superior, pueden realizarse en tiempo constante, \\(O(1)\\).\nEn principio, esta implementaci칩n no ofrece ventajas significativas respecto de la versi칩n basada en un arreglo, que tambi칠n permite inserci칩n y eliminaci칩n al final en tiempo constante. Sin embargo, cuando el arreglo alcanza su capacidad m치xima, es necesario reservar un nuevo bloque contiguo de memoria y copiar todos los elementos, lo que implica un costo adicional. En cambio, la versi칩n basada en una lista enlazada no requiere realocaci칩n, por lo que resulta m치s eficiente en escenarios donde el tama침o de la pila puede crecer considerablemente.\n\n\nColas con una lista doblemente enlazada\nSi mantenemos referencias tanto al primer como al 칰ltimo nodo, una lista doblemente enlazada permite acceder de forma inmediata a ambos extremos de la secuencia. Adem치s, insertar o eliminar elementos en cualquiera de ellos es una operaci칩n de orden \\(O(1)\\), lo que la hace una estructura muy adecuada para implementar una cola.\nEn comparaci칩n, cuando usamos un arreglo para almacenar los elementos, agregar un nuevo valor al final tiene un costo \\(O(1)\\), pero extraer desde el principio requiere mover los \\(N - 1\\) elementos restantes, lo que implica un costo \\(O(N)\\).\nPor otro lado, si modificamos nuestra implementaci칩n de la lista simplemente enlazada para que mantenga una referencia al 칰ltimo nodo, tambi칠n podr칤amos implementar una cola con inserci칩n y extracci칩n en tiempo constante (\\(O(1)\\)).",
    "crumbs": [
      "Teor칤a",
      "U4 - Estructuras de Datos y Algoritmos",
      "2 - Estructuras lineales"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/01_por_que_importan.html",
    "href": "teoria/04_estructuras_y_algoritmos/01_por_que_importan.html",
    "title": "1 - 쯇or qu칠 importan?",
    "section": "",
    "text": "En esta 칰ltima unidad nos ocuparemos de Estructuras de Datos y Algoritmos.\nPuede que estos t칠rminos suenen un tanto abstractos, pero como veremos a lo largo de estos apuntes, dominarlos nos ayudar치 a escribir c칩digo m치s eficiente, que corre m치s r치pido y consume menos memoria.\nEn pocas palabras, podemos decir que una estructura datos es una forma sistem치tica de organizar y acceder a datos, mientras que un algoritmo es un procedimiento paso a paso para realizar una tarea en tiempo finito.\n\n\nA lo largo de este curso hemos ido adquiriendo experiencia en la programaci칩n con Python y probablemente hayamos empezado a desarrollar un instinto u olfato que nos permite juzgar la calidad de un programa. Al enfrentarnos con dos programas que realizan la misma tarea, podemos determinar si uno es mejor que otro.\nNo hay un 칰nico aspecto que determina la calidad de un programa. Uno de ellos, por ejemplo, es la mantenibilidad. Una base de c칩digo legible, organizada y modular es m치s f치cil de manetener que otra poco legible, desorganizada y monol칤tica.\nLa eficiencia es otro aspecto que determina la calidad de un programa. Por ejemplo, podemos contar con dos funciones que resuelven el mismo problema, pero una de ellas es m치s r치pida que la otra.\nLas dos funciones debajo resuelven exactamente el mismo problema: imprimir los n칰meros pares entre 2 y 100.\ndef imprimir_numeros_1():\n    numero = 2\n    while numero &lt;= 100:\n        if numero % 2 == 0:\n            print(numero)\n            numero += 1\n\ndef imprimir_numeros_2():\n    numero = 2\n    while numero &lt;= 100:\n        print(numero)\n        numero += 2\nSin embargo, cabe preguntarse: 쯖u치l de las dos funciones se ejecuta m치s r치pido?\nLa respuesta correcta es la segunda. La primera funci칩n realiza 100 iteraciones, mientras que la segunda solo realiza 50. Por lo tanto, la primera funci칩n requiere el doble de pasos que la segunda para resolver el mismo problema.",
    "crumbs": [
      "Teor칤a",
      "U4 - Estructuras de Datos y Algoritmos",
      "1 - 쯇or qu칠 importan?"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/01_por_que_importan.html#introducci칩n",
    "href": "teoria/04_estructuras_y_algoritmos/01_por_que_importan.html#introducci칩n",
    "title": "1 - 쯇or qu칠 importan?",
    "section": "",
    "text": "En esta 칰ltima unidad nos ocuparemos de Estructuras de Datos y Algoritmos.\nPuede que estos t칠rminos suenen un tanto abstractos, pero como veremos a lo largo de estos apuntes, dominarlos nos ayudar치 a escribir c칩digo m치s eficiente, que corre m치s r치pido y consume menos memoria.\nEn pocas palabras, podemos decir que una estructura datos es una forma sistem치tica de organizar y acceder a datos, mientras que un algoritmo es un procedimiento paso a paso para realizar una tarea en tiempo finito.\n\n\nA lo largo de este curso hemos ido adquiriendo experiencia en la programaci칩n con Python y probablemente hayamos empezado a desarrollar un instinto u olfato que nos permite juzgar la calidad de un programa. Al enfrentarnos con dos programas que realizan la misma tarea, podemos determinar si uno es mejor que otro.\nNo hay un 칰nico aspecto que determina la calidad de un programa. Uno de ellos, por ejemplo, es la mantenibilidad. Una base de c칩digo legible, organizada y modular es m치s f치cil de manetener que otra poco legible, desorganizada y monol칤tica.\nLa eficiencia es otro aspecto que determina la calidad de un programa. Por ejemplo, podemos contar con dos funciones que resuelven el mismo problema, pero una de ellas es m치s r치pida que la otra.\nLas dos funciones debajo resuelven exactamente el mismo problema: imprimir los n칰meros pares entre 2 y 100.\ndef imprimir_numeros_1():\n    numero = 2\n    while numero &lt;= 100:\n        if numero % 2 == 0:\n            print(numero)\n            numero += 1\n\ndef imprimir_numeros_2():\n    numero = 2\n    while numero &lt;= 100:\n        print(numero)\n        numero += 2\nSin embargo, cabe preguntarse: 쯖u치l de las dos funciones se ejecuta m치s r치pido?\nLa respuesta correcta es la segunda. La primera funci칩n realiza 100 iteraciones, mientras que la segunda solo realiza 50. Por lo tanto, la primera funci칩n requiere el doble de pasos que la segunda para resolver el mismo problema.",
    "crumbs": [
      "Teor칤a",
      "U4 - Estructuras de Datos y Algoritmos",
      "1 - 쯇or qu칠 importan?"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/01_por_que_importan.html#estructuras-de-datos",
    "href": "teoria/04_estructuras_y_algoritmos/01_por_que_importan.html#estructuras-de-datos",
    "title": "1 - 쯇or qu칠 importan?",
    "section": "Estructuras de datos",
    "text": "Estructuras de datos\nLa palabra datos es sencilla y amplia a la vez. Puede referirse tanto a valores elementales, como el n칰mero 1, como a estructuras m치s complejas, por ejemplo, los datos contenidos en un diccionario anidado.\nCuando realizamos una operaci칩n como 3 + 5, los valores 3 y 5 son los datos con los que trabajamos. En particular, las estructuras de datos se refieren al c칩mo se organizan los datos.\nObservemos el siguiente bloque de c칩digo:\n\nx = \"춰Hola! \"\ny = \"쮺칩mo est치s? \"\nz = \"쯊odo bien?\"\n\nprint(x + y + z)\n\n춰Hola! 쮺칩mo est치s? 쯊odo bien?\n\n\nEn este programa sencillo se cuenta con tres datos, todos ellos cadenas de texto, que al combinarse forman un mensaje coherente.\nSi tuvieramos que describir la organizaci칩n de los datos en este bloque de c칩digo, dir칤amos que se tienen tres cadenas de texto independientes, cada una representada por una variable distina.\nPero esta no es la 칰nica forma de organizar estos datos. Otra alternativa consiste en agrupar las cadenas de texto en un arreglo, del ingl칠s array, que en Python se implementa mediante listas.\n\narreglo = [\"춰Hola! \", \"쮺칩mo est치s? \", \"쯊odo bien?\"]\n\nprint(arreglo[0] + arreglo[1] + arreglo[2])\n\n춰Hola! 쮺칩mo est치s? 쯊odo bien?\n\n\nEl resultado de ambos bloques es el mismo: se obtiene un 칰nico mensaje como resultado de concatenar todas las cadenas de texto, formando un mensaje coherente.\nAhora, si nos preguntamos cu치l de los dos programas es mejor, no existe una 칰nica respuesta correcta, ya que depender치 del criterio en base al cu치l es comparan los bloques de c칩digo.\nEl objetivo este ejemplo es mostrar que no existe una 칰nica forma de organizar los datos de un programa. M치s adelante veremos que la forma en que los organizamos no solo afecta c칩mo se ve un programa, sino tambi칠n su velocidad de ejecuci칩n. Dependiendo de c칩mo decidamos representar los datos, un programa puede llegar a ser varias 칩rdenes de magnitud m치s r치pido o m치s lento que otro.\nPero antes de correr, hay que aprender a caminar. Empecemos por una estructura de datos con la que estamos m치s que familiarizados: los arreglos.\n\nArreglos\nEl arreglo es una de las estructuras de datos m치s b치sicas en la computaci칩n. En Python, la estructura built-in que representa al arreglo es la lista, con la que ya hemos trabajado extensamente. Gracias a ello, aprendimos que el arreglo es una estructura de datos muy vers치til, que nos puede ayudar en una gran variedad de situaciones.\nSi tuvieramos que describir al arreglo en pocas palabras, dir칤amos que es una colecci칩n de datos en un orden determinado.\nPara lo que sigue, consideremos al siguiente arreglo que contiene diferentes tipos de frutos secos:\n\narray = [\"nueces\", \"almendras\", \"pistachos\", \"man칤es\", \"casta침as\"]\n\nR치pidamente, podr칤amos decir que trabajamos con arreglo que contiene 5 cadenas de texto, y que cada una representando un fruto seco distinto.\nPero los arreglos, al igual que otras estructuras de datos, cargan con vocabulario t칠cnico propio para describirlos:\n\nEl tama침o (size) del arreglo indica cu치ntos elementos contiene. En nuestro ejemplo, array es un arreglo de tama침o 5.\nEl 칤ndice (index) es el n칰mero que identifica la posici칩n de cada elemento dentro de 칠l.\n\nComo en Python el 칤ndice comienza en 0, decimos que \"nueces\" est치 en el 칤ndice 0, \"almendras\" en el 칤ndice 1 y que \"casta침as\" est치 en el 칤ndice 4.\n\n\n\n\n\n\n쯈u칠 tan buena es una estructura de datos?\nUna forma de determinar que tan buena es una estructura de datos es midiendo su desempe침o para realizar diferentes operaciones. Para ello, se suelen considerar cuatro operaciones b치sicas que se utilizan para interactuar con la estructura:\n\nLectura (read): acceder a un valor en una posici칩n espec칤fica dentro de la estructura. En un arreglo, significa obtener el elemento que se encuentra en un 칤ndice determinado.\nB칰squeda (search): verificar si un valor existe dentro de la estructura y, de ser as칤, obtener en qu칠 posici칩n se encuentra.\nInserci칩n (insert): agregar un nuevo valor a la estructura. En un arreglo, ser칤a a침adir un elemento en una posici칩n determinada.\nEliminaci칩n (delete): quitar un valor existente de la estructura.\n\nEn las pr칩ximas secciones analizaremos la eficiencia de cada una de estas operaciones cuando se aplican a un arreglo.\n\n\n\n\n\n\nViejos conocidos\n\n\n\nYa sabemos como realizar operaciones de lectura, b칰squeda, inserci칩n y eliminaci칩n con listas de Python. De hecho, para cada una de ellas disponemos de un m칠todo espec칤fico:\n# Lectura\narray[indice]\n\n# B칰squeda\narray.index(valor)\n\n# Inserci칩n\narray.insert(valor, indice)\n\n# Eliminaci칩n\narray.pop(indice) # Por 칤ndice\narray.remove(valor) # Por valor\nSin embargo, el prop칩sito de esta unidad es comprender c칩mo funcionan internamente estas operaciones, para as칤 entender las fortalezas y limitaciones de cada estructura de datos.\n\n\n\n\n쮺칩mo se mide la velocidad de una operaci칩n?\nCuando hablamos de qu칠 tan r치pida es una operaci칩n no nos referimos al tiempo en segundos, sino a la cantidad de pasos que requiere.\nEsto se debe a que el tiempo real depende del hardware donde se ejecuta la operaci칩n. Un mismo programa puede tardar m치s en una computadora antigua y menos en una moderna. En cambio, contar los pasos nos permite comparar operaciones independientemente del equipo donde se ejecuten.\nPor ejemplo, si una operaci칩n A necesita 5 pasos y otra B requiere 500, podemos afirmar que A es una operaci칩n m치s r치pida que B.\nA este an치lisis se lo conoce como medida de la complejidad temporal (time complexity) de una operaci칩n.\nA continuaci칩n, veremos cu치ntos pasos requiere cada una de las cuatro operaciones b치sicas de un arreglo.\n\n\nLectura\nLa primera operaci칩n que analizaremos es la lectura, que consiste en acceder al valor almacenado en una posici칩n espec칤fica del arreglo. En Python, esto se realiza simplemente con el 칤ndice:\narray[indice]\nPor ejemplo:\narray = [30, 10, 15, 25, 85]\narray[4]  # Devuelve 85\nGracias al dise침o de la memoria RAM (Random Access Memory), que permite acceder directamente a cualquier posici칩n sin recorrer otras, la computadora puede leer un elemento de un arreglo en un solo paso.\nPor ejemplo, en el arreglo [\"nueces\", \"almendras\", \"pistachos\", \"man칤es\", \"casta침as\"], si pedimos el valor en el 칤ndice 2, el procesador accede de inmediato a la posici칩n correspondiente y devuelve \"pistachos\".\n\n쯇or qu칠 esto es posible?\nPodemos imaginar la memoria como una gran colecci칩n de celdas numeradas (algunas vac칤as, otras con datos).\n\n\n\n\n\nCada celda tiene una direcci칩n 칰nica.\n\n\n\n\n\nY cuando declaramos un arreglo, la computadora reserva un bloque contiguo de celdas para almacenarlo.\n\n\n\n\n\nAs칤, si el arreglo ocupa cinco posiciones, el sistema asigna cinco direcciones consecutivas.\n\n\n\n\n\nLuego, el procesador puede calcular la posici칩n exacta del elemento i mediante una operaci칩n aritm칠tica simple:\ndirecci칩n_base + i * tama침o_del_elemento\nEsto explica el nombre memoria de acceso aleatorio: cualquier celda puede leerse o modificarse en el mismo tiempo, sin importar su posici칩n, a diferencia de medios secuenciales (como los discos duros), donde hay que desplazarse f칤sicamente hasta el dato.\nEn el siguiente diagrama se muestra nuestro arreglo de frutos secos junto con sus 칤ndices y direcciones de memoria:\nCada 칤ndice indica la posici칩n l칩gica del elemento dentro del arreglo, mientras que cada direcci칩n representa la ubicaci칩n f칤sica de ese dato en la memoria RAM.\n\n\n\n\n\nPor ejemplo, si queremos leer el valor en el 칤ndice 3, la computadora toma la direcci칩n inicial (칤ndice 0) y le suma 3, ya que las direcciones de memoria son consecutivas.\nAplicado a nuestro arreglo de frutos secos, que comienza en la direcci칩n 1010:\n\nEl 칤ndice 0 est치 en la direcci칩n 1010.\nEl 칤ndice 3 est치 tres posiciones despu칠s.\nPor lo tanto, su direcci칩n es 1013 (1010 + 3).\n\nAs칤, la computadora puede saltar directamente a la direcci칩n 1013 y ver que all칤 se encuentra el valor \"man칤es\".\nLeer desde un arreglo es, por tanto, una operaci칩n muy eficiente, porque permite acceder a cualquier elemento en un solo paso.\nAhora bien, 쯤u칠 ocurre si en lugar de preguntar 람u칠 valor hay en el 칤ndice 3 queremos saber 란n qu칠 칤ndice se encuentra 딿istachos뙉?\nEsa es la operaci칩n de b칰squeda, y ser치 la pr칩xima que analizaremos.\n\n\n\nB칰squeda\nBuscar en un arreglo consiste en comprobar si un valor existe y, de ser as칤, obtener en qu칠 칤ndice se encuentra.\nA la b칰squeda se la puede pensar como la operaci칩n inversa a la lectura. Mientras que leer implica dar un 칤ndice y obtener un valor, buscar implica dar un valor y obtener su 칤ndice.\nAunque parezcan operaciones similares, su eficiencia difiere much칤simo.\nLa lectura es r치pida porque la computadora puede saltar directo a cualquier direcci칩n de la memoria. En cambio, la b칰squeda es m치s lenta, ya que la computadora no puede saltar a un valor espec칤fico, sino que debe revisar las celdas una por una hasta encontrarlo.\nSi retomamos nuestro arreglo de frutos secos, la computadora no 랐e los nombres de los elementos, solo una secuencia de celdas con direcciones. Al comenzar la b칰squeda, para la computadora, el arreglo podr칤a verse de la siguiente manera.\n\n\n\n\n\nPor lo tanto, para buscar un valor dentro del arreglo, la computadora no tiene otra opci칩n que inspeccionar cada celda de la memoria, una por una.\nEn los diagramas siguientes se muestra el proceso que seguir칤a para buscar \"pistachos\" en nuestro arreglo.\nPrimero, la computadora revisa el 칤ndice 0:\n\n\n\n\n\nComo el valor en el 칤ndice 0 es 랉ueces y no 랋istachos, la computadora avanza al siguiente 칤ndice, tal como se muestra a continuaci칩n.\n\n\n\n\n\nHasta que al fin encontramos los tan buscados \"pistachos\" y ahora sabemos que se encuentran en el 칤ndice 2.\n\n\n\n\n\nEn este punto, la computadora ya no necesita seguir revisando el resto del arreglo, porque encontr칩 el valor que buscaba.\nEn este ejemplo, como la computadora tuvo que inspeccionar tres celdas hasta dar con el resultado, decimos que la operaci칩n tom칩 tres pasos en total.\nEsta forma de b칰squeda, en la que la computadora revisa cada celda una por una, se llama b칰squeda lineal.\nSi el valor buscado est치 en la 칰ltima celda, o no se encuentra en absoluto, la computadora deber치 recorrer todo el arreglo.\nAs칤, en un arreglo de 5 elementos, la b칰squeda lineal puede requerir hasta 5 pasos; en uno de 500, hasta 500. En general, para un arreglo de N elementos, el n칰mero m치ximo de pasos es N.\nEsto demuestra que la b칰squeda es menos eficiente que la lectura: leer siempre toma un paso, mientras que buscar puede requerir muchos.\nA continuaci칩n veremos la operaci칩n de inserci칩n.\n\n\nInserci칩n\nLa eficiencia de insertar un nuevo dato en un arreglo depende del lugar donde se realice la inserci칩n.\nSi queremos agregar \"pasas\" al final de nuestra lista de frutos secos, la operaci칩n toma un solo paso. Esto es posible porque la computadora conoce tanto la direcci칩n de memoria inicial del arreglo como su tama침o.\nPor ejemplo, si el arreglo comienza en la direcci칩n 1010 y tiene 5 elementos, el 칰ltimo se encuentra en 1014. Insertar uno nuevo implica simplemente ocupar la siguiente direcci칩n, 1015 (asumiendo que no est치 ocupada).\nUna vez calculada esa posici칩n, la computadora puede realizar la inserci칩n en un 칰nico paso.\n\n\n\n\n\nHay un detalle importante: cuando la computadora reserv칩 memoria para el arreglo, asign칩 solo cinco celdas. Si agregamos un sexto elemento, puede ser necesario extender el arreglo, lo cual muchos lenguajes hacen autom치ticamente.\nInsertar al final es simple, pero hacerlo al inicio o en el medio requiere desplazar los elementos para dejar espacio, lo que a침ade pasos adicionales.\nPor ejemplo, si queremos insertar \"pasas\" en el 칤ndice 2, el proceso ser칤a as칤:\n\n\n\n\n\nPara hacerlo, debemos mover \"pistachos\", \"man칤es\" y \"casta침as\" una posici칩n a la derecha para hacer espacio a \"pasas\".\nEsto requiere varios pasos: primero se mueve \"casta침as\" una celda a la derecha, lo que libera un espacio a la derecha de \"man칤es\".\n\n\n\n\n\nLuego, se mueve \"man칤es\" a la derecha, dejando un espacio a la derecha de \"pistachos\".\n\n\n\n\n\nPor 칰ltimo, se mueve \"pistachos\" a la derecha y se genera el hueco donde se inserta el valor de \"pasas\".\n\n\n\n\n\n\n\n\n\n\nAl final, se cuenta on un arreglo de longitud 6, donde \"pasas\" ocupa el 칤ndice 2.\n\n\n\n\n\nEn este ejemplo la inserci칩n tom칩 cuatro pasos: tres para mover datos y uno para agregar el nuevo valor.\nEl peor caso ocurre al insertar al inicio del arreglo, ya que hay que desplazar todos los elementos una posici칩n a la derecha. En general, una inserci칩n en el peor escenario requiere N + 1 pasos para un arreglo de N elementos.\nAhora pasemos a la 칰ltima operaci칩n: la eliminaci칩n.\n\n\nEliminaci칩n\nEliminar un elemento de un arreglo consiste en quitar el valor ubicado en un 칤ndice determinado.\nVolviendo a nuestro ejemplo original, eliminemos el valor del 칤ndice 1, que corresponde a \"almendras\".\n\n\n\n\n\nAunque la eliminaci칩n en s칤 toma solo un paso, deja una celda vac칤a en el medio del arreglo. Como un arreglo no puede tener huecos, es necesario mover los elementos \"pistachos\", \"man칤es\" y \"casta침as\" una posici칩n a la izquierda, lo que agrega pasos adicionales al proceso.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFinalmente, el arreglo se encoje y pasa de tener 5 elementos a tener 4.\n\n\n\n\n\nEn este ejemplo la eliminaci칩n toma cuatro pasos: uno para borrar el valor y tres para mover los datos y cerrar el espacio vac칤o.\nAl igual que con la inserci칩n, el peor caso ocurre al eliminar el primer elemento del arreglo, ya que el 칤ndice 0 queda vac칤o y es necesario desplazar todos los dem치s elementos una posici칩n a la izquierda.\nEn un arreglo de 5 elementos, eso implica 1 paso para eliminar y 4 para mover; en uno de 500, 1 para eliminar y 499 para desplazar. En general, para un arreglo con N elementos, la eliminaci칩n puede requerir hasta N pasos.\nCon esto concluimos el an치lisis de la complejidad temporal de nuestro primer tipo de estructura de datos.\nAhora que comprendemos c칩mo evaluar la eficiencia de las operaciones sobre un arreglo, podemos comparar este comportamiento con el de otras estructuras.\nLa siguiente que estudiaremos es el conjunto (set), que a primera vista puede parecer similar a un arreglo, pero veremos que sus operaciones se comportan de manera muy diferente en t칠rminos de eficiencia.\n\n\n\nConjuntos\nEn esta breve secci칩n trabajaremos con otra estructura de datos: el conjunto.\nEl conjunto puede ser implementado de diferentes maneras. En Python, por ejemplo, el conjunto es una estructura donde el orden de los elementos no importa.\nPodemos tambi칠n suponer un conjunto basado en arreglos. Es decir, la estructura consiste en un arreglo que no permite valores duplicados.\nEn un conjunto basado en un arreglo, las operaciones de lectura, b칰squeda y eliminaci칩n funcionan igual que en los arreglos. Leer un elemento toma un solo paso y buscar o eliminar puede requerir hasta N pasos. La diferencia aparece en la inserci칩n.\nDada la condici칩n de que no se pueden repetir elementos en un conjunto, antes de agregar un valor, la computadora debe verificar que este no exista ya en el conjunto.\nEsta peque침a modificaci칩n implica que para cada inserci칩n primero hay que hacer una b칰squeda previa y, solo si el valor no est치 presente, efectuar la inserci칩n.\nPor ejemplo, si un conjunto con nombres de alumnos contiene [\"Ana\", \"Bruno\", \"Carla\", \"Diego\", \"Elena\"] y queremos agregar \"Francisco\", la computadora primero comprobar치 que \"Francisco\" no est칠 ya inscripto antes de a침adirlo.\nSe inspeccionan los elementos del conjunto uno a uno, hasta que se encuentra el elemento a insertar o se terminar de recorrer el arreglo. Las siguientes imagenes representan el proceso en nuestro ejemplo:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAhora que hemos buscado en todo el conjunto, sabemos con certeza que no contiene a \"Francisco\".\nEn este punto, podemos realizar la inserci칩n sin problema. Y con eso llegamos al paso final:\n\n\n\n\n\nInsertar un valor al final de un conjunto es el mejor caso posible, pero aun as칤 requiere m치s pasos que en un arreglo.\nEn un conjunto con N elementos, hay que buscar entre los N valores antes de insertar, lo que implica N + 1 pasos, mientras que en un arreglo basta con uno.\nEn el peor caso, al insertar al inicio, el conjunto requiere 2N + 1 pasos (N para buscar, N para mover y uno para insertar), frente a los N + 1 de un arreglo.\n\n\n\n\n\n\nContando pasos\n\n\n\nAnalizar cu치ntos pasos requiere una operaci칩n es clave para entender el rendimiento de una estructura de datos. Elegir la estructura correcta puede marcar la diferencia entre un programa 치gil y uno ineficiente.",
    "crumbs": [
      "Teor칤a",
      "U4 - Estructuras de Datos y Algoritmos",
      "1 - 쯇or qu칠 importan?"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/01_por_que_importan.html#algoritmos",
    "href": "teoria/04_estructuras_y_algoritmos/01_por_que_importan.html#algoritmos",
    "title": "1 - 쯇or qu칠 importan?",
    "section": "Algoritmos",
    "text": "Algoritmos\nEn la secci칩n anterior vimos c칩mo la elecci칩n de una estructura de datos puede afectar el rendimiento del c칩digo. Incluso dos estructuras que parecen similares, como los arreglos y los conjuntos, pueden tener eficiencias muy distintas seg칰n la operaci칩n.\nEn esta secci칩n vamos a descubrir que, adem치s de la estructura de datos, otro factor clave influye en la eficiencia: el algoritmo que usamos.\nAunque la palabra pueda sonar compleja, un algoritmo no es m치s que un conjunto de pasos definidos para realizar una tarea. Por ejemplo, preparar un mate puede describirse con estos pasos:\n\nCalentar el agua.\nColocar la yerba en el mate.\nInsertar la bombilla.\nServir el agua con cuidado.\n\nSi cambiamos el orden y, por ejemplo, echamos el agua antes de la yerba, el resultado es un mal mate o, a칰n peor, un enchastre total.\nEn computaci칩n, un algoritmo es el conjunto de instrucciones que le damos a la computadora para cumplir una tarea. Cada vez que escribimos c칩digo, estamos creando algoritmos que la computadora sigue al pie de la letra para obtener un resultado.\nA veces, distintos algoritmos pueden resolver el mismo problema, pero con eficiencias distintas. Ya vimos un ejemplo al imprimir n칰meros pares, donde un algoritmo requer칤a el doble de pasos que otro. En esta secci칩n veremos otro caso similar, en el que una soluci칩n resulta mucho m치s r치pida que la otra, y para analizarlo presentaremos una nueva estructura de datos.\n\nArreglos ordenados\nEl arreglo ordenado es casi id칠ntico al arreglo cl치sico que vimos antes.\nLa 칰nica diferencia es que en un arreglo ordenado los valores deben mantenerse siempre en orden. Cada vez que se agrega un nuevo valor, este se coloca en la posici칩n correcta para conservar ese orden.\nSupongamos que tenemos el arreglo [6, 21, 38, 95] y queremos insertar el valor 30. En un arreglo com칰n podr칤amos agregarlo simplemente al final y tomar칤a un solo paso.\nCon un un arreglo ordenado no podemos insertar al final en nu solo paso, ya que podr칤a resultar en un arreglo que no cumple el requisito de que los valores est칠n ordenados.\n\n\n\n\n\nEn un arreglo ordenado debemos insertar el 30 en el lugar correspondiente para que los valores sigan en orden ascendente, como se muestra debajo:\n\n\n\n\n\nEn la pr치ctica, llevar a cabo esta inserci칩n es m치s compleja que su simple enunciaci칩n. La computadora no puede 랋oner el 30 en el lugar correcto en un solo paso. Primero debe encontrar d칩nde insertarlo y luego desplazar los dem치s valores para crear el espacio necesario.\nVeamos el proceso paso a paso, partiendo del arreglo ordenado original:\n\n\n\n\n\nPrimero verificamos el valor en el 칤ndice 0 para decidir si el n칰mero que queremos insertar, EL 30, debe ubicarse a su izquierda o a su derecha.\n\n\n\n\n\nComo el 30 es mayor que 6, sabemos que deber치 insertarse en alguna posici칩n a su derecha. C칩mo a칰n no sabemos en cu치l posici칩n exactamente, debemos revisar la siguiente celda.\n\n\n\n\n\nComo el 30 tambi칠n es mayor que el valor en la segunda posici칩n, seguimos avanzando hacia la derecha.\n\n\n\n\n\nEn este punto, encontramos el valor 38, que es mayor que el 30 y, por lo tanto, sabemos que debemos insertar el 30 a su izquierda.\n\n\n\n\n\nPara hacerlo, necesitamos desplazar los datos y dejar espacio para insertar el 30.\n\n\n\n\n\nCuando insertamos en un arreglo ordenado, siempre debemos buscar primero la posici칩n correcta antes de hacer la inserci칩n. Esa b칰squeda previa marca una diferencia importante respecto al arreglo cl치sico.\nEn el ejemplo, con cuatro elementos, la inserci칩n tom칩 6 pasos. En t칠rminos generales, para un arreglo con N elementos, la inserci칩n requiere N + 2 pasos.\nEl n칰mero total de pasos var칤a poco seg칰n la posici칩n del nuevo valor: si se inserta cerca del inicio, hay menos comparaciones y m치s desplazamientos. Si se inserta al final, hay m치s comparaciones y menos movimientos. El caso m치s r치pido ocurre cuando el nuevo valor se agrega al final, ya que no hay que mover nada: se necesitan N pasos de comparaci칩n y uno de inserci칩n, es decir, N + 1 pasos.\nAunque insertar en un arreglo ordenado es menos eficiente que en uno cl치sico, esta estructura tiene una gran ventaja cuando se trata de buscar valores, como veremos a continuaci칩n.\n\n\nB칰squeda en arreglos ordenados\nEn un arreglo cl치sico, buscar un valor implica revisar las celdas una por una, de izquierda a derecha, hasta encontrarlo o llegar al final. Este proceso se conoce como b칰squeda lineal.\nPor ejemplo, si tenemos el arreglo [67, 25, 13, 6, 132] y buscamos el valor 21, debemos recorrer todos los elementos, ya que podr칤a estar en cualquier posici칩n. Solo podr칤amos detenernos temprano si encontr치ramos el valor 21.\nEn cambio, en un arreglo ordenado podemos detener la b칰squeda antes, incluso si el valor no est치 presente. Si el arreglo es [6, 13, 25, 67, 132] y buscamos 21, podemos detenernos al llegar al 67, porque sabemos que ning칰n valor mayor a 21 aparecer치 m치s adelante.\n\ndef busqueda_lineal(array, valor):\n    for indice, elemento in enumerate(array):\n        if elemento == valor:\n            return indice\n        elif elemento &gt; valor:\n            break\n    return None\n\nEste m칠todo recibe dos argumentos: array, que es el arreglo ordenado en el que buscamos, y valor, que es el valor que queremos encontrar. As칤 es como usar칤amos esta funci칩n para buscar el n칰mero 21 en nuestro arreglo de ejemplo:\n\nprint(busqueda_lineal([6, 13, 25, 67, 132], 21))\n\nNone\n\n\nLa funci칩n busqueda_lineal inspecciona cada elemento del arreglo en busca del valor indicado. La b칰squeda se detiene en el momento en que el elemento actual es mayor que el valor buscado, ya que sabemos que este no puede encontrarse m치s adelante en el arreglo.\nEn ciertos casos, la b칰squeda lineal puede requerir menos pasos en un arreglo ordenado que en uno cl치sico. Sin embargo, si el valor buscado est치 al final o no se encuentra en el arreglo, igualmente habr치 que revisar todas los valores.\nA simple vista, los arreglos cl치sicos y los ordenados no muestran grandes diferencias en eficiencia, al menos en los peores casos: en ambos, una b칰squeda lineal puede requerir hasta N pasos.\nPero existe un algoritmo mucho m치s eficiente que invalida nuestra temprana conclusi칩n. Aunque la b칰squeda lineal es una opci칩n para recorrer un arreglo ordenado, no es la 칰nica. La gran ventaja de los arreglos ordenados es que permiten aplicar otro tipo de b칰squeda: la b칰squeda binaria, un algoritmo considerablemente m치s r치pido que la b칰squeda lineal.\n\n\nB칰squeda binaria\nSeguro alguna vez jugaste a esto: alguien piensa un n칰mero entre 1 y 100, y vos ten칠s que adivinarlo. Despu칠s de cada intento, te dicen si el n칰mero buscado es mayor o menor.\nLa estrategia intuitiva no es empezar por el 1, sino por la mitad (por ejemplo, el 50). As칤, sin importar la respuesta, se eliminan de una vez la mitad de las posibilidades.\nSi te dicen que el n칰mero es mayor, se puede probar con 75; si es menor, con 25. En cada paso, se vuelve a elegir el punto medio y se reduce el conjunto de n칰meros a la mitad.\nEse es exactamente el principio detr치s de la b칰squeda binaria.\nVeamos ahora c칩mo se aplica la b칰squeda binaria sobre un arreglo ordenado.\nSupongamos que tenemos un arreglo con nueve elementos y que estamos buscando el valor 15.\nLa computadora no sabe de antemano qu칠 valor hay en cada posici칩n, as칤 que podemos representarlo de esta forma:\n\n\n\n\n\nSe inspecciona el valor en la posici칩n central:\n\n\n\n\n\nComo el valor encontrado es 11, podemos concluir que el 15 est치 a su derecha.\nAs칤 eliminamos la mitad del arreglo: todas las casillas a la izquierda del 11 (incluida la del 11).\n\n\n\n\n\nA continuaci칩n es inspecciona el centro de la mitad que puede contener al valor buscado.\n\n\n\n\n\nComo el valor hallado es mayor a 15, inspeccionamos los valores a su izquierda.\nEn este punto quedan dos valores posibles y elegimos arbitrariamente en el de la derecha:\n\n\n\n\n\nNuevamente el valor hallado es mayor a 15, por lo que inspeccionamos la 칰ltima celda posible. Si el valor 15 no se encuentra all칤, entonces no est치 en el arreglo.\n\n\n\n\n\nEsta vez, lo encontramos y podemos concluir que el 15 est치 en el arreglo y devolver su posici칩n.\nCon el algoritmo de b칰squeda binaria nos llev칩 cuatro pasos encontrar el valor de inter칠s. Si hubieramos usado b칰squeda lineal, nos hubiera llevado 6 pasos.\nEn t칠rminos generales la b칰squeda binaria ser치 mas r치pida que la busqueda lineal, aunque pueden existir ejemplos donde esto no suceda. La gran desventaja de la b칰squeda binaria es que solo funciona en arreglos ordenados: en uno desordenado no sabr칤amos hacia qu칠 lado seguir buscando.\nA continuaci칩n, una implementaci칩n del algoritmo de b칰squeda binaria en Python:\n\ndef busqueda_binaria(array, valor):\n    limite_inferior = 0\n    limite_superior = len(array) - 1\n\n    while limite_inferior &lt;= limite_superior:\n        punto_medio = (limite_inferior + limite_superior) // 2\n        valor_en_punto_medio = array[punto_medio]\n\n        if valor == valor_en_punto_medio:\n            return punto_medio\n        elif valor &lt; valor_en_punto_medio:\n            limite_superior = punto_medio - 1\n        elif valor &gt; valor_en_punto_medio:\n            limite_inferior = punto_medio + 1\n\n    return None\n\n\nprint(busqueda_binaria([3, 17, 75, 80, 202], 22))\n\nNone\n\n\n\n\nB칰squeda lineal vs.막칰squeda binaria\nCon arreglos peque침os, la b칰squeda binaria no tiene mucha ventaja frente a la lineal. Pero al aumentar el tama침o del arreglo, la diferencia se vuelve notable.\nEn un arreglo de 100 elementos, la b칰squeda lineal puede requerir hasta 100 pasos, mientras que la binaria necesita solo 7. Con la b칰squeda lineal, si el valor buscado est치 al final, hay que revisar cada elemento. En cambio, la b칰squeda binaria descarta la mitad de las opciones en cada intento: el primer paso ya elimina 50 valores.\nSi el arreglo tiene 3 elementos, la b칰squeda binaria requiere 2 pasos; con 7 elementos, 3 pasos; con 15, 4 pasos. Cada vez que se duplica el tama침o del arreglo, solo se suma un paso m치s. En cambio, la b칰squeda lineal duplica su n칰mero de pasos cada vez que se duplica el tama침o.\nPor eso, con 10000 elementos la b칰squeda binaria necesita como m치ximo 13 pasos, y con un mill칩n, solo 20. Esta eficiencia explica por qu칠 la b칰squeda binaria es tan poderosa en arreglos ordenados.\nLa siguiente figura muestra como crece la cantidad m치xima de pasos que requiere cada tipo de b칰squeda conforme crece la cantidad de elementos.\n\n\n\n\n\n\n\n\n\nEn el eje horizontal se representa la cantidad de elementos del arreglo: hacia la derecha, el tama침o de los datos aumenta. En el eje vertical, se muestra la cantidad de pasos que requiere el algoritmo: cuanto m치s arriba, m치s pasos.\nLa l칤nea de la b칰squeda lineal crece de forma proporcional: cada nuevo elemento implica un paso adicional, por eso la gr치fica forma una l칤nea diagonal ascendente.\nEn cambio, la b칰squeda binaria apenas aumenta su n칰mero de pasos al crecer los datos. Para duplicar la cantidad de elementos, solo suma un paso m치s, lo que produce una curva que crece muy lentamente.\nConviene recordar que los arreglos ordenados no son m치s r치pidos en todo: insertar nuevos valores es m치s lento que en un arreglo com칰n. El beneficio est치 en la b칰squeda. Por eso, antes de elegir una estructura, hay que considerar el uso: 쯛ar치s muchas inserciones o muchas b칰squedas?",
    "crumbs": [
      "Teor칤a",
      "U4 - Estructuras de Datos y Algoritmos",
      "1 - 쯇or qu칠 importan?"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/01_por_que_importan.html#big-o",
    "href": "teoria/04_estructuras_y_algoritmos/01_por_que_importan.html#big-o",
    "title": "1 - 쯇or qu칠 importan?",
    "section": "Big O",
    "text": "Big O\nHasta ahora vimos que la eficiencia de un algoritmo depende, principalmente, de la cantidad de pasos que realiza.\nPero no podemos decir simplemente que un algoritmo tiene 35 pasos y otro 200 pasos, porque ese n칰mero en realidad depende del tama침o del problema. Por ejemplo, una b칰squeda lineal necesita tantos pasos como elementos haya en el arreglo: si hay 35 elementos, toma 35 pasos; si hay 200, toma 200.\nEn lugar de hablar de un n칰mero fijo de pasos, decimos que la b칰squeda lineal requiere N pasos para N elementos. Para expresar esto de forma m치s clara y general, la inform치tica usa una herramienta tomada de las matem치ticas: la notaci칩n Big O.\nLa notaci칩n Big O permite describir y comparar la eficiencia de los algoritmos con un lenguaje conciso y consistente. Gracias a esta, describiremos algoritmos con \\(O(1)\\), \\(O(N)\\), \\(O(\\log N)\\), etc. Veamos que significa.\n\nBig O: es relativo\nLa notaci칩n Big O permite comparar algoritmos de forma consistente al centrarse en la cantidad de pasos que requieren, dejando detalles espec칤ficos de lado.\nVolvamos al ejemplo de la b칰squeda lineal. Si el arreglo tiene \\(N\\) elementos, la b칰squeda puede requerir hasta \\(N\\) pasos y decimos que es un algoritmo de complejidad \\(O(N)\\) o 띿e orden N. A este tipo de comportamiento tambi칠n se lo llama tiempo lineal, porque el n칰mero de pasos crece de forma proporcional al tama침o del arreglo.\nAhora comparemos esto con la operaci칩n de lectura en un arreglo com칰n. Como ya vimos, leer un elemento lleva siempre un solo paso, sin importar cu치ntos elementos haya. Si nos hacemos la misma pregunta, si hay N elementos, 쯖u치ntos pasos toma leer uno?, la respuesta es siempre la misma: uno. En notaci칩n Big O, esto se expresa como \\(O(1)\\), que se pronuncia O de uno.\n\\(O(1)\\) es un caso especial: aunque la pregunta se formula en funci칩n de \\(N\\), la respuesta no depende de \\(N\\). No importa si el arreglo tiene 10, 100 o un mill칩n de elementos: leer el valor en una posici칩n siempre lleva un paso. Por eso, los algoritmos \\(O(1)\\) se consideran los m치s r치pidos posibles: su tiempo de ejecuci칩n es constante, sin importar el tama침o de los datos.\n\n\nBig O: lo que realmente importa\nYa vimos ejemplos de \\(O(N)\\) y \\(O(1)\\). A esta altura, podemos notar que la notaci칩n Big O no se trata solo de contar pasos, sino de responder una pregunta clave:\n\nsi hay N elementos, 쯖u치ntos pasos realiza el algoritmo?\n\nImaginemos, por ejemplo, un algoritmo que siempre ejecuta tres pasos, sin importar el tama침o del conjunto de datos. Podr칤amos pensar que este algoritmo es \\(O(3)\\), pero en realidad se escribe como \\(O(1)\\).\n쯇or qu칠? Porque Big O no mide el n칰mero exacto de operaciones, sino c칩mo cambia el tiempo de ejecuci칩n cuando el tama침o del problema aumenta.\nPor eso no diferenciamos entre \\(O(1)\\) y \\(O(3)\\), ambos representan algoritmos de tiempo constante, cuyo desempe침o no depende de N. En cambio, un algoritmo \\(O(N)\\) es distinto: su tiempo crece proporcionalmente al tama침o de los datos.\nEn resumen, la notaci칩n Big O cuenta la historia de c칩mo aumenta el n칰mero de pasos que requiere un algoritmo a medida que la cantidad de datos crece.\nDebajo, se observa como crece la cantidad de pasos de un algoritmo \\(O(n)\\) versus otro \\(O(1)\\).\n\n\n\n\n\n\n\n\n\nLa curva para \\(O(N)\\) es una l칤nea recta perfecta. Cada vez que se agrega un dato nuevo, el algoritmo necesita un paso m치s. Cuantos m치s datos haya, m치s pasos se requerir치n.\nEn cambio, la curva para \\(O(1)\\) es una l칤nea horizontal: sin importar la cantidad de datos, el n칰mero de pasos se mantiene constante.\nPara entender en profundidad el prop칩sito de la notaci칩n Big O, vayamos un poco m치s all치. Imaginemos un algoritmo de tiempo constante que siempre toma 20 pasos, sin importar el tama침o de los datos.\n쯇odr칤amos decir que es m치s o menos eficiente que un algoritmo \\(O(N)\\)?\nPodemos visualizar la relaci칩n entre cantidad de elementos y n칰mero de pasos debajo.\n\n\n\n\n\n\n\n\n\nCon menos de 20 elementos el algoritmo \\(O(N)\\) realiza menos pasos que el algoritmo \\(O(1)\\), que siempre toma 20. En 20 elementos, ambas l칤neas se cruzan, los dos algoritmos tardan lo mismo. Pero a partir de ese punto, el \\(O(N)\\) comienza a necesitar m치s pasos, y la diferencia sigue creciendo a medida que aumenta el tama침o de los datos.\nSiempre existe un punto a partir del cual \\(O(N)\\) se vuelve menos eficiente, sin importar cu치ntos pasos fijos tenga el \\(O(1)\\). Incluso si un algoritmo \\(O(1)\\) tomara un mill칩n de pasos constantes, llegar칤a un tama침o de datos lo suficientemente grande donde el \\(O(N)\\) ser칤a m치s lento, y seguir칤a si칠ndolo hasta el infinito.\n\n\n\n\n\n\nBig O es pesimista\n\n\n\nLa b칰squeda lineal no siempre tiene un costo O(N). En el mejor caso, cuando el elemento buscado est치 en la primera posici칩n, se encuentra en tiempo O(1). En el peor caso, cuando est치 al final o no se encuentra en absoluto, requiere O(N) pasos.\nEn general, la notaci칩n Big O se utiliza para describir el peor caso de un algoritmo, a menos que se indique lo contrario. Este enfoque pesimista resulta 칰til porque permite anticipar el rendimiento m치s ineficiente y tomar decisiones informadas sobre qu칠 algoritmo usar.\n\n\n\n\nUn tercer tipo\nPreviamente, vimos que la b칰squeda binaria en un arreglo ordenado es, en general, mucho m치s r치pida que la b칰squeda lineal.\nAhora veamos c칩mo se expresa eso en t칠rminos de notaci칩n Big O.\nPara empezar, no podemos decir que la b칰squeda binaria sea \\(O(1)\\), porque el n칰mero de pasos aumenta cuando crecen los datos. Tampoco es \\(O(N)\\), ya que la velocidad en la que crece la cantidad de pasos es mucho menor. Por ejemplo, con 100 elementos solo requiere unos 7 pasos.\nLa complejidad de la b칰squeda binaria se ubica, entonces, entre \\(O(1)\\) y \\(O(N)\\). En notaci칩n Big O se expresa como \\(O(\\log N)\\), se lee O de log N y se la conoce como un algoritmo de tiempo logar칤tmico.\nEn pocas palabras, \\(O(log N)\\) describe un algoritmo cuyo n칰mero de pasos crece en una unidad cada vez que se duplica la cantidad de datos; exactamente lo que sucede con la b칰squeda binaria.\nEl siguiente gr치fico muestra la evoluci칩n del numero de pasos para las tres complejidades algor칤tmicas mencionadas.\n\n\n\n\n\n\n\n\n\nSe puede observar que la curva \\(O(\\log N)\\) se eleva apenas, lo que la hace un poco menos eficiente que \\(O(1)\\), pero much칤simo m치s eficiente que \\(O(N)\\).\n\n\n\n\n\n\nIntuici칩n detr치s de \\(O(\\log N)\\)\n\n\n\nCuando un algoritmo es \\(O(\\log N)\\), significa que, para N elementos, realizar치 \\(\\log_2 N\\) pasos. Por ejemplo, si hay 8 elementos, tomar치 3 pasos, porque \\(\\log_2 8 = 3\\).\nPodemos imaginarlo as칤: si seguimos dividiendo un arreglo de N elementos a la mitad, necesitaremos \\(\\log_2 N\\) divisiones hasta quedarnos con un solo elemento. Eso es exactamente lo que ocurre en la b칰squeda binaria.\n\n\nLa siguiente tabla muestra la diferencia entre las eficiencias de \\(O(N)\\) y \\(O(\\log N)\\):\n\n\n\nElementos (N)\n\\(O(N)\\)\n\\(O(\\log N)\\)\n\n\n\n\n8\n8\n3\n\n\n16\n16\n4\n\n\n32\n32\n5\n\n\n64\n64\n6\n\n\n128\n128\n7\n\n\n256\n256\n8\n\n\n512\n512\n9\n\n\n1024\n1024\n10\n\n\n\nMientras que un algoritmo \\(O(N)\\) puede realizar tantas operaciones como elementos hay en los datos, un algoritmo \\(O(\\log N)\\) agrega solo un paso adicional cada vez que se duplica la cantidad de datos.\n\n\nComplejidad cuadr치tica\nPara finalizar, exploraremos un ejemplo que nos presentar치 otro tipo de complejidad algor칤tmica.\nSupongamos que desarrollamos una aplicaci칩n en Python que analiza las calificaciones que los usuarios dan a distintos productos, en una escala de 0 a 10. Se quiere implementar funci칩n que verifica si un arreglo de calificaciones contiene n칰meros repetidos.\nPor ejemplo, el arreglo [1, 5, 3, 9, 1, 4] tiene dos valores iguales a 1, por lo que la funci칩n deber칤a devolver True.\nUna primera idea podr칤a ser usar bucles anidados, como se muestra a continuaci칩n:\n\ndef contiene_duplicados(array):\n    for i in range(len(array)):\n        for j in range(len(array)):\n            if (i != j) and (array[i] == array[j]):\n                return True\n    return False\n\n\ncontiene_duplicados([1, 5, 3, 9, 4, 6])\n\nFalse\n\n\n\ncontiene_duplicados([1, 5, 3, 9, 1, 4, 6])\n\nTrue\n\n\nEn esta funci칩n recorremos cada posici칩n del arreglo con la variable i. En cada posici칩n i, ejecutamos un segundo bucle que recorre nuevamente todos los valores con la variable j, comparando si array[i] y array[j] son iguales. Si encontramos dos valores iguales, devolvemos True, mientras que si completamos todos los bucles sin hallar coincidencias, devolvemos False, ya que no hay duplicados.\nEste algoritmo para buscar duplicados funciona, pero 쯘s eficiente? Podemos analizarlo con lo que ya sabemos sobre notaci칩n Big O.\nBig O describe cu치ntos pasos realiza un algoritmo en funci칩n de la cantidad de datos, N. Entonces, para nuestro caso, debemos preguntarnos: si el arreglo tiene N valores, 쯖u치ntos pasos realiza la funci칩n en el peor escenario?\nEl peor caso ocurre cuando no hay duplicados, ya que el c칩digo debe realizar todas las comparaciones posibles antes de terminar. Cada iteraci칩n externa del bucle se ejecuta N veces, y dentro de cada una se ejecuta otro bucle N veces m치s. Por lo tanto, el n칰mero total de comparaciones es \\(N \\times N = N^2\\).\nDecimos entonces que el algoritmo tiene una complejidad \\(O(N^2)\\), tambi칠n conocida como tiempo cuadr치tico.\n\n\n\n\n\n\nBucles anidados\n\n\n\nCon frecuencia (aunque no siempre), cuando un algoritmo tiene un bucle dentro de otro, su complejidad es \\(O(N^2)\\). As칤 que, cada vez que veas bucles anidados, deber칤an sonar las alarmas de la complejidad cuadr치tica\n\n\n\nSoluci칩n lineal\nEl hecho de que nuestra funci칩n original tenga complejidad \\(O(N^2)\\) deber칤a hacernos reflexionar: este tipo de algoritmos se consideran relativamente lentos. Siempre que nos enfrentemos a uno, conviene preguntarnos si existe una alternativa m치s eficiente. Puede que no la haya, pero vale la pena analizarlo.\nA continuaci칩n se muestra otra versi칩n de la funci칩n contiene_duplicados que no usa bucles anidados. La l칩gica detr치s de esta funci칩n es un poco m치s ingeniosa, as칤 que primero veremos c칩mo funciona y luego evaluaremos si resulta m치s eficiente que la primera implementaci칩n.\n\ndef contiene_duplicados_lineal(array):\n    valores_existentes = [0] * 11\n    for i in range(len(array)):\n        if valores_existentes[array[i]] == 1:\n            return True\n        else:\n            valores_existentes[array[i]] = 1\n    return False\n\n\ncontiene_duplicados_lineal([1, 5, 3, 9, 4, 6])\n\nFalse\n\n\n\ncontiene_duplicados_lineal([1, 5, 3, 9, 1, 4, 6])\n\nTrue\n\n\nEsta funci칩n crea un arreglo llamado valores_existentes, que comienza con once ceros, uno para cada valor posible en el arreglo.\nLuego usamos un bucle para revisar cada n칰mero del arreglo original. A medida que encontramos cada n칰mero, colocamos un valor arbitrario (elegimos usar un 1) en valores_existentes, en la posici칩n correspondiente a ese n칰mero.\nPor ejemplo, si el arreglo de entrada es [3, 5, 8]:\n\nAl encontrar el 3, colocamos un 1 en el 칤ndice 3 de valores_existentes:\n\n[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]\n\nLuego, al encontrar el 5, colocamos un 1 en el 칤ndice 5:\n\n[0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0]\n\nFinalmente, al llegar al 8, el arreglo queda as칤:\n\n[0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0]\n\n\nEn esencia, estamos usando los 칤ndices de valores_existentes para recordar qu칠 n칰meros del arreglo ya hemos encontrado.\nAhora viene el punto clave: antes de guardar un 1 en un 칤ndice, el c칩digo revisa si ese 칤ndice ya tiene un 1. Si lo tiene, significa que ya encontramos ese n칰mero antes, es decir, que hay un duplicado. En ese caso, la funci칩n devuelve True y termina de inmediato. Si recorremos todo el arreglo sin encontrar duplicados, devolvemos False.\nPara determinar la eficiencia de este nuevo algoritmo en t칠rminos de Big O, volvemos a analizar cu치ntos pasos realiza en el peor caso.\nEl paso importante es revisar cada n칰mero y comprobar si el valor en el 칤ndice correspondiente de valores_existentes es un 1:\nif valores_existentes[array[i]] == 1:\nAdem치s de las comparaciones, el algoritmo tambi칠n realiza asignaciones en valores_existentes, pero consideramos esos pasos triviales en este an치lisis.\nEl peor caso ocurre cuando el arreglo no contiene duplicados, lo que obliga al c칩digo a completar todo el bucle. En consecuencia, para N elementos, el algoritmo realiza N comparaciones: un solo bucle que itera una vez por cada n칰mero.\nPor lo tanto, este algoritmo tiene una complejidad \\(O(N)\\), o tiempo lineal.\n\n\n\n\n\n\nLetra chica\n\n\n\nEl algoritmo de complejidad lineal es posible solo porque sabemos que array toma valores en un conjunto finito predeterminado. Si los valores en array fuesen cualquiera, no podr칤amos ya utilizar este mismo algoritmo.\nFinalmente, otra desventaja de esta nueva implementaci칩n es que consume m치s memoria que la primera debido a valores_existentes.\n\n\n\n\nResumen de complejidades\nEn este apunte vimos ejemplos de complejidad constante, lineal, logar칤tmica o cuadr치tica. Pero estas no son las 칰nicas disponibles. Otros ejemplos son la complejidad lineal-logar칤tmica (\\(O(N \\log N)\\)), c칰bica (\\(O(N ^3)\\)), exponencial (\\(O(2 ^ N)\\)) o incluso factorial (\\(O(N!)\\)).",
    "crumbs": [
      "Teor칤a",
      "U4 - Estructuras de Datos y Algoritmos",
      "1 - 쯇or qu칠 importan?"
    ]
  },
  {
    "objectID": "teoria/03_oop/05_excepciones.html",
    "href": "teoria/03_oop/05_excepciones.html",
    "title": "5 - Excepciones",
    "section": "",
    "text": "Elevacion de errores\nImplementacion de errores",
    "crumbs": [
      "Teor칤a",
      "U3 - Programaci칩n Orientada a Objetos",
      "5 - Excepciones"
    ]
  },
  {
    "objectID": "teoria/03_oop/05_excepciones.html#errores",
    "href": "teoria/03_oop/05_excepciones.html#errores",
    "title": "5 - Excepciones",
    "section": "",
    "text": "Elevacion de errores\nImplementacion de errores",
    "crumbs": [
      "Teor칤a",
      "U3 - Programaci칩n Orientada a Objetos",
      "5 - Excepciones"
    ]
  },
  {
    "objectID": "teoria/03_oop/01_fundamentos.html",
    "href": "teoria/03_oop/01_fundamentos.html",
    "title": "1 - Fundamentos",
    "section": "",
    "text": "Para hablar de programaci칩n orientada a objetos (OOP, por sus siglas en ingl칠s), podemos empezar pregunt치ndonos qu칠 es un objeto. Aunque no solemos pensar en ello de forma consciente, porque todos podemos distinguir un objeto de lo que no lo es, vale la pena definirlo como algo tangible, que se puede percibir, tocar y manipular. 춰Nos pasamos toda la vida interactuando con objetos!\nEn el mundo real, los objetos tienen atributos o propiedades que los describen. Por ejemplo, un televisor tiene forma, tama침o, color, peso, entre otros. Adem치s, los objetos tambi칠n pueden realizar acciones. Siguiendo con el ejemplo del televisor, puede encenderse, apagarse, cambiar de canal, modificar la fuente de entrada para ver una serie en Netflix o simplemente reproducir m칰sica.\nEn programaci칩n, la definici칩n de objeto no difiere mucho de la anterior. Aunque los objetos no sean elementos f칤sicos, representan entidades que poseen atributos y pueden ejecutar acciones.\nLa programaci칩n orientada a objetos es un paradigma que organiza el c칩digo en torno a estos objetos, que combinan datos (atributos) y comportamientos o acciones (m칠todos) dentro de una misma entidad. Este enfoque permite no solo crear e interactuar con objetos, sino tambi칠n definir nuestros propios tipos de objetos, adaptados a las necesidades del programa.",
    "crumbs": [
      "Teor칤a",
      "U3 - Programaci칩n Orientada a Objetos",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/03_oop/01_fundamentos.html#introducci칩n",
    "href": "teoria/03_oop/01_fundamentos.html#introducci칩n",
    "title": "1 - Fundamentos",
    "section": "",
    "text": "Para hablar de programaci칩n orientada a objetos (OOP, por sus siglas en ingl칠s), podemos empezar pregunt치ndonos qu칠 es un objeto. Aunque no solemos pensar en ello de forma consciente, porque todos podemos distinguir un objeto de lo que no lo es, vale la pena definirlo como algo tangible, que se puede percibir, tocar y manipular. 춰Nos pasamos toda la vida interactuando con objetos!\nEn el mundo real, los objetos tienen atributos o propiedades que los describen. Por ejemplo, un televisor tiene forma, tama침o, color, peso, entre otros. Adem치s, los objetos tambi칠n pueden realizar acciones. Siguiendo con el ejemplo del televisor, puede encenderse, apagarse, cambiar de canal, modificar la fuente de entrada para ver una serie en Netflix o simplemente reproducir m칰sica.\nEn programaci칩n, la definici칩n de objeto no difiere mucho de la anterior. Aunque los objetos no sean elementos f칤sicos, representan entidades que poseen atributos y pueden ejecutar acciones.\nLa programaci칩n orientada a objetos es un paradigma que organiza el c칩digo en torno a estos objetos, que combinan datos (atributos) y comportamientos o acciones (m칠todos) dentro de una misma entidad. Este enfoque permite no solo crear e interactuar con objetos, sino tambi칠n definir nuestros propios tipos de objetos, adaptados a las necesidades del programa.",
    "crumbs": [
      "Teor칤a",
      "U3 - Programaci칩n Orientada a Objetos",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/03_oop/01_fundamentos.html#objetos-familiares",
    "href": "teoria/03_oop/01_fundamentos.html#objetos-familiares",
    "title": "1 - Fundamentos",
    "section": "Objetos familiares",
    "text": "Objetos familiares\nAs칤 como interactuamos con objetos en la vida real desde nuestros primeros d칤as, tambi칠n lo hemos estado haciendo en Python desde el comienzo. Por ejemplo, cada vez que creamos una cadena de texto, en realidad estamos creando un objeto de la clase str.\n\nx = \"Hola, soy un objeto de tipo 'str'.\"\ny = \"쯏 yo? 춰Yo tambi칠n soy un objeto de tipo 'str'!\"\nprint(f\"x = {x}\")\nprint(f\"y = {y}\")\n\nx = Hola, soy un objeto de tipo 'str'.\ny = 쯏 yo? 춰Yo tambi칠n soy un objeto de tipo 'str'!\n\n\nTanto x como y son objetos del mismo tipo: cadenas de caracteres, que en Python corresponden al tipo str. Sin embargo, x e y no son el mismo objeto, sino dos objetos distintos. Esto puede comprobarse no solo por su contenido (uno de sus atributos), sino tambi칠n comparando sus identificadores 칰nicos (ID), que son diferentes.\n\nprint(id(x))\nprint(id(y))\n\n140223504929120\n140223504962192\n\n\nA su vez, los objetos de tipo str pueden realizar ciertas acciones. Por ejemplo, si queremos convertir todas las letras de una cadena a may칰sculas, podemos hacer lo siguiente:\n\nx.upper()\n\n\"HOLA, SOY UN OBJETO DE TIPO 'STR'.\"\n\n\nLas cadenas de caracteres son uno de los muchos tipos de objetos con los que ya hemos interactuado. Todas las estructuras de datos que hemos utilizado 닧esde las m치s simples, como los enteros, flotantes y booleanos, hasta las m치s complejas, como listas, tuplas y diccionarios no son m치s que distintos tipos de objetos.\nEn Python, cada tipo de dato est치 implementado como una clase, y trabajar con estas clases no solo nos permite crear nuestros propios tipos de datos seg칰n nuestras necesidades, sino tambi칠n interactuar con los objetos que generamos a partir de ellas.",
    "crumbs": [
      "Teor칤a",
      "U3 - Programaci칩n Orientada a Objetos",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/03_oop/01_fundamentos.html#clases-y-objetos",
    "href": "teoria/03_oop/01_fundamentos.html#clases-y-objetos",
    "title": "1 - Fundamentos",
    "section": "Clases y objetos",
    "text": "Clases y objetos\nEn el contexto de la programaci칩n orientada a objetos, se utilizan clases para definir nuevas clases o tipos de objetos, especificando qu칠 atributos deben tener y qu칠 acciones pueden realizar. De forma informal, una clase puede pensarse como una plantilla que determina c칩mo se ve y se comporta un objeto.\nPor ejemplo, imaginemos un molde para hacer paletas heladas. Este molde permite producir paletas, pero no es una paleta en s칤. De hecho, se parece m치s a una f치brica de paletas.\nEl molde define aspectos estructurales como la forma y el tama침o de las paletas, pero no determina por completo c칩mo ser치n. Podemos llenarlo con diferentes l칤quidos, sabores, colores o aromas, y as칤 obtener resultados variados a partir del mismo molde.\nEn programaci칩n orientada a objetos, una clase cumple un rol similar: define la estructura y el comportamiento general de los objetos que se crear치n a partir de ella. Los objetos, en cambio, son las instancias concretas generadas a partir de esa clase, cada una con sus propias caracter칤sticas particulares, como cada paleta helada que sale del molde.\n\n\n\n\n\n\n쮺lases o tipos?\n\n\n\nEn Python, los tipos de datos est치n implementados como clases. Por eso mismo, en todos los casos debajo, se puede ver que el tipo est치 precedido por class.\nprint(type(\"texto\"))\nprint(type([1, 2, 3]))\nprint(type({\"a\": 1, \"b\": 2}))\n&lt;class 'str'&gt;\n&lt;class 'list'&gt;\n&lt;class 'dict'&gt;\nAs칤, en Python, es lo mismo hablar de clases o tipos de datos.\n\n\n\nEjemplo: la clase dict\nLos diccionarios de Python son instancias de la clase dict. Es esta clase la que define, entre otras cosas, que los diccionarios tienen claves y valores.\nEn el ejemplo debajo, tanto d1 como d2 son instancias u objetos de la clase dict (es decir, son objetos creados con el mismo molde). Sin embargo, d1 y d2 son objetos distintos, que adem치s tienen diferentes valores para sus atributos (claves y valores).\n\nd1 = {\"a\": 100, \"b\": 250}\nd2 = {\"m\": 20, \"n\": False}\n\nprint(type(d1))\nprint(type(d2))\n\n&lt;class 'dict'&gt;\n&lt;class 'dict'&gt;\n\n\n\nprint(d1 is d2)\nprint(d1 == d2)\n\nFalse\nFalse\n\n\nSi consultamos la ayuda de dict mediante help(dict), podemos ver que Python dice que esto se refiere a una clase:\nhelp(dict)\n\nHelp on class dict in module builtins:\n\n\n\n\n\n\n\n쯆bjetos o instancias?\n\n\n\nEn el contexto de programaci칩n orientada a objetos, los t칠rminos 랊bjeto e 랄nstancia suelen usarse de manera intercambiable: ambos hacen referencia a una entidad concreta creada a partir de una clase.\nEn el siguiente ejemplo, decimos que l es una instancia de la clase list:\nl = list(\"abcde\")",
    "crumbs": [
      "Teor칤a",
      "U3 - Programaci칩n Orientada a Objetos",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/03_oop/01_fundamentos.html#creando-nuestras-propias-clases",
    "href": "teoria/03_oop/01_fundamentos.html#creando-nuestras-propias-clases",
    "title": "1 - Fundamentos",
    "section": "Creando nuestras propias clases",
    "text": "Creando nuestras propias clases\nLa definici칩n de una clase, que crea un nuevo tipo de dato, define los atributos de un objeto (datos que representan estado) y las cosas que este objeto puede hacer (funciones que representan comportamiento).\nPara definir una nueva clase en Python se usa la sentencia class seguida del nombre de la clase. Veamos el siguiente ejemplo comentado l칤nea a l칤nea.\n\n1class PaletaHelada:\n2    def __init__(self):\n3        print(\"Creando nueva paleta helada\")\n\n\n1\n\nLa sentencia class indica el inicio de la definici칩n de una clase. A continuaci칩n se escribe el nombre de la clase y, al final, los dos puntos (:), que se침alan el comienzo del bloque donde se definen sus atributos y funciones (llamados m칠todos).\n\n2\n\nPor lo general, lo primero que se define dentro de una clase es su m칠todo de inicializaci칩n, siempre llamado __init__.\n\n3\n\nEsta l칤nea se ejecuta cada vez que se crea un nuevo objeto de la clase. En este caso, imprime un mensaje en pantalla como parte del proceso de inicializaci칩n.\n\n\n\n\nDefinir una clase no crea ning칰n objeto por s칤 misma; simplemente construye el molde o plantilla a partir del cual se podr치n crear objetos m치s adelante.\nPara crear un objeto a partir de una clase, es necesario 랇lamar a la clase, lo que genera una nueva instancia de esa clase.\n\npaleta1 = PaletaHelada()\n\nCreando nueva paleta helada\n\n\nLa variable paleta1 representa un objeto de la clase PaletaHelada. En otras palabras, hemos creado, al menos en c칩digo, una paleta helada.\nComo las clases son reutilizables, podemos crear tantas paletas heladas como queramos, simplemente creando nuevas instancias de la clase.\n\npaleta2 = PaletaHelada()\n\nCreando nueva paleta helada\n\n\nAl imprimir estos objetos, obtenemos una representaci칩n generada autom치ticamente por Python. En ella podemos ver que ambos son instancias de la clase PaletaHelada, aunque tambi칠n queda claro que ocupan ubicaciones distintas en memoria. Esto confirma que se trata de objetos distintos, aunque provengan de la misma clase.\n\nprint(paleta1)\nprint(paleta2)\n\n&lt;__main__.PaletaHelada object at 0x7f8854339220&gt;\n&lt;__main__.PaletaHelada object at 0x7f8854338530&gt;\n\n\n\nPar치metros de inicializaci칩n\nTambi칠n es posible pasar argumentos al momento de inicializar un objeto. Previamente, tenemos que agregar los par치metros necesarios en el m칠todo de inicializaci칩n.\n\nclass PaletaHelada:\n1    def __init__(self, gusto):\n2        print(f\"Creando nueva paleta helada de gusto {gusto}\")\n\n\n1\n\nEl m칠todo __init__ ahora recibe dos par치metros:\n\n2\n\nEl valor de gusto se utiliza para mostrar un mensaje de inicializaci칩n personalizado, indicando el sabor de la paleta.\n\n\n\n\nGracias a esto, ahora podemos crear paletas heladas con distintos sabores, como frutilla, naranja, entre otros.\n\npaleta1 = PaletaHelada(\"frutilla\")\npaleta2 = PaletaHelada(\"naranja\")\n\nCreando nueva paleta helada de gusto frutilla\nCreando nueva paleta helada de gusto naranja\n\n\nSin embargo, podemos observar que ninguna de estas dos instancias recuerda algo relacionado al gusto con el que fue inicializado.\npaleta1.gusto\n\nAttributeError: 'PaletaHelada' object has no attribute 'gusto'\n\npaleta2.gusto\n\nAttributeError: 'PaletaHelada' object has no attribute 'gusto'\n\nSi queremos que nuestros objetos puedan recordar datos, necesitamos comprender c칩mo se utilizan los atributos.\n\n\n\n\n\n\nInstanciaci칩n de un nuevo objeto\n\n\n\nLa instanciaci칩n es el proceso mediante el cual se crea un objeto a partir de una clase. La sintaxis general es la siguiente:\n&lt;objeto&gt; = &lt;NombreClase&gt;(&lt;argumentos opcionales&gt;)\nAunque al principio pueda parecer poco familiar, en realidad hemos estado instanciando objetos desde los primeros pasos que dimos en Python. Por ejemplo, al escribir list(\"hola\"), estamos creando un objeto de la clase list a partir de la cadena \"hola\". Del mismo modo, con range(10) craemos un objeto de la clase range.",
    "crumbs": [
      "Teor칤a",
      "U3 - Programaci칩n Orientada a Objetos",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/03_oop/01_fundamentos.html#atributos",
    "href": "teoria/03_oop/01_fundamentos.html#atributos",
    "title": "1 - Fundamentos",
    "section": "Atributos",
    "text": "Atributos\nLos atributos son variables asociadas a un objeto que representan su estado.\nEn Python, los atributos no requieren ninguna sintaxis especial para ser declarados. Simplemente se crean dentro de un m칠todo (generalmente en __init__) usando la notaci칩n self.&lt;atributo&gt;.\nEn nuestro ejemplo de la clase PaletaHelada, podemos hacer:\n\nclass PaletaHelada:\n    def __init__(self, gusto):\n1        self.gusto = gusto\n\n\n1\n\nEl valor de gusto que se pasa al momento de crear la instancia se asigna al atributo gusto del objeto.\n\n\n\n\nAunque la representaci칩n autom치tica del objeto no cambia, ahora el objeto tiene estado: puede recordar el gusto con el que fue inicializado.\n\npaleta1 = PaletaHelada(\"frutilla\")\npaleta1\n\n&lt;__main__.PaletaHelada at 0x7f8854339c70&gt;\n\n\n\npaleta1.gusto\n\n'frutilla'\n\n\nEn este caso, la variable gusto es una variable de instancia o atributo de instancia. Estas variables existen solo dentro del objeto que las contiene, y no afectan a otras instancias de la misma clase. As칤, distintos objetos de una misma clase pueden tener valores diferentes en sus atributos.\n\npaleta2 = PaletaHelada(\"naranja\")\nprint(paleta2.gusto)\nprint(paleta1.gusto)\n\nnaranja\nfrutilla\n\n\nLos atributos tambi칠n pueden definirse o modificarse fuera de los m칠todos de la clase.\nPor ejemplo, es posible cambiar el valor de un atributo simplemente asign치ndole un nuevo valor utilizando la instancia:\n\npaleta1.gusto = \"crema americana\"\n\n\npaleta1.gusto\n\n'crema americana'\n\n\nY tambi칠n se puede asignarle un valor a un nuevo atributo:\n\npaleta1.cobertura = \"chocolate\"\n\nprint(paleta1.gusto, paleta1.cobertura, sep=\", \")\n\ncrema americana, chocolate\n\n\nEste nuevo atributo existe 칰nicamente en la instancia a la que fue asignado (paleta1). Es decir, paleta2 no tiene un atributo llamado cobertura, ya que no fue definido durante su inicializaci칩n ni se le asign칩 m치s adelante.\npaleta2.cobertura\n\nAttributeError: 'PaletaHelada' object has no attribute 'cobertura'\n\nEn Python, los atributos de instancia son independientes entre objetos: si un atributo no se define expl칤citamente en una instancia, simplemente no existe en ella.\n\nAtributos opcionales\nAunque Python permite crear nuevos atributos fuera del proceso de inicializaci칩n de un objeto, eso no significa que sea una pr치ctica recomendable en todos los casos.\nAsignar un atributo directamente a una instancia espec칤fica puede generar inconsistencias: terminamos con objetos de la misma clase que no comparten la misma estructura de atributos. Esto puede dificultar la lectura del c칩digo y producir errores si intentamos acceder a un atributo que no existe en todas las instancias.\nUna alternativa m치s clara y segura es definir atributos opcionales dentro del m칠todo __init__, asign치ndoles un valor por defecto como None. De esta forma, todas las instancias tendr치n los mismos atributos, aunque algunos puedan no tener un valor definido inicialmente.\n\nclass PaletaHelada:\n    def __init__(self, gusto, cobertura=None):\n        self.gusto = gusto\n        self.cobertura = cobertura\n\npaleta1 = PaletaHelada(\"crema americana\", \"chocolate\")\npaleta2 = PaletaHelada(\"frutilla\")\n\n\nprint(paleta1.gusto, paleta1.cobertura, sep=\", \")\nprint(paleta2.gusto, paleta2.cobertura, sep=\", \")\n\ncrema americana, chocolate\nfrutilla, None\n\n\nCon este enfoque, ambos objetos tienen los mismos atributos (gusto y cobertura), lo que mantiene la consistencia entre instancias de la clase. En el caso de paleta2, como no se especific칩 ninguna cobertura al crear el objeto, el valor de cobertura es None, lo cual indica que esa paleta no tiene ninguna cobertura.",
    "crumbs": [
      "Teor칤a",
      "U3 - Programaci칩n Orientada a Objetos",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/03_oop/01_fundamentos.html#m칠todos",
    "href": "teoria/03_oop/01_fundamentos.html#m칠todos",
    "title": "1 - Fundamentos",
    "section": "M칠todos",
    "text": "M칠todos\nAhora que comprendemos c칩mo los datos definen el estado de un objeto, el 칰ltimo concepto que nos falta abordar son las acciones que un objeto puede realizar.\nPara llevar a cabo acciones, los objetos utilizan m칠todos.\nLos m칠todos son funciones asociadas a una clase determinada, y permiten que los objetos de la clase realicen operaciones o modifiquen su propio estado.\nPor ejemplo, el m칠todo upper es un m칠todo propio de los objetos de tipo str (cadenas de caracteres) y podemos invocarlo de la siguiente manera:\n\n\"Rosario\".upper()\n\n'ROSARIO'\n\n\nPero no podemos llamarlo sobre una lista:\n[\"Rosario\", \"Santa Fe\"].upper()\n\nAttributeError: 'list' object has no attribute 'upper'\n\nEn el caso de las clases creadas por nosotros, los m칠todos no son m치s que funciones definidas dentro de la clase.\nA diferencia de las funciones normales, todos los m칠todos deben tener al menos un par치metro especial, llamado self por convenci칩n, que representa a la instancia sobre la que se est치 llamando el m칠todo.\nGracias a self, los m칠todos pueden acceder y modificar los atributos del objeto:\n\nclass PaletaHelada:\n    def __init__(self, gusto, cobertura=None):\n        self.gusto = gusto\n        self.cobertura = cobertura\n\n    def mostrar_info(self):\n        print(\"PaletaHelada\")\n        print(f\" - Gusto: {self.gusto}\")\n        print(f\" - Cobertura: {self.cobertura}\")\n\n\npaleta = PaletaHelada(gusto=\"Dulce de leche\", cobertura=\"Chocolate amargo\")\npaleta\n\n&lt;__main__.PaletaHelada at 0x7f885433b440&gt;\n\n\nPara ejecutar el m칠todo, se lo llama de la misma forma que a cualquier otro m칠todo.\n\npaleta.mostrar_info()\n\nPaletaHelada\n - Gusto: Dulce de leche\n - Cobertura: Chocolate amargo\n\n\n\npaleta2 = PaletaHelada(gusto=\"Mentra granizada\", cobertura=\"Chocolate blanco\")\npaleta2.mostrar_info()\n\nPaletaHelada\n - Gusto: Mentra granizada\n - Cobertura: Chocolate blanco\n\n\n\nM칠todos que modifican estado\nEl m칠todo mostrar_info no altera el estado del objeto: simplemente muestra un resumen de su estado actual.\nSin embargo, como los m칠todos acceden al objeto mediante self, tambi칠n pueden modificar su estado.\nEn el siguiente ejemplo, el m칠todo quitar_cobertura elimina cualquier cobertura que pueda tener nuestro helado.\n\nclass PaletaHelada:\n    def __init__(self, gusto, cobertura=None):\n        self.gusto = gusto\n        self.cobertura = cobertura\n\n    def mostrar_info(self):\n        print(\"PaletaHelada\")\n        print(f\" - Gusto: {self.gusto}\")\n        print(f\" - Cobertura: {self.cobertura}\")\n\n    def quitar_cobertura(self):\n        self.cobertura = None\n\n\npaleta = PaletaHelada(\"Chocolate\", \"Chocolate\")\npaleta.mostrar_info()\nprint(\"\")\npaleta.quitar_cobertura()\npaleta.mostrar_info()\n\nPaletaHelada\n - Gusto: Chocolate\n - Cobertura: Chocolate\n\nPaletaHelada\n - Gusto: Chocolate\n - Cobertura: None\n\n\n\n\nM칠todos que reciben argumentos\nLos m칠todos mostrar_info y quitar_cobertura no reciben argumentos, a lo sumo usan los datos ya almacenados en el objeto.\nTambi칠n es posible definir m칠todos que acepten argumentos, lo que permite realizar distintas operaciones y, por ejemplo, modificar el estado interno del objeto.\nA continuaci칩n, incorporamos a la clase un nuevo m칠todo que permite actualizar la cobertura de la paleta helada.\n\nclass PaletaHelada:\n    def __init__(self, gusto, cobertura=None):\n        self.gusto = gusto\n        self.cobertura = cobertura\n\n    def mostrar_info(self):\n        print(\"PaletaHelada\")\n        print(f\" - Gusto: {self.gusto}\")\n        print(f\" - Cobertura: {self.cobertura}\")\n\n    def cambiar_cobertura(self, cobertura):\n        self.cobertura = cobertura\n\n\npaleta = PaletaHelada(\"Chocolate\", \"Chocolate\")\npaleta.mostrar_info()\n\nprint(\"\")\npaleta.cambiar_cobertura(\"Chocolate blanco\")\npaleta.mostrar_info()\n\nPaletaHelada\n - Gusto: Chocolate\n - Cobertura: Chocolate\n\nPaletaHelada\n - Gusto: Chocolate\n - Cobertura: Chocolate blanco\n\n\n\n\nM칠todos que devuelven resultados\nComo los m칠todos son funciones de Python, tambi칠n pueden devolver un resultado.\nPor ejemplo, el m칠todo tiene_cobertura retorna True cuando la paleta helada tiene asignada alguna cobertura, sin importar cu치l sea.\n\nclass PaletaHelada:\n    def __init__(self, gusto, cobertura=None):\n        self.gusto = gusto\n        self.cobertura = cobertura\n\n    def mostrar_info(self):\n        print(\"PaletaHelada\")\n        print(f\" - Gusto: {self.gusto}\")\n        print(f\" - Cobertura: {self.cobertura}\")\n\n    def cambiar_cobertura(self, cobertura):\n        self.cobertura = cobertura\n\n    def tiene_cobertura(self):\n        return self.cobertura is not None\n\n\npaleta = PaletaHelada(\"Dulce de leche\", \"Chocolate blanco\")\npaleta2 = PaletaHelada(\"Dulce de leche\")\n\nprint(paleta.tiene_cobertura())\nprint(paleta2.tiene_cobertura())\n\nTrue\nFalse\n\n\n\n\nM칠todos que devuelven al objeto\nFinalmente, como un m칠todo puede devolver cualquier tipo de objeto, tambi칠n puede retornar la propia instancia sobre la que fue llamado (es decir, la que recibe en self).\nEste patr칩n se utiliza con frecuencia cuando se desea permitir el encadenamiento de m칠todos, ya que cada m칠todo devuelve el mismo objeto y permite seguir llamando otros m칠todos sobre 칠l en una sola l칤nea.\n\nclass PaletaHelada:\n    def __init__(self, gusto, cobertura=None):\n        self.gusto = gusto\n        self.cobertura = cobertura\n\n    def mostrar_info(self):\n        print(\"PaletaHelada\")\n        print(f\" - Gusto: {self.gusto}\")\n        print(f\" - Cobertura: {self.cobertura}\")\n\n    def cambiar_cobertura(self, cobertura):\n        self.cobertura = cobertura\n1        return self\n\nPaletaHelada(\"Frutilla\").cambiar_cobertura(\"Chocolate\").mostrar_info()\n\n\n1\n\nLuego de actualizar la cobertura, se devuelve a la instancia con la que se llam칩 al m칠todo.\n\n\n\n\nPaletaHelada\n - Gusto: Frutilla\n - Cobertura: Chocolate\n\n\nComo el m칠todo cambiar_cobertura devuelve la propia instancia, es posible encadenar su llamada con otros m칠todos de la clase, como por ejemplo .mostrar_info.",
    "crumbs": [
      "Teor칤a",
      "U3 - Programaci칩n Orientada a Objetos",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/03_oop/01_fundamentos.html#ejemplo-final-cuenta-bancaria",
    "href": "teoria/03_oop/01_fundamentos.html#ejemplo-final-cuenta-bancaria",
    "title": "1 - Fundamentos",
    "section": "Ejemplo final: Cuenta bancaria",
    "text": "Ejemplo final: Cuenta bancaria\nPara concluir este apunte, vamos a implementar una clase que represente de forma sencilla una cuenta bancaria.\nEn este modelo simplificado, cada cuenta tendr치 tres atributos:\n\ntitular: el nombre de la persona due침a de la cuenta\nsaldo: el dinero disponible en la cuenta\nmoneda: el tipo de moneda en el que est치 expresado el saldo (por ejemplo, \"ARS\" o \"USD\")\n\nAdem치s, la clase contar치 con m칠todos que permitan realizar operaciones b치sicas:\n\ndepositar: suma dinero al saldo actual\nretirar: descuenta dinero del saldo, si hay fondos suficientes\ntransferir: mueve dinero de una cuenta a otra\nresumen: muestra el estado actual de la cuenta de forma clara y legible\n\n\nclass CuentaBancaria:\n    def __init__(self, titular, saldo=0, moneda=\"ARS\"):\n        self.titular = titular\n        self.saldo = saldo\n        self.moneda = moneda\n\n    def depositar(self, monto):\n        self.saldo = self.saldo + monto\n\n    def retirar(self, monto):\n        if monto &lt;= self.saldo:\n            self.saldo = self.saldo - monto\n            return True\n\n        print(f\"El saldo es insuficiente ({self.saldo} {self.moneda})\")\n        return False\n\n    def transferir(self, other, monto): # 'other' es tambien una 'CuentaBancaria'\n        if self.moneda != other.moneda:\n            print(f\"Las cuentas usan monedas distintas ({self.moneda} vs {other.moneda})\")\n            return False\n\n        if self.retirar(monto):\n            other.depositar(monto)\n\n        return True\n\n    def resumen(self):\n        print(\"Cuenta bancaria\")\n        print(f\" - Titular: {self.titular}\")\n        print(f\" - Saldo: {self.saldo}\")\n        print(f\" - Moneda: {self.moneda}\")\n\n\ncuenta_A = CuentaBancaria(\"Guido Van Rossum\", saldo=20000, moneda=\"ARS\")\ncuenta_B = CuentaBancaria(\"Ross Ihaka\", saldo=8000, moneda=\"ARS\")\n\ncuenta_A.resumen()\nprint(\"\")\ncuenta_B.resumen()\n\nCuenta bancaria\n - Titular: Guido Van Rossum\n - Saldo: 20000\n - Moneda: ARS\n\nCuenta bancaria\n - Titular: Ross Ihaka\n - Saldo: 8000\n - Moneda: ARS\n\n\n\ncuenta_A.retirar(2500)\n\nTrue\n\n\n\ncuenta_A.resumen()\n\nCuenta bancaria\n - Titular: Guido Van Rossum\n - Saldo: 17500\n - Moneda: ARS\n\n\nEn el caso de las transferencias, no solo se modifica el estado de la cuenta desde la que se realiza la operaci칩n (cuenta_A), sino tambi칠n el estado de la cuenta que recibe el dinero (cuenta_B).\n\ncuenta_A.transferir(cuenta_B, 10000)\n\nTrue\n\n\n\ncuenta_A.resumen()\n\nCuenta bancaria\n - Titular: Guido Van Rossum\n - Saldo: 7500\n - Moneda: ARS\n\n\n\ncuenta_B.resumen()\n\nCuenta bancaria\n - Titular: Ross Ihaka\n - Saldo: 18000\n - Moneda: ARS\n\n\n\ncuenta_B.retirar(20000)\n\nEl saldo es insuficiente (18000 ARS)\n\n\nFalse\n\n\n\n\n\n\n\n\n쯉ab칤as que ? Sobre __init__\n\n\n\n\n__init__ no lleva una sentencia return. Su prop칩sito no es devolver datos, sino inicializar el objeto.\n__init__ no crea la instancia (eso lo hace Python antes); su funci칩n es inicializar el estado del objeto reci칠n creado.\n__init__ no es obligatorio: una clase puede funcionar perfectamente sin definirlo, aunque en ese caso no se podr치n establecer valores iniciales personalizados al instanciar.\n\n\n\n\n\n\n\n\n\nSobre self\n\n\n\nNunca se debe pasar expl칤citamente un valor para self, Python lo hace autom치ticamente.",
    "crumbs": [
      "Teor칤a",
      "U3 - Programaci칩n Orientada a Objetos",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/problemas.html",
    "href": "practica/02_programacion_funcional/problemas.html",
    "title": "游빌 Problemas",
    "section": "",
    "text": "En programaci칩n, el logging es el proceso de registrar eventos durante la ejecuci칩n de un programa. Estos registros, llamados logs, permiten mantener un historial de lo que ocurri칩, incluyendo estados del sistema, acciones realizadas y posibles errores o advertencias.\nEn este problema se propone implementar un decorador llamado log que registre, en un archivo, los valores de entrada y salida de cada llamada a las funciones decoradas. El decorador debe recibir como argumento la ruta del archivo donde se guardar치n los mensajes.\nPor ejemplo, el siguiente c칩digo:\nimport time\n\n@log(\"registro.log\")\ndef f(x, y):\n    return x + y\n\n@log(\"registro.log\")\ndef g(a, b):\n    return a + b ** 2\n\nf(3, 9)\ntime.sleep(1)\nf(256, 256)\ntime.sleep(3)\ng(3, 2)\nf(7, 8)\nDeber칤a generar un archivo registro.log con un contenido similar al siguiente:\n\n\nregistro.log\n\n2025-09-02 18:04:07 - | f(x=3, y=9) -&gt; 12\n2025-09-02 18:04:08 - | f(x=256, y=256) -&gt; 512\n2025-09-02 18:04:11 - | g(a=3, b=2) -&gt; 7\n2025-09-02 18:04:11 - | f(x=7, y=8) -&gt; 15\n\n\n\n\nSi el archivo no existe, debe crearse autom치ticamente.\nSi el archivo ya existe, los nuevos registros deben agregarse al final, sin sobrescribir los anteriores.\n\n\n\n\n\nPara obtener el momento exacto de la llamada, puede usar datetime.now() del m칩dulo datetime.\nPara formatear ese valor como texto, utilice el m칠todo .strftime.\n\nPor ejemplo:\ndatetime.datetime.now().strftime(\"%Y-%m-%d%H:%M:%S\")\n2025-09-02 18:30:39",
    "crumbs": [
      "Pr치ctica",
      "U2 - Programaci칩n funcional",
      "游빌 Problemas"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/problemas.html#registro-de-llamadas",
    "href": "practica/02_programacion_funcional/problemas.html#registro-de-llamadas",
    "title": "游빌 Problemas",
    "section": "",
    "text": "En programaci칩n, el logging es el proceso de registrar eventos durante la ejecuci칩n de un programa. Estos registros, llamados logs, permiten mantener un historial de lo que ocurri칩, incluyendo estados del sistema, acciones realizadas y posibles errores o advertencias.\nEn este problema se propone implementar un decorador llamado log que registre, en un archivo, los valores de entrada y salida de cada llamada a las funciones decoradas. El decorador debe recibir como argumento la ruta del archivo donde se guardar치n los mensajes.\nPor ejemplo, el siguiente c칩digo:\nimport time\n\n@log(\"registro.log\")\ndef f(x, y):\n    return x + y\n\n@log(\"registro.log\")\ndef g(a, b):\n    return a + b ** 2\n\nf(3, 9)\ntime.sleep(1)\nf(256, 256)\ntime.sleep(3)\ng(3, 2)\nf(7, 8)\nDeber칤a generar un archivo registro.log con un contenido similar al siguiente:\n\n\nregistro.log\n\n2025-09-02 18:04:07 - | f(x=3, y=9) -&gt; 12\n2025-09-02 18:04:08 - | f(x=256, y=256) -&gt; 512\n2025-09-02 18:04:11 - | g(a=3, b=2) -&gt; 7\n2025-09-02 18:04:11 - | f(x=7, y=8) -&gt; 15\n\n\n\n\nSi el archivo no existe, debe crearse autom치ticamente.\nSi el archivo ya existe, los nuevos registros deben agregarse al final, sin sobrescribir los anteriores.\n\n\n\n\n\nPara obtener el momento exacto de la llamada, puede usar datetime.now() del m칩dulo datetime.\nPara formatear ese valor como texto, utilice el m칠todo .strftime.\n\nPor ejemplo:\ndatetime.datetime.now().strftime(\"%Y-%m-%d%H:%M:%S\")\n2025-09-02 18:30:39",
    "crumbs": [
      "Pr치ctica",
      "U2 - Programaci칩n funcional",
      "游빌 Problemas"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/problemas.html#fibonacci-el-memorioso",
    "href": "practica/02_programacion_funcional/problemas.html#fibonacci-el-memorioso",
    "title": "游빌 Problemas",
    "section": "2 Fibonacci el memorioso",
    "text": "2 Fibonacci el memorioso\nLa implementaci칩n recursiva m치s directa de la secuencia de Fibonacci es tan concisa como ineficiente.\ndef fibonacci(n):\n    if n &lt;= 1:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)\nAl invocar fibonacci(7), se realizan llamadas a fibonacci(6) y fibonacci(5). Luego, fibonacci(6) vuelve a llamar a fibonacci(5) y fibonacci(4), y as칤 sucesivamente. Muchas de estas llamadas se repiten: por ejemplo, fibonacci(5) se calcula m치s de una vez.\nEste comportamiento muestra que los subproblemas se superponen: los mismos valores se recalculan de manera redundante.\nEl objetivo de este ejercicio es dise침ar una funci칩n capaz de recordar resultados ya obtenidos, evitando recomputarlos cada vez que aparecen. Para lograrlo, podemos construir una funci칩n recursiva que memorice sus valores anteriores y, as칤, avance en la secuencia sin rehacer todos los c치lculos previos.\n\nAyuda\nConsidere una function factory que devuelva la funci칩n recursiva. Dentro del 치mbito de la function factory puede existir una estructura de datos mutable que almacene los resultados ya calculados.",
    "crumbs": [
      "Pr치ctica",
      "U2 - Programaci칩n funcional",
      "游빌 Problemas"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html",
    "href": "practica/02_programacion_funcional/ejercicios.html",
    "title": "游멆잺 Ejercicios",
    "section": "",
    "text": "Debajo se muestra un listado de funciones impuras. Analice por qu칠 son impuras e implemente alternativas puras (manteniendo su l칩gica):\nFunci칩n 1\ncontador = 0\ndef incrementar():\n1    global contador\n    contador += 1\n    return contador\n\n1\n\nLa palabra global es una keyword que indica que se pretende usar y modificar una variable definida fuera del 치mbito de ejecuci칩n de la funci칩n.\n\n\nFunci칩n 2\ndef obtener_hora_actual():\n    import datetime\n    return datetime.datetime.now().hour\nFunci칩n 3\ndef add_time(time, hours, minutes, seconds):\n1    increment_time(time, hours, minutes, seconds)\n    return time\n\n1\n\nAsuma que esta funci칩n incrementa a time, que es un objeto datetime, en hours horas, minutes minutos y seconds segundos.\n\n\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nRepresente fechas y horas con el objeto objeto datetime del m칩dulo est치ndar datetime. Adem치s, considere el objeto timedelta del mismo m칩dulo para luego calcular diferencias. Por ejemplo:\nimport datetime\n\nahora = datetime.datetime.now() # Devuelve un objeto con la fecha y la hora actual\nprint(ahora)\n\nuna_hora_mas_tarde = datetime.timedelta(hours=1, minutes=0, seconds=0)\nprint(ahora + una_hora_mas_tarde)\n2025-08-31 09:48:58.327461\n2025-08-31 10:48:58.327461\n\n\n\nFunci칩n 4\nhistorial_de_nombres = []\ndef registrar_nombre(nombre):\n    historial_de_nombres.append(nombre)\n    return f\"'{nombre}' ha sido registrado en el historial.\"\nFunci칩n 5\nLIMITE_MAXIMO = 100\ndef verificar_limite(valor):\n    if valor &gt; LIMITE_MAXIMO:\n        return \"Excede el l칤mite\"\n    return \"Dentro del l칤mite\"",
    "crumbs": [
      "Pr치ctica",
      "U2 - Programaci칩n funcional",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#trasfromando-funciones",
    "href": "practica/02_programacion_funcional/ejercicios.html#trasfromando-funciones",
    "title": "游멆잺 Ejercicios",
    "section": "",
    "text": "Debajo se muestra un listado de funciones impuras. Analice por qu칠 son impuras e implemente alternativas puras (manteniendo su l칩gica):\nFunci칩n 1\ncontador = 0\ndef incrementar():\n1    global contador\n    contador += 1\n    return contador\n\n1\n\nLa palabra global es una keyword que indica que se pretende usar y modificar una variable definida fuera del 치mbito de ejecuci칩n de la funci칩n.\n\n\nFunci칩n 2\ndef obtener_hora_actual():\n    import datetime\n    return datetime.datetime.now().hour\nFunci칩n 3\ndef add_time(time, hours, minutes, seconds):\n1    increment_time(time, hours, minutes, seconds)\n    return time\n\n1\n\nAsuma que esta funci칩n incrementa a time, que es un objeto datetime, en hours horas, minutes minutos y seconds segundos.\n\n\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nRepresente fechas y horas con el objeto objeto datetime del m칩dulo est치ndar datetime. Adem치s, considere el objeto timedelta del mismo m칩dulo para luego calcular diferencias. Por ejemplo:\nimport datetime\n\nahora = datetime.datetime.now() # Devuelve un objeto con la fecha y la hora actual\nprint(ahora)\n\nuna_hora_mas_tarde = datetime.timedelta(hours=1, minutes=0, seconds=0)\nprint(ahora + una_hora_mas_tarde)\n2025-08-31 09:48:58.327461\n2025-08-31 10:48:58.327461\n\n\n\nFunci칩n 4\nhistorial_de_nombres = []\ndef registrar_nombre(nombre):\n    historial_de_nombres.append(nombre)\n    return f\"'{nombre}' ha sido registrado en el historial.\"\nFunci칩n 5\nLIMITE_MAXIMO = 100\ndef verificar_limite(valor):\n    if valor &gt; LIMITE_MAXIMO:\n        return \"Excede el l칤mite\"\n    return \"Dentro del l칤mite\"",
    "crumbs": [
      "Pr치ctica",
      "U2 - Programaci칩n funcional",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#f치brica-de-promociones",
    "href": "practica/02_programacion_funcional/ejercicios.html#f치brica-de-promociones",
    "title": "游멆잺 Ejercicios",
    "section": "2 F치brica de promociones",
    "text": "2 F치brica de promociones\nConsidere el ejercicio Promociones de la Pr치ctica 1. Utilizando el mismo sistema de descuentos cree la funci칩n crear_promocion que reciba como argumento el medio de pago y devuelva una funci칩n que al aplicarse sobre un n칰mero aplique el descuento (o recargo) que le corresponde a ese medio de pago. Por ejemplo:\npromo_debito = crear_promocion(\"d칠bito\")\nprint(promo_debito(1000))\nprint(promo_debito(2700))\n900\n2430.0\nLuego, cree la funci칩n crear_promocion_personalizada que recibe el medio de pago y, de manera opcional, el porcentaje de descuento a aplicar. Como resultado devuelve una funci칩n que al aplicarse sobre un n칰mero impacta el descuento o recargo correspondiente. Adem치s, considere que:\n\nSi no se pasa el porcentaje a aplicar, se deben usar los descuentos y recargos detallados en el enunciado del ejercicio en la Pr치ctica 1.\nCaso contrario, la funci칩n devuelta debe aplicar ese porcentaje personalizado (e.g., crear_promocion_personalizada(\"d칠bito\", 15) para 15% de descuento).\n\nEjemplo de uso:\npromo_debito = crear_promocion_personalizada(\"d칠bito\", 15)\npromo_debito(1000)\n850",
    "crumbs": [
      "Pr치ctica",
      "U2 - Programaci칩n funcional",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#bendita-media",
    "href": "practica/02_programacion_funcional/ejercicios.html#bendita-media",
    "title": "游멆잺 Ejercicios",
    "section": "3 Bendita media",
    "text": "3 Bendita media\nEn Python no existe una funci칩n built-in que calcule la media de una secuencia de n칰meros. El objetivo de este ejercicio es implementar una funci칩n mean que funcione tanto cuando se le pasa un iterable, como cuando se le pasa una cantidad arbitraria de n칰meros.\nEl argumento es un iterable:\nmean([6.27, 8.11, 7.6, 5.2, 4.8])\nSe pasan una cantidad arbitraria de valores num칠ricos:\nmean(7.3, 8.2, 11.0, 12.5)",
    "crumbs": [
      "Pr치ctica",
      "U2 - Programaci칩n funcional",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#sucesi칩n-de-fibonacci",
    "href": "practica/02_programacion_funcional/ejercicios.html#sucesi칩n-de-fibonacci",
    "title": "游멆잺 Ejercicios",
    "section": "4 Sucesi칩n de Fibonacci",
    "text": "4 Sucesi칩n de Fibonacci\nConsidere la sucesi칩n que comienza por los n칰meros 0 y 1. Los siguientes n칰meros se forman sumando los dos anteriores.\n\\[\n\\{\\;0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, \\cdots\\;\\}\n\\]\nEsta sucesi칩n se conoce como sucesi칩n de Fibonacci.\nImplemente una funci칩n recursiva que tome un n칰mero natural n como entrada y devuelva el n-칠simo n칰mero en la sucesi칩n.",
    "crumbs": [
      "Pr치ctica",
      "U2 - Programaci칩n funcional",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#pal칤ndromos-recursivos",
    "href": "practica/02_programacion_funcional/ejercicios.html#pal칤ndromos-recursivos",
    "title": "游멆잺 Ejercicios",
    "section": "5 Pal칤ndromos recursivos",
    "text": "5 Pal칤ndromos recursivos\nUn pal칤ndromo es una palabra, frase, n칰mero o secuencia que se lee igual de izquierda a derecha que de derecha a izquierda. En Argentina, a un n칰mero de este tipo le decimos le decimos capic칰a.\nPara comprobar en Python si una cadena es pal칤ndroma, puede compararse con su versi칩n invertida, que se construye mediante un slice con paso -1:\nc = \"anilina\"\nc == c[::-1]\nTrue\nTambi칠n podr칤aimos determinar si una cadena es un pal칤ndromo de manera recursiva comparando el primer y el 칰ltimo car치cter:\n\nSi la cadena tiene longitud 0 o 1, se devuelve True.\nSi el primer y el 칰ltimo car치cter son iguales, se llama recursivamente a la funci칩n pas치ndole la cadena excluyendo al primer y 칰ltimo caracter ya comparados. Si son distintos, se devuelve False.\n\nEn otras palabras, la funci칩n recursiva devolver치 True cuando todas las comparaciones por pares resulten verdaderas y se alcance el caso base: queda un 칰nico car치cter (longitud impar) o ninguno (longitud par).\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara seleccionar todos los caracteres de una cadena, exceptuando al primero y el 칰ltimo, se puede usar\n\"radar\"[1:-1]\n\"ada\"\n\n\n\n\nPunto extra\nAdapte la funci칩n para que no considere espacios ni distinga may칰sculas de min칰sculas. De este modo, deber칤a detectar que la siguiente frase es pal칤ndroma.\npalindromo(\"Anita lava la tina\") # True",
    "crumbs": [
      "Pr치ctica",
      "U2 - Programaci칩n funcional",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#치rea-de-aprendizaje",
    "href": "practica/02_programacion_funcional/ejercicios.html#치rea-de-aprendizaje",
    "title": "游멆잺 Ejercicios",
    "section": "6 츼rea de aprendizaje",
    "text": "6 츼rea de aprendizaje\nSe cuenta con una lista de tuplas de longitud 2, representando el ancho y alto de distintos rect치ngulos.\nrectangulos = [\n    (5, 8),\n    (2, 2),\n    (9, 2),\n    (3, 3),\n    (3, 7),\n    (6, 3)\n]\nCree una nueva lista que ordene dichos rect치ngulos en funci칩n de su 치rea utilizando la funci칩n sorted.",
    "crumbs": [
      "Pr치ctica",
      "U2 - Programaci칩n funcional",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#socios-ordenados",
    "href": "practica/02_programacion_funcional/ejercicios.html#socios-ordenados",
    "title": "游멆잺 Ejercicios",
    "section": "7 Socios ordenados",
    "text": "7 Socios ordenados\nSe cuenta con la siguiente lista de diccionarios, la cual contiene datos personales sobre miembros de un club de atletismo:\ndatos_socios = [\n    {\"nombre\": \"Bautista Carrara\", \"edad\": 22, \"altura_cm\": 178, \"record_100m\": 13.4},\n    {\"nombre\": \"Valentina Lucci\",  \"edad\": 23, \"altura_cm\": 163, \"record_100m\": 14.2},\n    {\"nombre\": \"Ger칩nimo Cuesta\",  \"edad\": 26, \"altura_cm\": 170, \"record_100m\": 14.0},\n    {\"nombre\": \"Lucio Borga\",      \"edad\": 28, \"altura_cm\": 186, \"record_100m\": 13.8},\n    {\"nombre\": \"Julia Spoglia\",    \"edad\": 21, \"altura_cm\": 163, \"record_100m\": 11.9},\n    {\"nombre\": \"Soledad Colombo\",  \"edad\": 22, \"altura_cm\": 170, \"record_100m\": 13.5}\n]\nOrdene la lista en base a los r칠cords en la carrera de 100 metros, en forma ascendente.\n\nPunto extra\nImplemente una funci칩n que tome como argumento una clave de diccionario y devuelva una lista ordenada por los valores de dicha clave. Si el argumento toma el valor \"nombre\", ordene los elementos alfab칠ticamente en base a los apellidos.",
    "crumbs": [
      "Pr치ctica",
      "U2 - Programaci칩n funcional",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#listado-de-rimas",
    "href": "practica/02_programacion_funcional/ejercicios.html#listado-de-rimas",
    "title": "游멆잺 Ejercicios",
    "section": "8 Listado de rimas",
    "text": "8 Listado de rimas\nSe tiene la siguiente lista de palabras, la cual se quiere utilizar para formar rimas:\npalabras_a_rimar = [\n    \"actividad\",\n    \"bendici칩n\",\n    \"cartelera\",\n    \"ciudad\",\n    \"escalera\",\n    \"estaci칩n\",\n    \"felicidad\",\n    \"funci칩n\",\n    \"reposera\"\n]\nOrdene la lista en base al orden alfab칠tico del reverso de cada palabra, de modo que las palabras que riman se encuentren juntas.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nSi la lista fuese [\"durazno\", \"kiwi\"], el resultado ser칤a [\"kiwi\", \"durazno\"], porque \"iwik\" precede a \"onzarud\" en orden alfab칠tico.",
    "crumbs": [
      "Pr치ctica",
      "U2 - Programaci칩n funcional",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#analistas-de-temperaturas",
    "href": "practica/02_programacion_funcional/ejercicios.html#analistas-de-temperaturas",
    "title": "游멆잺 Ejercicios",
    "section": "9 Analistas de temperaturas",
    "text": "9 Analistas de temperaturas\nConsidere una lista de temperaturas en grados Celsius sobre la cual se deben aplicar distintas operaciones.\ntemperaturas_celsius = [\n    25.5, 28.0, 19.3, 31.5, 22.8, 17.0, 30.2, 35.6, 14.2,\n    32.4, 22.7, 10.1, 29.5, 33.9, 22.1, 38.9, 18.4, 16.3\n]\n\nEnfoque funcional\n\nConvierta las temperaturas a grados Fahrenheit utilizando map y almacene el resultado en una lista llamada temperaturas_f. Use la f칩rmula de conversi칩n: \\[\nF = C \\times \\frac{9}{5} + 32\n\\]\nUtilice filter para seleccionar de la lista anterior las temperaturas que sean mayores a 80춿F. Guarde el resultado en una nueva lista. 쯉e le ocurre una alternativa que no utilice la lista creada en el primer punto?\n\n\n\nEnfoque idiom치tico\n\nUtilice una list comprehension para obtener una lista de temperaturas en grados Fahrenheit solo cuando para temperaturas mayores a 22 춿C.",
    "crumbs": [
      "Pr치ctica",
      "U2 - Programaci칩n funcional",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#el-tiempo-vuela",
    "href": "practica/02_programacion_funcional/ejercicios.html#el-tiempo-vuela",
    "title": "游멆잺 Ejercicios",
    "section": "10 El tiempo vuela",
    "text": "10 El tiempo vuela\nSe quiere medir el tiempo que tarda la computadora en ejecutar distintos bloques de c칩digo. Para eso, implemente una funci칩n crear_cronometro que fabrique una funci칩n cronometro, la cual devuelve el tiempo transcurrido entre su creaci칩n y la llamada a la funci칩n. Luego, utilice dos cron칩metros en paralelo para evaluar el siguiente c칩digo:\ncronometro1 = crear_cronometro()\n\nfor i in range(10**4):\n    i ** 2 # Calcula el cuadrado de un n칰mero pero no lo devuelve\n\nprint(f\"El bloque entero tard칩 {cronometro1()} segundos en ejecutarse.\")\n\ncronometro2 = crear_cronometro()\n\nfor j in range(10**6):\n    j // 2 # Calcula la divisi칩n entera por 2 pero no la devuelve\n\nprint(f\"El segundo bucle tard칩 {cronometro2()} segundos en ejecutarse.\")\n\nPunto extra\nModifique el funcionamiento del cron칩metro para que en cada llamada devuelva el tiempo transcurrido entre la llamada actual y la inmediata anterior (excepto en la primera llamada, que devuelve el tiempo transcurrido desde su creaci칩n).\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara medir el paso del tiempo en Python podemos usar la funci칩n time del m칩dulo hom칩nimo.\nfrom time import time, sleep\n\ninicio = time()\nsleep(2) # Detiene la ejecuci칩n por 2 segundos\nprint(time() - inicio) # ~ 2 (segundos)",
    "crumbs": [
      "Pr치ctica",
      "U2 - Programaci칩n funcional",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#no-perdamos-el-centro",
    "href": "practica/02_programacion_funcional/ejercicios.html#no-perdamos-el-centro",
    "title": "游멆잺 Ejercicios",
    "section": "11 No perdamos el centro",
    "text": "11 No perdamos el centro\nSuponga el siguiente listado de n칰meros, que contiene algunos None:\nnumeros = [\n    2.05, 1.09, None, 2.31, 2.28, 0.97, 2.59, 2.72, 0.76, None, 1.88, 2.04, 3.25, 1.88, None\n]\nCalcule la media de los numeros, sin considerar los nulos. Luego, utilizando una list comprehension, obtenga una nueva lista de los valores centrados, conservando los None en las posiciones originales.",
    "crumbs": [
      "Pr치ctica",
      "U2 - Programaci칩n funcional",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#en-python-es-mejor",
    "href": "practica/02_programacion_funcional/ejercicios.html#en-python-es-mejor",
    "title": "游멆잺 Ejercicios",
    "section": "12 En Python es mejor",
    "text": "12 En Python es mejor\nConsidere el siguiente programa, que selecciona valores at칤picos de un listado:\nnumeros = [\n    4.74346239e-01, -2.90877176e-01, -1.44377789e+00, -4.48680759e+01,\n    -1.21249801e+00, -3.32729317e-01,  2.21676912e-01,  1.05599711e+00,\n    -3.62372053e+00, -2.96441579e-01, -4.28304222e+00,  1.55908820e+02,\n    9.00858234e-01, -1.09384173e+00, -1.51083571e+00, -5.38491167e-01,\n    -3.84153084e-02,  1.20393395e+00,  1.82651406e-01,  2.05179405e+00\n]\n\ndef media(x):\n    return sum(x) / len(x)\n\ndef varianza(x):\n    numerador = 0\n    x_media = media(x)\n    for x_i in x:\n        numerador += (x_i - x_media) ** 2\n    return numerador / len(x)\n\nx_media = media(numeros)\nx_desvio = varianza(numeros) ** 0.5\n\nmap_obj = map(lambda x: (x - x_media) / x_desvio, numeros)\nlist(filter(lambda x: abs(x) &gt; 3, map_obj))\nImplemente un programa equivalente haciendo uso de una list comprehension, en vez de map y filter.",
    "crumbs": [
      "Pr치ctica",
      "U2 - Programaci칩n funcional",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#subiendo-de-rango",
    "href": "practica/02_programacion_funcional/ejercicios.html#subiendo-de-rango",
    "title": "游멆잺 Ejercicios",
    "section": "13 Subiendo de rango",
    "text": "13 Subiendo de rango\nLa funci칩n range(start, stop, step) de Python devuelve un objeto que genera una secuencia de n칰meros desde start (inclusive) hasta stop (exclusive) en incrementos de step unidades. El argumento step, sin embargo, s칩lo puede ser un n칰mero entero (excepto cero). Implemente una funci칩n llamada frange que acepte los mismos argumentos, pudiendo step ser de tipo float. La funci칩n debe retornar un generador de la secuencia correspondiente.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nUtilice el siguiente ejemplo a modo de control:\nfor i in frange(3, 4, 0.2):\n    print(f\"{i:.2f}\")\n3.00\n3.20\n3.40\n3.60\n3.80\nTenga en cuenta que la precisi칩n finita de las computadoras puede afectar el comportamiento de su generador.",
    "crumbs": [
      "Pr치ctica",
      "U2 - Programaci칩n funcional",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#la-cajita-musical",
    "href": "practica/02_programacion_funcional/ejercicios.html#la-cajita-musical",
    "title": "游멆잺 Ejercicios",
    "section": "14 La cajita musical",
    "text": "14 La cajita musical\nTenemos una caja musical que recita los siguientes versos:\nversos = [\n    \"Tengo que confesar que a veces no me gusta tu forma de ser\",\n    \"Luego te me desapareces y no entiendo muy bien por qu칠\",\n\n    \"No dices nada rom치ntico cuando llega el atardecer\",\n    \"Te pones de un humor extra침o con cada luna llena al mes\",\n\n    \"Pero a todo lo dem치s le gana lo bueno que me das\",\n    \"S칩lo tenerte cerca, siento que vuelvo a empezar\"\n]\nImplemente una funci칩n para darle cuerda a la caja musical. En cada llamada debe devolver un verso distinto, hasta agotarlos todos.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nMediante el uso de yield se puede lograr que una funci칩n se detenga en un punto intermedio y retome desde ese punto en la siguiente llamada.\ndef mostrar_fase():\n    print(\"Inicio\")\n    yield\n    print(\"Medio\")\n    yield\n    print(\"Desenlace\")\n    yield",
    "crumbs": [
      "Pr치ctica",
      "U2 - Programaci칩n funcional",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#el-mejor-precio",
    "href": "practica/02_programacion_funcional/ejercicios.html#el-mejor-precio",
    "title": "游멆잺 Ejercicios",
    "section": "15 El mejor precio",
    "text": "15 El mejor precio\nUn supermercado ofrece m칰ltiples promociones:\n\n15% de descuento los d칤as lunes y mi칠rcoles.\n10% de descuento en compras con monto superior a $50.000.\n20% de descuento a clientes mayores de 65 a침os.\n\nPara determinar la promoci칩n a aplicar, el supermercado utiliza un programa con la siguiente estructura:\ndef promo_dia_semana(compra):\n    \"\"\"Aplica un 15% de descuento si la compra se realiza un lunes o mi칠rcoles.\"\"\"\n    return None # hay que implementar esta funci칩n\n\ndef promo_monto_grande(compra):\n    \"\"\"Aplica un 10% de descuento si la compra tiene un monto superior a $50.000.\"\"\"\n    return None # hay que implementar esta funci칩n\n\ndef promo_edad(compra):\n    \"\"\"Aplica un 20% de descuento si el cliente tiene 65 a침os o m치s.\"\"\"\n    return None # hay que implementar esta funci칩n\n\npromos = [promo_dia_semana, promo_monto_grande, promo_edad]\n\ndef mejor_promo(compra):\n    \"\"\"Construye diccionario con el monto luego de aplicar la mejor promoci칩n.\n\n    Esta funci칩n devuelve un diccionario con el monto original, el monto final, y el descuento\n    aplicado.\n    \"\"\"\n    # Obtener el multiplicador del mayor descuento\n    multiplicador = sorted([promo(compra) for promo in promos])[0]\n\n    return {\n        \"monto_original\": compra[\"monto\"],\n        \"monto_final\": compra[\"monto\"] * multiplicador,\n        \"descuento\": f\"{round((1 - multiplicador) * 100)}%\"\n    }\n\nejemplo_compra = {\"dia\": \"mi칠rcoles\", \"edad_cliente\": 42, \"monto\": 66420}\nmejor_promo(ejemplo_compra)\n# {'monto_original': 66420, 'monto_final': 56457.0, 'descuento': '15%'}\nEl problema con esta implementaci칩n es que, cada vez que se a침ade o elimina una promoci칩n, el cambio debe llevarse a cabo tanto en la funci칩n de la promoci칩n como en la lista de promociones. Para evitar el trabajo duplicado, implemente los siguientes cambios:\n\nDefina primero la lista promos, la cual comienza estando vac칤a.\nDefina un decorador promo que a침ade una funci칩n a la lista promos antes de ejecutarla.\nImplemente las tres funciones de promoci칩n y dec칩relas con el decorador del paso anterior.",
    "crumbs": [
      "Pr치ctica",
      "U2 - Programaci칩n funcional",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#bromas-pesadas",
    "href": "practica/02_programacion_funcional/ejercicios.html#bromas-pesadas",
    "title": "游멆잺 Ejercicios",
    "section": "16 Bromas pesadas 游땸",
    "text": "16 Bromas pesadas 游땸\nNuestro amigo programador est치 armando una p치gina web, con una funci칩n que saluda a los nuevos usuarios por su nombre cuando se registran. Nosotros queremos gastarle una broma a nuestro amigo, metiendo en su c칩digo un decorador que haga que su funci칩n corra normalmente excepto cada n-칠sima corrida, fallando silenciosamente (no imprime nada). El valor n es un n칰mero entero de nuestra elecci칩n.\n@romper_cada(3)\ndef saludar(nombre):\n  print(f\"춰Hola, {nombre}!\")\n\nsaludar(\"Carlos\")     # \"춰Hola, Carlos!\"\nsaludar(\"Mar칤a Luz\")  # \"춰Hola, Mar칤a Luz!\"\nsaludar(\"Mirna\")      # Nada (la funci칩n devuelve None)\nsaludar(\"Diego\")      # \"춰Hola, Diego!\"\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara crear un decorador que reciba argumentos, podemos crear una f치brica de decoradores:\ndef mi_decorador(n):\n    def decorar(funcion):\n        print(f\"Ejecutando decorador con argumento {n}\")\n        return funcion\n    return decorar\n\n@mi_decorador(7)\ndef imprimir(mensaje):\n    print(mensaje)\n\nimprimir(\"Hola mundo\")\n# &gt; Ejecutando decorador con argumento 7\n# &gt; Hola mundo",
    "crumbs": [
      "Pr치ctica",
      "U2 - Programaci칩n funcional",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#pipelines-de-procesamiento",
    "href": "practica/02_programacion_funcional/ejercicios.html#pipelines-de-procesamiento",
    "title": "游멆잺 Ejercicios",
    "section": "17 Pipelines de procesamiento 游땸",
    "text": "17 Pipelines de procesamiento 游땸\nEste ejercicio tiene como objetivo implementar un sistema de preprocesamiento para una lista de diccionarios, donde cada diccionario representa una fila con sus columnas como pares clave늤alor. Un conjunto de datos de ejemplo es el siguiente:\ndatos = [\n    {\"edad\": 20, \"ingresos\": 2000},\n    {\"edad\": 30, \"ingresos\": 3000},\n    {\"edad\": None, \"ingresos\": 2500},\n    {\"edad\": 40, \"ingresos\": None},\n    {\"edad\": 25, \"ingresos\": 4000},\n]\nEl primer paso consiste en definir tres funciones:\n\neliminar_nulos: elimina las filas con al menos un valor None.\ncalcular_log: que calcula el logaritmo en base 10 para los valores de la variable indicada.\nfiltrar: recibe el listado, el nombre de una columna y una funci칩n booleana que se aplica para determinar que registros se conservan.\n\nQue deben funcionar como se muestra en los ejemplos:\neliminar_nulos(datos)\n[\n    {\"edad\": 20, \"ingresos\": 2000},\n    {\"edad\": 30, \"ingresos\": 3000},\n    {\"edad\": 25, \"ingresos\": 4000},\n]\ncalcular_log(datos, \"ingresos\")\n[\n    {\"edad\": 20, \"ingresos\": 3.301},\n    {\"edad\": 30, \"ingresos\": 3.477},\n    {\"edad\": None, \"ingresos\": 3.397},\n    {\"edad\": 40, \"ingresos\": None},\n    {\"edad\": 25, \"ingresos\": 3.602},\n]\nfiltrar(datos, \"edad\", lambda e: e &gt; 25)\n[\n    {\"edad\": 30, \"ingresos\": 3000},\n    {\"edad\": 40, \"ingresos\": None},\n]\nEn el segundo paso, se debe implementar una funci칩n crear_pipeline, que recibe una cantidad arbitraria de funciones de procesamiento, junto a sus argumentos, y debe devolver una funci칩n que, al pasarle un listado de datos, los aplica de manera secuencial y devuelve un conjunto de datos procesado. Por ejemplo:\npipeline = crear_pipeline(\n    {\"fun\": eliminar_nulos, \"kwargs\": {}},\n    {\"fun\": calcular_log, \"kwargs\": {\"var_name\": \"ingresos\"}},\n    {\"fun\": filtrar, \"kwargs\": {\"var_name\": edad, \"key\": lambda e: e &gt; 25}}\n)\npipeline(datos)\n[{\"edad\": 30, \"ingresos\": 3.477}]",
    "crumbs": [
      "Pr치ctica",
      "U2 - Programaci칩n funcional",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#espacio-o-tiempo",
    "href": "practica/02_programacion_funcional/ejercicios.html#espacio-o-tiempo",
    "title": "游멆잺 Ejercicios",
    "section": "18 쮼spacio o tiempo? 낍",
    "text": "18 쮼spacio o tiempo? 낍\nSuponga que trabaja en el equipo de an치lisis de datos de un e-commerce y suponga que recibe un listado ventas del 칰ltimo mes. Deber치 extraer informaci칩n clave de esos datos utilizando dos maneras distintas de resolver cada tarea.\n1. Preparaci칩n de los datos\nPara empezar, use la siguiente funci칩n que genera datos de ejemplo de ventas de distinto tama침o:\nimport random\n\nCATEGORIAS = (\"electr칩nica\", \"hogar\", \"accesorios\", \"deportes\")\n\ndef generar_ventas(n=100_000, seed=None):\n    \"\"\"Generar datos de ventas.\n\n    Parameters\n    ----------\n    n : int\n        Cantidad de ventas a simular.\n    seed : int, optional\n        Semilla para el generador de n칰meros aleatorios. Por defecto, `None`.\n\n    Returns\n    -------\n    list[dict]\n        Listado de ventas.\n        Cada venta es un diccionario con claves `\"id\"`, `\"precio\"` y `\"categoria\"`.\n    \"\"\"\n    rng = random.Random(seed)\n    ventas = []\n    for i in range(1, n + 1):\n        ventas.append(\n            {\n                \"id\": f\"P{i+1:06d}\",\n                \"precio\": round(rng.uniform(5.0, 500.0), 2),\n                \"categoria\": CATEGORIAS[i % len(CATEGORIAS)],\n            }\n        )\n    return ventas\nGenere un conjunto de datos con 100,000 ventas:\nventas = generar_ventas(n=100_000, seed=1234)\n2. Implementaci칩n de operaciones\nRealice dos operaciones sobre este conjunto de datos, cada una en dos variantes.\n\nCalcular precios con IVA (21%):\n\nVersi칩n A. Use una list comprehension para crear una nueva lista llamada precios_con_iva_1 que contenga todos los precios con el 21 % de IVA ya calculado.\nVersi칩n B. Use una expresi칩n generadora para crear un objeto precios_con_iva_2 que represente la operaci칩n, pero sin calcular ni almacenar los resultados todav칤a.\n\nFiltrar ventas de 란lectr칩nica:\n\nVersi칩n A. Use una list comprehension para crear una nueva lista llamada electronica_1 que contenga todas las ventas de la categor칤a 란lectr칩nica.\nVersi칩n B. Use una expresi칩n generadora para crear un objeto electronica_2 que represente el filtro, sin materializar la lista.\n\n\n3. An치lisis y comparaci칩n\n\nCalcule el total de las ventas de electr칩nica usando sum() en ambas variantes (electronica_1 y electronica_2).\nPara cada operaci칩n, antes y despu칠s de aplicar sum(), mida el tiempo de ejecuci칩n y el uso de memoria del objeto. Para el tiempo, podr칤a usar time.time() del m칩dulo time; para la memoria, sys.getsizeof() del m칩dulo sys. Registre los resultados (si no observa diferencias claras, duplique n al generar el dataset).\n\n4. Reutilizaci칩n del objeto\n\nIntente calcular el total de ventas de electr칩nica una segunda vez para ambos objetos (electronica_1 y electronica_2).\nObserve qu칠 sucede en cada caso. 쯈u칠 objeto puede volver a usarse y cu치l no?\n\n5. Preguntas para reflexi칩n\n\n쯈u칠 diferencias fundamentales encontr칩 entre las dos maneras de procesar los datos? Considere cu치ndo se realiza la operaci칩n, el uso de memoria y el tiempo de ejecuci칩n.\n쯈u칠 ocurri칩 cuando intent칩 recorrer o usar el mismo resultado dos veces?\n쯉e comportaron de la misma manera la lista generada y el objeto generador? 쯇or qu칠 cree que sucede esto?\n쮼n qu칠 situaciones elegir칤a un enfoque u otro? D칠 un ejemplo de un escenario donde la ejecuci칩n A sea mejor y otro donde la B resulte m치s eficiente.",
    "crumbs": [
      "Pr치ctica",
      "U2 - Programaci칩n funcional",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html",
    "href": "practica/01_programacion_en_python/autoevaluacion.html",
    "title": "游 Autoevaluaci칩n",
    "section": "",
    "text": "쯈u칠 valor contiene la variable contador luego de ejecutar el siguiente c칩digo?\ncontador = 20\ncontador + 1\nComplete la siguiente tabla indicando si el nombre es v치lido para una variable de Python.\n\n\n\nNombre\n쯌치lido?\nJustificaci칩n\n\n\n\n\nbalance\n\n\n\n\nbalanceActual\n\n\n\n\nbalance-actual\n\n\n\n\nbalance actual\n\n\n\n\nbalance_actual\n\n\n\n\nmis.datos\n\n\n\n\n0cuenta\n\n\n\n\ncuenta0\n\n\n\n\n_cuenta\n\n\n\n\nSPAM\n\n\n\n\ncantidad$",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游 Autoevaluaci칩n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#variables",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#variables",
    "title": "游 Autoevaluaci칩n",
    "section": "",
    "text": "쯈u칠 valor contiene la variable contador luego de ejecutar el siguiente c칩digo?\ncontador = 20\ncontador + 1\nComplete la siguiente tabla indicando si el nombre es v치lido para una variable de Python.\n\n\n\nNombre\n쯌치lido?\nJustificaci칩n\n\n\n\n\nbalance\n\n\n\n\nbalanceActual\n\n\n\n\nbalance-actual\n\n\n\n\nbalance actual\n\n\n\n\nbalance_actual\n\n\n\n\nmis.datos\n\n\n\n\n0cuenta\n\n\n\n\ncuenta0\n\n\n\n\n_cuenta\n\n\n\n\nSPAM\n\n\n\n\ncantidad$",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游 Autoevaluaci칩n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#n칰meros",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#n칰meros",
    "title": "游 Autoevaluaci칩n",
    "section": "2 N칰meros",
    "text": "2 N칰meros\n\n쮺u치l es el tipo de 10 / 2? 쯇or qu칠?\n쮺u치l es el tipo de 5 * 2? 쯇or qu칠?\n쯇or qu칠 5 == 5.0 es True?",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游 Autoevaluaci칩n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#booleanos",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#booleanos",
    "title": "游 Autoevaluaci칩n",
    "section": "3 Booleanos",
    "text": "3 Booleanos\n\n쮺u치l es el resultado de las siguientes expresiones? 쯇or qu칠?\nFalse or not False\nnot (True and True)\nnot True and True\n\"True\" != True\n10 &gt; 5 + 3\nNone is None\nFalse is False\nEjecute l칤nea por l칤nea los siguientes bloques y analice los resultados.\nint(True) * 50\nTrue * 50\n1 is True\nbool(1) is True\nid(True)\nid(bool(1))\nid(bool(1024))\n쮺u치les son los 3 operadores booleanos?",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游 Autoevaluaci칩n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#cadenas-de-caracteres",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#cadenas-de-caracteres",
    "title": "游 Autoevaluaci칩n",
    "section": "4 Cadenas de caracteres",
    "text": "4 Cadenas de caracteres\n\n쯇or qu칠 la siguiente comparaci칩n resulta en True?\n\"spam\" + \"spamspam\" == \"spam\" * 3\n쯇or qu칠 la siguiente expresi칩n resulta en un error? 쮺칩mo se puede arreglar?\n\"Me com칤 \" + 6 + \" panchos.\"\n쮼ncuentra algo extra침o en la siguiente expresi칩n? 쮺칩mo la mejorar칤a?\nmateria = \"Programaci칩n 2\"\nprint(\"춰Sean bienvenidos a la materia {materia}!\")\nExplique por qu칠 es redundante utilizar str() en el siguiente bloque de c칩digo:\nx, y = 10, 20\nprint(f\"La suma de {str(x)} y {str(y)} es: {str(x + y)}.\")\nConsidere el siguiente bloque de c칩digo:\nmensaje = \"Hola, 쯖칩mo estes?\"\nmensaje[-3] = \"치\"\n\n쮺u치l es la intenci칩n detr치s del programa?\n쯇or qu칠 no funciona?\n쮺칩mo podr칤a arreglarlo? Alerta: la soluci칩n no es muy elegante.\n\n쮺u치l es el resultado de list(\"abcdefgh\")? 쯇or qu칠?\n쯇or qu칠 set(\"abcde\") es distinto de {\"abcde\"}?",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游 Autoevaluaci칩n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#funciones",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#funciones",
    "title": "游 Autoevaluaci칩n",
    "section": "5 Funciones",
    "text": "5 Funciones\n\n쮺u치l es la diferencia entre una funci칩n y una llamada a funci칩n?\n쮺u치l es el valor que devuelve una funci칩n que no tiene return?\n쮺u치ndo se ejecuta el c칩digo dentro de una funci칩n: cuando la funci칩n se define o cuando se la llama? Considere la siguiente funci칩n:\ndef suma(x, y):\n    print(100 / 0)\n    return x + y\nLuego, ejecute el siguiente bloque:\nsuma(2, 4)",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游 Autoevaluaci칩n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#listas",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#listas",
    "title": "游 Autoevaluaci칩n",
    "section": "6 Listas",
    "text": "6 Listas\n\n쯈u칠 es []? 쮺u치l es el resultado de len([])?\n쯇or qu칠 la siguiente expresi칩n resulta en False? Ayuda: use la funci칩n id().\n[] is []\n쯇or qu칠 se obtiene un error en el siguiente bloque de c칩digo?\nl = []\nl[0]\nSi [0][0] devuelve 0, 쯣or qu칠 [1][1] no devuelve [1]?\n쮺u치l es el valor de x en el siguiente bloque de c칩digo? 쯇or qu칠?\nl = [\"hola\", \"hola hola\", \"hasta luego\"]\nx = l.remove(\"hola\")\n쮺칩mo le asignar칤a el valor \"hola\" como el tercer valor en una lista almacenada en una variable llamada cosas? Asuma que cosas contiene [2, 4, 6, 8, 10].\nAsuma que letras contiene la lista [\"a\", \"b\", \"c\", \"d\"]:\n\n쮸 qu칠 eval칰a letras[-1]?\n쮸 qu칠 eval칰a letras[:2]?\n쮸 qu칠 eval칰a letras[int(int('3' * 2) // 11)]? 쮼s necesario usar dos veces int()?\n\nAsuma que bartulos contiene la lista [3.14, \"casa\", 11, \"casa\", True]:\n\n쮸 qu칠 eval칰a bartulos.index(\"casa\")? 쯇or qu칠?\n쮺칩mo queda la lista en bartulos despu칠s de ejecutar bartulos.append(99)?\n쮺칩mo queda la lista en bartulos despu칠s de ejecutar bartulos.remove(\"casa\"') ?쯇or qu칠?\n\n쮺u치les son los operadores para la concatenaci칩n y la replicaci칩n de listas?\n쮺u치l es la diferencia entre los m칠todos append() e insert() de las listas?\n쮺u치les son dos formas de eliminar valores de una lista?\nEl siguiente bloque de c칩digo imprime ['a', 'b', True, 30]. 쯇or qu칠?\ncosas = [\"a\", \"b\", True]\nbartulos = cosas\nbartulos.append(20 + 10)\nprint(cosas)\nConsidere el siguiente bloque de c칩digo:\nmarcas = [\"Milka\", \"Cofler\", \"츼guila\", \"Cadbury\", \"Lindt\", \"Toblerone\", \"After Eight\"]\nmarcas[2:5]\nque correctamente muestra [\"츼guila\", \"Cadbury\", \"Lindt\"]. 쯇or qu칠 el siguiente bloque de c칩digo no funciona?\nmarcas = [\"Milka\", \"Cofler\", \"츼guila\", \"Cadbury\", \"Lindt\", \"Toblerone\", \"After Eight\"]\nindices = 2:5\nmarcas[indices]",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游 Autoevaluaci칩n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#tuplas",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#tuplas",
    "title": "游 Autoevaluaci칩n",
    "section": "7 Tuplas",
    "text": "7 Tuplas\n\n쯇or qu칠 la tupla no implementa un m칠todo similar al m칠todo .extend() de las listas?\nLas tuplas de Python son conocidas por ser inmutables. Por ejemplo, el siguiente bloque de c칩digo resulta en un error:\ntupla = (1, 2, 3)\ntupla[1] = 10\nSin embargo, el siguiente bloque no arroja ning칰n error y pareciera que se logra modificar la tupla exitosamente:\nbartulos = [\"Hola\", 10, None]\ntupla = (1, bartulos, 3)\n\ntupla[1].append(\"춰Sorpesa!\")\n\nprint(tupla)\n쯈u칠 pas칩?",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游 Autoevaluaci칩n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#diccionarios",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#diccionarios",
    "title": "游 Autoevaluaci칩n",
    "section": "8 Diccionarios",
    "text": "8 Diccionarios\n\n쮺칩mo se escribe en c칩digo un diccionario vac칤o?\n쮺칩mo se ve un diccionario que tiene la clave \"cosa\" y el valor 15?\n쮺u치l es la principal diferencia entre un diccionario y una lista?\n쯈u칠 ocurre si se intenta acceder a bartulos[\"cosa\"] cuando bartulos es {\"coso\": 100}?\nSi un diccionario est치 almacenado en bartulos, 쯖u치l es la diferencia entre las siguientes expresiones?\n\"cosa\" in bartulos\n\"cosa\" in bartulos.keys()\nSuponga el diccionario datos = {\"nombre\": \"Juan\"}. 쯇or qu칠 la siguiente expresi칩n resulta en False?\n\"Juan\" in datos",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游 Autoevaluaci칩n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#control-de-flujo",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#control-de-flujo",
    "title": "游 Autoevaluaci칩n",
    "section": "9 Control de flujo",
    "text": "9 Control de flujo\n\n9.1 Condicionales\n\nExplique qu칠 es una condici칩n y en qu칠 situaciones se utilizar칤a.\nIdentifique los tres bloques de c칩digo en el siguiente ejemplo:\ncodigo = 0\n\nif codigo == 10:\n    print(\"mensaje 1\")\n    if codigo &gt; 5:\n        print(\"mensaje 2\")\n    else:\n        print(\"mensaje alternativo\")\n    print(\"mensaje final\")\n\nprint(\"Fin del programa\")\n쯊ienen sentido las comparaciones utilizadas?\n쮺u치l es el problema con el siguiente programa? Proponga una soluci칩n.\nnumero = 10\nif numero &lt; 0:\n    print(f\"El numero {numero} es negativo\")\nelif numero &lt; -5:\n    print(f\"El numero {numero} es menor a -5\")\nelif numero &gt; 0:\n    print(f\"El numero {numero} es positivo\")\nelse:\n    print(f\"El numero {numero} es 0\")\n\n\n\n9.2 Bucles\n\nConsidere el siguiente programa:\nfor i in range(10):\n    print(i)\nEscriba un programa que realice la misma tarea utilizando un bucle while.\n쮺u치l es la diferencia entre range(10), range(0, 10) y range(0, 10, 1) en un bucle for?\nSuponga que numeros es una lista que contiene numeros enteros, 쯘n qu칠 se diferencian los siguientes bloques de c칩digo?\nfor i in numeros:\n    if i % 2 == 0:\n        break\n    print(i)\nfor i in numeros:\n    if i % 2 == 0:\n        continue\n    print(i)\n쮼s posible re-escribir el siguiente bloque de c칩digo usando while True? 쯈u칠 modificaciones habr칤a que hacer?\nsuma = 0\ni = 0\nwhile suma &lt;= limite:\n    suma += numeros[i]\n    i += 1",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游 Autoevaluaci칩n"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/problemas.html",
    "href": "practica/04_estructuras_y_algoritmos/problemas.html",
    "title": "游빌 Problemas",
    "section": "",
    "text": "El recurso Arreglos manuales muestra como implementar un arreglo en Python sin utilizar ninguna estructura de datos de alto nivel como las listas o las tuplas.\nSi bien la clase Array provee m칠todos elementales para interactuar con los arreglos, carece de otros m칠todos convenientes que encontramos en estructuras como las listas.\nImplemente los siguientes m칠todos en la clase Array.\n\nappend(self, valor): agrega el elemento valor al final del arreglo. An치logo al m칠todo append de las listas.\nextend(self, arreglo): agrega todos los elementos del arreglo arreglo al final del arreglo. An치logo al m칠todo extend de las listas.\nreverse(self): invierte el orden de los elementos en el arreglo, modificandolo in-place.\ncount(self, valor): devuelve la cantidad de veces que aparece valor en el arreglo.\nclear(self): elimina todos los elementos del arreglo, dejandolo vac칤o in-place.\n__repr__(self): modif칤quelo para que muestre solo los tres elementos iniciales y finales cuando la cantidad de elementos sea mayor a 10. En el medio, debe mostrar .... Por ejemplo Array(10, 22, -10, ..., 5, 5, 5).\n__iter__(self): permite iterar sobre el arreglo. Debe contener un bucle for que entrega (con yield) los valores del arreglo de a uno.\n\nFinalmente, modifique la clase Array para que encoja el tama침o del bloque de memoria cuando la cantidad de elementos sea menor al 20% de la capacidad.",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游빌 Problemas"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/problemas.html#arreglos-manuales-completos",
    "href": "practica/04_estructuras_y_algoritmos/problemas.html#arreglos-manuales-completos",
    "title": "游빌 Problemas",
    "section": "",
    "text": "El recurso Arreglos manuales muestra como implementar un arreglo en Python sin utilizar ninguna estructura de datos de alto nivel como las listas o las tuplas.\nSi bien la clase Array provee m칠todos elementales para interactuar con los arreglos, carece de otros m칠todos convenientes que encontramos en estructuras como las listas.\nImplemente los siguientes m칠todos en la clase Array.\n\nappend(self, valor): agrega el elemento valor al final del arreglo. An치logo al m칠todo append de las listas.\nextend(self, arreglo): agrega todos los elementos del arreglo arreglo al final del arreglo. An치logo al m칠todo extend de las listas.\nreverse(self): invierte el orden de los elementos en el arreglo, modificandolo in-place.\ncount(self, valor): devuelve la cantidad de veces que aparece valor en el arreglo.\nclear(self): elimina todos los elementos del arreglo, dejandolo vac칤o in-place.\n__repr__(self): modif칤quelo para que muestre solo los tres elementos iniciales y finales cuando la cantidad de elementos sea mayor a 10. En el medio, debe mostrar .... Por ejemplo Array(10, 22, -10, ..., 5, 5, 5).\n__iter__(self): permite iterar sobre el arreglo. Debe contener un bucle for que entrega (con yield) los valores del arreglo de a uno.\n\nFinalmente, modifique la clase Array para que encoja el tama침o del bloque de memoria cuando la cantidad de elementos sea menor al 20% de la capacidad.",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游빌 Problemas"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/problemas.html#lista-enlazada",
    "href": "practica/04_estructuras_y_algoritmos/problemas.html#lista-enlazada",
    "title": "游빌 Problemas",
    "section": "2 Lista enlazada",
    "text": "2 Lista enlazada\nModifique la ListaEnlazada del apunte  para que:\n\nImplemente el m칠todo especial __len__.\nMantenga un conteo interno de la cantidad de elementos en la lista de forma tal que no sea necesario recorrerla para obtener su longitud.\nImplemente un m칠todo eliminar_siguiente que reciba como argumento un nodo de una lista enlazada y elimine el nodo que se encuentra inmediatamente despu칠s del nodo dado.\nImplemente un m칠todo elimiar_valor que reciba como argumento un valor y elimine de la lista enlazada todos los nodos que contengan ese valor.\n\nLuego, implemente el m칠todo reverse(self) que invierte los elementos de la lista enlazada.",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游빌 Problemas"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/problemas.html#pila-como-lista-enlazada",
    "href": "practica/04_estructuras_y_algoritmos/problemas.html#pila-como-lista-enlazada",
    "title": "游빌 Problemas",
    "section": "3 Pila como lista enlazada",
    "text": "3 Pila como lista enlazada\nImplemente una clase Pila que utilice una lista enlazada para almacenar los elementos de la pila.",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游빌 Problemas"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/problemas.html#cola-como-lista-doblemente-enlazada",
    "href": "practica/04_estructuras_y_algoritmos/problemas.html#cola-como-lista-doblemente-enlazada",
    "title": "游빌 Problemas",
    "section": "4 Cola como lista doblemente enlazada",
    "text": "4 Cola como lista doblemente enlazada\nImplemente una clase Cola que utilice una lista doblemente enlazada para almacenar los elementos de la pila.\nImplemente un m칠todo concatenar(self, C2) que agregue todos los elementos de la cola C2 al final de la cola C1 (es decir, la cola sobre la que se realiza la llamada). La operaci칩n debe ejecutarse en tiempo constante (O(1)) y debe dejar a C2 convertida en una cola vac칤a.",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游빌 Problemas"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/problemas.html#eliminar-nodo-de-lista-enlazada",
    "href": "practica/04_estructuras_y_algoritmos/problemas.html#eliminar-nodo-de-lista-enlazada",
    "title": "游빌 Problemas",
    "section": "5 Eliminar nodo de lista enlazada",
    "text": "5 Eliminar nodo de lista enlazada\nSuponga que tiene acceso a un nodo ubicado en alg칰n punto intermedio de una lista enlazada cl치sica, pero no tiene acceso a la lista completa. Es decir, se tiene una variable que apunta a una instancia de Nodo, pero no al objeto ListaEnlazada.\nEn esta situaci칩n es posible acceder a todos los valores desde este nodo hasta el final de la lista, pero no hay forma de acceder a los nodos que lo preceden.\nEscriba un programa que elimine el nodo de la lista original. La lista original restante debe permanecer completa, con solo este nodo eliminado.",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游빌 Problemas"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/problemas.html#arreglos-indexados",
    "href": "practica/04_estructuras_y_algoritmos/problemas.html#arreglos-indexados",
    "title": "游빌 Problemas",
    "section": "6 Arreglos indexados",
    "text": "6 Arreglos indexados\nAgregue el m칠todo __getitem__(self, indice) a la clase Array para que sea posible acceder a sus valores de la siguiente manera:\narreglo = Array(10, 20, 150)\narreglo[0] # 10\narreglo[1] # 20\narreglo[2] # 150\narreglo[3] # IndexError\nAseg칰rese de que el m칠todo __getitem__ soporta 칤ndices negativos.",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游빌 Problemas"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/problemas.html#pilas-y-colas-ruidosas",
    "href": "practica/04_estructuras_y_algoritmos/problemas.html#pilas-y-colas-ruidosas",
    "title": "游빌 Problemas",
    "section": "7 Pilas y colas ruidosas",
    "text": "7 Pilas y colas ruidosas\nLa implementaci칩n actual de Pila y Cola devuelve None cuando se intenta extraer un elemento de una pila (o cola) vac칤a. Modifique estas clases para que eleven un error llamado EmptyStructure.",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游빌 Problemas"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/problemas.html#pilas-y-colas-limitadas",
    "href": "practica/04_estructuras_y_algoritmos/problemas.html#pilas-y-colas-limitadas",
    "title": "游빌 Problemas",
    "section": "8 Pilas y colas limitadas",
    "text": "8 Pilas y colas limitadas\nModifique la implementaci칩n de Pila y Cola para que tengan una capacidad limitada, establecida mediante el par치metro capacidad_maxima el m칠todo inicializador, cuyo valor por defecto es None. Cuando se intente agregar un elemento en una pila o cola que est치 a m치xia capaciad, se debe arrojar un error FullCapacity.",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游빌 Problemas"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/problemas.html#inversi칩n-recursiva",
    "href": "practica/04_estructuras_y_algoritmos/problemas.html#inversi칩n-recursiva",
    "title": "游빌 Problemas",
    "section": "9 Inversi칩n recursiva",
    "text": "9 Inversi칩n recursiva\nDescriba un algoritmo recursivo eficiente para invertir una lista simplemente enlazada.",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游빌 Problemas"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html",
    "title": "游멆잺 Ejercicios",
    "section": "",
    "text": "Imagin치 un estante de farmacia con \\(N\\) posiciones perfectamente contiguas (sin huecos), numeradas desde 0 hasta \\(N-1\\). Cada posici칩n guarda exactamente una caja de un medicamento.\nPara este ejercicio, asumiremos que N = 100.\n\n\n\nPara medir el costo de cada operaci칩n, definimos un paso como la unidad de tiempo m치s peque침a:\n\nObservar (Leer): Mirar qu칠 medicamento hay en una posici칩n espec칤fica. (1 paso)\nMover: Deslizar una caja una posici칩n a la izquierda o derecha. (1 paso por cada caja movida)\nColocar (Escribir): Poner una caja nueva en una posici칩n vac칤a. (1 paso)\n\n\n\n\n\nInserci칩n: Para hacer un hueco en medio del estante, hay que mover todas las cajas desde esa posici칩n en adelante hacia la derecha.\nEliminaci칩n: Para cerrar un hueco en medio del estante, hay que mover todas las cajas desde la posici칩n eliminada en adelante hacia la izquierda.\nEl estante debe permanecer siempre contiguo (sin huecos).\n\n\n\n\nPara cada escenario, calcule el costo en pasos y deduzca su complejidad asint칩tica (Big O), bas치ndote en la analog칤a f칤sica.\n\n\n\n\n\n\n\n\n\n\nOperaci칩n\nDescripci칩n del escenario\nPasos (Con N=100)\nExpresi칩n con N (Big O impl칤cito)\nJustificaci칩n (쯇or qu칠?)\n\n\n\n\na) Lectura por Posici칩n\nDecime qu칠 medicamento hay en la posici칩n 37.\n\n\n\n\n\nb) B칰squeda (peor caso)\n쮼st치 el medicamento X en el estante? (Asum칤 que NO est치 y debes revisar todo el estante).\n\n\n\n\n\nc) Inserci칩n al Inicio\nPon칠 un nuevo medicamento en la posici칩n 0 y corr칠 todo lo dem치s.\n\n\n\n\n\nd) Inserci칩n al Final\nAgreg치 un nuevo medicamento en la posici칩n N (al final del estante).\n\n\n\n\n\ne) Eliminaci칩n al Inicio\nSac치 la caja de la posici칩n 0 y corr칠 el resto para cerrar el hueco.\n\n\n\n\n\nf) Eliminaci칩n al Final\nSac치 la 칰ltima caja del estante (posici칩n N1).",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#el-estante-de-la-farmacia",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#el-estante-de-la-farmacia",
    "title": "游멆잺 Ejercicios",
    "section": "",
    "text": "Imagin치 un estante de farmacia con \\(N\\) posiciones perfectamente contiguas (sin huecos), numeradas desde 0 hasta \\(N-1\\). Cada posici칩n guarda exactamente una caja de un medicamento.\nPara este ejercicio, asumiremos que N = 100.\n\n\n\nPara medir el costo de cada operaci칩n, definimos un paso como la unidad de tiempo m치s peque침a:\n\nObservar (Leer): Mirar qu칠 medicamento hay en una posici칩n espec칤fica. (1 paso)\nMover: Deslizar una caja una posici칩n a la izquierda o derecha. (1 paso por cada caja movida)\nColocar (Escribir): Poner una caja nueva en una posici칩n vac칤a. (1 paso)\n\n\n\n\n\nInserci칩n: Para hacer un hueco en medio del estante, hay que mover todas las cajas desde esa posici칩n en adelante hacia la derecha.\nEliminaci칩n: Para cerrar un hueco en medio del estante, hay que mover todas las cajas desde la posici칩n eliminada en adelante hacia la izquierda.\nEl estante debe permanecer siempre contiguo (sin huecos).\n\n\n\n\nPara cada escenario, calcule el costo en pasos y deduzca su complejidad asint칩tica (Big O), bas치ndote en la analog칤a f칤sica.\n\n\n\n\n\n\n\n\n\n\nOperaci칩n\nDescripci칩n del escenario\nPasos (Con N=100)\nExpresi칩n con N (Big O impl칤cito)\nJustificaci칩n (쯇or qu칠?)\n\n\n\n\na) Lectura por Posici칩n\nDecime qu칠 medicamento hay en la posici칩n 37.\n\n\n\n\n\nb) B칰squeda (peor caso)\n쮼st치 el medicamento X en el estante? (Asum칤 que NO est치 y debes revisar todo el estante).\n\n\n\n\n\nc) Inserci칩n al Inicio\nPon칠 un nuevo medicamento en la posici칩n 0 y corr칠 todo lo dem치s.\n\n\n\n\n\nd) Inserci칩n al Final\nAgreg치 un nuevo medicamento en la posici칩n N (al final del estante).\n\n\n\n\n\ne) Eliminaci칩n al Inicio\nSac치 la caja de la posici칩n 0 y corr칠 el resto para cerrar el hueco.\n\n\n\n\n\nf) Eliminaci칩n al Final\nSac치 la 칰ltima caja del estante (posici칩n N1).",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#cita-con-el-dentista",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#cita-con-el-dentista",
    "title": "游멆잺 Ejercicios",
    "section": "2 Cita con el dentista",
    "text": "2 Cita con el dentista\n\nContexto\nUna cl칤nica odontol칩gica necesita un sistema sencillo para gestionar su agenda de turnos. Los turnos se agregan a la lista en orden de llegada, sin preocuparse inicialmente por el orden cronol칩gico.\n\n\nDatos iniciales\nLa agenda se mantiene en un arreglo (lista) de diccionarios.\nagenda = [\n    {\"paciente\": \"Juana P칠rez\", \"hora\": \"08:30\"},\n    {\"paciente\": \"Mario G칩mez\", \"hora\": \"09:00\"},\n    {\"paciente\": \"Sof칤a L칩pez\", \"hora\": \"09:30\"},\n    {\"paciente\": \"Ana Fern치ndez\", \"hora\": \"10:15\"},\n]\n\n\nFunciones a implementar\nUsando operaciones b치sicas sobre el arreglo (sin usar .remove ni .pop directamente):\n\nleer_pos(i): Devuelve el turno en la posici칩n i. Si i no existe, devuelve None.\ninsertar(turno): Agrega un nuevo diccionario {\"paciente\": ..., \"hora\": \"HH:MM\"} al final de la lista (simulando la llegada de un nuevo paciente). Devuelve True.\neliminar(hora): Busca el primer turno con esa hora y lo elimina. Devuelve True si lo elimin칩, False si el horario no estaba en la lista.\nbuscar(hora): Recorre la lista desde el principio hasta el final. Devuelve la posici칩n (칤ndice) donde est치 ese horario, o -1 si no existe.\nlistar(): Devuelve una lista de strings con el formato: [\"0) 08:30 - Juana P칠rez\", \"1) 09:00 - Mario G칩mez\", ...]\n\n\n\nEjemplo de uso\nprint(leer_pos(1))\n# {'paciente': 'Mario G칩mez', 'hora': '09:00'}\n\nnuevo = {\"paciente\": \"Diego Romero\", \"hora\": \"09:45\"}\ninsertar(nuevo)  # Se agrega al final\n\nprint(buscar(\"09:45\"))\n# 4  (Si era el quinto elemento, ya que la lista creci칩)\n\nprint(eliminar(\"09:00\"))\n# True\n\nprint(listar())\n# ['0) 08:30 - Juana P칠rez',\n#  '1) 09:30 - Sof칤a L칩pez',\n#  '2) 10:15 - Ana Fern치ndez',\n#  '3) 09:45 - Diego Romero']\n\n\nCasos a probar\n\nInsertar \"08:15\" (debe ir al inicio).\nInsertar \"12:00\" (debe ir al final).\nInsertar repetido \"09:30\" (debe rechazarse).\nBuscar un horario inexistente (debe devolver -1).\nEliminar uno inexistente (debe devolver False).\n\n\n\nMini-consigna te칩rica\nResponda:\n\n쯈u칠 ocurre con los 칤ndices cuando elimin치s o insert치s un turno en el medio de la lista? (Pista: 쯤u칠 pasa con los elementos que estaban despu칠s?)\n쯇or qu칠 acceder a agenda[i] es una operaci칩n \\(O(1)\\) pero buscar un turno por hora es \\(O(N)\\)?\n쯈u칠 estructura te parecer칤a m치s conveniente si hubiera miles de turnos? Explic치 brevemente por qu칠.",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#la-lista-de-reproducci칩n-del-dj",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#la-lista-de-reproducci칩n-del-dj",
    "title": "游멆잺 Ejercicios",
    "section": "3 La lista de reproducci칩n del DJ勇",
    "text": "3 La lista de reproducci칩n del DJ勇끂n\nContexto\nUn DJ est치 gestionando su lista principal de canciones, almacenada en una secuencia ordenada de reproducci칩n. Se necesita desarrollar las herramientas para manipular esta lista de forma eficiente y precisa antes del show.\n\n\nRequerimientos de manipulaci칩n\nEl sistema debe soportar las siguientes acciones, considerando que la lista es una secuencia lineal donde el orden es fundamental:\n\nConsulta por ubicaci칩n: El DJ debe poder pedir la canci칩n que est치 en una posici칩n exacta de la secuencia (ej. Dime qu칠 canci칩n est치 en el tercer lugar).\nAdici칩n controlada: Se debe poder insertar una nueva canci칩n exactamente en una posici칩n espec칤fica de la secuencia (ej. Pon Nueva Canci칩n justo antes de la canci칩n que actualmente est치 en la posici칩n 5). Esto implica que las canciones que estaban en esa posici칩n y despu칠s deben moverse para hacer espacio.\nRemoci칩n dirigida: El DJ debe poder quitar una canci칩n conociendo su nombre de la lista. Una vez retirada, las canciones que estaban despu칠s deben moverse para cerrar el hueco y mantener la secuencia contigua.\nIdentificaci칩n por nombre: Se requiere una funci칩n para localizar una canci칩n por su nombre y devolver su ubicaci칩n actual en la secuencia.\n\n\n\nDatos iniciales\ncanciones = [\"Thunderstruck\", \"Billie Jean\", \"Smells Like Teen Spirit\"]\n\n\nEjemplos de uso\n# Ejemplo de requerimiento: Inserci칩n\n# Intentamos poner \"One\" en la posici칩n 2 (el tercer espacio)\ninsertar_cancion(2, \"One\")\n# La lista debe ajustarse autom치ticamente: [\"Thunderstruck\", \"Billie Jean\", \"One\", \"Smells Like Teen Spirit\"]\n\n# Ejemplo de requerimiento: Eliminaci칩n\neliminar_cancion(\"Billie Jean\")\n# La lista debe reajustarse: [\"Thunderstruck\", \"One\", \"Smells Like Teen Spirit\"]\n\n\nPunto extra: Visualizaci칩n del 칈ndice\nMuestre al DJ la lista completa, indicando claramente la posici칩n inicial de cada pista en la secuencia.",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#scanner-pro-3000",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#scanner-pro-3000",
    "title": "游멆잺 Ejercicios",
    "section": "4 Scanner Pro 3000",
    "text": "4 Scanner Pro 3000\n\nContexto\nEn un recital, cada entrada tiene un c칩digo. Al ingresar, el lector va guardando los c칩digos en una lista en el orden en que se escanean. La producci칩n te pide detectar si hubo c칩digos repetidos (fraude o doble escaneo).\nTe entregan una lista escaneos con miles de c칩digos (que son strings de Python).\nescaneos = [\n    \"A1F3\", \"B9K2\", \"X7Z1\", \"A1F3\", \"L0P9\", \"M2Q5\", \"B9K2\", ...\n]\n\nEscriba una funci칩n que encuentre si hay alg칰n c칩digo repetido comparando cada elemento con todos los que le siguen (utilice un doble bucle for).\n\n쮺u치ntas comparaciones hace en el peor caso con N elementos?\n쯈u칠 pasa cuando N crece x10?\n\nImplemente una versi칩n lineal usando un set para registrar c칩digos ya vistos.\n\n쯇or qu칠 ahora es \\(O(N)\\)?\n쯈u칠 operaci칩n te permite 랍altar comparaciones?\n\nUse esta funcion que crea codigos aleatorios para generar listas de codigos de tama침os crecientes y mida el tiempo de ejecucion de cada funcion anterior: ```python import random, string, time\ndef generar_codigos(n, dup_ratio=0.0, seed=0): rng = random.Random(seed) base = set() # crear c칩digos 칰nicos while len(base) &lt; int(n * (1 - dup_ratio)): base.add(뙉.join(rng.choices(string.ascii_uppercase + string.digits, k=6))) lista = list(base) # inyectar duplicados while len(lista) &lt; n: lista.append(rng.choice(list(base))) rng.shuffle(lista) return lista ```",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#el-club-secreto-de-los-hackers",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#el-club-secreto-de-los-hackers",
    "title": "游멆잺 Ejercicios",
    "section": "5 El club secreto de los hackers",
    "text": "5 El club secreto de los hackers\n\nContexto\nUn grupo de hackers tiene un club secreto con reglas muy estrictas sobre qui칠n puede entrar y salir. Los miembros se ordenan seg칰n su entrada: desde el fundador hasta el 칰ltimo ingresante. En caso de ser necesaria una reducci칩n de miembros, los primeros en irse deben ser los que menos experiencia tienen (el 칰ltimo en entrar al club debe ser el primero en salir).\nSi un hacker que no es el 칰ltimo en entrar sale del grupo fuera de orden, se considera una violaci칩n de seguridad y se registra la acci칩n en el sistema.\n\n\nDatos iniciales\nclub = [\n    {\"nombre\": \"Anonymous\"},\n    {\"nombre\": \"Mitnick\"},\n    {\"nombre\": \"Soupnazi\"},\n    {\"nombre\": \"D-Dante\"}\n]\nTeniendo en cuenta el contexto implementa las siguientes funciones para regular la entrada y salida de los miembros del club:\n\nentrar(nombre)\n\nAgrega un hacker a la pila del club\nCada entrada debe registrarse como un diccionario: {\"nombre\": \"Neo\"}\nSi hay m치s de 10 hacker, imprimir: El Club esta lleno, capacidad m치xima alcanzada렢n\nsalir()\n\nSaca al 칰ltimo hacker que entr칩\nRetorna el nombre del hacker que sali칩\nSi la pila est치 vac칤a, imprimir: El club ha desaparecido en la oscuridad뷕렢n\nultimo_en_entrar()\n\nMuestra qui칠n est치 en la cima de la pila sin sacarlo\nRetorna el nombre del 칰ltimo que entr칩\nSi la posiion aun no fue cubierta, retorna None\n\nmostrar_club()\n\nMuestra todos los hackers en el club, del m치s reciente al m치s antiguo\nIndica cu치ntos hay en total\nFormato: [Top] Neo -&gt; Trinity -&gt; Anonymous [Base]\n\nesta_en_club(nombre)\n\nVerifica si un hacker espec칤fico est치 dentro\nRetorna True o False\nIMPORTANTE: No destruir la pila al buscar\n\n\n\n\nEjemplo de uso esperado\nentrar(\"Morpheus\")\nentrar(\"Trinity\")\nentrar(\"Neo\")\n\nmostrar_club()\n# Salida:  Club (3 hackers): [Top] Neo -&gt; Trinity -&gt; Morpheus [Base]\n\nprint(ultimo_en_entrar())\n# Salida: Neo\n\nsalir()\n# Salida: Neo ha salido del club\n\nprint(esta_en_club(\"Trinity\"))\n# Salida: True\n\nprint(esta_en_club(\"Cypher\"))\n# Salida: False\n\n\nEjemplo de uso esperado\n# Caso 1: Club vac칤o\nclub.clear()\nsalir()  # Debe mostrar mensaje\n\n# Caso 2: Verificar LIFO\nentrar(\"A\")\nentrar(\"B\")\nentrar(\"C\")\nsalir()  # Debe salir C (칰ltimo en entrar)\nsalir()  # Debe salir B\nultimo_en_entrar()  # Debe ser A\n\n# Caso 3: Club lleno\nfor i in range(12):\n    entrar(f\"Hacker{i}\")  # En el 11vo debe avisar que est치 lleno\n\n# Caso 4: Buscar sin destruir\nentrar(\"Neo\")\nentrar(\"Trinity\")\nprint(esta_en_club(\"Neo\"))  # True\nmostrar_club()  # Neo debe seguir en la pila\n\n\nNivel 2: Desaf칤o 游\nNueva funcionalidad: Control de acceso con violaciones\nImpelmente las siguentes funciones:\n\nsalir_especifico(nombre)\n\n\nSi nombre es el TOP: sacarlo sin registrar violaci칩n, retornar True.\nSi no es el TOP pero est치 en la pila: - Desapilar a un buffer hasta encontrar nombre. - Remover nombre. - Reapilar en orden original todo lo que sacaste.\nRegistrar violaci칩n en _log_violaciones con formato: \"{HH:MM} - Violaci칩n: {nombre} sali칩 fuera de orden\" (usar datetime.now().strftime(\"%H:%M\")). Retornar True.\nSi no se encuentra: retornar False.\n\n\nhistorial_violaciones()\n\nMuestra todas las violaciones de seguridad registradas\nFormato: [\"17:30 - Violaci칩n: Trinity sali칩 fuera de orden\"]\n\n\n\n\nEjemplo de uso\nentrar(\"Morpheus\")\nentrar(\"Trinity\")\nentrar(\"Neo\")\nentrar(\"Cypher\")\n\n# Neo y Cypher est치n encima de Trinity\nsalir_especifico(\"Trinity\")\n# Salida: VIOLACI칍N DE SEGURIDAD: Trinity sali칩 fuera de orden\n\nmostrar_club()\n# Salida: [Top] Cypher -&gt; Neo -&gt; Morpheus [Base]\n# Trinity ya no est치",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#torre-de-control-a칠reo",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#torre-de-control-a칠reo",
    "title": "游멆잺 Ejercicios",
    "section": "6 Torre de control a칠reo",
    "text": "6 Torre de control a칠reo\n\nContexto\nLa Autoridad de Tr치fico A칠reo necesita optimizar las operaciones de una torre de control. Tu tarea es modelar el sistema que gestiona los permisos de movimiento de los aviones.\nExisten dos tipos de solicitudes pendientes:\n\nAviones esperando despegue: Estos aviones forman una fila de espera. Se les debe dar permiso para despegar siguiendo un principio estricto: el avi칩n que lleva m치s tiempo esperando en la fila es el primero en recibir permiso.\nAviones en aproximaci칩n de emergencia: Estos aviones requieren aterrizaje inmediato debido a una situaci칩n cr칤tica. Estos permisos de aterrizaje se apilan, y la torre debe procesar la emergencia m치s reciente antes que cualquier otra, es decir: el 칰ltimo avi칩n en reportar la emergencia es el primero en recibir la autorizaci칩n de aterrizaje.\n\n\n\nPrioridad de la torre\nLa torre de control siempre otorga permisos siguiendo una estricta jerarqu칤a:\n\nPrioridad absoluta: Si hay alguna emergencia pendiente, la torre siempre debe autorizar primero un aterrizaje de emergencia.\nPrioridad secundaria: Solo cuando no haya ninguna emergencia pendiente, la torre podr치 autorizar el despegue del avi칩n que le corresponda.\n\n\n\nDatos iniciales\nComienza con la siguiente situaci칩n en el aeropuerto:\n# Lista de aviones esperando para Despegar\nsolicitudes_despegue = [\"Vuelo 101\", \"Vuelo 205\"]\n# Lista de aviones reportando Emergencia\nsolicitudes_emergencia = [\"Vuelo 999\"]\n\n\nRequisitos funcionales\nSe debe crear un sistema con las siguientes acciones:\n\nUna funci칩n para registrar la llegada de un nuevo avi칩n a la lista de despegue.\nUna funci칩n para registrar una nueva solicitud de aterrizaje de emergencia.\nUna funci칩n principal, procesar_evento(), que simule la acci칩n de la torre de control al otorgar un permiso seg칰n las reglas de prioridad.\n\nPunto extra: Si la torre intenta otorgar un permiso y ambas listas est치n vac칤as, debe notificarlo con el mensaje: \"Torre en silencio\".",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#alerta-de-virus-zombie",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#alerta-de-virus-zombie",
    "title": "游멆잺 Ejercicios",
    "section": "7 Alerta de virus zombie",
    "text": "7 Alerta de virus zombie\n\nContexto\nSos un cient칤fico/a de un laboratorio secreto que est치 procesando muestras de virus zombies. Debes implementar un sistema de gesti칩n usando colas para manejar el flujo de trabajo.\nAlerta importante: Si hay m치s de 5 muestras del mismo tipo de virus en la cola, se activa una alerta biol칩gica (riesgo de propagaci칩n masiva).\n\n\nDatos iniciales\nfrom collections import deque\n\nmuestras = deque([\"virus_tank\", \"virus_witch\", \"virus_charger\"])\n\n\nTareas\nImplementa las siguientes funciones:\n\nagregar_muestra(nombre)\n\nAgrega una muestra al final de la cola\nMuestra mensaje confirmando la operaci칩n\nVerifica si hay m치s de 5 muestras del mismo tipo\nSi se cumple la condici칩n, imprime: \"춰Alerta biol칩gica! Detectadas X muestras de [nombre_virus]\"\n\nprocesar_muestra()\n\nProcesa (elimina) la primera muestra de la cola\nRetorna el nombre de la muestra procesada\nSi la cola est치 vac칤a, muestra un mensaje de error\n\nmostrar_pendientes()\n\nMuestra la lista de muestras pendientes\nRetorna la lista de muestras\nIndica cu치ntas muestras hay en espera\n\ncontar_por_tipo()\n\nRetorna un diccionario con el conteo de cada tipo de virus\nEjemplo: {\"virus_tank\": 3, \"virus_witch\": 2}\n\n\n\n\nEjemplo de uso esperado\nprint(mostrar_pendientes())\n# Salida: Muestras pendientes (3): ['virus_tank', 'virus_witch', 'virus_charger']\n\nagregar_muestra(\"virus_tank\")\nagregar_muestra(\"virus_tank\")\nagregar_muestra(\"virus_tank\")\nagregar_muestra(\"virus_tank\")\nagregar_muestra(\"virus_tank\")\n# Salida en la 5ta: 춰Alerta biol칩gica! Detectadas X muestras de virus_tank 驕勇끂n\nprint(contar_por_tipo())\n# Salida: {'virus_tank': 6, 'virus_witch': 1, 'virus_charger': 1}\n\nprocesar_muestra()\n# Salida: Procesando 'virus_tank'\n# Retorna: 'virus_tank'\n\n\nCasos a probar\n# Caso 1: Cola vac칤a\nmuestras.clear()\nprocesar_muestra()  # Debe mostrar error\n\n# Caso 2: Alerta biol칩gica por acumulaci칩n\nfor i in range(6):\n    agregar_muestra(\"virus_hunter\")  # Debe activar alerta en la 6ta\n\n# Caso 3: Verificar que la alerta sea por tipo espec칤fico\nagregar_muestra(\"virus_tank\")\nagregar_muestra(\"virus_witch\")\nagregar_muestra(\"virus_tank\")\n# No debe haber alerta (solo 2 de cada tipo)\n\n# Caso 4: Procesar reduce el conteo\nfor i in range(7):\n    agregar_muestra(\"virus_smoker\")  # Alerta: 7 smoker\nprocesar_muestra()  # Procesa 1 virus_tank (de los iniciales)\nprint(contar_por_tipo())  # Deber칤a seguir mostrando 7 smoker\n\n\nNivel 2: Desaf칤o 游\n\n\nNueva funcionalidad: Muestras prioritarias\nAlgunas muestras son urgentes y deben procesarse antes que las normales.\n\n\nDatos iniciales\nfrom collections import deque\n\nmuestras_normales = deque([\"virus_tank\", \"virus_witch\"])\nmuestras_urgentes = deque()\n\n\nTareas adicionales\n\nagregar_muestra(nombre, urgente=False)\n\nSi urgente=True, agrega a la cola de urgentes\nSi urgente=False, agrega a la cola normal\nLa alerta biol칩gica debe contar en AMBAS colas (misma cepa puede estar en las dos)\n\nprocesar_muestra() (modificada)\n\nPrimero procesa muestras urgentes\nSi no hay urgentes, procesa normales\nSi ambas colas est치n vac칤as, muestra error\n\nmostrar_todas()\n\nMuestra ambas colas por separado\nIndica cu치ntas muestras hay en cada una\nMuestra el conteo total por tipo de virus\n\ncontar_por_tipo() (modificada)\n\nDebe contar en ambas colas\nRetorna el conteo global de cada tipo\n\n\n\n\nEjemplo de uso\n# Agregar 4 tank normales y 3 tank urgentes\nfor i in range(4):\n    agregar_muestra(\"virus_tank\", urgente=False)\n\nfor i in range(3):\n    agregar_muestra(\"virus_tank\", urgente=True)\n    # En la 3ra debe activarse la alerta (total: 4+3=7 tanks)\n\nmostrar_todas()\n# Salida:\n# Urgentes (3): ['virus_tank', 'virus_tank', 'virus_tank']\n# Normales (6): ['virus_tank', 'virus_witch', 'virus_tank', ...]\n# Conteo por tipo: {'virus_tank': 7, 'virus_witch': 1}",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#batalla-pok칠mon",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#batalla-pok칠mon",
    "title": "游멆잺 Ejercicios",
    "section": "8 Batalla Pok칠mon",
    "text": "8 Batalla Pok칠mon\n\nContexto\nUn gimnasio Pok칠mon necesita un sistema para gestionar los batallas entre equipos. Para lograrlo te contratan y te dan la siguiente infromaci칩n:\n\nLos entrenadores Pok칠mon pueden capturar nuevos Pok칠mones y agregarlos a su equipo\nLos entrenadores necesitan poder buscar un Pok칠mon espec칤fico por su nombre para usarlo en batalla\nLos entrenadores tienen que poder retirar del equipo a los Pok칠mon debilitados o que ya no quieren usar\nLos entrenadores deben poder revisar su equipo completo para decidir su estrategia\n\nTu trabajo sera implementar la clase Equipo, para eso puedes usar la siguente clase ya implementada:\nclass Pokemon:\n    \"\"\"Representa un Pok칠mon individual\"\"\"\n    def __init__(self, nombre, tipo, nivel, max_hp, ataque):\n        self.nombre = nombre\n        self.tipo = tipo\n        self.nivel = nivel\n        self.max_hp = max_hp\n        self.hp = max_hp  # Empieza con vida completa\n        self.ataque = ataque\n\n    def recibir_da침o(self, puntos):\n        \"\"\"Reduce HP, no puede ser negativo\"\"\"\n        self.hp = max(0, self.hp - puntos)\n\n    def curar(self, puntos):\n        \"\"\"Aumenta HP, no puede superar el m치ximo\"\"\"\n        self.hp = min(self.max_hp, self.hp + puntos)\n\n    def esta_debilitado(self):\n        \"\"\"Retorna True si el Pok칠mon no puede combatir\"\"\"\n        return self.hp == 0\n\n    def subir_nivel(self):\n        \"\"\"Sube de nivel y aumenta stats\"\"\"\n        self.nivel += 1\n        self.max_hp += 5\n        self.hp = self.max_hp  # Se cura completamente\n\n    def __str__(self):\n        return f\"{self.nombre} ({self.tipo.capitalize()}) Nv.{self.nivel} [HP: {self.hp}/{self.max_hp}]\"\n\n\nEjemplo de uso\npikachu = Pokemon(\"Pikachu\", \"el칠ctrico\", nivel=25, max_hp=35, ataque=14)\nprint(pikachu)  # Pikachu (El칠ctrico) Nv.25 [HP: 35/35]\n\npikachu.recibir_da침o(10)\nprint(pikachu)  # Pikachu (El칠ctrico) Nv.25 [HP: 25/35]\n\n\nRequerimientos para implementar la clase Equipo\nLos maestros/as Pok칠mon necesitan gestionar su equipo de forma din치mica. Las operaciones que m치s realizan son:\n\nAgregar un Pok칠mon reci칠n capturado (siempre al final)\nBuscar un Pok칠mon espec칤fico por nombre\nEliminar un Pok칠mon espec칤fico del equipo\nListar todos los Pok칠mon para revisarlos\nEliminar todos los debilitados despu칠s de una batalla\nContar cu치ntos Pok칠mon tiene\n\nImportante\n\nNo se te permite usar listas normales de Python con acceso por 칤ndice** (lista[0], lista[2], etc.)\nLa clase debe ser eficiente para agregar y eliminar elementos\nPodes crear clases auxiliares si lo necesitas (como Nodo).\n\n\n\nM칠todos necesarios\n\n__init__(nombre_entrenador). Inicializa un equipo vac칤o para el entrenador.\nagregar_pokemon(pokemon). Agrega un Pok칠mon al final del equipo.\nbuscar(nombre). Busca un Pok칠mon por nombre. Retorna el objeto Pokemon si lo encuentra, None si no existe.\neliminar(nombre). Elimina un Pok칠mon espec칤fico del equipo. Retorna True si lo elimin칩, False si no exist칤a. Importante: este metodo debe manejar correctamente los casos de elimnar un elemento que sea el primero, uno del medio o el ultimo.\neliminar_debilitados(). Elimina todos los Pok칠mon con HP igual a 0. Retorna una lista con los nombres de los eliminados.\ncontar(). Retorna cu치ntos Pok칠mon hay en el equipo.\nesta_vacio(). Retorna True si no hay ning칰n Pok칠mon en el equipo.\nlistar(). Retorna una lista de cadenas de texto con todos los Pok칠mon en orden. Formato: [\"1. Pikachu (El칠ctrico) Nv.25 [HP: 35/35]\", \"2. Charmander...\", ...]\nobtener_primero(). Retorna el primer Pok칠mon del equipo sin eliminarlo. None si est치 vac칤o.\nobtener_mas_fuerte(). Retorna el Pok칠mon con mayor ataque. None si est치 vac칤o.\npokemon_por_tipo(tipo). Retorna una lista con todos los Pok칠mon de un tipo espec칤fico. Ejemplo: pokemon_por_tipo(\"fuego\")  lista con Charmander, Vulpix, etc.\n\n\n\nEjemplo de uso completo\n# Crear Pok칠mon\npikachu = Pokemon(\"Pikachu\", \"el칠ctrico\", nivel=25, max_hp=35, ataque=14)\ncharmander = Pokemon(\"Charmander\", \"fuego\", nivel=20, max_hp=39, ataque=12)\nsquirtle = Pokemon(\"Squirtle\", \"agua\", nivel=22, max_hp=44, ataque=9)\nbulbasaur = Pokemon(\"Bulbasaur\", \"planta\", nivel=21, max_hp=45, ataque=10)\neevee = Pokemon(\"Eevee\", \"normal\", nivel=18, max_hp=55, ataque=8)\n\n# Crear equipo\nequipo_ash = Equipo(\"Ash\")\n\n# Agregar Pok칠mon\nequipo_ash.agregar_pokemon(pikachu)\nequipo_ash.agregar_pokemon(charmander)\nequipo_ash.agregar_pokemon(squirtle)\nequipo_ash.agregar_pokemon(bulbasaur)\n\nprint(f\"Pok칠mon en el equipo: {equipo_ash.contar()}\")  # 4\n\n# Listar equipo\nprint(\"\\n=== EQUIPO DE ASH ===\")\nfor info in equipo_ash.listar():\n    print(info)\n\n# Buscar un Pok칠mon\nencontrado = equipo_ash.buscar(\"Squirtle\")\nif encontrado:\n    print(f\"\\n Encontrado: {encontrado}\")\n\n# Obtener el m치s fuerte\nfuerte = equipo_ash.obtener_mas_fuerte()\nprint(f\"\\n  M치s fuerte: {fuerte}\")\n\n# Simular batalla\nprint(\"\\n=== SIMULANDO BATALLA ===\")\ncharmander.recibir_da침o(39)  # Charmander se debilita\nsquirtle.recibir_da침o(20)    # Squirtle pierde HP pero sobrevive\n\nprint(f\"Charmander debilitado: {charmander.esta_debilitado()}\")\n\n# Eliminar debilitados\neliminados = equipo_ash.eliminar_debilitados()\nprint(f\"Pok칠mon eliminados: {eliminados}\")  # ['Charmander']\n\n# Ver equipo actualizado\nprint(f\"\\nPok칠mon restantes: {equipo_ash.contar()}\")  # 3\nfor info in equipo_ash.listar():\n    print(info)\n\n# Agregar nuevo Pok칠mon\nequipo_ash.agregar_pokemon(eevee)\nprint(f\"\\n Eevee agregado. Total: {equipo_ash.contar()}\")\n\n# Buscar por tipo\nfuego = equipo_ash.pokemon_por_tipo(\"fuego\")\nprint(f\"\\nPok칠mon de fuego: {[str(p) for p in fuego]}\")\n\n# Eliminar un Pok칠mon espec칤fico\nequipo_ash.eliminar(\"Pikachu\")\nprint(f\"\\n Pikachu liberado. Restantes: {equipo_ash.contar()}\")\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPreguntas para reflexionar ANTES de programar\n\n쯈u칠 estructura me permite conectar elementos sin 칤ndices?\n쯅ecesito crear una clase auxiliar (como Nodo)?\nAl eliminar un elemento, 쯤u칠 debo hacer con los enlaces?\n\nPista: Debes 랍altar al elemento eliminado reconectando los que estaban antes y despu칠s\n\n쮺칩mo recorro todos los elementos sin 칤ndices?\n\nPista: Empezas por el primero y seguis los enlaces hasta llegar al final\n\n쯈u칠 pasa si elimino el primer elemento? 쮼s diferente a eliminar del medio?\n\nPista: El primer elemento es especial, no tiene un elemento anterior",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#uno-m치s-dos",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#uno-m치s-dos",
    "title": "游멆잺 Ejercicios",
    "section": "9 Uno m치s dos",
    "text": "9 Uno m치s dos\nProponer e implementar dos algoritmos que calculen la suma de los primeros N n칰meros naturales.\n\nUno con complejidad \\(O(N)\\) (lineal).\nUno con complejidad \\(O(1)\\) (constante).",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#uno-m치s-tres",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#uno-m치s-tres",
    "title": "游멆잺 Ejercicios",
    "section": "10 Uno m치s tres",
    "text": "10 Uno m치s tres\nProponer e implementar dos algoritmos que calculen la suma de los primeros N n칰meros naturales impares.\n\nUno con complejidad \\(O(N)\\) (lineal).\nUno con complejidad \\(O(1)\\) (constante).",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#m치s-y-m치s-datos",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#m치s-y-m치s-datos",
    "title": "游멆잺 Ejercicios",
    "section": "11 M치s y m치s datos",
    "text": "11 M치s y m치s datos\n\nConsidere el siguiente c칩digo que calcula un acumulado de promedios para una lista de tama침o N.\n\ndef promedios_acumulados(lista):\n    \"\"\"\n    Ejemplo:  Entrada -&gt; [1, 2, 3, 5]\n              Salida  -&gt; [1, 1.5, 2, 2.75]\n    \"\"\"\n    N = len(lista)\n    promedios = []\n    for i in range(1, N+1):\n        promedio = sum(lista[:i]) / i\n        promedios.append(promedio)\n    return promedios\nDetermine la complejidad de este algoritmo.\n\nSiendo \\(\\overline{X}_n\\) el promedio de los primeros \\(n\\) n칰meros en la lista, vale la siguiente identidad recursiva: \\[\n\\overline{X}_{n+1} = \\frac{n \\cdot \\overline{X}_n + x_{n+1}}{n+1}\n\\]\ndonde \\(x_{n+1}\\) es el elemento \\((n+1)\\)-칠simo de la lista.\n\nUtilice este resultado para implementar un algoritmo m치s eficiente.",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#el-regreso-de-fibonacci",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#el-regreso-de-fibonacci",
    "title": "游멆잺 Ejercicios",
    "section": "12 El regreso de Fibonacci",
    "text": "12 El regreso de Fibonacci\nEn el Ejercicio 4 de la Unidad 2 se implement칩 una funci칩n recursiva para calcular el \\(n\\)-칠simo n칰mero en la sucesi칩n de Fibonacci.\nEsta implementaci칩n, sin embargo, es muy ineficiente. De hecho, se puede demostrar que su complejidad es \\(O(2^n)\\) (exponencial).\nUtilice memoizaci칩n para mejorar la eficiencia del algoritmo recursivo. Este nuevo programa tendr치 eficiencia lineal: \\(O(n)\\).\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nAl inicio de la funci칩n se debe crear un diccionario vac칤o: valores = {}.\nAnte cada valor \\(f(n)\\) de la sucesi칩n que toque calcular, se deber치 chequear si \\(n\\) est치 entre las claves existentes del diccionario.\n\nSi no lo est치, se deber치 calcular recursivamente y luego almacenar su resultado: valores[n] = f(n).\nSi lo est치, se devolver치 el valor f(n) sin efectuar m치s c치lculos.",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#vinieron-los-primos",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#vinieron-los-primos",
    "title": "游멆잺 Ejercicios",
    "section": "13 Vinieron los primos",
    "text": "13 Vinieron los primos\nImplementar un algoritmo para determinar si un n칰mero natural N es primo, con complejidad \\(O(\\sqrt{N})\\).\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nN칩tese que, dado un n칰mero natural \\(N\\), para verificar su primalidad es suficiente con verificar si es divisible por alg칰n entero entre \\(1\\) y \\(\\sqrt{N}\\).\nSi fuese un n칰mero compuesto, jam치s podr칤a expresarse como el producto de dos n칰meros mayores a \\(\\sqrt{N}\\).\n\\[\na &gt; \\sqrt{N}, \\quad b &gt; \\sqrt{N} \\implies a \\cdot b &gt; \\sqrt{N} \\cdot \\sqrt{N} = N\n\\]",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#el-bueno-el-malo-y-el-eficiente",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#el-bueno-el-malo-y-el-eficiente",
    "title": "游멆잺 Ejercicios",
    "section": "14 El bueno, el malo y el eficiente",
    "text": "14 El bueno, el malo y el eficiente\nSe tiene una lista con N n칰meros enteros. Se quiere saber si en la lista existe al menos un par de elementos tales que su suma sea impar.\nProponga e implemente dos algoritmos para esta tarea:\n\nUno con complejidad \\(O(N^2)\\) (cuadr치tica).\nUno con complejidad \\(O(N)\\) (lineal).",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#seamos-sinceros",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#seamos-sinceros",
    "title": "游멆잺 Ejercicios",
    "section": "15 Seamos sinceros",
    "text": "15 Seamos sinceros\nUtilizando el m칩dulo time, compare el tiempo que tardan estos dos m칠todos para determinar si una lista incluye ceros:\n\nUn bucle for que eval칰a cada elemento.\n0 in mi_lista\n\n쮺u치l es m치s r치pido? 쯈u칠 complejidad parece tener cada uno?\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nUtilice la funci칩n random.randint de NumPy para generar un arreglo grande con n칰meros al azar.\nimport numpy as np\n\nN = 3\n\n# Arreglo de n칰meros enteros aleatorios\nmi_lista = np.random.randint(0, 10**N, size=10**N)\nHaga variar el valor de N entre 3 y 6 para ver c칩mo cambia el tiempo de c칩mputo en cada m칠todo.\n(En el Ejercicio 10 de la Unidad 2 se explica c칩mo usar el m칩dulo time.)",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#seamos-originales",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#seamos-originales",
    "title": "游멆잺 Ejercicios",
    "section": "16 Seamos originales",
    "text": "16 Seamos originales\nUtilizando el m칩dulo time, compare el tiempo que tardan estos dos m칠todos para remover duplicados de una lista:\n\nConviertiendo la lista a dict y luego de nuevo a list.\nConviertiendo la lista a set y luego de nuevo a list.\n\n쮺u치l es m치s r치pido? 쯈u칠 complejidad parece tener cada uno?\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nEl primer m칠todo implica crear un diccionario a partir de una lista.\nEsto debe hacerse de forma tal que cada elemento en la lista pase a ser una clave, y a cada ella se le asigna un valor arbitrario (por ejemplo, None). De este modo, Python se encargar치 de que no haya claves duplicadas.\nPor 칰ltimo, se deber치 tomar el conjunto de claves y convertirlo a una lista. Esto devolver치 una lista similar a la original, pero sin duplicados.",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#altas-dimensiones",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#altas-dimensiones",
    "title": "游멆잺 Ejercicios",
    "section": "17 Altas dimensiones",
    "text": "17 Altas dimensiones\nImplemente un algoritmo para multiplicar dos matrices de dimensi칩n N x N.\n쯈u칠 complejidad tiene?",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#mediana-complejidad",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#mediana-complejidad",
    "title": "游멆잺 Ejercicios",
    "section": "18 Mediana complejidad",
    "text": "18 Mediana complejidad\nSe tiene una lista desordenada con 2N+1 n칰meros distintos (es decir, la lista es de tama침o impar).\nImplemente un algoritmo naive para hallar la mediana. 쯈u칠 complejidad tiene?\nLuego, utilice un algoritmo de ordenamiento que permita resolver el problema de forma m치s eficiente.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara una lista de tama침o 2N+1, la mediana es el valor tal que N elementos son menores (o iguales) a 칠l.",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#bubble-sort-eficiente",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#bubble-sort-eficiente",
    "title": "游멆잺 Ejercicios",
    "section": "19 Bubble sort eficiente",
    "text": "19 Bubble sort eficiente\nLa implementaci칩n de bubble sort en el apunte de teor칤a realiza m치s comparaciones de las necesarias. Recorre la lista de punta a punta en todas las pasadas, cuando podr칤an obviarse los elementos ya ubicados al final.\nImplemente una versi칩n de bubble sort que recorra solo la parte desordenada de la lista, sin considerar los valores ya ordenados.",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#piedra-sort",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#piedra-sort",
    "title": "游멆잺 Ejercicios",
    "section": "20 Piedra sort",
    "text": "20 Piedra sort\nEl algoritmo bubble sort recibe su nombre por la analog칤a con las burbujas que suben a la superficie, que en nuestro caso son los elementos de mayor valor que se ubican al final de la secuencia.\nImplemente una versi칩n 랄nversa a bubble sort que, en vez de 랍ubir los elementos con mayor valor a la superficie, 랃unda los de menor valor hacia el fondo como una piedra.",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#selection-sort-basado-en-m치ximos",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#selection-sort-basado-en-m치ximos",
    "title": "游멆잺 Ejercicios",
    "section": "21 Selection sort basado en m치ximos",
    "text": "21 Selection sort basado en m치ximos\nLa versi칩n de selection sort que se discute en el apunte de teor칤a se basa en buscar el m칤nimo en la parte desordenada de la lista y trasladarlo a su ubicaci칩n final.\nImplemente una versi칩n que est칠 basada en la b칰squeda y traslado del m치ximo.",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "informacion/bibliografia.html",
    "href": "informacion/bibliografia.html",
    "title": "Bibliograf칤a",
    "section": "",
    "text": "Principal\n\nCormen et마l. (2022) Downey (2024) Kalb (2022) Kubica (2022) Lott y Phillips (2021) Lott (2022) Mertz (2015) Miller, Ranum, y Yasinovskyy (2023) Sedgewick y Wayne (2011) Sedgewick, Wayne, y Dondero (2015) Sweigart (2020) Tuckfield (2021)\n\n\n\nCormen, Thomas H., Charles E. Leiserson, Ronald L. Rivest, y Clifford Stein. 2022. Introduction to Algorithms. 4th ed. MIT.\n\n\nDowney, Allen B. 2024. Think Python. 3.춹 ed. OReilly Media. https://allendowney.github.io/ThinkPython/.\n\n\nKalb, Irv. 2022. Object-Oriented Python. No Starch Press.\n\n\nKubica, Jacek. 2022. Data Structures the Fun Way. 1st ed. No Starch Press.\n\n\nLott, Steven F. 2022. Functional Python Programming. 3rd ed. Packt Publishing.\n\n\nLott, Steven F., y Dusty Phillips. 2021. Python Object-Oriented Programming. 4th ed. Packt Publishing.\n\n\nMertz, David. 2015. Functional Programming in Python. OReilly Media.\n\n\nMiller, Bradley, David Ranum, y Jan Yasinovskyy. 2023. Problem Solving with Algorithms and Data Structures Using Python. 3rd ed. Franklin, Beedle & Associates.\n\n\nSedgewick, Robert, y Kevin Wayne. 2011. Algorithms. 4th ed. Addison-Wesley Professional.\n\n\nSedgewick, Robert, Kevin Wayne, y Robert Dondero. 2015. Introduction to Programming in Python. Addison-Wesley Professional.\n\n\nSweigart, Al. 2020. Beyond the Basic Stuff with Python. No Starch Press. https://inventwithpython.com/beyond/.\n\n\nTuckfield, Bradford. 2021. Dive Into Algorithms. No Starch Press.\n\n\n\n\nComplementaria\n\nHetland (2014) Mailund (2023) Sweigart (2021) Vaughan (2019) Wickham (2019)\n\n\n\n\n\nHetland, Magnus Lie. 2014. Python Algorithms. 2.춹 ed. Apress.\n\n\nMailund, Thomas. 2023. Functional Programming in R 4. 2.춹 ed. Apress.\n\n\nSweigart, Al. 2021. The Big Book of Small Python Projects. No Starch Press. https://inventwithpython.com/bigbookpython/.\n\n\nVaughan, Lee. 2019. Impractical Python Projects. No Starch Press.\n\n\nWickham, Hadley. 2019. Advanced R. 2.춹 ed. Chapman & Hall/CRC. https://adv-r.hadley.nz/.",
    "crumbs": [
      "Informaci칩n",
      "Bibliograf칤a"
    ]
  },
  {
    "objectID": "informacion/calendario.html",
    "href": "informacion/calendario.html",
    "title": "Calendario",
    "section": "",
    "text": "Semana\nFecha\nTemas\nOtras actividades\n\n\n\n\n1\n4 de agosto\n Lenguaje Python y su ecosistema. Uso de Python en la terminal. Uso de Positron. Python en Positron. Python: expresiones; variables y asignaciones; tipos de datos elementales; operadores num칠ricos, de comparaci칩n y l칩gicos. Jupyter Notebooks. Definici칩n de funciones. Ejecuci칩n condicional de c칩digo.\n\n\n\n2\n11 de agosto\n Colecciones de datos en Python: list, tuple, dict y set. Secuencias. Las secuencias str y range. Bucles definidos (for) y no definidos (while). Sentencias break y continue.\n\n\n\n3\n17 de agosto\n Uso de c칩digo externo (propio y de terceros). M칩dulos y librer칤as. Librer칤a est치ndar de Python. Instalaci칩n y gesti칩n de librer칤as. Scripting. Modularizaci칩n de programas. Lectura y escritura de archivos de texto plano.\n\n\n\n4\n25 de agosto\n Funciones como ciudadanos de primera clase. Funciones puras. Funciones an칩nimas. Closures. Recursi칩n.\n\n\n\n5\n1 de septiembre\n Funciones de orden superior: map, filter, reduce. Evaluaci칩n estricta y no estricta. Evaluaci칩n perezosa (lazy) e inmediata (eager). Generadores. Aplicaci칩n parcial de funciones. Decoradores.\n\n\n\n6\n15 de septiembre\n Objetos, clases e instancias. Atributos y m칠todos. Propiedades p칰blicas y privadas. M칠todos de clase y m칠todos de instancia.\n\n\n\n7\n22 de septiembre\n Encapsulamiento. Herencia simple y m칰ltiple. Polimorfismo. Abstracci칩n.\n\n\n\n8\n29 de septiembre\n M칠todos especiales (dunder methods). Decoradores aplicados a m칠todos. Sobrecarga de operadores.\nParcial\n\n\n9\n6 de octubre\n Concepto y clasificaci칩n. Estructuras lineales y no lineales. Listas y listas enlazadas. Operaciones b치sicas: agregar, quitar y recorrer.\nPresentaci칩n TP Grupal\n\n\n10\n13 de octubre\n Hashing. Diccionarios y conjuntos como estructuras asociativas. 츼rboles y grafos.\nRecuperatorio\n\n\n11\n20 de octubre\n Arreglos multidimensionales de NumPy.\n\n\n\n12\n27 de octubre\n Concepto de algoritmo y complejidad. Algoritmos de b칰squeda. B칰squeda lineal y binaria. Notaci칩n Big O.\n\n\n\n13\n3 de noviembre\n Algoritmos de ordenamiento. bubble sort, insert sort, select sort, quick sort y merge sort. Comparaci칩n de algoritmos de ordenamiento.\nEntrega TP GrupalPresentaci칩n TP Individual\n\n\n14\n10 de noviembre\n Funciones de b칰squeda y ordenamiento en Python.\n\n\n\n15\n17 de noviembre\n\n\n\n\n16\n24 de noviembre\n\nEntrega y defensa TP Individual",
    "crumbs": [
      "Informaci칩n",
      "Calendario"
    ]
  },
  {
    "objectID": "informacion/programa.html",
    "href": "informacion/programa.html",
    "title": "Programa",
    "section": "",
    "text": "Los profesionales en Estad칤stica y Ciencia de Datos necesitan contar con habilidades avanzadas de programaci칩n, que les permitan abordar problemas complejos y desarrollar soluciones eficientes y robustas.\nLa asignatura Programaci칩n 2 introduce a los estudiantes a conceptos y pr치cticas avanzadas de la programaci칩n, incorporando herramientas y paradigmas que resultan fundamentales para el desarrollo profesional en Estad칤stica y Ciencia de Datos.\nLa asignatura profundiza en enfoques como la programaci칩n funcional y la programaci칩n orientada a objetos, promoviendo el desarrollo de soluciones estructuradas, reutilizables, robustas y escalables. Adem치s, se abordan conceptos fundamentales de estructuras de datos y algoritmos, relevantes para el dise침o y an치lisis de programas eficientes, as칤 como para la comprensi칩n de la complejidad computacional. Se focaliza en el lenguaje Python, ampliamente utilizado en la industria y la academia por su versatilidad, su ecosistema de librer칤as y su capacidad para integrarse con diversas tecnolog칤as.\nDictada en el segundo cuatrimestre del primer a침o, Programaci칩n 2 completa los contenidos del 치rea de Fundamentos Computacionales en el Ciclo de Formaci칩n T칠cnica en Estad칤stica y Ciencia de Datos, iniciada en el primer cuatrimestre con Programaci칩n 1. De este modo, consolida las competencias inform치ticas de los estudiantes y los prepara para afrontar asignaturas m치s avanzadas y desaf칤os profesionales que requieren un dominio s칩lido de la programaci칩n. Asimismo, fomenta buenas pr치cticas de desarrollo de c칩digo, el uso eficiente de los recursos computacionales y el pensamiento cr칤tico en la resoluci칩n de problemas.",
    "crumbs": [
      "Informaci칩n",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/programa.html#fundamentaci칩n",
    "href": "informacion/programa.html#fundamentaci칩n",
    "title": "Programa",
    "section": "",
    "text": "Los profesionales en Estad칤stica y Ciencia de Datos necesitan contar con habilidades avanzadas de programaci칩n, que les permitan abordar problemas complejos y desarrollar soluciones eficientes y robustas.\nLa asignatura Programaci칩n 2 introduce a los estudiantes a conceptos y pr치cticas avanzadas de la programaci칩n, incorporando herramientas y paradigmas que resultan fundamentales para el desarrollo profesional en Estad칤stica y Ciencia de Datos.\nLa asignatura profundiza en enfoques como la programaci칩n funcional y la programaci칩n orientada a objetos, promoviendo el desarrollo de soluciones estructuradas, reutilizables, robustas y escalables. Adem치s, se abordan conceptos fundamentales de estructuras de datos y algoritmos, relevantes para el dise침o y an치lisis de programas eficientes, as칤 como para la comprensi칩n de la complejidad computacional. Se focaliza en el lenguaje Python, ampliamente utilizado en la industria y la academia por su versatilidad, su ecosistema de librer칤as y su capacidad para integrarse con diversas tecnolog칤as.\nDictada en el segundo cuatrimestre del primer a침o, Programaci칩n 2 completa los contenidos del 치rea de Fundamentos Computacionales en el Ciclo de Formaci칩n T칠cnica en Estad칤stica y Ciencia de Datos, iniciada en el primer cuatrimestre con Programaci칩n 1. De este modo, consolida las competencias inform치ticas de los estudiantes y los prepara para afrontar asignaturas m치s avanzadas y desaf칤os profesionales que requieren un dominio s칩lido de la programaci칩n. Asimismo, fomenta buenas pr치cticas de desarrollo de c칩digo, el uso eficiente de los recursos computacionales y el pensamiento cr칤tico en la resoluci칩n de problemas.",
    "crumbs": [
      "Informaci칩n",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/programa.html#objetivos",
    "href": "informacion/programa.html#objetivos",
    "title": "Programa",
    "section": "Objetivos",
    "text": "Objetivos\nQue los estudiantes logren:\n\nanalizar problemas computacionales y formular soluciones algor칤tmicas adecuadas;\nimplementar esas soluciones mediante el desarrollo de programas en Python, seleccionando estructuras de datos apropiadas y evaluando la eficiencia de los algoritmos involucrados;\nidentificar y aplicar los paradigmas funcional y orientado a objetos cuando resulte pertinente, desarrollando programas que integren estos enfoques; y\nutilizar e integrar m칩dulos y librer칤as que permitan extender, organizar y mejorar las funcionalidades de sus programas.",
    "crumbs": [
      "Informaci칩n",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/programa.html#contenidos",
    "href": "informacion/programa.html#contenidos",
    "title": "Programa",
    "section": "Contenidos",
    "text": "Contenidos\n\nUnidad 1: Introducci칩n a Python\n\nLenguaje Python y su ecosistema. Uso de la interfaz Positron. Sintaxis de Python. Expresiones. Variables y asignaciones. Tipos de datos elementales. Operadores num칠ricos, de comparaci칩n y l칩gicos. Funciones. Ejecuci칩n condicional de c칩digo. Bucles definidos y no definidos. Listas, tuplas y diccionarios. Uso de c칩digo externo. M칩dulos y librer칤as. Librer칤a est치ndar de Python. Instalaci칩n y gesti칩n de librer칤as. Scripting. Lectura y escritura de archivos de texto plano. Modularizaci칩n de programas.\n\nUnidad 2: Programaci칩n funcional\n\nPrincipios fundamentales. Funciones como ciudadanos de primera clase. Funciones puras. Funciones an칩nimas. Closures. Recursi칩n. Funciones de orden superior: map, filter, reduce. Evaluaci칩n estricta y no estricta. Evaluaci칩n perezosa (lazy) e inmediata (eager). Generadores. Aplicaci칩n parcial de funciones. Decoradores.\n\nUnidad 3: Programaci칩n orientada a objetos\n\nPrincipios fundamentales. Objetos, clases e instancias. Atributos y m칠todos. Propiedades p칰blicas y privadas. M칠todos de clase y m칠todos de instancia. Encapsulamiento. Herencia simple y m칰ltiple. Polimorfismo. M칠todos especiales (dunder methods). Decoradores aplicados a m칠todos. Sobrecarga de operadores.\n\nUnidad 4: Estructuras de datos\n\nConcepto y clasificaci칩n. Estructuras lineales: listas, listas enlazadas, pilas y colas. Operaciones b치sicas: agregar, quitar y recorrer. Estructuras no lineales: 치rboles y grafos. Recorridos de 치rboles y grafos. Uso de colecciones de Python (list, deque, dict, set). Arreglos multidimensionales de NumPy.\n\nUnidad 5: Algoritmos de b칰squeda y ordenamiento\n\nConcepto de algoritmo y complejidad. Notaci칩n Big O. B칰squeda lineal y binaria. Algoritmos de ordenamiento: bubble sort, insertion sort, selection sort, quick sort y merge sort. Comparaci칩n de eficiencia. Funciones de b칰squeda y ordenamiento en Python (sorted, sort, heapq).",
    "crumbs": [
      "Informaci칩n",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/aprobacion.html",
    "href": "informacion/aprobacion.html",
    "title": "Condiciones de aprobaci칩n",
    "section": "",
    "text": "游닇 Examen parcial: individual y escrito. Hay un recuperatorio, de similares caracter칤sticas, que reemplaza la nota del parcial.\n游뱋 Trabajo pr치ctico grupal: se hace fuera de clase, en grupos de entre dos y tres integrantes.\n游븸꽳눹 Trabajo pr치ctico individual: opcional para promoci칩n, con presentaci칩n y defensa oral.\nTodas las instancias se califican en una escala de 0 a 10 y se aprueban con 6.",
    "crumbs": [
      "Informaci칩n",
      "Condiciones de aprobaci칩n"
    ]
  },
  {
    "objectID": "informacion/aprobacion.html#instancias-de-evaluaci칩n",
    "href": "informacion/aprobacion.html#instancias-de-evaluaci칩n",
    "title": "Condiciones de aprobaci칩n",
    "section": "",
    "text": "游닇 Examen parcial: individual y escrito. Hay un recuperatorio, de similares caracter칤sticas, que reemplaza la nota del parcial.\n游뱋 Trabajo pr치ctico grupal: se hace fuera de clase, en grupos de entre dos y tres integrantes.\n游븸꽳눹 Trabajo pr치ctico individual: opcional para promoci칩n, con presentaci칩n y defensa oral.\nTodas las instancias se califican en una escala de 0 a 10 y se aprueban con 6.",
    "crumbs": [
      "Informaci칩n",
      "Condiciones de aprobaci칩n"
    ]
  },
  {
    "objectID": "informacion/aprobacion.html#condiciones-de-aprobaci칩n",
    "href": "informacion/aprobacion.html#condiciones-de-aprobaci칩n",
    "title": "Condiciones de aprobaci칩n",
    "section": "Condiciones de aprobaci칩n",
    "text": "Condiciones de aprobaci칩n\n\nPromoci칩n\n\nQuienes aprueben el parcial individual (con nota \\(\\text{P}\\)), el trabajo pr치ctico grupal (con nota \\(\\text{T}\\)) y el trabajo pr치ctico individual con defensa oral (con nota \\(\\text{O}\\)), adquieren la condici칩n de estudiante promovido y su nota final se calcula como \\(0.5 \\times \\text{P} + 0.2 \\times \\text{T} + 0.3 \\times \\text{O}\\).\n\nRegularidad\n\nQuienes aprueben el parcial individual (o su recuperatorio) y el trabajo pr치ctico grupal, pero no accedan o no aprueben el trabajo pr치ctico individual, adquieren la condici칩n de estudiante regular.\n\nLibres\n\nQuienes no aprueben el parcial individual (ni su recuperatorio) o el trabajo pr치ctico grupal, adquieren la condici칩n de estudiante libre.",
    "crumbs": [
      "Informaci칩n",
      "Condiciones de aprobaci칩n"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html",
    "href": "practica/03_oop/ejercicios.html",
    "title": "游멆잺 Ejercicios",
    "section": "",
    "text": "Defina una clase Contador que represente un contador num칠rico. Por defecto, las instancias comienzan con el valor 0, aunque debe permitirse inicializarlas con un valor distinto.\nImplemente los siguientes m칠todos:\n\nincrementar: aumenta el valor del contador en una cantidad arbitraria (por defecto, 1).\ndecrementar: disminuye el valor del contador en una cantidad arbitraria (por defecto, 1).\nreiniciar: restablece el contador a su valor inicial (춰que puede ser distinto de 0!).\nvalor: devuelve el valor actual del contador.\n\nEjemplo de uso\ncontador = Contador()\ncontador.incrementar(5)    # El valor interno es 5\ncontador.decrementar(2)    # El valor interno es 3\nprint(contador.valor())    # Imprime 3\ncontador.reiniciar()\nprint(contador.valor())    # Imprime 0",
    "crumbs": [
      "Pr치ctica",
      "U3 - Programaci칩n Orientada a Objetos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html#contador",
    "href": "practica/03_oop/ejercicios.html#contador",
    "title": "游멆잺 Ejercicios",
    "section": "",
    "text": "Defina una clase Contador que represente un contador num칠rico. Por defecto, las instancias comienzan con el valor 0, aunque debe permitirse inicializarlas con un valor distinto.\nImplemente los siguientes m칠todos:\n\nincrementar: aumenta el valor del contador en una cantidad arbitraria (por defecto, 1).\ndecrementar: disminuye el valor del contador en una cantidad arbitraria (por defecto, 1).\nreiniciar: restablece el contador a su valor inicial (춰que puede ser distinto de 0!).\nvalor: devuelve el valor actual del contador.\n\nEjemplo de uso\ncontador = Contador()\ncontador.incrementar(5)    # El valor interno es 5\ncontador.decrementar(2)    # El valor interno es 3\nprint(contador.valor())    # Imprime 3\ncontador.reiniciar()\nprint(contador.valor())    # Imprime 0",
    "crumbs": [
      "Pr치ctica",
      "U3 - Programaci칩n Orientada a Objetos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html#magia-para-programadores",
    "href": "practica/03_oop/ejercicios.html#magia-para-programadores",
    "title": "游멆잺 Ejercicios",
    "section": "2 Magia para programadores",
    "text": "2 Magia para programadores\nEsta es tu primera clase de Pociones en Hogwarts y el profesor te dio como tarea descubrir de qu칠 color se volver치 una poci칩n si se mezcla con otra. Todas las pociones tienen un color definido en formato RGB, desde [0, 0, 0] hasta [255, 255, 255].\nPara complicar un poco m치s la tarea, el profesor realizar치 varias mezclas seguidas y luego te preguntar치 por el color final. Adem치s del color, tambi칠n deber치s calcular qu칠 volumen tendr치 la poci칩n despu칠s de la mezcla final.\nGracias a tu experiencia en programaci칩n descubriste que al mezclar dos pociones, los colores se combinan como si se mezclaran dos colores en formato RGB. Por ejemplo, si mezclas una poci칩n con color [255, 255, 0] y volumen 10 con otra de color [0, 254, 0] y volumen 5, obtendr치s una nueva poci칩n con:\n\ncolor [170, 255, 0]\nvolumen 15\n\nPor lo tanto, decid칤s crear una clase Pocion que tenga:\n\ndos propiedades:\n\ncolor (una lista o tupla con 3 enteros)\nvolumen (un n칰mero)\n\nun m칠todo mezclar que acepte otra Pocion y devuelva una nueva Pocion ya mezclada.\n\nEjemplo:\nfelix_felicis = Pocion([255, 255, 255],  7)\npocion_multijugos = Pocion([51, 102, 51], 12)\nnueva_pocion = felix_felicis.mezclar(pocion_multijugos)\n\nnueva_pocion.color # Devuelve [127, 159, 127]\nnueva_pocion.volumen # Devuelve 19\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nLos colores de las pociones deben representarse como tr칤os de n칰meros enteros en formato RGB. Al realizar una mezcla de colores, se debe redondear hacia arriba utilizando math.ceil.",
    "crumbs": [
      "Pr치ctica",
      "U3 - Programaci칩n Orientada a Objetos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html#mensaje-secreto",
    "href": "practica/03_oop/ejercicios.html#mensaje-secreto",
    "title": "游멆잺 Ejercicios",
    "section": "3 Mensaje secreto",
    "text": "3 Mensaje secreto\nUn cifrado por sustituci칩n simple reemplaza cada car치cter de un alfabeto con un car치cter de un alfabeto alternativo. Cada posici칩n en el alfabeto original se mapea a la posici칩n correspondiente en el alfabeto alternativo, y esto sirve tanto para codificar como para decodificar.\nEl objetivo es crear una clase que, al inicializarse, reciba dos alfabetos (original y alternativo). La clase debe tener un m칠todo para encriptar mensajes y otro para revertir la encriptaci칩n.\nEjemplo:\nalfabeto = \"abcdefghijklmnopqrstuvwxyz\"\nalfabeto_mezclado = \"etaoinshrdlucmfwypvbgkjqxz\"\n\nmi_cifrado = Cifrado(alfabeto, alfabeto_mezclado)\n\nmi_cifrado.codificar(\"abc\")    # =&gt; \"eta\"\nmi_cifrado.codificar(\"xyz\")    # =&gt; \"qxz\"\nmi_cifrado.codificar(\"aeiou\")  # =&gt; \"eirfg\"\n\nmi_cifrado.decodificar(\"eta\")    # =&gt; \"abc\"\nmi_cifrado.decodificar(\"qxz\")    # =&gt; \"xyz\"\nmi_cifrado.decodificar(\"eirfg\")  # =&gt; \"aeiou\"\n\nPunto extra\nVerifique en el m칠todo __init__ que la longitud de los alfabetos sea la misma. Caso contrario, levante una excepci칩n ValueError indicando cu치l es el problema.",
    "crumbs": [
      "Pr치ctica",
      "U3 - Programaci칩n Orientada a Objetos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html#real-envido",
    "href": "practica/03_oop/ejercicios.html#real-envido",
    "title": "游멆잺 Ejercicios",
    "section": "4 Real envido",
    "text": "4 Real envido\nConstruir una clase ManoDeTruco que, al inicializarse, reciba una lista o tupla de hasta tres n칰meros enteros, correspondientes a los valores de las cartas en una mano de truco.\nLa clase debe incluir un m칠todo llamado comparar_con que recibe otra mano de truco y determine cu치l de las dos suma m치s puntos para el envido. En caso de empate, se considera ganadora la mano que invoc칩 el m칠todo.\nEjemplo de uso\nmano1 = ManoDeTruco([7, 5, 6])\nmano2 = ManoDeTruco([4, 11, 2])\n\nganadora = mano1.comparar_con(mano2)\n\n\n\n\n\n\nConsideraciones\n\n\n\n\n\n\nAsuma que todas las cartas cargadas en la mano son del mismo palo.\nPara calcular los puntos del envido, solo se consideran dos de las tres cartas, no la suma de las tres.",
    "crumbs": [
      "Pr치ctica",
      "U3 - Programaci칩n Orientada a Objetos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html#la-muestra-infinita",
    "href": "practica/03_oop/ejercicios.html#la-muestra-infinita",
    "title": "游멆잺 Ejercicios",
    "section": "5 La muestra infinita",
    "text": "5 La muestra infinita\nDefina una clase Muestra que represente un conjunto de datos num칠ricos. La clase debe inicializarse a partir de un iterable de n칰meros e implementar los siguientes m칠todos:\n\nagregar(x): agrega un n칰mero a la muestra.\nn(): devuelve la cantidad de elementos.\nsuma(): devuelve la suma de los valores.\nmedia(): devuelve el promedio de los valores.\nvarianza(muestral=False): calcula la varianza.\n\nSi muestral=False, se usa el denominador n (varianza poblacional).\nSi muestral=True, se usa el denominador n-1 (varianza muestral).\n\n\nEjemplo de uso\nmuestra = Muestra([10, 12, 13, 15])\nmuestra.agregar(20)\nmuestra.n()                     # 5\nmuestra.suma()                  # 70\nmuestra.media()                 # 14.0\nmuestra.varianza()              # varianza poblacional\nmuestra.varianza(muestral=True) # varianza muestral\n\nPunto extra\nModifique la clase para que:\n\nGuarde los datos en un atributo 랋rivado llamado _datos.\nProvea una propiedad de solo lectura valores, que devuelva una copia inmutable de los datos (por ejemplo, una tupla).",
    "crumbs": [
      "Pr치ctica",
      "U3 - Programaci칩n Orientada a Objetos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html#orden-en-el-laboratorio",
    "href": "practica/03_oop/ejercicios.html#orden-en-el-laboratorio",
    "title": "游멆잺 Ejercicios",
    "section": "6 춰Orden en el laboratorio!",
    "text": "6 춰Orden en el laboratorio!\nEn un laboratorio se necesita llevar un registro ordenado de los experimentos realizados. Cada experimento debe contar con un n칰mero identificador 칰nico, un nombre y, de manera opcional, el nombre de la persona responsable.\nEl objetivo de este ejercicio es construir una clase que facilite dicha organizaci칩n.\nPara ello, implemente una clase llamada Experimento que se inicializa con el nombre del experimento y, opcionalmente, con el nombre del responsable. La clase debe asignar autom치ticamente un n칰mero identificador 칰nico a cada instancia. Para lograrlo, utilice un atributo de clase llamado total_creados, que comience en 0.\nCada instancia debe contar con:\n\nUn identificador num칠rico 칰nico (asignado autom치ticamente de forma incremental por la clase).\nUn nombre.\nUn responsable, si se proporciona.\n\nEjemplo de uso\ne1 = Experimento(\"Piloto A\", responsable=\"Dolores\")\ne2 = Experimento(\"Piloto Z\")\nExperimento.total_creados  # Devuelve 2\n\nPuntos extra\nModifique la clase para que tambi칠n:\n\nSe puedan crear objetos utilizando un m칠todo de clase llamado desde_dict que reciba un diccionario de la forma {\"nombre\": ..., \"responsable\": ...} y devuelva una instancia de Experimento.\nImplemente el m칠todo m치gico __repr__ que devuelva una cadena de texto con el siguiente formato: python     Experimento(id=1, nombre=\"A/B\", responsable=\"Sosa\")\n\nEjemplo de uso\ne = Experimento.desde_dict({\"nombre\": \"Piloto B\", \"responsable\": \"Ana\"})\nrepr(e)\n# Experimento(id=3, nombre=\"Piloto B\", responsable=\"Ana\")",
    "crumbs": [
      "Pr치ctica",
      "U3 - Programaci칩n Orientada a Objetos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html#sensores-descalibrados",
    "href": "practica/03_oop/ejercicios.html#sensores-descalibrados",
    "title": "游멆잺 Ejercicios",
    "section": "7 Sensores descalibrados",
    "text": "7 Sensores descalibrados\nEste ejercicio requiere dise침ar una peque침a jerarqu칤a de clases para simular sensores utilizados en un laboratorio.\nEn la pr치ctica, los sensores no siempre son completamente precisos: pueden registrar valores ligeramente superiores o inferiores al valor real. Para corregir ese desv칤o, se aplica una calibraci칩n, que consiste en ajustar las lecturas mediante un valor adicional o corrector llamado offset.\n\nJerarqu칤a de clases\nClase base: Sensor\nLa clase Sensor debe incluir:\n\nUn atributo nombre para identificar al sensor.\nUn m칠todo leer que levante una excepci칩n NotImplementedError, indicando que debe ser implementado por las subclases.\nUn m칠todo calibrar(offset) que permita almacenar un valor de ajuste (offset) que se aplicar치 a las lecturas.\n\nSubclases\nSe deben definir dos subclases: SensorTemperatura y SensorHumedad, ambas con su propia implementaci칩n del m칠todo leer:\n\nSensorTemperatura: simula una medici칩n utilizando random.uniform(18, 28).\nSensorHumedad: simula una medici칩n utilizando random.uniform(30, 70).\n\nEn ambos casos, la medici칩n debe ser ajustada por el offset correspondiente (si fue calibrado).\n\n\nFunci칩n auxiliar\nAdem치s, implemente una funci칩n llamada promedio_lecturas que reciba dos argumentos: una secuencia de sensores y un n칰mero entero n, que indica cu치ntas lecturas realizar con cada sensor.\nLa funci칩n debe realizar n lecturas para cada sensor utilizando su m칠todo leer, calcular el promedio de esas lecturas y devolver un diccionario que asocie el nombre de cada sensor con su promedio correspondiente.\nEjemplo de uso\nst = SensorTemperatura(\"T1\")\nsh = SensorHumedad(\"H1\")\nst.calibrar(0.5)\n\npromedios = promedio_lecturas([st, sh], n=3)\n# {'T1': ..., 'H1': ...}",
    "crumbs": [
      "Pr치ctica",
      "U3 - Programaci칩n Orientada a Objetos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html#python-para-matem치ticos",
    "href": "practica/03_oop/ejercicios.html#python-para-matem치ticos",
    "title": "游멆잺 Ejercicios",
    "section": "8 Python para matem치ticos",
    "text": "8 Python para matem치ticos\nConstruya una clase Fraccion que acepte dos argumentos: numerador y denominador. Se desea que esta clase:\n\nSea representable como cadena de texto.\nImplemente la suma entre fracciones.\nDevuelva siempre el resultado en la m칤nima representaci칩n posible (fracci칩n irreducible).\n\nEjemplo:\nfraccion1 = Fraccion(4, 5)\nprint(fraccion1 + Fraccion(1, 8))\n#&gt; \"37/40\"\n\nPunto extra\nExtender la funcionalidad de la clase incluyendo las operaciones de resta, multiplicaci칩n y divisi칩n.",
    "crumbs": [
      "Pr치ctica",
      "U3 - Programaci칩n Orientada a Objetos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html#tiempo-al-tiempo",
    "href": "practica/03_oop/ejercicios.html#tiempo-al-tiempo",
    "title": "游멆잺 Ejercicios",
    "section": "9 Tiempo al tiempo 낍",
    "text": "9 Tiempo al tiempo 낍\nEl m칩dulo est치ndar datetime de Python incluye, entre otras cosas, la clase date para trabajar con fechas. El objetivo de este ejercicio es implementar, desde cero, una nueva clase Date que permita representar fechas y operar con ellas.\n\nPrimera implementaci칩n\n\nConstruya la clase Date. El m칠todo __init__ debe tomar 3 par치metros: year, month y day, y asignarlos como atributos de la instancia. Cree un objeto que represente el 6 de noviembre de 1995 y verifique que los atributos contengan los valores esperados.\nImplemente el m칠todo __str__, que debe devolver una cadena con el formato YYYY-MM-DD, donde YYYY representa el a침o, MM el mes y DD el d칤a. Ayuda: Puede utilizar el m칠todo .rjust de las cadenas de texto para agregar ceros a la izquierda cuando sea necesario. Por ejemplo, para el 6 de noviembre de 1995, str(fecha) debe devolver \"1995-11-06\".\nImplemente el m칠todo __repr__, que debe devolver una representaci칩n similar a la utilizada para crear la instancia. Para la fecha 6 de noviembre de 1995, debe devolver la cadena \"Date(year=1995, month=11, day=6)\".\nImplemente un m칠todo de clase que permita crear una Date a partir de una cadena en formato YYYY-MM-DD. Por ejemplo, Date.from_str(\"2025-03-08\") debe devolver un objeto Date que representa al 8 de marzo de 2025. Ayuda: Puede utilizar el m칠todo .lstrip(\"0\") para eliminar ceros a la izquierda en una cadena.\nImplemente los m칠todos de comparaci칩n entre objetos Date.\n\n__eq__: igualdad (==)\n__ne__: desigualdad (!=)\n__lt__: menor que (&lt;)\n__gt__: mayor que (&gt;)\n__le__: menor o igual que (&lt;=)\n__ge__: mayor o igual que (&gt;=)\n\nAyuda: Dos fechas se consideran iguales si sus atributos year, month, y day coinciden. Para las comparaciones, considere primero el a침o, luego el mes y finalmente el d칤a.\n\n\n\nA prueba de balas\nA esta altura, se cuenta con una implementaci칩n razonablemente completa y funcional para representar objetos de tipo fecha. Sin embargo, la clase Date no garantiza la validez ni la robustez de las instancias que se crean. Es posible construir objetos Date que representen fechas inv치lidas, como el 31 de abril o el 55.8 del mes 25.3, y operar con ellos sin que el programa emita ning칰n tipo de advertencia.\n\nModifique la implementaci칩n de los atributos year, month y day de modo que sean privados y que su asignaci칩n incluya una verificaci칩n de validez. Para ello, se propone lo siguiente:\n\nUtilice atributos privados llamados _year, _month y _day.\nDefina m칠todos year, month y day, decorados con @property, que expongan dichos atributos para su lectura. Estos m칠todos deben devolver el valor del atributo correspondiente.\nPara permitir la asignaci칩n controlada, implemente un setter para cada atributo Para ello, decore el mismo m칠todo con @&lt;nombre&gt;.setter (por ejemplo, @year.setter) y defina all칤 la l칩gica de verificaci칩n. Por el momento, verifique 칰nicamente que el valor asignado sea un n칰mero entero y positivo. Eleve un ValueError en caso de que el valor por asignar no pase la verificaci칩n.\n\n\nUtilice los siguientes ejemplos de verificaci칩n\nd = Date(2022, 7, 1)\nrepr(d) # Date(year=2022, month=7, day=1)\nstr(d)  # \"2022-07-01\"\n(d.year, d.month, d.day) # (2022, 7, 1)\nDate(2022, 0, 1)       # Falla: el mes no es positivo\nDate(2022, 3, 5.5)     # Falla: el d칤a no es un entero\nDate(\"11\", 3, 1)       # Falla: el a침o es una cadena de texto\nd = Date(2022, 7, 1)\nd.day = 11             # Funciona: pasa la verificaci칩n\nstr(d)                 # \"2022-07-11\"\n\nd.month = -1           # Falla\nd.year = -1            # Falla\n\nMejore ahora las verificaciones de los valores asignados para que sean m치s robustas:\n\nEl a침o debe ser entero y mayor o igual a 0.\nEl mes debe ser un n칰mero entero entre 1 y 12 inclusive.\nEl d칤a debe ser un n칰mero entero mayor o igual a 1 y menor o igual a la cantidad de d칤as del mes correspondiente.\n\n\nLa cantidad de d칤as depende del mes. Para todos los meses excepto febrero, utilice el diccionario provisto en la ayuda debajo. Para el caso de febrero, implemente un m칠todo est치tico que reciba un a침o como argumento y devuelva un booleano indicando si ese a침o es bisiesto.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nDiccionario de d칤as por mes:\nDOM = {\n    1: 31,  # Enero\n    2: 28,  # Febrero (29 en a침o bisiesto)\n    3: 31,  # Marzo\n    4: 30,  # Abril\n    5: 31,  # Mayo\n    6: 30,  # Junio\n    7: 31,  # Julio\n    8: 31,  # Agosto\n    9: 30,  # Septiembre\n    10: 31, # Octubre\n    11: 30, # Noviembre\n    12: 31, # Diciembre\n}\n\nDOM[5] # Devuelve 31, porque es mayo\nPor otro lado, un a침o es bisiesto si:\n\nEs divisible por 4,\nexcepto que sea divisible por 100,\nsalvo que tambien sea divisibles por 400\n\nEn Python\n(year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)\n\n\n\nFinalmente, verifique que su clase Date funciona correctamente con los siguientes ejemplos:\n# Definici칩n de fechas\nd1 = Date(1990, 5, 20)\nd2 = Date(1998, 9, 21)\nd3 = Date(1998, 9, 20)\nd4 = Date(2022, 12, 18)\n\nd1 &lt; d2\nd1 &gt; d2\nd1 != d3\nd4 &gt;= d3\n\nDate(2000, 2, 29) # Funciona, es bisiesto\nDate(2001, 2, 29) # Falla, no es bisiesto\n\n\nl = [d1, d2, d3, d4]\nsorted(l) # Funciona, 쯣or qu칠?",
    "crumbs": [
      "Pr치ctica",
      "U3 - Programaci칩n Orientada a Objetos",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/autoevaluacion.html",
    "href": "practica/04_estructuras_y_algoritmos/autoevaluacion.html",
    "title": "游 Autoevaluaci칩n",
    "section": "",
    "text": "Para un arreglo que contiene 100 elementos, indica la cantidad de pasos que llevar칤an las siguientes operaciones:\n\nLectura\nB칰squeda de un valor que no est치 contenido en el arreglo\nInserci칩n al inicio del arreglo\nInserci칩n al final del arreglo\nEliminaci칩n al inicio del arreglo\nEliminaci칩n al final del arreglo\n\nPara un conjunto basado en un arreglo que contiene 100 elementos, indica la cantidad de pasos que llevar칤an las siguientes operaciones:\n\nLectura\nB칰squeda de un valor que no est치 contenido en el conjunto\nInserci칩n de un nuevo valor al inicio del conjunto\nInserci칩n de un nuevo valor al final del conjunto\nEliminaci칩n al inicio del conjunto\nEliminaci칩n al final del conjunto\n\nEn general, la operaci칩n de b칰squeda en un arreglo busca la primera instancia de un valor dado. Pero a veces queremos buscar todas las instancias de un valor determinado. Por ejemplo, supongamos que queremos contar cu치ntas veces aparece el valor \"manzana\" dentro de un arreglo. 쮺u치ntos pasos tomar칤a encontrar todas las apariciones de \"manzana\"? Da tu respuesta en funci칩n de N.\nUse la notaci칩n Big O para describir la complejidad temporal de las siguientes funciones:\ndef es_bisiesto(valor):\n    if valor % 100 == 0:\n        if valor % 400 == 0:\n            return False\n        else:\n            return True\n    return valor % 4 == 0\ndef suma(arreglo):\n    total = 0\n    for numero in arreglo:\n        total += numero\n    return total\nLa siguiente funci칩n recibe un arreglo de cadenas y devuelve un nuevo arreglo que solo contiene las cadenas que comienzan con la letra \"a\". Use la notaci칩n Big O para describir la complejidad temporal de la funci칩n:\ndef seleccionar_cadenas_a(arreglo):\n    arreglo_nuevo = []\n    for cadena in arreglo:\n        if cadena[0] == \"a\":\n            arreglo_nuevo.append(cadena)\n    return arreglo_nuevo\nLa siguiente funci칩n calcula la mediana de un arreglo ordenado. Describa su complejidad temporal en t칠rminos de la notaci칩n Big O:\ndef mediana(arreglo):\n    if not arreglo:\n        return None\n\n    medio = len(arreglo) // 2\n\n    # Si el arreglo tiene una cantidad par de n칰meros:\n    if len(arreglo) % 2 == 0:\n        return (arreglo[medio - 1] + arreglo[medio]) / 2.0\n    else:  # Si el arreglo tiene una cantidad impar de n칰meros:\n        return arreglo[medio]\nReemplace los signos de interrogaci칩n en la siguiente tabla para describir cu치ntos pasos ocurren para una cantidad dada de elementos de datos, seg칰n distintos tipos de Big O:\n\n\n\nN elementos\nO(N)\nO(log N)\nO(N)\n\n\n\n\n100\n100\n?\n?\n\n\n2000\n?\n?\n?\n\n\n\nLa siguiente funci칩n encuentra el producto m치s grande posible entre cualquier par de n칰meros dentro de un arreglo dado. Us치 la notaci칩n Big O para describir la complejidad temporal de la siguiente funci칩n:\ndef greatest_product(arreglo):\n    if len(producto_mas_grande) &lt; 2:\n        return None\n\n    producto_mas_grande = arreglo[0] * arreglo[1]\n\n    for i, valor_i in enumerate(arreglo):\n        for j, valor_j in enumerate(arreglo):\n            if (i != j and valor_i * valor_j &gt; producto_mas_grande):\n                producto_mas_grande = valor_i * valor_j\n\n    return producto_mas_grande\nLa siguiente funci칩n verifica si un arreglo de n칰meros contiene un par de n칰meros cuya suma sea igual a 10:\ndef suma_de_pares(arreglo):\n    for i, valor_i in enumerate(arreglo):\n        for j, valor_j in enumerate(arreglo):\n            if (i != j) and (valor_i + valor_j == 10):\n                return True\n    return False\n\n쮺u치l es el mejor caso, el caso promedio y el peor caso?\nExprese el peor caso en t칠rminos de notaci칩n Big O.\n\nLa siguiente funci칩n encuentra el n칰mero m치s grande dentro de un arreglo, pero tiene una eficiencia de O(N). Reescrib칤 la funci칩n para que sea una versi칩n m치s r치pida, con eficiencia O(N):\ndef maximo(arreglo):\n    if not arreglo:\n        return None\n\n    for i in arreglo:\n        # Supongamos por ahora que i es el mayor\n        es_i_el_mas_grande = True\n\n        for j in arreglo:\n            # Si encontramos otro valor mayor que i, i no es el mayor\n            if j &gt; i:\n                es_i_el_mas_grande = False\n\n        # Si, al revisar todos los otros n칰meros, i sigue siendo el mayor,\n        # entonces i es el n칰mero m치s grande:\n        if es_i_el_mas_grande:\n            return i",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游 Autoevaluaci칩n"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/autoevaluacion.html#complejidad-computacional",
    "href": "practica/04_estructuras_y_algoritmos/autoevaluacion.html#complejidad-computacional",
    "title": "游 Autoevaluaci칩n",
    "section": "",
    "text": "Para un arreglo que contiene 100 elementos, indica la cantidad de pasos que llevar칤an las siguientes operaciones:\n\nLectura\nB칰squeda de un valor que no est치 contenido en el arreglo\nInserci칩n al inicio del arreglo\nInserci칩n al final del arreglo\nEliminaci칩n al inicio del arreglo\nEliminaci칩n al final del arreglo\n\nPara un conjunto basado en un arreglo que contiene 100 elementos, indica la cantidad de pasos que llevar칤an las siguientes operaciones:\n\nLectura\nB칰squeda de un valor que no est치 contenido en el conjunto\nInserci칩n de un nuevo valor al inicio del conjunto\nInserci칩n de un nuevo valor al final del conjunto\nEliminaci칩n al inicio del conjunto\nEliminaci칩n al final del conjunto\n\nEn general, la operaci칩n de b칰squeda en un arreglo busca la primera instancia de un valor dado. Pero a veces queremos buscar todas las instancias de un valor determinado. Por ejemplo, supongamos que queremos contar cu치ntas veces aparece el valor \"manzana\" dentro de un arreglo. 쮺u치ntos pasos tomar칤a encontrar todas las apariciones de \"manzana\"? Da tu respuesta en funci칩n de N.\nUse la notaci칩n Big O para describir la complejidad temporal de las siguientes funciones:\ndef es_bisiesto(valor):\n    if valor % 100 == 0:\n        if valor % 400 == 0:\n            return False\n        else:\n            return True\n    return valor % 4 == 0\ndef suma(arreglo):\n    total = 0\n    for numero in arreglo:\n        total += numero\n    return total\nLa siguiente funci칩n recibe un arreglo de cadenas y devuelve un nuevo arreglo que solo contiene las cadenas que comienzan con la letra \"a\". Use la notaci칩n Big O para describir la complejidad temporal de la funci칩n:\ndef seleccionar_cadenas_a(arreglo):\n    arreglo_nuevo = []\n    for cadena in arreglo:\n        if cadena[0] == \"a\":\n            arreglo_nuevo.append(cadena)\n    return arreglo_nuevo\nLa siguiente funci칩n calcula la mediana de un arreglo ordenado. Describa su complejidad temporal en t칠rminos de la notaci칩n Big O:\ndef mediana(arreglo):\n    if not arreglo:\n        return None\n\n    medio = len(arreglo) // 2\n\n    # Si el arreglo tiene una cantidad par de n칰meros:\n    if len(arreglo) % 2 == 0:\n        return (arreglo[medio - 1] + arreglo[medio]) / 2.0\n    else:  # Si el arreglo tiene una cantidad impar de n칰meros:\n        return arreglo[medio]\nReemplace los signos de interrogaci칩n en la siguiente tabla para describir cu치ntos pasos ocurren para una cantidad dada de elementos de datos, seg칰n distintos tipos de Big O:\n\n\n\nN elementos\nO(N)\nO(log N)\nO(N)\n\n\n\n\n100\n100\n?\n?\n\n\n2000\n?\n?\n?\n\n\n\nLa siguiente funci칩n encuentra el producto m치s grande posible entre cualquier par de n칰meros dentro de un arreglo dado. Us치 la notaci칩n Big O para describir la complejidad temporal de la siguiente funci칩n:\ndef greatest_product(arreglo):\n    if len(producto_mas_grande) &lt; 2:\n        return None\n\n    producto_mas_grande = arreglo[0] * arreglo[1]\n\n    for i, valor_i in enumerate(arreglo):\n        for j, valor_j in enumerate(arreglo):\n            if (i != j and valor_i * valor_j &gt; producto_mas_grande):\n                producto_mas_grande = valor_i * valor_j\n\n    return producto_mas_grande\nLa siguiente funci칩n verifica si un arreglo de n칰meros contiene un par de n칰meros cuya suma sea igual a 10:\ndef suma_de_pares(arreglo):\n    for i, valor_i in enumerate(arreglo):\n        for j, valor_j in enumerate(arreglo):\n            if (i != j) and (valor_i + valor_j == 10):\n                return True\n    return False\n\n쮺u치l es el mejor caso, el caso promedio y el peor caso?\nExprese el peor caso en t칠rminos de notaci칩n Big O.\n\nLa siguiente funci칩n encuentra el n칰mero m치s grande dentro de un arreglo, pero tiene una eficiencia de O(N). Reescrib칤 la funci칩n para que sea una versi칩n m치s r치pida, con eficiencia O(N):\ndef maximo(arreglo):\n    if not arreglo:\n        return None\n\n    for i in arreglo:\n        # Supongamos por ahora que i es el mayor\n        es_i_el_mas_grande = True\n\n        for j in arreglo:\n            # Si encontramos otro valor mayor que i, i no es el mayor\n            if j &gt; i:\n                es_i_el_mas_grande = False\n\n        # Si, al revisar todos los otros n칰meros, i sigue siendo el mayor,\n        # entonces i es el n칰mero m치s grande:\n        if es_i_el_mas_grande:\n            return i",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游 Autoevaluaci칩n"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/autoevaluacion.html#estructuras-de-datos-lineales",
    "href": "practica/04_estructuras_y_algoritmos/autoevaluacion.html#estructuras-de-datos-lineales",
    "title": "游 Autoevaluaci칩n",
    "section": "2 Estructuras de datos lineales",
    "text": "2 Estructuras de datos lineales\n\nSi estuvieras desarrollando un programa para un centro de llamadas que pone a los clientes en espera y luego los asigna al 랋r칩ximo representante disponible, 쯧sar칤as una pila o una cola?\nSi se apilan n칰meros en una pila en el siguiente orden: 1, 2, 3, 4, 5, 6, y luego se desapilan dos elementos, 쯤u칠 n칰mero quedar칤a visible en la parte superior de la pila?\nSi se insertan n칰meros en una cola en el siguiente orden: 1, 2, 3, 4, 5, 6, y luego se extraen dos elementos, 쯤u칠 n칰mero ser칤a el siguiente en salir de la cola?\nEscriba una funci칩n que use una pila para invertir una cadena de texto. (Por ejemplo, 라bcde deber칤a convertirse en 란dcba)\n쯈u칠 valores se devuelven durante la siguiente serie de operaciones sobre una pila, si se ejecutan sobre una pila inicialmente vac칤a?\ninsertar(5)\ninsertar(3)\nextraer()\ninsertar(2)\ninsertar(8)\nextraer()\nextraer()\ninsertar(9)\ninsertar(1)\nextraer()\ninsertar(7)\ninsertar(6)\nextraer()\nextraer()\ninsertar(4)\nextraer()\nextraer()\n쯈u칠 valores se devuelven durante la siguiente secuencia de operaciones sobre una cola, si se ejecutan sobre una cola inicialmente vac칤a?\ninsertar(5)\ninsertar(3)\nextraer()\ninsertar(2)\ninsertar(8)\nextraer()\nextraer()\ninsertar(9)\ninsertar(1)\nextraer()\ninsertar(7)\ninsertar(6)\nextraer()\nextraer()\ninsertar(4)\nextraer()\nextraer()\nSuponga que se realiza una secuencia de operaciones de pila (insertar y extraer). Las operaciones de inserci칩n colocan los enteros del 0 al 9, en orden, dentro de la pila; las operaciones extracci칩n imprimen los valores que se extraen. 쮺u치l o cu치les de las siguientes secuencias no podr칤an ocurrir?\n\n4 3 2 1 0 9 8 7 6 5\n4 6 8 7 5 3 2 9 0 1\n2 5 6 7 4 8 9 3 1 0\n4 3 2 1 0 5 6 7 8 9\n1 2 3 4 5 6 9 8 7 0\n0 4 6 5 3 8 1 7 2 9\n1 4 7 9 8 6 5 3 0 2\n2 1 4 3 6 5 8 7 9 0\n\nSuponga que se realiza una secuencia de operaciones de cola (insertar y extraer). Las operaciones de inserci칩n colocan los enteros del 0 al 9, en orden, dentro de la cola; las operaciones extracci칩n imprimen los valores que se extraen. 쮺u치l o cu치les de las siguientes secuencias no podr칤an ocurrir?\n\n0 1 2 3 4 5 6 7 8 9\n4 6 8 7 5 3 2 9 0 1\n2 5 6 7 4 8 9 3 1 0\n4 3 2 1 0 5 6 7 8 9\n\nEscriba un algoritmo para encontrar el pen칰ltimo nodo en una lista simplemente enlazada, en la cual el 칰ltimo nodo est치 indicado por una referencia siguiente igual a None.\nEscriba un buen algoritmo para concatenar dos listas enlazadas simples L y M, dadas 칰nicamente las referencias al primer nodo de cada lista, en una sola lista L que contenga todos los nodos de L seguidos por todos los nodos de M.\nEscriba un algoritmo recursivo que cuente la cantidad de nodos en una lista simplemente enlazada.\nEscriba un algoritmo para dos nodos x e y (no solo sus contenidos) en una lista simplemente enlazada L, teniendo 칰nicamente las referencias a x e y. Repita el ejercicio para el caso en que L sea una lista doblemente enlazada. 쮺u치l de los dos algoritmos requiere m치s tiempo?\nSuponga que x es un nodo de una lista enlazada y no es el 칰ltimo nodo de la lista. 쮺u치l es el efecto del siguiente fragmento de c칩digo?\nx.siguiente = x.siguiente.siguiente\nSuponga que x es un nodo de una lista enlazada e y es un nodo cualquiera. 쮺u치l es el efecto del siguiente fragmento de c칩digo?\ny.siguiente = x.siguiente\nx.siguiente = y\n쯇or qu칠 el siguiente fragmento de c칩digo no hace la misma tarea que el fragmento del punto anterior?\nx.siguiente = y\ny.siguiente = x.siguiente",
    "crumbs": [
      "Pr치ctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "游 Autoevaluaci칩n"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html",
    "href": "practica/01_programacion_en_python/ejercicios.html",
    "title": "游멆잺 Ejercicios",
    "section": "",
    "text": "Escriba una funci칩n en Python que reciba el radio de un c칤rculo y devuelva su 치rea. Luego, escriba otra funci칩n que tambi칠n reciba el radio de un c칤rculo, pero devuelva su per칤metro. Finalmente, escriba una tercera funci칩n que reciba el radio de un c칤rculo y devuelva tanto el 치rea como el per칤metro.\nUna vez que haya implementado todas las funciones, analice la diferencia entre:\narea, perimetro = calcular_area_y_perimetro(radio=5)\ny\nresultados = calcular_area_y_perimetro(radio=5)\nConsidere el tipo de las variables area, perimetro y resultados.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\n\\[\n\\begin{aligned}\nA &= \\pi \\cdot r^2 \\\\\nP &= 2 \\cdot \\pi \\cdot r\n\\end{aligned}\n\\]",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#치rea-y-per칤metro-de-un-c칤rculo",
    "href": "practica/01_programacion_en_python/ejercicios.html#치rea-y-per칤metro-de-un-c칤rculo",
    "title": "游멆잺 Ejercicios",
    "section": "",
    "text": "Escriba una funci칩n en Python que reciba el radio de un c칤rculo y devuelva su 치rea. Luego, escriba otra funci칩n que tambi칠n reciba el radio de un c칤rculo, pero devuelva su per칤metro. Finalmente, escriba una tercera funci칩n que reciba el radio de un c칤rculo y devuelva tanto el 치rea como el per칤metro.\nUna vez que haya implementado todas las funciones, analice la diferencia entre:\narea, perimetro = calcular_area_y_perimetro(radio=5)\ny\nresultados = calcular_area_y_perimetro(radio=5)\nConsidere el tipo de las variables area, perimetro y resultados.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\n\\[\n\\begin{aligned}\nA &= \\pi \\cdot r^2 \\\\\nP &= 2 \\cdot \\pi \\cdot r\n\\end{aligned}\n\\]",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#promociones",
    "href": "practica/01_programacion_en_python/ejercicios.html#promociones",
    "title": "游멆잺 Ejercicios",
    "section": "2 Promociones",
    "text": "2 Promociones\nEscriba una funci칩n llamada calcular_precio que reciba dos argumentos: el monto total de una compra y el medio de pago utilizado.\nEl medio de pago puede ser \"efectivo\", \"d칠bito\" o \"cr칠dito\", y seg칰n el caso se aplicar치 una modificaci칩n sobre el monto:\n\nSi el medio de pago es \"efectivo\", el monto no se modifica.\nSi es \"d칠bito\", se aplica un descuento del 10% sobre el monto.\nSi es \"cr칠dito\", se aplica un recargo del 5% sobre el monto.\n\nLa funci칩n debe retornar el monto final a pagar, con el descuento o recargo aplicado seg칰n corresponda.\n\nPunto extra\nModifique la funci칩n de modo tal que no sea necesario especificar el medio de pago. En tal caso, el medio de pago se asume \"efectivo\". Ayuda: asigne un valor por defecto al argumento medio. Considere una implementaci칩n donde este sea \"efectivo\" y otra donde sea None.",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#etapas-de-la-vida",
    "href": "practica/01_programacion_en_python/ejercicios.html#etapas-de-la-vida",
    "title": "游멆잺 Ejercicios",
    "section": "3 Etapas de la vida",
    "text": "3 Etapas de la vida\nImplemente una funci칩n que reciba una edad y devuelva un mensaje que indique la etapa de la vida correspondiente.\nUtilice una cadena de condicionales if-elif-else para clasificar la edad en alguno de los siguientes grupos:\n\nMenor a 2 a침os: beb칠.\nEntre 2 (inclusive) y 4 a침os: infante.\nEntre 4 (inclusive) y 13 a침os: ni침o/a.\nEntre 13 (inclusive) y 20 a침os: adolescente.\nEntre 20 (inclusive) y 65 a침os: adulto/a.\n65 a침os o m치s: persona mayor.\n\nLa funci칩n debe imprimir un mensaje del tipo: \"La persona es un/a &lt;etapa&gt;\".",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres",
    "href": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres",
    "title": "游멆잺 Ejercicios",
    "section": "4 Conteo de caracteres",
    "text": "4 Conteo de caracteres\nEscriba una funci칩n que reciba una cadena de texto y devuelva un diccionario que indique cu치ntas veces aparece cada caracter en la cadena. La funci칩n no debe diferenciar entre may칰sculas y min칰sculas y debe ignorar espacios. Utilice el siguiente ejemplo como validaci칩n:\ncontar_caracteres(\"Ahora es mejor que nunca\")\n# {\"a\": 3, \"h\": 1, \"o\": 2, \"r\": 2, \"e\": 3, \"s\": 1, \"m\": 1, \"j\": 1, \"q\": 1, \"u\": 2, \"n\": 2, \"c\": 1}\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara saltear pasos de un bucle cuando se encuentra un espacio se puede utilizar la sentencia continue.\nfor i in ...:\n    # ... &lt;- Se ejecuta en todas las iteraciones\n    if condicion_de_salto:\n        continue\n    # ... &lt;- Se ejecuta en las iteraciones 'condicion_de_salto' es False",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#orden-de-m칠rito",
    "href": "practica/01_programacion_en_python/ejercicios.html#orden-de-m칠rito",
    "title": "游멆잺 Ejercicios",
    "section": "5 Orden de m칠rito",
    "text": "5 Orden de m칠rito\nSe cuenta con una lista de tuplas que contienen las notas del examen final de Programaci칩n 2 para un conjunto de alumnos:\nnotas = [\n    (\"Escalada\", 9),\n    (\"Alonso\", 7),\n    (\"P칠rez\", 8),\n    (\"Castro\", 8),\n    (\"Rossini\", 10),\n    (\"Mart칤nez\", 9),\n    (\"P칠rez\", 6),\n    (\"Riquelme\", 5),\n]\n\nEscriba un programa que a partir de notas genere un diccionario donde las claves se corresponden con los apellidos y los valores con las notas del examen final.\nEscriba un programa que a partir de notas genere un diccionario donde las claves son las notas y el valor asociado sea una lista con los apellidos de quienes tuvieron esa nota.",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#rendimento-acad칠mico",
    "href": "practica/01_programacion_en_python/ejercicios.html#rendimento-acad칠mico",
    "title": "游멆잺 Ejercicios",
    "section": "6 Rendimento acad칠mico",
    "text": "6 Rendimento acad칠mico\nSe cuenta con el siguiente diccionario que asocia nombres de estudiantes con una lista de sus calificaciones:\nnotas = {\n    \"Ana\": [8, 9, 10],\n    \"Luis\": [6, 7, 8, 3, 9],\n    \"Carla\": [10, 9, 10],\n    \"Marcos\": [5, 6],\n    \"Sof칤a\": [7, 7, 8],\n    \"Pedro\": [6, 4, 5, 6, 3, 8],\n    \"Luc칤a\": [9, 8, 10, 9]\n}\nImplemente una funci칩n que resuma el rendimiento acad칠mico de los estudiantes. La funci칩n debe recibir el diccionario de notas y un argumento adicional llamado modo. Seg칰n el valor de modo, se debe devolver un nuevo diccionario con la siguiente informaci칩n:\n\nSi modo es \"promedio\", se debe devolver el promedio de notas por estudiante.\nSi modo es \"proporcion\", se debe devolver la proporci칩n de ex치menes aprobados por estudiante (se considera aprobado todo valor mayor o igual a 6).",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#칤ndice-de-precios",
    "href": "practica/01_programacion_en_python/ejercicios.html#칤ndice-de-precios",
    "title": "游멆잺 Ejercicios",
    "section": "7 칈ndice de precios",
    "text": "7 칈ndice de precios\nSe cuenta con la serie mensual del 칈ndice de Precios al Consumidor (IPC) del a침o 2024:\nipc_2024 = [20.6, 13.2, 11.0, 8.8, 4.2, 4.6, 4.0, 4.2, 3.5, 2.7, 2.4, 2.7]\nRealice los siguientes c치lculos y an치lisis:\n\nDetermine el menor y el mayor 칤ndice reportado durante el a침o.\nCalcule el IPC promedio mensual del 2024.\nEncuentre la diferencia entre el IPC m칤nimo y m치ximo del a침o.\n\n쮼n qu칠 mes se registr칩 la inflaci칩n m치s alta?\n\nCalcule la inflaci칩n mediana del 2024.\n쮺칩mo podr칤a calcular el rango del IPC (diferencia entre el valor m치ximo y m칤nimo) sin usar las funciones min() ni max()?",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#res칰menes-estad칤sticos",
    "href": "practica/01_programacion_en_python/ejercicios.html#res칰menes-estad칤sticos",
    "title": "游멆잺 Ejercicios",
    "section": "8 Res칰menes estad칤sticos",
    "text": "8 Res칰menes estad칤sticos\nCree funciones que, dada una lista de n칰meros, calculen los siguientes res칰menes estad칤sticos:\n\nLa media \\[\n\\text{media}(X) = \\frac{1}{n}\\sum_{i=1}^n{x_i}\n\\]\nEl rango \\[\n\\text{rango}(X) = \\text{max}(X) - \\text{min}(X)\n\\]\nLa varianza \\[\n\\text{var}(X) = \\frac{1}{n}\\sum_{i=1}^n{(x_i - \\bar{x})^2}\n\\]\nEl desv칤o est치ndar \\[\n\\text{sd}(X) = \\sqrt{\\text{var}(X)}\n\\]\nLa mediana \\[\n\\begin{array}{lr}\n\\text{mediana}(X) = x_{(\\frac{n + 1}{2})} & \\text{Si } n \\text{ es impar} \\\\\n\\text{mediana}(X) = \\frac{x_{(\\frac{n}{2})} + x_{(\\frac{n}{2}+1)}}{2} & \\text{Si } n \\text{ es par}\n\\end{array}\n\\]\ndonde los \\(x_{(i)}\\) est치n ordenados de manera ascendente.",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#validaci칩n-de-dni",
    "href": "practica/01_programacion_en_python/ejercicios.html#validaci칩n-de-dni",
    "title": "游멆잺 Ejercicios",
    "section": "9 Validaci칩n de DNI",
    "text": "9 Validaci칩n de DNI\nCrear una funci칩n que dada una cadena de caracteres verifique si se corresponde con un DNI.\nSi es un DNI, devolver True. Caso contrario, devolver False.\nA tener en cuenta:\n\nAlgunos ejemplos de DNI v치lidos\n\n40.094.127\n19053512\n6.392.780\n\nDNI no v치lidos\n\n40,094,127\n19-053-512\n123456",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#la-f칤sica-del-rebote",
    "href": "practica/01_programacion_en_python/ejercicios.html#la-f칤sica-del-rebote",
    "title": "游멆잺 Ejercicios",
    "section": "10 La f칤sica del rebote",
    "text": "10 La f칤sica del rebote\nUna pelota de goma es lanzada desde una altura inicial de 100 metros. Cada vez que toca el suelo, rebota alcanzando una altura equivalente a 3/5 de la altura desde la que cay칩.\nEscriba un programa que imprima una tabla mostrando las alturas alcanzadas por la pelota en cada uno de sus primeros 10 rebotes.\nLuego, implemente este programa como una funci칩n que reciba dos par치metros:\n\nAltura inicial desde la que se lanza la pelota.\nCantidad de rebotes que se desea calcular.\n\nLa funci칩n debe devolver una lista con las alturas alcanzadas en cada rebote.\n\nPunto extra\nModifique la funci칩n para que considere un rebote como 랍ignificativo solo si la altura alcanzada es mayor o igual a un valor m칤nimo especificado (por ejemplo, 1 cent칤metro).\nSi la pelota no alcanza esta altura m칤nima en alg칰n rebote, se considera que ha completado su trayectoria y queda quieta. En este caso, la funci칩n debe devolver 칰nicamente los valores correspondientes a los rebotes significativos.",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#un-mont칩n-de-plata",
    "href": "practica/01_programacion_en_python/ejercicios.html#un-mont칩n-de-plata",
    "title": "游멆잺 Ejercicios",
    "section": "11 Un mont칩n de plata",
    "text": "11 Un mont칩n de plata\nUna ma침ana pon칠s un billete en la vereda al lado del Monumento a la Bandera. A partir de ah칤, cada d칤a vas y duplic치s la cantidad de billetes, apil치ndolos prolijamente. 쮺u치nto tiempo pasa antes de que la pila de billetes sea m치s alta que la del Monumento?\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nAlgunas constantes 칰tiles para resolver el problema:\nbillete_grosor = 0.11 * 0.001  # grosor de un billete en metros\naltura_monumento = 70          # altura en metros\nSugerencia: Usar un bucle while para realizar el c치lculo.\n\n\n\n\nPunto extra\nEscribe una funci칩n que permita determinar la cantidad de d칤as necesarios para superar cualquier altura arbitraria.",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#la-conjetura-de-collatz",
    "href": "practica/01_programacion_en_python/ejercicios.html#la-conjetura-de-collatz",
    "title": "游멆잺 Ejercicios",
    "section": "12 La conjetura de Collatz",
    "text": "12 La conjetura de Collatz\nLa conjetura de Collatz dice:\n\nSi tomamos un n칰mero natural cualquiera, su secuencia de Collatz termina llegando siempre al n칰mero 1.\n\nSecuencia de Collatz:\n\nSi el n칰mero es par, se divide entre 2.\nSi el n칰mero es impar, se multiplica por 3 y se le suma 1.\n\n\\[\nf(n) =\n\\begin{cases}\n    \\displaystyle \\frac{n}{2} & \\text{si } n \\text{ es par,} \\\\ \\\\\n    3n + 1 & \\text{si } n \\text{ es impar.}\n\\end{cases}\n\\]\nEscribir una funci칩n que calcule la secuencia de Collatz para un n칰mero natural cualquiera.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\n\nUtilizar bucle while.\nEl bucle debe correr solo cuando el valor de la secuencia sigue siendo mayor a 1. Si es 1, hay que frenar.\nInsertar los elementos de la secuencia en una lista.",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#adivina-el-n칰mero",
    "href": "practica/01_programacion_en_python/ejercicios.html#adivina-el-n칰mero",
    "title": "游멆잺 Ejercicios",
    "section": "13 Adivina el n칰mero",
    "text": "13 Adivina el n칰mero\nEscriba un programa que implemente el cl치sico juego ㄹdivina el n칰mero. El programa debe:\n\nTener un n칰mero secreto (entero) que el usuario debe adivinar.\nSolicitar al usuario que ingrese un n칰mero.\nSi el n칰mero ingresado no coincide con el n칰mero secreto:\n\nInformar si el n칰mero ingresado es mayor o menor que el n칰mero secreto.\nPedir al usuario que intente nuevamente.\n\nSi el usuario adivina el n칰mero, el programa debe terminar mostrando un mensaje de felicitaciones.\n\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara generar n칰meros aleatorios enteros en un rango dado puede utilizar randint() del m칩dulo random:\nimport random\nrandom.randint(-100,100)     # Genera un n칰mero aleatorio entre -100 y 100\n\n\n\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nEl programa que resuelve este problema realiza una cantidad de iteraciones que se desconoce al momento de escribirlo. La soluci칩n t칤pica a este tipo de problema involucra el uso de while True junto a la sentencia break.\nwhile True:\n    # realizar alguna accion\n    if condicion_de_salida:\n        break\n\n\n\n\nPunto extra\nImplemente una versi칩n de este programa donde el usuario cuenta con 10 intentos.",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres-pythonico",
    "href": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres-pythonico",
    "title": "游멆잺 Ejercicios",
    "section": "14 Conteo de caracteres Pythonico",
    "text": "14 Conteo de caracteres Pythonico\nLos diccionarios en Python cuentan con un m칠todo .get() que devuelve el valor asociado a una clave. Este m칠todo permite pasarle un segundo argumento con un valor que se devuelve cuando no se encuentra un elemento asociado a la clave que le pasamos. Por ejemplo:\nd = {\"a\": 1, \"b\": 20}\nd.get(\"b\", 0)\n20\nd.get(\"c\", 0)\n0\nModifique la funci칩n contar_caracteres del ejercicio Conteo de caracteres utilizando el metodo .get() para obtener una implementaci칩n m치s sencilla. As칤, deber칤a poder eliminar el bloque if.",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#validador-de-contrase침as",
    "href": "practica/01_programacion_en_python/ejercicios.html#validador-de-contrase침as",
    "title": "游멆잺 Ejercicios",
    "section": "15 Validador de contrase침as 游땸",
    "text": "15 Validador de contrase침as 游땸\nEscriba un programa que solicite al usuario una contrase침a y verifique que cumpla con las siguientes condiciones:\n\nDebe tener entre de 8 y 24 caracteres.\nDebe incluir letras, n칰meros y caracteres especiales (@#$%^&*()).\n\nSi la contrase침a no es v치lida, el programa debe informar al usuario qu칠 condici칩n no se cumple y permitirle ingresar una nueva contrase침a. El proceso se repite hasta que el usuario ingrese una contrase침a v치lida o decida no continuar.",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres-ii",
    "href": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres-ii",
    "title": "游멆잺 Ejercicios",
    "section": "16 Conteo de caracteres II 游땸",
    "text": "16 Conteo de caracteres II 游땸\nAgregue a la funci칩n contar_frecuencias del ejercicio Conteo de caracteres un argumento llamado orden que admita los valores \"aparicion\", \"alfabetico\" y \"frecuencia\".\nEste argumento debe permitir ordenar las claves del diccionario resultante seg칰n el siguiente criterio:\n\n\"aparicion\": mantiene el orden en que las palabras aparecen por primera vez en la lista original.\n\"alfabetico\": ordena las palabras alfab칠ticamente.\n\"frecuencia\": ordena las palabras por su frecuencia, de mayor a menor.",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游멆잺 Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/problemas.html",
    "href": "practica/01_programacion_en_python/problemas.html",
    "title": "游빌 Problemas",
    "section": "",
    "text": "En criptograf칤a, el cifrado C칠sar es una de las t칠cnicas de cifrado m치s simples y m치s usadas.\nEs un tipo de cifrado en el que una letra en el texto original es reemplazada por otra letra que se encuentra un n칰mero fijo de posiciones m치s adelante en el alfabeto.\nPor ejemplo, con un desplazamiento de 3, la A ser칤a sustituida por la D (situada 3 lugares a la derecha de la A), la B ser칤a reemplazada por la E, etc.\n\n\n\n\n\nEscriba una funci칩n, y luego un script, que permita cifrar y descifrar cadenas usando el cifrado C칠sar con un n칰mero arbitrario de posiciones.\nDos funciones incluidas con Python que pueden ser 칰tiles para esta tarea son ord(), que convierte caracteres num칠ricos a n칰meros, y chr(), que realiza la operaci칩n inversa.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara el cifrado de un 칰nico caracter:\n\nDefinir un desplazamiento, por ejemplo 3.\nConvertir el caracter a n칰mero usando ord().\nSumarle desplazamiento.\nFinalmente, convertirlo a caracter nuevamente utilizando chr().\n\nY para el descifrado:\n\nConvertir el caracter a n칰mero.\nRestarle desplazamiento.\nConvertirlo a caracter nuevamente utilizando chr().\n\nAs칤, se deber칤a recuperar el caracter definido al principio.",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游빌 Problemas"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/problemas.html#cifrado-c칠sar",
    "href": "practica/01_programacion_en_python/problemas.html#cifrado-c칠sar",
    "title": "游빌 Problemas",
    "section": "",
    "text": "En criptograf칤a, el cifrado C칠sar es una de las t칠cnicas de cifrado m치s simples y m치s usadas.\nEs un tipo de cifrado en el que una letra en el texto original es reemplazada por otra letra que se encuentra un n칰mero fijo de posiciones m치s adelante en el alfabeto.\nPor ejemplo, con un desplazamiento de 3, la A ser칤a sustituida por la D (situada 3 lugares a la derecha de la A), la B ser칤a reemplazada por la E, etc.\n\n\n\n\n\nEscriba una funci칩n, y luego un script, que permita cifrar y descifrar cadenas usando el cifrado C칠sar con un n칰mero arbitrario de posiciones.\nDos funciones incluidas con Python que pueden ser 칰tiles para esta tarea son ord(), que convierte caracteres num칠ricos a n칰meros, y chr(), que realiza la operaci칩n inversa.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara el cifrado de un 칰nico caracter:\n\nDefinir un desplazamiento, por ejemplo 3.\nConvertir el caracter a n칰mero usando ord().\nSumarle desplazamiento.\nFinalmente, convertirlo a caracter nuevamente utilizando chr().\n\nY para el descifrado:\n\nConvertir el caracter a n칰mero.\nRestarle desplazamiento.\nConvertirlo a caracter nuevamente utilizando chr().\n\nAs칤, se deber칤a recuperar el caracter definido al principio.",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游빌 Problemas"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/problemas.html#n칰meros-aleatorios",
    "href": "practica/01_programacion_en_python/problemas.html#n칰meros-aleatorios",
    "title": "游빌 Problemas",
    "section": "2 N칰meros aleatorios",
    "text": "2 N칰meros aleatorios\nConstruya un programa en Python que genere una cantidad determinada de n칰meros aleatorios uniformes dentro de un rango definido por el usuario. El programa debe:\n\nSolicitar al usuario la cantidad de n칰meros a generar y los valores m칤nimo y m치ximo del rango.\nGenerar los n칰meros aleatorios\nGuardar los n칰meros en un archivo de texto, uno por l칤nea.\nOfrecer la opci칩n de mostrar un resumen estad칤stico con m칤nimo, m치ximo, media y desv칤o est치ndar, solo si el usuario lo solicita.\n\nPara resolver este problema utilice el m칩dulo random y las funciones desarrolladas en el ejercicio Res칰menes estad칤sticos guardadas en un m칩dulo llamado estadistica.py.",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游빌 Problemas"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/problemas.html#mensaje-al-descubierto",
    "href": "practica/01_programacion_en_python/problemas.html#mensaje-al-descubierto",
    "title": "游빌 Problemas",
    "section": "3 Mensaje al descubierto",
    "text": "3 Mensaje al descubierto\nResulta que Franco, un amigo que estudia Ciencias de la Computaci칩n en la FCEIA, te env칤a por WhatsApp un archivo de texto plano con mensajes 란ncriptados usando caracteres sobrantes y s칤mbolos extra침os:\n    !!!,.,  aY??/u/DAM**e,, se =m!!e\n&&M&&e v!o!?LV...I.O /L/*oC/*o\n        __?e_?l//+ T++**e/*Cl!?aD==*O**\nTiene sentido pensar que est치 experimentando con nuevos algoritmos de cifrado y, de paso, te lanza el reto de descifrarlo.\nTu misi칩n es escribir un programa que:\n\nLea un archivo de texto plano cualquiera.\nMuestre en pantalla su contenido original (tal cual llega).\nAplique un proceso de limpieza basado en las siguientes reglas:\n\nEliminar todos los caracteres +, *, -, /, =, !, ?, & y _.\nReemplazar cualquier secuencia de espacios m칰ltiples por un solo espacio.\nHomogeinizar la capitalizaci칩n de los caracteres.\nConservar los saltos de l칤nea tal cual aparecen en el archivo original.\n\nMuestre en pantalla la versi칩n desencriptada del texto.\nGuarde la versi칩n limpia en un nuevo archivo de texto.\n\nEl usuario debe poder especificar el nombre del archivo de salida.\nSi no lo hace, se generar치 uno con el sufijo _limpio antes de la extensi칩n original (por ejemplo, secreto.txt  secreto_limpio.txt).",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游빌 Problemas"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/problemas.html#c칩digo-morse",
    "href": "practica/01_programacion_en_python/problemas.html#c칩digo-morse",
    "title": "游빌 Problemas",
    "section": "4 C칩digo Morse",
    "text": "4 C칩digo Morse\nEl c칩digo Morse es un sistema utilizado para representar letras mediante combinaciones espec칤ficas de se침ales cortas y largas, denominadas puntos (.) y rayas (-). A continuaci칩n se muestra un diccionario con el mapeo de caracteres alfab칠ticos, d칤gitos del 0 al 9 y algunos s칤mbolos de puntuaci칩n comunes:\nmapeo_morse = {\n    \"A\": \".-\",\n    \"B\": \"-...\",\n    \"C\": \"-.-.\",\n    \"D\": \"-..\",\n    \"E\": \".\",\n    \"F\": \"..-.\",\n    \"G\": \"--.\",\n    \"H\": \"....\",\n    \"I\": \"..\",\n    \"J\": \".---\",\n    \"K\": \"-.-\",\n    \"L\": \".-..\",\n    \"M\": \"--\",\n    \"N\": \"-.\",\n    \"O\": \"---\",\n    \"P\": \".--.\",\n    \"Q\": \"--.-\",\n    \"R\": \".-.\",\n    \"S\": \"...\",\n    \"T\": \"-\",\n    \"U\": \"..-\",\n    \"V\": \"...-\",\n    \"W\": \".--\",\n    \"X\": \"-..-\",\n    \"Y\": \"-.--\",\n    \"Z\": \"--..\",\n    \"1\": \".----\",\n    \"2\": \"..---\",\n    \"3\": \"...--\",\n    \"4\": \"....-\",\n    \"5\": \".....\",\n    \"6\": \"-....\",\n    \"7\": \"--...\",\n    \"8\": \"---..\",\n    \"9\": \"----.\",\n    \"0\": \"-----\",\n    \", \": \"--..--\",\n    \".\": \".-.-.-\",\n}\nEscriba una funci칩n en Python que permita convertir cualquier palabra a c칩digo Morse utilizando este diccionario. Luego, escriba otra funci칩n que haga exactamente lo contrario: dada una secuencia en c칩digo Morse, debe recuperar la palabra original. Finalmente, incorpore ambas funciones en un script principal que combine ambas funciones y permita encriptar o desencriptar texto desde un archivo de texto plano. El programa debe recibir:\n\nEl nombre del archivo de entrada.\nEl nombre del archivo de salida.\nLa operaci칩n a realizar (encriptar o desencriptar).\n\nAyuda: Para indicar espacios en c칩digo Morse utilice /.",
    "crumbs": [
      "Pr치ctica",
      "U1 - Programaci칩n en Python",
      "游빌 Problemas"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/autoevaluacion.html",
    "href": "practica/02_programacion_funcional/autoevaluacion.html",
    "title": "游 Autoevaluaci칩n",
    "section": "",
    "text": "쯇or qu칠 decimos que fun es una funci칩n con efectos secundarios?\ndef fun():\n    global x\n    x = 10\n    return x\n쮺u치l es el problema con la siguiente funci칩n? Explore el resultado de las llamadas que se incluyen luego de la definici칩n.\ndef agregar_usuario(usuario, listado=[]):\n    listado.append(usuario)\n    return listado\n\nbase1 = agregar_usuario(\"Adri치n\")\nbase2 = agregar_usuario(\"Daniela\")\nExplore el contenido y la identidad de base1 y base2. Si es necesario, utilice alg칰n agente de IA para explorar en qu칠 parte de la definici칩n de la funci칩n se esconde una trampa.\n\n\n\n\n\n쯇or qu칠 la siguiente definici칩n devuelve un error?\nlambda x: return x + 1\n쯈u칠 hacen los siguientes bloques de c칩digo?\n(lambda x, y: x + y)(1, 5)\n(lambda f, x: f(x + 10))(lambda y: y * 5, 2)\n쯈u칠 devuelve la siguiente llamada? 쯇or qu칠?\n(lambda x: print(x))(1)\nAyuda: asigne el resultado a una variable y explore el valor de esa variable.\n\n\n\n\n\n쮺u치l es el valor de args en la siguiente llamada? 쯇or qu칠?\n def fun(x, *args):\n     return x + 10\n\n fun(128)\n쯏 el valor de kwargs debajo?\ndef fun(x, **kwargs):\n    return x + 11\n\nfun(128)\nLos siguientes intentos por definir una funci칩n arrojan un error. Investigue por qu칠 y reflexione sobre el sentido de los errores.\ndef fun(**kwargs, x, y):\n    return x + y\ndef fun(**kwargs, *args):\n    return sum(args)\nCualquier llamada a la siguiente funci칩n que solo pase argumentos posicionales va a resultar en un error. 쯇or qu칠? 쮺칩mo habr칤a que llamarla para que no resulte en un error?\ndef fun(*args, x, y):\n    return sum(args), x + y\n\n\n\n\n\nEjecute el siguiente bloque de c칩digo e inspeccione el objeto que devuelven las sucesivas llamadas realizadas. Analice por qu칠 ocurre este comportamiento y piense qu칠 tipo de funcionalidades podr칤an aprovechar un mecanismo similar.\ndef fabrica():\n    cosas = []\n    def fun(elemento):\n        cosas.append(elemento)\n        return cosas\n    return fun\n\nf = fabrica()\nf(128)\nf(256)\nf(1024)\nAyuda: Compare el ID de los objetos devueltos en cada llamada. 쯇odr칤a observar el mismo comportamiento si en vez de usar una lista para cosas se usara una tupla?",
    "crumbs": [
      "Pr치ctica",
      "U2 - Programaci칩n funcional",
      "游 Autoevaluaci칩n"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/autoevaluacion.html#funciones",
    "href": "practica/02_programacion_funcional/autoevaluacion.html#funciones",
    "title": "游 Autoevaluaci칩n",
    "section": "",
    "text": "쯇or qu칠 decimos que fun es una funci칩n con efectos secundarios?\ndef fun():\n    global x\n    x = 10\n    return x\n쮺u치l es el problema con la siguiente funci칩n? Explore el resultado de las llamadas que se incluyen luego de la definici칩n.\ndef agregar_usuario(usuario, listado=[]):\n    listado.append(usuario)\n    return listado\n\nbase1 = agregar_usuario(\"Adri치n\")\nbase2 = agregar_usuario(\"Daniela\")\nExplore el contenido y la identidad de base1 y base2. Si es necesario, utilice alg칰n agente de IA para explorar en qu칠 parte de la definici칩n de la funci칩n se esconde una trampa.\n\n\n\n\n\n쯇or qu칠 la siguiente definici칩n devuelve un error?\nlambda x: return x + 1\n쯈u칠 hacen los siguientes bloques de c칩digo?\n(lambda x, y: x + y)(1, 5)\n(lambda f, x: f(x + 10))(lambda y: y * 5, 2)\n쯈u칠 devuelve la siguiente llamada? 쯇or qu칠?\n(lambda x: print(x))(1)\nAyuda: asigne el resultado a una variable y explore el valor de esa variable.\n\n\n\n\n\n쮺u치l es el valor de args en la siguiente llamada? 쯇or qu칠?\n def fun(x, *args):\n     return x + 10\n\n fun(128)\n쯏 el valor de kwargs debajo?\ndef fun(x, **kwargs):\n    return x + 11\n\nfun(128)\nLos siguientes intentos por definir una funci칩n arrojan un error. Investigue por qu칠 y reflexione sobre el sentido de los errores.\ndef fun(**kwargs, x, y):\n    return x + y\ndef fun(**kwargs, *args):\n    return sum(args)\nCualquier llamada a la siguiente funci칩n que solo pase argumentos posicionales va a resultar en un error. 쯇or qu칠? 쮺칩mo habr칤a que llamarla para que no resulte en un error?\ndef fun(*args, x, y):\n    return sum(args), x + y\n\n\n\n\n\nEjecute el siguiente bloque de c칩digo e inspeccione el objeto que devuelven las sucesivas llamadas realizadas. Analice por qu칠 ocurre este comportamiento y piense qu칠 tipo de funcionalidades podr칤an aprovechar un mecanismo similar.\ndef fabrica():\n    cosas = []\n    def fun(elemento):\n        cosas.append(elemento)\n        return cosas\n    return fun\n\nf = fabrica()\nf(128)\nf(256)\nf(1024)\nAyuda: Compare el ID de los objetos devueltos en cada llamada. 쯇odr칤a observar el mismo comportamiento si en vez de usar una lista para cosas se usara una tupla?",
    "crumbs": [
      "Pr치ctica",
      "U2 - Programaci칩n funcional",
      "游 Autoevaluaci칩n"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/autoevaluacion.html#recursi칩n",
    "href": "practica/02_programacion_funcional/autoevaluacion.html#recursi칩n",
    "title": "游 Autoevaluaci칩n",
    "section": "2 Recursi칩n",
    "text": "2 Recursi칩n\n\n쮺u치l de las siguientes funciones es recursiva?\ndef f(x):\n    return x + 1\n\ndef g(x):\n    return f(x)\n\ndef h(x):\n    return h(x - 1)\n쯈u칠 son el caso base y el caso recursivo?\n쯇or qu칠 toda recursi칩n necesita un caso base?\n쯈u칠 pasa si una funci칩n recursiva nunca llega al caso base?\nReflexione sobre ventajas y desventajas de la recursi칩n.",
    "crumbs": [
      "Pr치ctica",
      "U2 - Programaci칩n funcional",
      "游 Autoevaluaci칩n"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/autoevaluacion.html#funciones-de-orden-superior",
    "href": "practica/02_programacion_funcional/autoevaluacion.html#funciones-de-orden-superior",
    "title": "游 Autoevaluaci칩n",
    "section": "3 Funciones de orden superior",
    "text": "3 Funciones de orden superior\n\nExplique por qu칠 el primer print muestra 10 y el segundo falla:\nfrom functools import partial\n\ndef suma(x, y):\n    return x + y\n\nsuma2 = partial(suma, 10, 0)\nprint(suma2())\nprint(suma2(10))\n쮺u치l de las siguientes funciones es de orden superior?\ndef f(x):\n    return x + 1\n\ndef g(fn, x):\n    return fn(x)\n\ndef h():\n    return f\n쮺u치l de las siguientes funciones de Python es de orden superior?\n\nsum\nmax\nmin\nsorted\nprint\nfunctools.partial\n\n쯈u칠 hace la funci칩n fun? 쯈u칠 condicion debe cumplir f respecto de sus valores de entrada y salida?\ndef fun(f, x):\n    return f(f(x))\n쯇ara qu칠 sirve la funci칩n definida debajo?\ndef fun(f, g):\n    return lambda x: f(g(x))\n쯈u칠 tipo de funci칩n se necesita pasar a filter?\n쮺u치l es el resultado de la 칰ltima l칤nea de c칩digo? 쯇or qu칠?\nfilter_obj = filter(lambda x: x &gt; 2, range(5))\nlist(filter_obj) # Primera conversi칩n a lista\nlist(filter_obj) # Segunda conversi칩n a lista\nAyuda: Para comprender lo que sucede en este ejercicio es necesario estar familiarizados con los generadores.\n쮺u치l implementaci칩n es m치s eficiente desde el punto de vista del consumo de memoria? 쯇or qu칠?\nimpares = list(filter(lambda x: x % 2, range(1_000)))\nimpares_al_cubo = list(map(lambda x: x ** 3, impares))\nimpares_al_cubo = list(map(lambda x: x ** 3, filter(lambda x: x % 2, range(1_000))))\nAyuda: Nuevamente, es necesario estar familiarizados con los generadores para responder a esta pregunta.\n쮺u치l es el resultado de la reducci칩n debajo? 쯇or qu칠?\nfrom functools import reduce\nreduce(lambda x, y: x + [y], range(3), [])\nAyuda: reduce ejecuta la funci칩n que se le pasa solamente 3 veces. Podr칤a resultar de ayuda enumerar cada una de las llamadas manualmente.",
    "crumbs": [
      "Pr치ctica",
      "U2 - Programaci칩n funcional",
      "游 Autoevaluaci칩n"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/autoevaluacion.html#comprehensions",
    "href": "practica/02_programacion_funcional/autoevaluacion.html#comprehensions",
    "title": "游 Autoevaluaci칩n",
    "section": "4 Comprehensions",
    "text": "4 Comprehensions\n\n쯈u칠 diferencia hay entre las siguientes dos l칤neas de c칩digo? Asuma que f es una funci칩n y xs es una secuencia.\nmap(f, xs)\n[f(x) for x in xs]\n쮺u치l es el resultado de esta expresi칩n?\n[x for x in \"hola\" if x != \"o\"]\nEscriba una list comprehension para obtener una lista con la primera letra de cada palabra.\npalabras = [\"hola\", \"mundo\", \"python\"]\nEscriba una list comprehension que reemplace los None por un -1.\ndatos = [1, None, 3, None, 5]\nConvierta este bucle en una list comprehension.\nresultado = []\nfor x in range(5):\n    if x % 2 != 0:\n        resultado.append(x)\n쮼s posible que una list comprehension devuelva una lista vac칤a? 쮺u치ndo?\nConstruya una 칰nica list comprehension que realice lo mismo que el siguiente bloque:\ndef f(x):\n    return 10 / x\n\ndef g(x):\n    return x != 0\n\nnumeros = [1, 0, -1, 0, 2, 0, -2, 0, 3, 0, -3]\nlist(map(f, filter(g, numeros)))",
    "crumbs": [
      "Pr치ctica",
      "U2 - Programaci칩n funcional",
      "游 Autoevaluaci칩n"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/autoevaluacion.html#generadores",
    "href": "practica/02_programacion_funcional/autoevaluacion.html#generadores",
    "title": "游 Autoevaluaci칩n",
    "section": "5 Generadores",
    "text": "5 Generadores\n\n쯈u칠 diferencia a una funci칩n regular de una funci칩n generadora?\n쮼n qu칠 momento se ejecuta el cuerpo de una funci칩n generadora? 쯉iempre se ejecuta todo?\n쮺칩mo se puede obtener una lista a partir de un generador? 쮺u치ntas veces se puede realizar esa operaci칩n sobre el mismo generador?\n쯈u칠 ventaja tiene un generador frente a una lista?\n쯈u칠 significa que un generador sea perezoso?\n쯈u칠 pasa si se llama a next sobre un generador m치s veces que la cantidad de yield en 칠l?\n쯈u칠 se obtiene en el siguiente bloque de c칩digo?\ndef f():\n    yield 1\n    yield 2\n\ngen = f()\nprint(list(gen))\n쯈u칠 pasa si se corre next(gen) a continuaci칩n?\n쯈u칠 se imprime en pantalla?\nprint((x * 2 for x in [1, 2, 3]))\n쯇or qu칠 es posible implementar un bucle infinito dentro de un generador?\n쮺u치ntas veces es posible llamar a next sobre el generador g?\ndef fun():\n    yield 1\n    return 2\n    yield 3\n\ng = fun()",
    "crumbs": [
      "Pr치ctica",
      "U2 - Programaci칩n funcional",
      "游 Autoevaluaci칩n"
    ]
  },
  {
    "objectID": "teoria/03_oop/03_herencia.html",
    "href": "teoria/03_oop/03_herencia.html",
    "title": "3 - Herencia",
    "section": "",
    "text": "En el Prefacio del apunte anterior mencionamos lo siguiente sobre el principio de herencia:\n\n\nHerencia: permite crear nuevas clases a partir de otras ya existentes, reutilizando su comportamiento y ampli치ndolo o modific치ndolo seg칰n sea necesario.\n\n\nSupongamos que necesitamos representar rect치ngulos en Python. Anteriormente, optamos por por representarlos con una tupla de longitud dos, donde el primer elemento representaba la base y el segundo la altura. Ahora, que ya dimos nuestros primeros pasos con la programaci칩n orientada a objetos, podemos crear una clase que no solo nos permite almacenar estado (los atributos de cada rect치ngulo), sino que nos posibilta implementar m칠todos que nos permiten obtener otras cantidades de inter칠s.\n\nclass Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    @property\n    def area(self):\n        return self.base * self.altura\n\n    @property\n    def perimetro(self):\n        return self.base * 2 + self.altura * 2\n\n    def resumen(self):\n        return f\"Rectangulo(base={self.base}, altura={self.altura})\"\n\n\nr1 = Rectangulo(4, 7)\nprint(r1.resumen())\nprint(\"츼rea:\", r1.area)\nprint(\"Per칤metro:\", r1.perimetro)\n\nRectangulo(base=4, altura=7)\n츼rea: 28\nPer칤metro: 22\n\n\nSi queremos representar cuadrados, podemos crear otra clase:\n\nclass Cuadrado:\n    def __init__(self, lado):\n        self.lado = lado\n\n    @property\n    def area(self):\n        return self.lado * self.lado\n\n    @property\n    def perimetro(self):\n        return self.lado * 4\n\n    def resumen(self):\n        return f\"Cuadrado(lado={self.lado})\"\n\nc1 = Cuadrado(3)\nprint(c1.resumen())\nprint(\"츼rea:\", c1.area)\nprint(\"Per칤metro:\", c1.perimetro)\n\nCuadrado(lado=3)\n츼rea: 9\nPer칤metro: 12\n\n\nEn Python podemos usar la funci칩n isinstance para verificar si un objeto es instancia de una clase determinada. Por ejemplo, en el siguiente c칩digo comprobamos que r1 es una instancia de Rectangulo y que c1 es una instancia de Cuadrado:\n\nprint(isinstance(r1, Rectangulo))\nprint(isinstance(c1, Cuadrado))\n\nTrue\nTrue\n\n\nSabemos que, desde el punto de vista geom칠trico, un cuadrado es un caso particular de rect치ngulo: tiene base y altura iguales. En otras palabras, todo cuadrado es tambi칠n un rect치ngulo, aunque no todo rect치ngulo sea un cuadrado.\nSin embargo, si intentamos verificar esta relaci칩n en nuestro programa, obtenemos que esto no es asi.\n\nisinstance(c1, Rectangulo)\n\nFalse\n\n\nEsto no significa que los cuadrados no sean rect치ngulos, sino que nuestro c칩digo a칰n no conoce esa relaci칩n entre las clases.",
    "crumbs": [
      "Teor칤a",
      "U3 - Programaci칩n Orientada a Objetos",
      "3 - Herencia"
    ]
  },
  {
    "objectID": "teoria/03_oop/03_herencia.html#introducci칩n",
    "href": "teoria/03_oop/03_herencia.html#introducci칩n",
    "title": "3 - Herencia",
    "section": "",
    "text": "En el Prefacio del apunte anterior mencionamos lo siguiente sobre el principio de herencia:\n\n\nHerencia: permite crear nuevas clases a partir de otras ya existentes, reutilizando su comportamiento y ampli치ndolo o modific치ndolo seg칰n sea necesario.\n\n\nSupongamos que necesitamos representar rect치ngulos en Python. Anteriormente, optamos por por representarlos con una tupla de longitud dos, donde el primer elemento representaba la base y el segundo la altura. Ahora, que ya dimos nuestros primeros pasos con la programaci칩n orientada a objetos, podemos crear una clase que no solo nos permite almacenar estado (los atributos de cada rect치ngulo), sino que nos posibilta implementar m칠todos que nos permiten obtener otras cantidades de inter칠s.\n\nclass Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    @property\n    def area(self):\n        return self.base * self.altura\n\n    @property\n    def perimetro(self):\n        return self.base * 2 + self.altura * 2\n\n    def resumen(self):\n        return f\"Rectangulo(base={self.base}, altura={self.altura})\"\n\n\nr1 = Rectangulo(4, 7)\nprint(r1.resumen())\nprint(\"츼rea:\", r1.area)\nprint(\"Per칤metro:\", r1.perimetro)\n\nRectangulo(base=4, altura=7)\n츼rea: 28\nPer칤metro: 22\n\n\nSi queremos representar cuadrados, podemos crear otra clase:\n\nclass Cuadrado:\n    def __init__(self, lado):\n        self.lado = lado\n\n    @property\n    def area(self):\n        return self.lado * self.lado\n\n    @property\n    def perimetro(self):\n        return self.lado * 4\n\n    def resumen(self):\n        return f\"Cuadrado(lado={self.lado})\"\n\nc1 = Cuadrado(3)\nprint(c1.resumen())\nprint(\"츼rea:\", c1.area)\nprint(\"Per칤metro:\", c1.perimetro)\n\nCuadrado(lado=3)\n츼rea: 9\nPer칤metro: 12\n\n\nEn Python podemos usar la funci칩n isinstance para verificar si un objeto es instancia de una clase determinada. Por ejemplo, en el siguiente c칩digo comprobamos que r1 es una instancia de Rectangulo y que c1 es una instancia de Cuadrado:\n\nprint(isinstance(r1, Rectangulo))\nprint(isinstance(c1, Cuadrado))\n\nTrue\nTrue\n\n\nSabemos que, desde el punto de vista geom칠trico, un cuadrado es un caso particular de rect치ngulo: tiene base y altura iguales. En otras palabras, todo cuadrado es tambi칠n un rect치ngulo, aunque no todo rect치ngulo sea un cuadrado.\nSin embargo, si intentamos verificar esta relaci칩n en nuestro programa, obtenemos que esto no es asi.\n\nisinstance(c1, Rectangulo)\n\nFalse\n\n\nEsto no significa que los cuadrados no sean rect치ngulos, sino que nuestro c칩digo a칰n no conoce esa relaci칩n entre las clases.",
    "crumbs": [
      "Teor칤a",
      "U3 - Programaci칩n Orientada a Objetos",
      "3 - Herencia"
    ]
  },
  {
    "objectID": "teoria/03_oop/03_herencia.html#herencia-simple",
    "href": "teoria/03_oop/03_herencia.html#herencia-simple",
    "title": "3 - Herencia",
    "section": "Herencia simple",
    "text": "Herencia simple\nLa herencia simple, como su nombre indica, es la forma m치s b치sica de herencia en programaci칩n orientada a objetos. Ocurre cuando una clase (que llamaremos hija, del ingl칠s child) hereda de una 칰nica clase (que llamaremos padre, del ingl칠s parent). Al hacerlo, la clase hija obtiene autom치ticamente los atributos y m칠todos de la clase padre, y puede utilizarlos directamente, modificarlos o agregar otros nuevos. Esto permite reutilizar y ampliar el comportamiento existente sin tener que volver a implementarlo desde cero.\n\nUn primer intento\nLa sintaxis para definir una clase que hereda de otra es la siguiente:\n1class ClasePadre:\n    ...\n\n\n2class ClaseHija(ClasePadre):\n    ...\n\n1\n\nPrimero se define la clase padre de forma habitual, con sus atributos y m칠todos.\n\n2\n\nLuego, al crear la clase hija, se coloca el nombre de la clase padre entre par칠ntesis despu칠s del nombre de la nueva clase, de forma similar a c칩mo se llama a una funci칩n.\n\n\nEn el caso de nuestras clases Rectangulo y Cuadrado tendr칤amos:\n\nclass Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    @property\n    def area(self):\n        return self.base * self.altura\n\n    @property\n    def perimetro(self):\n        return self.base * 2 + self.altura * 2\n\n    def resumen(self):\n        return f\"Rectangulo(base={self.base}, altura={self.altura})\"\n\n\nclass Cuadrado(Rectangulo):\n    def __init__(self, lado):\n        self.lado = lado\n\n    @property\n    def area(self):\n        return self.lado * self.lado\n\n    @property\n    def perimetro(self):\n        return self.lado * 4\n\n    def resumen(self):\n        return f\"Cuadrado(lado={self.lado})\"\n\nAhora, podemos comprobar que los cuadrados s칤 se reconocen como rect치ngulos:\n\nr1 = Rectangulo(2, 5)\nc1 = Cuadrado(3)\n\nprint(isinstance(r1, Rectangulo))\nprint(isinstance(c1, Cuadrado))\nprint(isinstance(c1, Rectangulo))\n\nTrue\nTrue\nTrue\n\n\n\n\nSobreescritura de m칠todos\nLa herencia no solo sirve para que nuestro programa entienda las relaciones entre clases, sino tambi칠n para reutilizar c칩digo sin duplicarlo. Gracias a ella, una clase hija puede aprovechar los atributos y m칠todos definidos en la clase padre y, al mismo tiempo, modificar solo aquello que necesita cambiar. Este proceso, llamado sobreescritura de m칠todos, permite adaptar o ampliar el comportamiento heredado sin necesidad de volver a implementarlo desde cero.\nEn nuestro ejemplo, podemos reutilizar los m칠todos area y perimetro definidos en la clase Rectangulo. Para lograrlo, basta con sobreescribir el m칠todo __init__ en la clase Cuadrado, de modo que asigne el valor de lado a los atributos base y altura.\n\n1class Cuadrado(Rectangulo):\n2    def __init__(self, lado):\n3        self.lado = lado\n        self.base = lado\n        self.altura = lado\n\n\n1\n\nSe crea la clase Cuadrado, que hereda de Rectangulo.\n\n2\n\nSe sobreescribe el m칠todo __init__, que ahora recibe un 칰nico par치metro: lado.\n\n3\n\nComo los m칠todos heredados utilizan los atributos base y altura, debemos asignarles el valor de lado para que el comportamiento siga siendo correcto.\n\n\n\n\nVemos que es posible acceder a las propiedades area y perimetro (en realidad, m칠todos decorados) de los objetos de la clase Cuadrado gracias a que los heredan de la clase Rectangulo.\n\nc1 = Cuadrado(3)\nprint(\"츼rea:\", c1.area)\nprint(\"Per칤metro:\", c1.perimetro)\n\n츼rea: 9\nPer칤metro: 12\n\n\nPor otro lado, el m칠todo resumen indica que se trata de un rect치ngulo.\n\nc1.resumen()\n\n'Rectangulo(base=3, altura=3)'\n\n\nSi bien la informaci칩n que se muestra no es incorrecta, ser칤a a칰n m치s claro que se devuelva una cadena que indica que el objeto no es un rect치ngulo cualquiera, sino que es de un tipo particular: un cuadrado. Para lograrlo, tenemos que reescribir el m칠todo resumen:\n\nclass Cuadrado(Rectangulo):\n    def __init__(self, lado):\n        self.lado = lado\n        self.base = lado\n        self.altura = lado\n\n1    def resumen(self):\n        return f\"Cuadrado(lado={self.lado})\"\n\n\n1\n\nSe reescribe el m칠todo resumen para que devuelva una cadena distinta.\n\n\n\n\n\nCuadrado(3).resumen()\n\n'Cuadrado(lado=3)'\n\n\nEn resumen, nuestro c칩digo queda organizado de la siguiente manera:\n\nClase Rectangulo\n\nSe inicializa con dos argumentos: base y altura.\nDefine tres m칠todos principales:\n\narea(): calcula el 치rea.\nperimetro(): calcula el per칤metro.\nresumen(): devuelve una descripci칩n en texto.\n\n\nClase Cuadrado\n\nHereda de Rectangulo, por lo que tiene acceso a todos sus m칠todos.\nSobreescribe dos de ellos:\n\n__init__(): para inicializar el objeto a partir de un 칰nico valor lado.\nresumen(): para personalizar la descripci칩n.\n\nUsa directamente los m칠todos heredados area() y perimetro() sin necesidad de redefinirlos.\n\n\n\n\n\n\n\n\n쯉ab칤as que? 游뱁\n\n\n\nTodas las clases en Python heredan de una gran clase base llamada object. Por eso, cualquier instancia, sin importar su tipo, es considerada un objeto:\nisinstance(1, object)                  # True\nisinstance(\"algo\", object)             # True\nisinstance([1, 10, 100], object)       # True\nisinstance(Rectangulo(2, 5), object)   # True\nEn Python 2, si quer칤amos aprovechar todas las caracter칤sticas modernas de la programaci칩n orientada a objetos, era necesario declarar expl칤citamente que nuestra clase heredaba de object. Por eso, era com칰n encontrar definiciones as칤:\nclass MiClase(object):\n    ...\nEn Python 3, esto ya no es necesario: todas las clases heredan de object de forma impl칤cita.\n\n\n\n\nFormas generales\nUn programa que trabaja con cuadrados y rect치ngulos probablemente tamb칤en incluya otros tipos de figuras geom칠tricas, como los c칤rculos. La clase Circulo define c칤rculos en base a su radio y, al igual que Cuadrado y Rectangulo, permite obtener su 치rea y per칤metro como si fuera un atributo gracias al decorador @property.\n\nimport math\n\nclass Circulo:\n    def __init__(self, radio):\n        self.radio = radio\n\n    @property\n    def area(self):\n1        return self.radio ** 2 * math.pi\n\n    @property\n    def perimetro(self):\n2        return 2 * self.radio * math.pi\n\n    def resumen(self):\n        return f\"Circulo(radio={self.radio})\"\n\n\n1\n\nEl 치rea de un c칤rculo es \\(r ^ 2 \\pi\\)\n\n2\n\nEl per칤metro de un c칤rculo es \\(2 r \\pi\\)\n\n\n\n\n\nc1 = Circulo(3)\nprint(c1.resumen())\nprint(\"츼rea:\", c1.area)\nprint(\"Per칤metro:\", c1.perimetro)\n\nCirculo(radio=3)\n츼rea: 28.274333882308138\nPer칤metro: 18.84955592153876\n\n\nEn este caso, no es posible establecer una jerarqu칤a que relacione directamente a la clase Circulo con Cuadrado y Rectangulo; no es ni un caso particular de las otras ni nos permitir칤a reutilizar ninguno de los m칠todos implementados.\nSin embargo, s칤 es posible considerar a todas estas clases como casos particulares de una clase base mayor: las figuras geom칠tricas.\n\n\nInterfaz informal\nVamos a crear una clase llamada Forma, que servir치 como clase base para todas las figuras geom칠tricas que implementemos. En ella, estableceremos que cualquier clase hija deber치 contar con las propiedades area y perimetro, adem치s de un m칠todo resumen.\nComo Forma representa un concepto general, no podemos dar una implementaci칩n concreta de estos m칠todos (ya que el c치lculo del 치rea o el per칤metro depende de la figura espec칤fica). Por eso, en esta primera versi칩n simplemente hacemos que los m칠todos devuelvan None, indicando que deber치n ser implementados por las clases hijas.\n\nclass Forma:\n    @property\n    def area(self):\n        return None\n\n    @property\n    def perimetro(self):\n        return None\n\n    def resumen(self):\n        return \"Forma()\"\n\nf1 = Forma()\nprint(f1.resumen())\nprint(\"츼rea:\", f1.area)\nprint(\"Per칤metro:\", f1.perimetro)\n\nForma()\n츼rea: None\nPer칤metro: None\n\n\nAhora, volvemos a implementar las clases Rectangulo y Cuadrado. Comenzamos con Rectangulo, haciendo que esta herede de Forma:\n\nclass Rectangulo(Forma):\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    @property\n    def area(self):\n        return self.base * self.altura\n\n    @property\n    def perimetro(self):\n        return self.base * 2 + self.altura * 2\n\n    def resumen(self):\n        return f\"Rectangulo(base={self.base}, altura={self.altura})\"\n\nY vemos que todos sus m칠todos funcionan correctamente:\n\nr1 = Rectangulo(5, 2)\nprint(r1.resumen())\nprint(\"츼rea:\", r1.area)\nprint(\"Per칤metro:\", r1.perimetro)\n\nRectangulo(base=5, altura=2)\n츼rea: 10\nPer칤metro: 14\n\n\nHacemos lo propio con la clase Cuadrado. En este caso, no es necesario declarar expl칤citamente que hereda de Forma, porque la relaci칩n ya est치 establecida de manera indirecta: Cuadrado hereda de Rectangulo, y Rectangulo hereda de Forma. En otras palabras, como los rect치ngulos son formas geom칠tricas y los cuadrados son rect치ngulos, se tiene que los cuadrados tambi칠n son formas geom칠tricas.\n\nclass Cuadrado(Rectangulo):\n    def __init__(self, lado):\n        self.lado = lado\n        self.base = lado\n        self.altura = lado\n\n    def resumen(self):\n        return f\"Cuadrado(lado={self.lado})\"\n\nc1 = Cuadrado(2)\nprint(c1.resumen())\nprint(\"츼rea:\", c1.area)\nprint(\"Per칤metro:\", c1.perimetro)\n\nCuadrado(lado=2)\n츼rea: 4\nPer칤metro: 8\n\n\nPor otro lado, volvemos a implementar la clase Circulo, esta vez heredando de Forma:\n\nclass Circulo(Forma):\n    def __init__(self, radio):\n        self.radio = radio\n\n    @property\n    def area(self):\n        return self.radio ** 2 * math.pi\n\n    @property\n    def perimetro(self):\n        return 2 * self.radio * math.pi\n\n    def resumen(self):\n        return f\"Circulo(radio={self.radio})\"\n\nci1 = Circulo(3)\nprint(ci1.resumen())\nprint(\"츼rea:\", ci1.area)\nprint(\"Per칤metro:\", ci1.perimetro)\n\nCirculo(radio=3)\n츼rea: 28.274333882308138\nPer칤metro: 18.84955592153876\n\n\nY, finalmente, podemos ver que todas las relaciones entre los tipos creados se reflejan correctamente:\n\n# r1 es Rectangulo y Forma\nprint(isinstance(r1, Rectangulo))\nprint(isinstance(r1, Forma))\n\nTrue\nTrue\n\n\n\n# c1 es Cuadrado, Rectangulo y Forma\nprint(isinstance(c1, Cuadrado))\nprint(isinstance(c1, Rectangulo))\nprint(isinstance(c1, Forma))\n\nTrue\nTrue\nTrue\n\n\n\n# ci1 es Circulo y Forma\nprint(isinstance(ci1, Circulo))\nprint(isinstance(ci1, Forma))\n\nTrue\nTrue\n\n\n\n\nInterfaz formal\nEn programaci칩n orientada a objetos existe un tipo especial de clase pensado para casos como el de Forma: clases que no se usan para crear objetos directamente, pero que s칤 definen una interfaz com칰n para sus clases hijas e imponen la implementaci칩n de ciertos m칠todos y propiedades. A este tipo de clases se las conoce como clases abstractas.\nEn Python, podemos crear una clase abstracta haciendo que herede de la clase ABC del m칩dulo est치ndar abc (cuyas siglas significan abstract base class). Este m칩dulo tambi칠n ofrece el decorador @abstractmethod, que permite definir m칠todos abstractos y obliga a las clases hijas a implementarlos. Adem치s, si combinamos @abstractmethod con @property, podemos crear propiedades abstractas que deber치n ser definidas en las subclases.\nImplementemos ahora la clase abstracta Forma.\n\nfrom abc import ABC, abstractmethod\n\n1class Forma(ABC):\n2    @property\n    @abstractmethod\n    def area(self):\n        pass\n\n3    @property\n    @abstractmethod\n    def perimetro(self):\n        pass\n\n4    @abstractmethod\n    def resumen(self):\n        pass\n\n\n1\n\nSe comienza a implementar la clase Forma, que hereda de la clase ABC.\n\n2\n\nSe implementa la propiedad abstracta area. La decoraci칩n con @property y @abstractmethod obligan a las clases hijas a implementar un m칠todo area decorado con @property. Se usa pass porque no se provee una implementaci칩n concreta.\n\n3\n\nSe implementa la propiedad abstracta perimetro de manera similar a area.\n\n4\n\nSe implementa el m칠todo abstracto resumen, que las clases hijas deben implementar como un m칠todo regular.\n\n\n\n\nSi intentamos crear un objeto Forma obtendremos un error porque esta clase no est치 pensada para crear objetos, sino para servir como modelo o interfaz com칰n de otras clases.\nForma()\n\nTypeError: Can't instantiate abstract class Forma without an implementation for abstract methods 'area', 'perimetro', 'resumen'\n\nTampoco podemos crear una clase que herede de forma e implemente solamente alguno de los m칠todos abstractos. Por ejemplo, si la clase Rectangulo no implementa el m칠todo resumen, tambi칠n se obtiene un error.\nclass Rectangulo(Forma):\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    @property\n    def area(self):\n        return self.base * self.altura\n\n    @property\n    def perimetro(self):\n        return self.base * 2 + self.altura * 2\n\nRectangulo(2, 1)\n\nTypeError: Can't instantiate abstract class Rectangulo without an implementation for abstract method 'resumen'\n\nPara que la implementaci칩n de una clase derivada de una clase abstracta no arroje ning칰n error, es necesario implementar todos los m칠todos y propiedades abstractas de la clase base, como se hace a continuaci칩n:\n\nclass Rectangulo(Forma):\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    @property\n    def area(self):\n        return self.base * self.altura\n\n    @property\n    def perimetro(self):\n        return self.base * 2 + self.altura * 2\n\n    def resumen(self):\n        return f\"Rectangulo(base={self.base}, altura={self.altura})\"\n\nr = Rectangulo(2, 1)\nr.resumen()\n\n'Rectangulo(base=2, altura=1)'\n\n\nDe manera an치loga, se pueden reimplementar las clases Cuadrado y Rectangulo.\n\nclass Cuadrado(Rectangulo):\n    def __init__(self, lado):\n        self.lado = lado\n        self.base = lado\n        self.altura = lado\n\n    def resumen(self):\n        return f\"Cuadrado(lado={self.lado})\"\n\n\nclass Circulo(Forma):\n    def __init__(self, radio):\n        self.radio = radio\n\n    @property\n    def area(self):\n        return self.radio ** 2 * math.pi\n\n    @property\n    def perimetro(self):\n        return self.radio ** 2 * math.pi\n\n    def resumen(self):\n        return f\"Circulo(radio={self.radio})\"\n\nc = Cuadrado(2)\nprint(c.resumen())\nci = Circulo(1.5)\nprint(ci.resumen())\n\nCuadrado(lado=2)\nCirculo(radio=1.5)\n\n\n\nprint(isinstance(r, Forma))\nprint(isinstance(c, Forma))\nprint(isinstance(ci, Forma))\n\nTrue\nTrue\nTrue\n\n\nAl utilizar una clase abstracta como Forma, no solo definimos una clase base que engloba a todos los tipos de figuras geom칠tricas que podamos implementar, sino que tambi칠n garantizamos que esas clases implementen los m칠todos y propiedades abstractas necesarias (area, perimetro y resumen). El uso de la clases abstractas impone un contrato claro que hace que el c칩digo sea m치s predecible y f치cil de mantener.\n\n\n\n\n\n\nAfinando el vocabulario\n\n\n\nA lo largo de este apunte mencionamos muchos t칠rminos relacionados a la programaci칩n orientada a objetos, es hora de afinar el vocabulario:\n\nClase padre (o clase base): es la clase de la que heredan otras. Puede ser concreta o abstracta, y define atributos y m칠todos comunes que las clases hijas pueden reutilizar, extender o modificar.\nClase hija (o clase derivada): es la clase que hereda de una clase padre. Hereda sus atributos y m칠todos, y puede agregar nueva funcionalidad o redefinir la existente.\nClase abstracta: es una clase que sirve como modelo general y no est치 pensada para crear objetos directamente. Puede contener m칠todos sin implementar, que deber치n definirse en las clases hijas.\nImplementaci칩n concreta: es una clase o m칠todo completamente definido y funcional, que puede usarse directamente para crear objetos o ejecutar comportamiento.",
    "crumbs": [
      "Teor칤a",
      "U3 - Programaci칩n Orientada a Objetos",
      "3 - Herencia"
    ]
  },
  {
    "objectID": "teoria/03_oop/03_herencia.html#herencia-m칰ltiple",
    "href": "teoria/03_oop/03_herencia.html#herencia-m칰ltiple",
    "title": "3 - Herencia",
    "section": "Herencia m칰ltiple",
    "text": "Herencia m칰ltiple\nHasta ahora vimos que en programaci칩n orientada a objetos una clase puede heredar de otra, lo que permite reutilizar atributos y m칠todos. En todos los ejemplos anteriores, esa herencia fue simple, ya que cada clase hija ten칤a una 칰nica clase padre, sin importar su complejidad o si era concreta o abstracta.\nSin embargo, al igual que muchos otros lenguajes orientados a objetos, Python tambi칠n permite la herencia m칰ltiple. El concepto es sencillo: una clase puede heredar de varias clases padre al mismo tiempo, combinando sus funcionalidades y accediendo a todos sus m칠todos y atributos.\nEn esta secci칩n, utilizaremos herencia m칰ltiple para representar diferentes distribuciones de probabilidad (discretas y continuas). Nuestro objetivo es implementar dos distribuciones: la normal (Normal) y la Poisson (Poisson). Estas clases van a contar con m칠todos para generar muestras aleatorias y graficar su distribuci칩n.\n\nEjemplo b치sico\nAntes de atrevernos a implementar distribuciones de probabilidad en Python usando herencia m칰ltiple, veamos un ejemplo muy sencillo de c칩mo funciona:\n\nclass A:\n    def saludar(self):\n        return \"Hola desde A\"\n\nclass B:\n    def despedir(self):\n        return \"Chau desde B\"\n\nclass C(A, B):\n    def saltar(self):\n        return \"Saltando desde C\"\n\n\ncosa = C()\n\n\ncosa.saludar()\n\n'Hola desde A'\n\n\n\ncosa.despedir()\n\n'Chau desde B'\n\n\n\ncosa.saltar()\n\n'Saltando desde C'\n\n\n\n\nDistribuci칩n normal\nComencemos implementando una clase abstracta llamada Distribucion que contiene los siguientes m칠todos abstractos:\n\nmuestra: Genera un valor aleatorio de la distribuci칩n\ngraficar: Genera un gr치fico que permite apreciar la distribuci칩n.\n\nAdem치s, tambi칠n incluye un m칠todo concreto que devuelve n muestras de la distribuci칩n\n\nclass Distribucion(ABC):\n    @abstractmethod\n    def muestra(self):\n        pass\n\n    @abstractmethod\n    def graficar(self):\n        pass\n\n    def muestras(self, n=1):\n        return [self.muestra() for _ in range(n)]\n\nPara inicializar la distribuci칩n normal usamos su media mu y desv칤o est치ndar sigma. Incluimos un m칠todo pdf que devuelve la funci칩n de densidad normal evaluada en un punto x e implementamos los m칠todos muestra y graficar que son requeridos por la clase padre Distribucion.\n\nimport random\nimport matplotlib.pyplot as plt\n\nclass Normal(Distribucion):\n    def __init__(self, mu, sigma):\n        self.mu = mu\n        self.sigma = sigma\n\n    def pdf(self, x):\n        a = 1 / (self.sigma * (2 * math.pi) ** 0.5)\n        b = math.exp( - 0.5 * ((x - self.mu) ** 2 / self.sigma ** 2))\n        return a * b\n\n    def muestra(self):\n        return random.normalvariate(mu=self.mu, sigma=self.sigma)\n\n    def graficar(self):\n        # Construir valores de 'x'\n        x_inicio = self.mu - self.sigma * 3\n        x_fin = self.mu + self.sigma * 3\n        x_paso = (x_fin - x_inicio) / 500\n        xs = [x_inicio + x_paso * i for i in range(500)]\n\n        # Construir valores de 'y'\n        ys = [self.pdf(x) for x in xs]\n\n        # Crear gr치fico\n        plt.plot(xs, ys)\n        plt.xlabel(\"x\")\n        plt.ylabel(\"p(x)\")\n        plt.title(f\"Normal(mu={self.mu}, sigma={self.sigma})\")\n        plt.show()\n\nSi queremos trabajar con una distribuci칩n normal de media 3 y desv칤o 1, basta con inicializarla de la siguiente manera:\n\nnormal = Normal(mu=3, sigma=1)\n\nAhora, podemos obtener uno o m칰ltiples n칰meros aleatorios de dicha distribuci칩n:\n\nnormal.muestra()\n\n2.248231320099541\n\n\n\nnormal.muestras(10)\n\n[0.6458518679909164,\n 3.9120653695218515,\n 2.1150760712804373,\n 2.9766247862532924,\n 3.9150019616191267,\n 2.4612383165622287,\n 2.0434502376268586,\n 2.3696759257123254,\n 1.8845024386324847,\n 1.9123881947344514]\n\n\nY si queremos evaluar la funci칩n de densidad en un punto (es decir, obtener la altura de la curva normal en un punto), usamos el m칠todo pdf que implementamos anteriormente.\n\nnormal.pdf(2)\n\n0.24197072451914337\n\n\n\nnormal.pdf(2.5), normal.pdf(3), normal.pdf(3.5) # Simetr칤a alrededor de la media.\n\n(0.3520653267642995, 0.3989422804014327, 0.3520653267642995)\n\n\nFinalmente, nuestro objeto tambi칠n nos permite visualizar la distribuci칩n.\n\nnormal.graficar()\n\n\n\n\n\n\n\n\n\n\nDistribuci칩n Poisson\nAhora que ya contamos la distribuci칩n normal, podemos continuar con la distribuci칩n de Poisson.\nPara inicializarla vamos a usar el par치metro \\(\\lambda\\), que representa tanto la media como la varianza. Pero, como lambda es una palabra reservada en Python, usaremos su versi칩n abreviada lam.\nAdem치s, como se trata de una distribuci칩n para variables discretas, no corresponde implementar un m칠todo pdf (probability density function), sino pmf (probability mass function). Esto tambi칠n influye en la visualizaci칩n: en lugar de representar una curva continua, utilizaremos un gr치fico de bastones para mostrar la distribuci칩n.\n\nclass Poisson(Distribucion):\n    def __init__(self, lam):\n        self.lam = lam\n\n    def pmf(self, x):\n        return (math.exp(-self.lam) * self.lam ** x) / math.factorial(x)\n\n    def muestra(self):\n        S, N = 0, 0\n        while S &lt; 1:\n            u = random.uniform(0, 1)\n            N += 1\n            S += - math.log(u) / self.lam\n        return N - 1\n\n    def graficar(self):\n        # Construir valores de 'x'\n        xs = []\n        x, cdf = 0, 0\n        while cdf &lt; 0.999:\n            xs.append(x)\n            cdf += self.pmf(x)\n            x += 1\n\n        # Construir valores de 'y'\n        ys = [self.pmf(x) for x in xs]\n\n        plt.vlines(xs, ymin=0, ymax=ys, lw=3)\n        plt.xlabel(\"x\")\n        plt.ylabel(\"P(X = x)\")\n        plt.title(f\"Poisson(lam={self.lam})\")\n        plt.show()\n\n\npoisson = Poisson(3)\npoisson.muestra()\n\n1\n\n\n\npoisson.muestras(5)\n\n[3, 6, 7, 3, 9]\n\n\n\npoisson.pmf(3)\n\n0.22404180765538775\n\n\n\npoisson.graficar()\n\n\n\n\n\n\n\n\n\nPoisson(5).graficar()\n\n\n\n\n\n\n\n\n\nPoisson(10).graficar()\n\n\n\n\n\n\n\n\n\n\nHerencia m칰ltiple en acci칩n\nSi bien obtuvimos clases funcionales para trabajar con variables aleatorias normales y Poisson, a칰n no hemos hecho uso de la herencia m칰ltiple.\nPara hacerlo, vamos a definir tres clases independientes, con responsabilidades bien diferenciadas:\n\nDistribucion: declara m칠todos gen칠ricos comunes a cualquier distribuci칩n de probabilidad.\nDiscreta: define el m칠todo abstracto pmf y un m칠todo concreto crear_grafico que genera un gr치fico de bastones.\nContinua: define el m칠todo abstracto pdf y un m칠todo crear_grafico que representa la distribuci칩n con una curva.\n\nEstas clases servir치n como base para construir distribuciones m치s espec칤ficas combinando funcionalidades a trav칠s de herencia m칰ltiple.\n\nclass Distribucion(ABC):\n    @abstractmethod\n    def muestra(self):\n        pass\n\n    @abstractmethod\n    def graficar(self):\n        pass\n\n    def muestras(self, n=1):\n        return [self.muestra() for _ in range(n)]\n\n\nclass Discreta(ABC):\n    @abstractmethod\n    def pmf(self, x):\n        pass\n\n    def crear_grafico(self, xs):\n        ys = [self.pmf(x) for x in xs]\n        plt.vlines(xs, ymin=0, ymax=ys, lw=3)\n        plt.xlabel(\"x\")\n        plt.ylabel(\"P(X = x)\")\n\n\nclass Continua(ABC):\n    @abstractmethod\n    def pdf(self, x):\n        pass\n\n    def crear_grafico(self, xs):\n        ys = [self.pdf(x) for x in xs]\n        plt.plot(xs, ys)\n        plt.xlabel(\"x\")\n        plt.ylabel(\"p(x)\")\n\nSi combinamos Distribucion y Continua, tenemos la base para implementar nuestra clase Normal.\n\nclass Normal(Distribucion, Continua):\n    def __init__(self, mu, sigma):\n        self.mu = mu\n        self.sigma = sigma\n\n    def pdf(self, x):\n        a = 1 / (self.sigma * (2 * math.pi) ** 0.5)\n        b = math.exp( - 0.5 * ((x - self.mu) ** 2 / self.sigma ** 2))\n        return a * b\n\n    def muestra(self):\n        return random.normalvariate(mu=self.mu, sigma=self.sigma)\n\n    def graficar(self):\n        x_inicio = self.mu - self.sigma * 3\n        x_fin = self.mu + self.sigma * 3\n        x_paso = (x_fin - x_inicio) / 500\n        xs = [x_inicio + x_paso * i for i in range(500)]\n        self.crear_grafico(xs)\n        plt.title(f\"Normal(mu={self.mu}, sigma={self.sigma})\")\n        plt.show()\n\nnormal = Normal(2, 1)\n\n\nnormal.muestras(5)\n\n[1.9364943585753434,\n 3.431844507514179,\n 4.1148165485370365,\n 0.7869931091513576,\n 1.99320198616381]\n\n\n\nnormal.graficar()\n\n\n\n\n\n\n\n\nCuando llamamos al m칠todo muestras, estamos haciendo uso del m칠todo concreto implementado en Distribucion, y cuando llamamos a graficar, estamos haciendo uso del m칠todo concreto implementado en Continua.\nPor otro lado, si combinamos Distribucion y Discreta tenemos la base para reimplementar nuestra clase Poisson.\n\nclass Poisson(Distribucion, Discreta):\n    def __init__(self, lam):\n        self.lam = lam\n\n    def pmf(self, x):\n        return (math.exp(-self.lam) * self.lam ** x) / math.factorial(x)\n\n    def muestra(self):\n        S, N = 0, 0\n        while S &lt; 1:\n            u = random.uniform(0, 1)\n            N += 1\n            S += - math.log(u) / self.lam\n        return N - 1\n\n    def graficar(self):\n        xs = []\n        x, cdf = 0, 0\n        while cdf &lt; 0.999:\n            xs.append(x)\n            cdf += self.pmf(x)\n            x += 1\n\n        self.crear_grafico(xs)\n        plt.title(f\"Poisson(lam={self.lam})\")\n        plt.show()\n\n\nPoisson(4).graficar()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReflexi칩n sobre el uso de herencia m칰ltiple\n\n\n\nEn el ejemplo de las distribuciones de probabilidad, cada clase concreta hereda de dos clases: Distribucion y Discreta o Continua, seg칰n corresponda. Esta no es la 칰nica forma posible de estructurar el c칩digo: podr칤amos haber hecho que Discreta y Continua heredaran de Distribucion, y que las distribuciones concretas heredaran solo de una de ellas (obteniendo as칤 a Distribucion de manera indirecta).\nComo el objetivo de esta secci칩n era trabajar con herencia m칰ltiple, decidimos mantener las clases por separado.\n\n\n\n\n\n\n\n\nMethod resolution order (MRO)\n\n\n\nEn la pr치ctica, es sencillo usar herencia m칰ltiple cuando cada clase padre define m칠todos y atributos con nombres distintos. El problema aparece cuando dos o m치s clases padre implementan un m칠todo con el mismo nombre. En esos casos, Python usa un mecanismo llamado Method resolution order (MRO) para determinar cu치l ejecutar.\nEn pocas palabras, Python busca primero en la clase actual, luego en el orden en que fueron listadas las clases padre, y finalmente en la jerarqu칤a de herencia.\nPor ejemplo:\nclass A:\n    def saludar(self):\n        print(\"Hola desde A\")\n\nclass B:\n    def saludar(self):\n        print(\"Hola desde B\")\n\nclass C(A, B):\n    pass\n\nC().saludar()  # Hola desde A\nEn este ejemplo, C hereda de A y B, pero al llamar saludar() se ejecuta el de A porque est치 primero en el MRO. Podemos inspeccionar este orden con C.__mro__ o C.mro().\n\n\n\n\nUso de super()\nA veces queremos extender el comportamiento de un m칠todo heredado sin reescribirlo por completo.\nSupongamos que queremos crear una versi칩n ruidosa de las listas, llamada ListaRuidosa, que se comporte exactamente igual que una lista normal salvo por un detalle: cada vez que agreguemos un elemento con append, imprimir치 un mensaje adicional.\nPara lograrlo, podemos sobreescribir el m칠todo append y, en lugar de copiar toda su l칩gica, simplemente agregar el print en el lugar adecuado y luego llamar al m칠todo original de la clase padre usando super(). As칤 modificamos solo lo necesario y mantenemos el resto del comportamiento intacto.\n\n1class ListaRuidosa(list):\n2    def append(self, elemento):\n3        print(\"Agregando:\", elemento)\n4        super().append(elemento)\n\n\n1\n\nListaRuidosa hereda de list.\n\n2\n\nSe reimplementa el m칠todo append, que recibe un argumento: el elemento a agregar al final.\n\n3\n\nCuando se llama a append se imprime un mensaje indicando el elemento que se agrega.\n\n4\n\nFinalmente, se llama al m칠todo append de la clase padre.\n\n\n\n\nObservemos a nuestra nueva clase en acci칩n. Se ve como una lista, porque es una lista.\n\nlista_ruidosa = ListaRuidosa()\nlista_ruidosa\n\n[]\n\n\nPero no es cualquier lista, 춰es ruidosa!\n\nlista_ruidosa.append(\"쯙unciona?\")\n\nAgregando: 쯙unciona?\n\n\n\nlista_ruidosa\n\n['쯙unciona?']\n\n\n\nprint(type(lista_ruidosa)) # Es una lista ruidosa\nprint(isinstance(lista_ruidosa, list)) # 춰Pero tambi칠n es una lista!\n\n&lt;class '__main__.ListaRuidosa'&gt;\nTrue\n\n\nY podr칤amos continuar agregando elementos뵢n\nlista_ruidosa.append(\"쯫 esto?\")\n\nAgregando: 쯫 esto?\n\n\n\nlista_ruidosa\n\n['쯙unciona?', '쯫 esto?']",
    "crumbs": [
      "Teor칤a",
      "U3 - Programaci칩n Orientada a Objetos",
      "3 - Herencia"
    ]
  },
  {
    "objectID": "teoria/03_oop/04_polimorfismo.html",
    "href": "teoria/03_oop/04_polimorfismo.html",
    "title": "4 - Polimorfismo",
    "section": "",
    "text": "El t칠rmino polimorfismo tiene origen en las palabras poly (muchos) y morfo (formas). Aplicado a la programaci칩n hace referencia a que los objetos pueden tomra diferentes formas.\nPero, 쯤u칠 significa que los objetos pueden tomar diferentes formas? En el contexto de programaci칩n orientada a objetos significa que los objetos pueden responder a una misma operaci칩n de distintas maneras.\nTomemos, por ejemplo, la suma de dos variables:\na + b\nSi a y b son de tipo int, la operaci칩n est치 definida y devuelve otro int. Si son de tipo list, la operaci칩n tambi칠n est치 definida y devuelve un nuevo objeto list. As칤, diferentes tipos de datos, responden al mismo mensaje (la suma) de maneras distintas.",
    "crumbs": [
      "Teor칤a",
      "U3 - Programaci칩n Orientada a Objetos",
      "4 - Polimorfismo"
    ]
  },
  {
    "objectID": "teoria/03_oop/04_polimorfismo.html#introducci칩n",
    "href": "teoria/03_oop/04_polimorfismo.html#introducci칩n",
    "title": "4 - Polimorfismo",
    "section": "",
    "text": "El t칠rmino polimorfismo tiene origen en las palabras poly (muchos) y morfo (formas). Aplicado a la programaci칩n hace referencia a que los objetos pueden tomra diferentes formas.\nPero, 쯤u칠 significa que los objetos pueden tomar diferentes formas? En el contexto de programaci칩n orientada a objetos significa que los objetos pueden responder a una misma operaci칩n de distintas maneras.\nTomemos, por ejemplo, la suma de dos variables:\na + b\nSi a y b son de tipo int, la operaci칩n est치 definida y devuelve otro int. Si son de tipo list, la operaci칩n tambi칠n est치 definida y devuelve un nuevo objeto list. As칤, diferentes tipos de datos, responden al mismo mensaje (la suma) de maneras distintas.",
    "crumbs": [
      "Teor칤a",
      "U3 - Programaci칩n Orientada a Objetos",
      "4 - Polimorfismo"
    ]
  },
  {
    "objectID": "teoria/03_oop/04_polimorfismo.html#ejemplos",
    "href": "teoria/03_oop/04_polimorfismo.html#ejemplos",
    "title": "4 - Polimorfismo",
    "section": "Ejemplos",
    "text": "Ejemplos\nA lo largo de esta secci칩n vamos a introducirnos en el polimorfismo mediante diferentes ejemplos.\n\nAnimales que hablan\nEn programaci칩n orientada a objetos (POO), el polimorfismo se refiere a la capacidad que tiene el programa de invocar un mismo m칠todo en objetos distintos, y que cada objeto responda de la forma que le corresponde seg칰n su propia implementaci칩n.\nPor ejemplo, imaginemos que tenemos una colecci칩n de perros, gatos y p치jaros, y que cada uno entiende algunos comandos b치sicos. Si les pedimos a estas mascotas que hablen (es decir, si les enviamos el mensaje 랃abla), los perros van a ladrar, los gatos van a maullar y los p치jaros van a piar.\n\nclass Animal:\n    def __init__(self, nombre):\n        self.nombre = nombre\n\nclass Perro(Animal):\n1    def hablar(self):\n        print(self.nombre, \"dice 춰guau!\")\n\nclass Gato(Animal):\n2    def hablar(self):\n        print(self.nombre, \"dice 춰miau!\")\n\nclass Pajaro(Animal):\n3    def hablar(self):\n        print(self.nombre, \"dice 춰pio pio!\")\n\n\n1\n\nLos perros dicen guau.\n\n2\n\nLos gatos dicen miau.\n\n3\n\nLos p치jaros dicen pio pio.\n\n\n\n\nComo todos los animales tienen la capacidad de hablar, podemos recorrer una lista de animales y ejecutar el m칠todo hablar en cada uno de ellos, sin importar de qu칠 tipo de animal se trate. Todos podr치n responder a la llamada, cada uno a su manera.\n\nmascotas = [\n    Perro(\"Julio\"),\n    Gato(\"Micha\"),\n    Perro(\"Justo\"),\n    Pajaro(\"Pedrito\")\n]\n\nfor mascota in mascotas:\n    mascota.hablar()\n\nJulio dice 춰guau!\nMicha dice 춰miau!\nJusto dice 춰guau!\nPedrito dice 춰pio pio!\n\n\n\n\n\n\n\n\n쮼nviar un mensaje?\n\n\n\nEn el contexto de la programaci칩n orientada a objetos se suele usar la expresi칩n 란nviar un mensaje cuando hablamos de que un programa (tambi칠n llamado cliente) llama a un m칠todo de un objeto o invoca una operaci칩n sobre el mismo. Por ejemplo:\nobjeto.correr() # Se env칤a el mensaje correr\nobj + obj2      # Se env칤a el mensaje de suma (__add__)\nLo que el objeto haga al recibir ese mensaje depende exclusivamente de 칠l. Con el polimorfismo, podemos enviar el mismo mensaje a varios objetos, y cada uno va a reaccionar de manera diferente seg칰n c칩mo fue dise침ado y seg칰n los datos que tenga disponibles.\n\n\n\n\nLa forma es lo de menos\nPodemos retomar el ejemplo de los rect치ngulos y circulos del apunte anterior. Ambos tienen acceso al m칠todo area que devuelve el 치rea de la figura.\n\nimport math\n\nclass Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    def area(self):\n        return self.base * self.altura\n\n    def resumen(self):\n        return f\"Rectangulo(base={self.base}, altura={self.altura})\"\n\n\nclass Circulo:\n    def __init__(self, radio):\n        self.radio = radio\n\n    def area(self):\n        return self.radio ** 2 * math.pi\n\n    def resumen(self):\n        return f\"Circulo(radio={self.radio})\"\n\nSi contamos con un listado de rect치ngulos y c칤rculos, podemos usar la funci칩n sorted junto a una funci칩n an칩nima para ordenar los elementos seg칰n su 치rea.\n\nformas = [\n    Circulo(2),\n    Rectangulo(3, 2),\n    Circulo(1.4),\n    Rectangulo(4, 3),\n    Rectangulo(6, 4),\n]\n\n# Ordenar\nformas_ordenadas = sorted(formas, key=lambda f: f.area())\n\n# Imprimir formas en orden\nfor forma in formas_ordenadas:\n    print(forma.resumen(), forma.area(), sep=\": \")\n\nRectangulo(base=3, altura=2): 6\nCirculo(radio=1.4): 6.157521601035993\nRectangulo(base=4, altura=3): 12\nCirculo(radio=2): 12.566370614359172\nRectangulo(base=6, altura=4): 24\n\n\nCuando la funci칩n an칩nima recibe una forma f, ejecuta su m칠todo area sin importar de qu칠 tipo sea. Como tanto rect치ngulos como c칤rculos saben c칩mo responder a esa llamada devolviendo un n칰mero, pueden ordenarse correctamente seg칰n ese valor.\nAunque ambos m칠todos devuelvan el mismo tipo de resultado (un n칰mero), la forma en que se calcula ese resultado es distinta y depende de cada figura geom칠trica. De eso se trata el polimorfismo.",
    "crumbs": [
      "Teor칤a",
      "U3 - Programaci칩n Orientada a Objetos",
      "4 - Polimorfismo"
    ]
  },
  {
    "objectID": "teoria/03_oop/04_polimorfismo.html#m칠todos-m치gicos",
    "href": "teoria/03_oop/04_polimorfismo.html#m칠todos-m치gicos",
    "title": "4 - Polimorfismo",
    "section": "M칠todos m치gicos",
    "text": "M칠todos m치gicos\nEl polimorfismo no solo se da con m칠todos regulares como hablar o area. Realmente, la magia del polimorfismo aparece cuando incorporamos los m칠todos m치gicos de Python en nuestras clases.\nLos m칠todos m치gicos 닶ambi칠n llamados dunder methods (por 띿ouble underscore) son m칠todos especiales que permiten que nuestros objetos participen en operaciones est치ndar del lenguaje, como comparaciones, sumas, conversiones a cadenas o iteraciones.\nPor ejemplo, si intentamos comparar dos rect치ngulos creados con nuestra clase Rectangulo, incluso si tienen las mismas dimensiones, la comparaci칩n devolver치 False.\n\nr1 = Rectangulo(3, 2)\nr2 = Rectangulo(3, 2)\n\nr1 == r2\n\nFalse\n\n\nConceptualmente, tiene sentido esperar que la comparaci칩n en valor de dos rect치ngulos de iguales dimensiones sea True. Pero obtenemos False.\nEsto no ocurre porque r1 y r2 representen objetos distintos, sino porque todav칤a no hemos implementado el m칠todo m치gico que define como se deben comparar objetos de la clase Rectangulo por valor.\n\nComparaciones\nEn Python, el operador de comparaci칩n por valor == utiliza internamente el m칠todo m치gico __eq__. Si queremos comparar rect치ngulos con ==, entonces debemos implementar __eq__.\n\nclass Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    @property\n    def area(self):\n        return self.base * self.altura\n\n1    def __eq__(self, other):\n2        if self.base == other.base and self.altura == other.altura:\n            return True\n3        return False\n\n\n1\n\nEl m칠todo __eq__ recibe siempre dos objetos a comparar, llamados por convenci칩n self y other.\n\n2\n\nSi las bases y las alturas de los objetos son iguales, devuelve True, ya que consideramos que los rect치ngulos son iguales.\n\n3\n\nEn caso contrario, devuelve False, indicando que los rect치ngulos no son iguales.\n\n\n\n\nSi probamos nuestro m칠todo de comparaci칩n reci칠n implementado, vemos que funciona correctamente:\n\nr1 = Rectangulo(3, 2)\nr2 = Rectangulo(3, 2)\nr3 = Rectangulo(5, 3)\n\n\nr1 == r3\n\nFalse\n\n\n\nr2 == r3\n\nFalse\n\n\n\nr1 == r2\n\nTrue\n\n\nNo solo tenemos acceso al operador ==, ahora tambi칠n podemos usar !=.\n\nr1 != r3\n\nTrue\n\n\nTodos los operadores de comparaci칩n se corresponden con un m칠todo especial determinado. La tabla a continuaci칩n incluye el nombre del m칠todo, el operador binario que utulizamos y una descripci칩n de c칩mo funciona.\n\n\n\n\n\n\n\n\nM칠todo\nOperador asociado\nDescripci칩n\n\n\n\n\n__eq__(self, other)\n==\nTrue si self es igual a other.\n\n\n__ne__(self, other)\n!=\nTrue si self no es igual a other.\n\n\n__lt__(self, other)\n&lt;\nTrue si self es menor que other.\n\n\n__le__(self, other)\n&lt;=\nTrue si self es menor o igual que other.\n\n\n__gt__(self, other)\n&gt;\nTrue si self es mayor que other.\n\n\n__ge__(self, other)\n&gt;=\nTrue si self es mayor o igual que other.\n\n\n\nDebajo incorporamos todos estos m칠todos en nuestra clase Rectangulo. No existe un criterio universal para determinar si un rect치ngulo es menor o mayor a otro. En nuestro caso, con el objetivo de mostrar la implementaci칩n de estos m칠todos, podemos decir que un rect치ngulo es menor a otro si su 치rea es menor.\n\nclass Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    @property\n    def area(self):\n        return self.base * self.altura\n\n    def __eq__(self, other):\n        return self.base == other.base and self.altura == other.altura\n\n    def __lt__(self, other):\n        return self.area &lt; other.area\n\n    def __le__(self, other):\n        return self.area &lt;= other.area\n\n    def __gt__(self, other):\n        return self.area &gt; other.area\n\n    def __ge__(self, other):\n        return self.area &gt;= other.area\n\n\nr1 = Rectangulo(3, 5) # 츼rea: 15\nr2 = Rectangulo(3, 4) # 츼rea: 12\nr3 = Rectangulo(5, 3) # 츼rea: 15\n\n\nr1 &lt; r2\n\nFalse\n\n\n\nr1 &lt; r3\n\nFalse\n\n\n\nr1 &lt;= r3\n\nTrue\n\n\n\nr3 &gt; r2\n\nTrue\n\n\n\nr1 == r2\n\nFalse\n\n\n\nr1 == r3 # No son iguales porque sus dimensiones no lo son.\n\nFalse\n\n\n\n\nApariencias\nAdem치s de los operadores de comparaci칩n, muchas funciones built-in de Python utilizan m칠todos m치gicos internamente. Una de las m치s comunes es repr(), que se encarga de devolver una representaci칩n de un objeto cuando se lo muestra en pantalla. Para personalizar esa representaci칩n en nuestras clases, debemos implementar el m칠todo m치gico __repr__.\n\nclass Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    def __repr__(self):\n        return f\"Rectangulo(base={self.base}, altura={self.altura})\"\n\n\nr1 = Rectangulo(5, 3.5)\nr1\n\nRectangulo(base=5, altura=3.5)\n\n\nTambi칠n str utiliza internamente un m칠todo especial llamado __str__, que define c칩mo debe mostrarse un objeto cuando se convierte a texto de forma legible.\n\nclass Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    def __repr__(self):\n        return f\"Rectangulo(base={self.base}, altura={self.altura})\"\n\n    def __str__(self):\n        return f\"Rect치ngulo de base {self.base} y altura {self.altura}\"\n\n\nr1 = Rectangulo(5, 3.5)\nr1\n\nRectangulo(base=5, altura=3.5)\n\n\n\nprint(\"repr:\", repr(r1))\nprint(\"str:\", str(r1))\n\nrepr: Rectangulo(base=5, altura=3.5)\nstr: Rect치ngulo de base 5 y altura 3.5\n\n\n\n\n\n\n\n\nDiferencia entre __repr__ y __str__\n\n\n\nAunque ambos m칠todos devuelven una representaci칩n en texto de un objeto, tienen prop칩sitos distintos:\n\n__repr__ busca ofrecer una representaci칩n precisa y detallada, 칰til para desarrolladores. Idealmente, deber칤a ser lo m치s cercana posible al c칩digo necesario para reconstruir el objeto.\n__str__, en cambio, devuelve una representaci칩n m치s legible y amigable, pensada para usuarios finales o para mostrar el objeto en interfaces y mensajes.\n\nPor ejemplo:\nfrom datetime import datetime\n\nd = datetime(2025, 10, 7, 17, 30)\nprint(\"repr:\", repr(d))\nprint(\"str:\", str(d))\nrepr: datetime.datetime(2025, 10, 7, 17, 30)\nstr: 2025-10-07 17:30:00\n\n\n\n\nAritm칠tica\nFinalmente, retomamos el ejemplo de la introducci칩n del apunte, que tanto hemos mencionado a lo largo del curso: la suma de objetos.\nResulta que el operador de suma + utiliza internamente el m칠todo especial __add__. Gracias a esto, tambi칠n podemos definir c칩mo deben sumarse dos objetos de una clase que nosotros creamos.\nPor ejemplo, supongamos una clase que representa vectores en dos dimensiones, inicializada con valores para x e y.\nLa suma de dos vectores est치 definida componente a componente:\n\\[\n\\vec{u} + \\vec{v} = (x_1 + x_2, y_1 + y_2)\n\\]\nY podemos implementar la clase de la siguiente manera:\n\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n\n    def __repr__(self):\n        return f\"Vector({self.x}, {self.y})\"\n\n\nv = Vector(2, 2)\nu = Vector(1, -0.5)\nprint(v)\nprint(u)\n\nVector(2, 2)\nVector(1, -0.5)\n\n\nGracias a la implementaci칩n de __add__, est치 definida la suma entre vectores:\n\nv + u\n\nVector(3, 1.5)\n\n\nY como tambi칠n implementamos __repr__, obtenemos una representaci칩n textual legible.\nTodos los operadores aritm칠ticos en Python utilizan internamente m칠todos especiales. A continuaci칩n se muestran algunos de los m치s comunes:\n\n\n\n\n\n\n\n\nM칠todo\nOperador asociado\nDescripci칩n\n\n\n\n\n__add__(self, other)\n+\nSuma: self + other\n\n\n__sub__(self, other)\n-\nResta: self - other\n\n\n__mul__(self, other)\n*\nMultiplicaci칩n: self * other\n\n\n__truediv__(self, other)\n/\nDivisi칩n real: self / other\n\n\n__floordiv__(self, other)\n//\nDivisi칩n entera: self // other\n\n\n__mod__(self, other)\n%\nM칩dulo: self % other\n\n\n__pow__(self, other)\n**\nPotencia: self ** other\n\n\n\nConsiderando los vectores \\(\\vec{u}\\), \\(\\vec{v}\\) y el escalar \\(c\\), podemos implementar las siguientes operaciones en nuestra clase Vector:\n\\[\n\\begin{aligned}\n\\vec{u} + \\vec{v} &= (x_1 + x_2, y_1 + y_2) \\\\\n\\vec{u} - \\vec{v} &= (x_1 - x_2, y_1 - y_2) \\\\\n\\vec{u} \\times c &= (x_1 \\times c, y_1 \\times c) \\\\\n\\frac{\\vec{u}}{c} &= \\left(\\frac{x_1}{c}, \\frac{y_1}{c}\\right) \\\\\n\\end{aligned}\n\\]\nEn Python:\n\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vector(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, scalar):\n        return Vector(self.x * scalar, self.y * scalar)\n\n    def __truediv__(self, scalar):\n        return Vector(self.x / scalar, self.y / scalar)\n\n    def __repr__(self):\n        return f\"Vector({self.x}, {self.y})\"\n\nVeamos algunos ejemplos:\n\nu = Vector(1, -0.5)\nv = Vector(2, 1)\n\n\nu + v\n\nVector(3, 0.5)\n\n\n\nu - v\n\nVector(-1, -1.5)\n\n\n\nv - u \n\nVector(1, 1.5)\n\n\n\nu * 2.5\n\nVector(2.5, -1.25)\n\n\n\nv / 4\n\nVector(0.5, 0.25)\n\n\nPara finalizar, podemos usar la funci칩n graficar_vectores, que recibe una lista de vectores y los representa gr치ficamente en el plano, mostrando de forma visual el resultado de las operaciones realizadas.\n\n\nC칩digo\nimport matplotlib.pyplot as plt\n\ndef graficar_vectores(vectores):\n    x_range = [0, 0]\n    y_range = [0, 0]\n\n    fig, ax = plt.subplots(figsize=(6, 5))\n\n    for i, vector in enumerate(vectores):\n        ax.quiver(\n            0, 0, vector.x, vector.y,\n            angles='xy',\n            scale_units='xy',\n            scale=1,\n            color=f\"C{i}\",\n            label=str(vector)\n        )\n\n        x_range[0] = min(x_range[0], vector.x)\n        x_range[1] = max(x_range[1], vector.x)\n\n        y_range[0] = min(y_range[0], vector.y)\n        y_range[1] = max(y_range[1], vector.y)\n\n    x_range[0] = x_range[0] - 0.5\n    x_range[1] = x_range[1] + 0.5\n    y_range[0] = y_range[0] - 0.5\n    y_range[1] = y_range[1] + 0.5\n\n    ax.axhline(0, color='k', linewidth=0.5)\n    ax.axvline(0, color='k', linewidth=0.5)\n    ax.set(xlim=x_range, ylim=y_range, xlabel=\"x\", ylabel=\"y\")\n    ax.grid()\n    ax.set_axisbelow(True)\n    ax.legend(loc=\"upper left\")\n    plt.show()\n\n\nGrafiquemos tres vectores cualesquiera:\n\ngraficar_vectores(\n    [\n        Vector(1, 2),\n        Vector(0.5, 0.75),\n        Vector(-1, 0.5),\n    ]\n)\n\n\n\n\n\n\n\n\nEl vector \\(\\vec{v}\\) y su opuesto \\(-\\vec{v}\\):\n\nv = Vector(2.5, 3)\n\ngraficar_vectores([v, v * (-1)])\n\n\n\n\n\n\n\n\nEl vector \\(\\vec{v}\\) y \\(1.5 \\times \\vec{v}\\):\n\ngraficar_vectores([v, v * 1.5])\n\n\n\n\n\n\n\n\nEl vector \\(\\vec{v}\\) y \\(0.5 \\times \\vec{v}\\):\n\ngraficar_vectores([v, v * 0.5])\n\n\n\n\n\n\n\n\nLos vectores \\(\\vec{u}\\), \\(\\vec{v}\\) y su suma:\n\nu = Vector(0.5, 0.3)\nv = Vector(0.2, 0.7)\n\ngraficar_vectores([u, v, u + v])\n\n\n\n\n\n\n\n\nY ahora su resta:\n\ngraficar_vectores([u, v, u - v])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSobrecarga de operadores\n\n\n\nA la capacidad de redefinir el comportamiento de los operadores est치ndar (como +, -, ==, etc.) se la conoce como sobrecarga de operadores.\nGracias a ella, podemos escribir programas m치s expresivos, legibles e intuitivos, haciendo que nuestras clases se comporten como tipos nativos de Python.",
    "crumbs": [
      "Teor칤a",
      "U3 - Programaci칩n Orientada a Objetos",
      "4 - Polimorfismo"
    ]
  },
  {
    "objectID": "teoria/03_oop/04_polimorfismo.html#otros-m칠todos",
    "href": "teoria/03_oop/04_polimorfismo.html#otros-m칠todos",
    "title": "4 - Polimorfismo",
    "section": "Otros m칠todos",
    "text": "Otros m칠todos\nLos m칠todos m치gicos que cubrimos en este apunte solo incluyen alg칰nos de los m칠todos disponibles.\nAlguno de ellos se muestran a continuaci칩n:\n\n\n\n\n\n\n\n\nM칠todo\nC칩mo se usa\nDescripci칩n\n\n\n\n\n__neg__(self)\n-obj\nDevuelve el valor negado del objeto.\n\n\n__pos__(self)\n+obj\nDevuelve el valor positivo del objeto.\n\n\n__abs__(self)\nabs(obj)\nDevuelve el valor absoluto del objeto.\n\n\n__len__(self)\nlen(obj)\nDevuelve la longitud del objeto.\n\n\n__iter__(self)\nfor x in obj\nDevuelve un iterador.\n\n\n__next__(self)\nnext(obj)\nDevuelve el siguiente elemento de un iterador.\n\n\n__contains__(self, item)\nitem in obj\nComprueba pertenencia.\n\n\n__call__(self, ...)\nobj()\nPermite llamar a un objeto como si fuera funci칩n.\n\n\n__bool__(self)\nbool(obj)\nDefine si el objeto se considera True o False.\n\n\n__hash__(self)\nhash(obj)\nPermite usar el objeto en conjuntos y como clave en diccionarios.\n\n\n\nUn recurso 칰til para explorar el funcionamiento de ellos es Python Magic Methods de Real Python. El listado exhaustivo se puede encontrar en la documentaci칩n oficial de Python.",
    "crumbs": [
      "Teor칤a",
      "U3 - Programaci칩n Orientada a Objetos",
      "4 - Polimorfismo"
    ]
  },
  {
    "objectID": "teoria/03_oop/02_encapsulamiento.html",
    "href": "teoria/03_oop/02_encapsulamiento.html",
    "title": "2 - Encapsulamiento",
    "section": "",
    "text": "Los tres principios fundamentales de la programaci칩n orientada a objetos son la encapsulaci칩n, la herencia y el polimorfismo.\nA lo largo de los pr칩ximos apuntes vamos a explorar cada uno en detalle, entendiendo los conceptos que los sustentan y analizando ejemplos concretos de c칩mo se aplican en Python. En l칤neas generales, estos principios se pueden describir de la siguiente manera:\n\nEncapsulaci칩n: consiste en reunir en un mismo lugar tanto los datos como las operaciones que act칰an sobre ellos, ocultando los detalles internos y exponiendo 칰nicamente la interfaz necesaria para interactuar con el objeto.\nHerencia: permite crear nuevas clases a partir de otras ya existentes, reutilizando su comportamiento y ampli치ndolo o modific치ndolo seg칰n sea necesario.\nPolimorfismo: hace posible que diferentes objetos de diferentes clases respondan de forma distinta a un mismo 랈ensaje (por ejemplo, un m칠todo con el mismo nombre), adaptando el comportamiento a las particularidades de cada caso.",
    "crumbs": [
      "Teor칤a",
      "U3 - Programaci칩n Orientada a Objetos",
      "2 - Encapsulamiento"
    ]
  },
  {
    "objectID": "teoria/03_oop/02_encapsulamiento.html#prefacio",
    "href": "teoria/03_oop/02_encapsulamiento.html#prefacio",
    "title": "2 - Encapsulamiento",
    "section": "",
    "text": "Los tres principios fundamentales de la programaci칩n orientada a objetos son la encapsulaci칩n, la herencia y el polimorfismo.\nA lo largo de los pr칩ximos apuntes vamos a explorar cada uno en detalle, entendiendo los conceptos que los sustentan y analizando ejemplos concretos de c칩mo se aplican en Python. En l칤neas generales, estos principios se pueden describir de la siguiente manera:\n\nEncapsulaci칩n: consiste en reunir en un mismo lugar tanto los datos como las operaciones que act칰an sobre ellos, ocultando los detalles internos y exponiendo 칰nicamente la interfaz necesaria para interactuar con el objeto.\nHerencia: permite crear nuevas clases a partir de otras ya existentes, reutilizando su comportamiento y ampli치ndolo o modific치ndolo seg칰n sea necesario.\nPolimorfismo: hace posible que diferentes objetos de diferentes clases respondan de forma distinta a un mismo 랈ensaje (por ejemplo, un m칠todo con el mismo nombre), adaptando el comportamiento a las particularidades de cada caso.",
    "crumbs": [
      "Teor칤a",
      "U3 - Programaci칩n Orientada a Objetos",
      "2 - Encapsulamiento"
    ]
  },
  {
    "objectID": "teoria/03_oop/02_encapsulamiento.html#introducci칩n",
    "href": "teoria/03_oop/02_encapsulamiento.html#introducci칩n",
    "title": "2 - Encapsulamiento",
    "section": "Introducci칩n",
    "text": "Introducci칩n\nSupongamos que nos encontramos manejando un auto por el centro rosarino y al llegar a la esquina vemos que por la calle perpendicular se aproxima otro veh칤culo que no aparenta intenciones de frenar.\nTodo indica que tendremos que detener el auto completamente.\nInstant치neamente, presionamos el embrague casi al mismo tiempo que el pedal de freno y colocamos la palanca de cambio en la posici칩n de punto muerto. El auto responde de la manera que esperamos y se detiene.\nUna vez que el otro veh칤culo cruza, nos disponemos a continuar nuestra marcha. Como a칰n no soltamos el pie del embrague, movemos la palanca de cambios a la posici칩n de primera, suavemente soltamos el embrague mientras comenzamos a presionar el acelerador, y finalmente cruzamos.\n쯏 qu칠 tiene que ver toda esta escena automovil칤stica con el encapsulamiento? M치s de lo que podr칤amos imaginarnos.\nPara detener el auto, tuvimos que interactuar con los pedales y eventualmente con la palanca de cambios. Todo un esfuerzo, s칤.\nSin embargo, no necesitamos saber en realidad como funciona el proceso de frenado de un auto: desconocemos como funcionan los discos, la hidr치ulica y mucho menos podr칤amos describir como funciona una caja de cambios. Todos estos mecanismos internos permanecen ocultos dentro del sistema (el auto). Lo 칰nico visible es una interfaz sencilla que nos permite lograr nuestro objetivo sin necesidad de saber qu칠 ocurre detr치s.\nEn programaci칩n ocurre lo mismo: la encapsulaci칩n consiste en mantener el estado interno y la l칩gica de un objeto fuera del alcance del exterior, exponiendo 칰nicamente una forma clara y controlada de interactuar con 칠l. De este modo, el c칩digo que interactua con el objeto no necesita conocer sus detalles internos y puede seguir funcionando incluso si estos cambian.",
    "crumbs": [
      "Teor칤a",
      "U3 - Programaci칩n Orientada a Objetos",
      "2 - Encapsulamiento"
    ]
  },
  {
    "objectID": "teoria/03_oop/02_encapsulamiento.html#las-m칰ltiples-caras-del-encapsulamiento",
    "href": "teoria/03_oop/02_encapsulamiento.html#las-m칰ltiples-caras-del-encapsulamiento",
    "title": "2 - Encapsulamiento",
    "section": "Las m칰ltiples caras del encapsulamiento",
    "text": "Las m칰ltiples caras del encapsulamiento\nEn programaci칩n no existe una 칰nica manera de aplicar el encapsulamiento, es decir, de aislar y proteger los detalles internos de c칩mo algo funciona. A continuaci칩n, veremos c칩mo esta idea aparece y se utiliza en distintos niveles: funciones, objetos y clases.\n\nFunciones\nLas funciones ofrecen un ejemplo clar칤simo de encapsulaci칩n: para usarlas, no hace falta conocer como funcionan internamente. De hecho, una funci칩n bien dise침ada se caracteriza por cumplir una 칰nica tarea y tener un nombre que la describa con claridad. De esta manera, con solo leer su nombre podemos anticipar qu칠 hace, sin preocuparnos por los detalles de su implementaci칩n.\nPor ejemplo, consideremos la siguiente funci칩n que devuelve el n칰mero \\(n\\)-칠simo en la secuencia de Fibonacci:\n\ndef fibonacci(n):\n    if n &lt;= 1:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)\n\nprint(fibonacci(10))\nprint(fibonacci(21))\n\n55\n10946\n\n\nSi est치 clara la interfaz de la funci칩n (cantidad y tipos de entradas y salidas), no es necesario conocer detalles de la implementaci칩n, ni si el c칩digo es largo o complejo. Incluso si se encuentra un mejor algoritmo para resolver el mismo problema, la funci칩n puede reescribirse sin cambiar su uso externo, siempre que la interfaz no cambie.\nEsta modularizaci칩n hace que el c칩digo sea m치s f치cil de mantener y adaptar a futuros cambios.\n\n\nObjetos\nEn la programaci칩n orientada a objetos hay una distinci칩n clave entre el interior y el exterior de una clase u objeto.\nDesde el interior, al dise침ar una clase o implementar sus m칠todos, debemos cuidar c칩mo interact칰an con los atributos, la eficiencia de los algoritmos y el dise침o de la interfaz. El objetivo es construir una estructura coherente y f치cil de mantener.\nDesde el exterior, lo que importa no son los detalles internos sino la interfaz p칰blica: qu칠 hace cada m칠todo, qu칠 argumentos necesita y qu칠 valores devuelve. Mientras esa interfaz se mantenga, la clase puede usarse sin conocer su implementaci칩n.\nLas clases favorecen el encapsulamiento porque:\n\nDefinen una interfaz clara para usar sus m칠todos sin saber c칩mo funcionan por dentro.\nProtegen el estado interno, evitando modificaciones directas desde fuera.\n\nY, gracias a ello, permiten cambiar la implementaci칩n sin afectar el c칩digo que las utiliza.\nAhora bien, 쯖칩mo es que las clases en Python definen una interfaz clara y protegen el estado interno?",
    "crumbs": [
      "Teor칤a",
      "U3 - Programaci칩n Orientada a Objetos",
      "2 - Encapsulamiento"
    ]
  },
  {
    "objectID": "teoria/03_oop/02_encapsulamiento.html#interfaz-clara",
    "href": "teoria/03_oop/02_encapsulamiento.html#interfaz-clara",
    "title": "2 - Encapsulamiento",
    "section": "Interfaz clara",
    "text": "Interfaz clara\n\nDocstrings\n쮺칩mo podemos saber cu치ntos argumentos debemos pasar y de qu칠 tipo al inicializar una clase? 쯏 c칩mo saberlo al llamar a uno de sus m칠todos?\nUna primera opci칩n ser칤a leer directamente su implementaci칩n, pero eso es precisamente lo que queremos evitar.\nUna alternativa mucho mejor es consultar la documentaci칩n. Para ello, la clase y sus m칠todos deben contar con docstrings adecuados que describan su uso.\nVeamos el siguiente ejemplo:\n\nclass CuentaBancaria:\n    \"\"\"Cuenta bancaria simple con operaciones b치sicas.\n\n    Esta clase implementa un modelo b치sico de cuenta bancaria que permite\n    depositar y retirar dinero, as칤 como consultar el saldo actual.\n    \"\"\"\n    def __init__(self, titular, saldo_inicial=0.0):\n        \"\"\"Inicializa una nueva cuenta bancaria.\n\n        Parameters\n        ----------\n        titular : str\n            Nombre del titular de la cuenta.\n        saldo_inicial : float, optional\n            Saldo inicial de la cuenta. Por defecto es 0.0.\n        \"\"\"\n        self.titular = titular\n        self.saldo = saldo_inicial\n\n    def depositar(self, monto):\n        \"\"\"Depositar dinero en la cuenta.\n\n        Parameters\n        ----------\n        monto : float\n            Monto a depositar. Debe ser un n칰mero positivo.\n        \"\"\"\n        if monto &lt;= 0:\n            print(\"Error: El monto a depositar debe ser positivo.\")\n            return\n        self.saldo += monto\n\n\n    def retirar(self, monto):\n        \"\"\"Extrae dinero de la cuenta si hay fondos suficientes.\n\n        Parameters\n        ----------\n        monto : float\n            Monto a retirar.\n        \"\"\"\n        if monto &gt; self.saldo:\n            print(\"Error: Fondos insuficientes.\")\n            return\n        self.saldo -= monto\n\n\n    def consultar_saldo(self):\n        \"\"\"Devuelve el saldo actual.\n\n        Returns\n        -------\n        float\n            Saldo disponible en la cuenta.\n        \"\"\"\n        return self.saldo\n\n\ncuenta = CuentaBancaria(titular=\"Jos칠 Paso\", saldo_inicial=12000)\ncuenta.consultar_saldo()\n\n12000\n\n\n\ncuenta.retirar(3800)\ncuenta.consultar_saldo()\n\n8200\n\n\n\ncuenta.depositar(1500)\ncuenta.retirar(50000)\ncuenta.consultar_saldo()\n\nError: Fondos insuficientes.\n\n\n9700\n\n\nPara consultar la documentaci칩n, podemos usar la funci칩n help de Python.\nSi la ejecutamos en Positron, se abrir치 una ventana a la derecha que muestra la informaci칩n disponible. Si, en cambio, la usamos desde una terminal, obtendremos un resultado similar al siguiente:\nAyuda para toda clase:\nhelp(CuentaBancaria)\nHelp on class CuentaBancaria in module __main__:\n\nclass CuentaBancaria(builtins.object)\n |  CuentaBancaria(titular, saldo_inicial=0.0)\n |\n |  Cuenta bancaria simple con operaciones b치sicas.\n |\n |  Esta clase implementa un modelo b치sico de cuenta bancaria que permite\n |  depositar y retirar dinero, as칤 como consultar el saldo actual.\n |\n |  Methods defined here:\n |\n |  __init__(self, titular, saldo_inicial=0.0)\n |      Inicializa una nueva cuenta bancaria.\n |\n |      Parameters\n |      ----------\n |      titular : str\n |          Nombre del titular de la cuenta.\n |      saldo_inicial : float, optional\n |          Saldo inicial de la cuenta. Por defecto es 0.0.\nAyuda para el m칠todo depositar, que recibe un flotante y no devuelve nada:\nhelp(CuentaBancaria.depositar)\nHelp on function depositar in module __main__:\n\ndepositar(self, monto)\n    Depositar dinero en la cuenta.\n\n    Parameters\n    ----------\n    monto : float\n        Monto a depositar. Debe ser un n칰mero positivo.\nAyuda para el m칠todo consultar_saldo, que no recibe ning칰n parametro y devuelve un flotante:\nhelp(CuentaBancaria.consultar_saldo)\nHelp on function consultar_saldo in module __main__:\n\nconsultar_saldo(self)\n    Devuelve el saldo actual.\n\n    Returns\n    -------\n    float\n        Saldo disponible en la cuenta.\nSi bien en algunos casos puede resultar necesario consultar la ayuda con la funci칩n help, los editores de c칩digo suelen mostrar autom치ticamente una peque침a ventana junto al c칩digo mientras escribimos, donde aparece la documentaci칩n de clases, m칠todos y funciones.\n\n\nAnotaciones de tipo\nSi bien Python es un lenguaje de tipado din치mico e impl칤cito 단s decir, no es necesario especificar el tipo de las variables y este puede cambiar durante la ejecuci칩n, es posible utilizar anotaciones de tipo (del ingl칠s type annotations) para indicar qu칠 tipo de dato se espera. Estas anotaciones son opcionales, pero ayudan a que el c칩digo sea m치s claro, f치cil de entender y detectar errores antes de ejecutar el programa.\nPara los par치metros de una funci칩n o m칠todo, las anotaciones de tipo se escriben con el formato &lt;nombre_variable&gt;: &lt;tipo&gt;. En el caso la salida, el tipo se indica despu칠s de una flecha (-&gt; &lt;tipo&gt;) al final de la definici칩n.\nPor ejemplo, en la siguiente funci칩n se especifica que el par치metro nombre debe ser de tipo str y que la funci칩n devuelve tambi칠n un objeto de tipo str:\n\ndef saludar(nombre: str) -&gt; str:\n    return f\"춰Hola, {nombre}!\"\n\nsaludar(\"Guido\")\n\n'춰Hola, Guido!'\n\n\nEn nuestra clase CuentaBancaria, la anotaci칩n de tipos se ve de la siguiente manera:\n\nclass CuentaBancaria:\n1    def __init__(self, titular: str, saldo_inicial: float = 0.0):\n        self.titular = titular\n        self.saldo = saldo_inicial\n\n2    def depositar(self, monto: float):\n        self.saldo += monto\n\n3    def retirar(self, monto: float):\n        self.saldo -= monto\n\n4    def consultar_saldo(self) -&gt; float:\n        return self.saldo\n\n\n1\n\nPara inicializar la clase, se espera un argumento titular de tipo str y otro saldo_inicial de tipo float.\n\n2\n\nEl m칠todo depositar espera recibir un argumento de tipo float.\n\n3\n\nEl m칠todo retirar tambi칠n espera recibir un argumento de tipo float.\n\n4\n\nPor 칰ltimo, consultar_saldo devuelve un valor de tipo float.\n\n\n\n\nSi se eligen nombres representativos para los m칠todos y se utilizan anotaciones de tipo en sus par치metros, es muy probable que no sea necesario escribir un docstring para que el usuario comprenda c칩mo funciona la clase.\nSin embargo, ni la documentaci칩n mediante docstrings ni el uso de anotaciones de tipo garantizan que una funci칩n o m칠todo se utilice con los tipos de datos adecuados. Por ejemplo, podr칤amos pasarle un n칰mero a nuestra funci칩n saludar sin que Python lo impida:\n\nsaludar(128)\n\n'춰Hola, 128!'\n\n\nO incluso podr칤amos inicializar el saldo_inicial de la cuenta bancaria con una lista y luego intentar 띿epositar otra lista.\n\ncuenta = CuentaBancaria(25, saldo_inicial=[\"Cosas\"])\ncuenta.consultar_saldo()\n\n['Cosas']\n\n\n\ncuenta.depositar([\"Otras cosas\", \"A칰n m치s cosas\"])\ncuenta.consultar_saldo()\n\n['Cosas', 'Otras cosas', 'A칰n m치s cosas']\n\n\nEn resumen, si bien Python nos permite especificar la interfaz de funciones y m칠todos mediante docstrings y anotaciones de tipo, al ser un lenguaje de tipado din치mico nada impide que se utilicen con tipos de datos para los que no fueron dise침ados. En algunos casos esto puede resultar en comportamientos inesperados y, en otros, simplemente generar un error en tiempo de ejecuci칩n.\n\n\n\n\n\n\nDuck typing 游붅\n\n\n\nEn lenguajes din치micos como Python, muchas veces no importa de qu칠 tipo es un objeto, sino qu칠 puede hacer. Lo relevante no es su clase, sino si se comporta como necesitamos.\nPor ejemplo, en una funci칩n como saludar, el par치metro no tiene que ser necesariamente un str, siempre que pueda usarse dentro de una f-string.\nEste enfoque, donde importa m치s el comportamiento que el tipo, se llama duck typing y suele expresarse as칤:\n\nSi camina como un pato y hace cuac como un pato, entonces probablemente es un pato.",
    "crumbs": [
      "Teor칤a",
      "U3 - Programaci칩n Orientada a Objetos",
      "2 - Encapsulamiento"
    ]
  },
  {
    "objectID": "teoria/03_oop/02_encapsulamiento.html#estado-interno",
    "href": "teoria/03_oop/02_encapsulamiento.html#estado-interno",
    "title": "2 - Encapsulamiento",
    "section": "Estado interno",
    "text": "Estado interno\nAhora que sabemos qu칠 estrategias podemos usar para que la interfaz de una clase sea clara, veamos c칩mo las clases definen y protegen su estado interno.\nConsideremos a la siguiente clase que sirve para representar a estudiantes de la Facultad de Ciencias Econ칩micas y Estad칤stica de la UNR.\n\nclass Estudiante:\n    def __init__(self, nombre, ingreso, carrera):\n        self.nombre = nombre\n        self.ingreso = ingreso\n        self.carrera = carrera\n\n    def resumen(self):\n        return f\"Estudiante(nombre={self.nombre}, ingreso={self.ingreso}, carrera={self.carrera})\"\n\nCada objeto mantiene sus propias variables de instancia, como nombre, ingreso y carrera, con valores independientes de los de otros objetos de la misma clase. Esto implica que modificar los datos de una instancia no afecta en absoluto a las dem치s: cada objeto gestiona y conserva su propio estado interno, es decir, los objetos son due침os de sus variables.\n\ne1 = Estudiante(\"Mariano Gonz치lez\", 2022, \"Contador P칰blico\")\ne2 = Estudiante(\"Leticia Gallardo\", 2023, \"Licenciatura en Estad칤stica\")\n\nGracias al m칠todo resumen, podemos obtener una representaci칩n clara e intuitiva de cada objeto.\n\ne1.resumen()\n\n'Estudiante(nombre=Mariano Gonz치lez, ingreso=2022, carrera=Contador P칰blico)'\n\n\nAunque tambi칠n es posible interactuar con los atributos de cada instancia de manera individual.\n\nprint(e1.nombre, e1.carrera, sep=\": \")\nprint(e2.nombre, e2.carrera, sep=\": \")\n\nMariano Gonz치lez: Contador P칰blico\nLeticia Gallardo: Licenciatura en Estad칤stica\n\n\nEsta interacci칩n no solo implica que podemos acceder a los valores individuales de los atributos, sino tambi칠n que tenemos la posibilidad de modificarlos.\n\ne1.ingreso = 2019\ne1.resumen()\n\n'Estudiante(nombre=Mariano Gonz치lez, ingreso=2019, carrera=Contador P칰blico)'\n\n\nTenemos tanta flexibilidad al modificar los atributos de una instancia que incluso podemos asignarles valores que no tienen sentido dentro del contexto de la clase.\n\ne1.ingreso = \"Cualquier cosa\"\ne1.resumen()\n\n'Estudiante(nombre=Mariano Gonz치lez, ingreso=Cualquier cosa, carrera=Contador P칰blico)'\n\n\n\nSetters y getters\nEn programaci칩n orientada a objetos, los getters y setters son m칠todos especiales que permiten acceder y modificar el estado interno de un objeto de forma segura y controlada. Su objetivo principal es proteger los atributos, evitando que se acceda o se cambien directamente desde el exterior de la clase.\nEn particular:\n\ngetter: m칠todo que obtiene o devuelve el valor de un atributo de un objeto.\nsetter: m칠todo que asigna o actualiza el valor de un atributo de un objeto.\n\nNuestra clase Estudiante, incorporando ahora estos m칠todos para acceder y modificar sus atributos, se ver칤a de la siguiente manera:\n\nclass Estudiante:\n    def __init__(self, nombre):\n1        self.setNombre(nombre)\n\n2    def setNombre(self, nombre):\n        if isinstance(nombre, str):\n            self.nombre = nombre\n        else:\n            print(\"El nombre debe ser de tipo 'str'\")\n\n3    def getNombre(self):\n        return self.nombre\n\n    def resumen(self):\n        return f\"Estudiante(nombre={self.getNombre()})\"\n\n\n1\n\nEl m칠todo de inicializaci칩n no asigna el atributo directamente, sino que delega la tarea en el setter.\n\n2\n\nEl setter recibe un valor, verifica su tipo y, si es el esperado, lo asigna como atributo de instancia.\n\n3\n\nEl getter simplemente devuelve el valor del atributo, proporcionando un punto de acceso controlado al estado interno.\n\n\n\n\nCreemos un nuevo objeto de tipo Estudiante.\n\ne = Estudiante(\"Macarena Gianetti\")\ne.resumen()\n\n'Estudiante(nombre=Macarena Gianetti)'\n\n\nLuego, obtenemos el nombre de la estudiante mediante su getter.\n\ne.getNombre()\n\n'Macarena Gianetti'\n\n\nSi queremos modificarlo, no asignamos el valor directamente a una variable del objeto, sino que llamamos a su m칠todo setter. Este m칠todo se encarga de validar el dato y evitar que se asignen valores de tipos no permitidos.\n\ne.setNombre(189)\n\nEl nombre debe ser de tipo 'str'\n\n\n\ne.resumen()\n\n'Estudiante(nombre=Macarena Gianetti)'\n\n\nSin embargo, Python no impide que, como usuarios, accedamos y modifiquemos directamente los atributos del objeto. Por ejemplo, podemos asignar un valor de cualquier tipo directamente a la variable nombre:\n\ne.nombre = 2\ne.resumen()\n\n'Estudiante(nombre=2)'\n\n\nEn ese caso, las ventajas de usar setter y getter dejan de tener efecto si el usuario decide romper el objeto ignorando su interfaz.\n\n\nAtributos protegidos\nEn muchos lenguajes de programaci칩n existe una distinci칩n clara entre atributos p칰blicos y privados. Los p칰blicos pueden ser accedidos tanto desde dentro como desde fuera de la clase, mientras que los privados solo pueden usarse internamente. Es decir, un m칠todo de la clase puede acceder a un atributo o m칠todo privado, pero el c칩digo externo que usa la clase no.\nEn Python no existe una separaci칩n estricta entre atributos p칰blicos y privados: todos son t칠cnicamente p칰blicos. Sin embargo, por convenci칩n, si el nombre de un atributo o m칠todo comienza con un guion bajo (_), esto indica que no deber칤a ser accedido ni modificado desde el exterior de la clase, ya que est치 protegido.\nSiguiendo esta convenci칩n, en nuestro ejemplo con la clase Estudiante podemos usar un atributo llamado _nombre para almacenar el nombre del estudiante.\n\nclass Estudiante:\n    def __init__(self, nombre):\n        self.setNombre(nombre)\n\n    def setNombre(self, nombre):\n        if isinstance(nombre, str):\n1            self._nombre = nombre\n        else:\n            print(\"El nombre debe ser de tipo 'str'\")\n\n    def getNombre(self):\n2        return self._nombre\n\n    def resumen(self):\n        return f\"Estudiante(nombre={self.getNombre()})\"\n\n\n1\n\nSe guarda el nombre en una variable 랋rivada _nombre.\n\n2\n\nSe devuelve el nombre usando la variable 랋rivada _nombre.\n\n\n\n\n\ne = Estudiante(\"Macarena Gianetti\")\ne.resumen()\n\n'Estudiante(nombre=Macarena Gianetti)'\n\n\nSi asignamos un nuevo valor a la variable nombre de la instancia, no ocurre ning칰n efecto indeseado. El objeto crea y almacena esa nueva variable, pero el m칠todo getter no la utiliza, ya que sigue accediendo al atributo _nombre.\n\ne.nombre = \"Algo nuevo\"\ne.resumen()\n\n'Estudiante(nombre=Macarena Gianetti)'\n\n\nSin embargo, Python no evita que reemplacemos el valor de la variable _nombre, nuevamente rompiendo el encapsulamiento del objeto:\n\ne._nombre = \"춰Ahora s칤!\"\ne.resumen()\n\n'Estudiante(nombre=춰Ahora s칤!)'\n\n\n\n\nAtributos privados\nSi bien los objetos en Python no cuentan con atributos verdaderamente privados, es posible emular ese comportamiento. Para ello, se emplean nombres de variables que comienzan con dos guiones bajos (__). En nuestro ejemplo, podemos usar __nombre.\n\nclass Estudiante:\n    def __init__(self, nombre):\n        self.setNombre(nombre)\n\n    def setNombre(self, nombre):\n        if isinstance(nombre, str):\n            self.__nombre = nombre\n        else:\n            print(\"El nombre debe ser de tipo 'str'\")\n\n    def getNombre(self):\n        return self.__nombre\n\n    def resumen(self):\n        return f\"Estudiante(nombre={self.getNombre()})\"\n\ne = Estudiante(\"Macarena Gianetti\")\ne.resumen()\n\n'Estudiante(nombre=Macarena Gianetti)'\n\n\nSi queremos acceder a la variable, obtendremos un error:\ne.__nombre\n\nAttributeError: 'Estudiante' object has no attribute '__nombre'\n\nPor el contrario, si intentamos asignar un valor a esa variable, Python no mostrar치 ning칰n error y el m칠todo getter continuar치 devolviendo el valor esperado:\n\ne.__nombre = \"쯏 ahora?\"\ne.getNombre()\n\n'Macarena Gianetti'\n\n\n\ne._Estudiante__nombre\n\n'Macarena Gianetti'\n\n\n\n\n\n\n\n\nName mangling\n\n\n\nNunca debemos olvidar que Python no soporta atributos privados. Por lo tanto, en alg칰n lado tiene que estar disponible el valor de la variable __nombre que se usa dentro de la clase.\nEn particular, cuando el nombre de una variable comienza con dos guiones bajos, Python utiliza una t칠cnica llamada name mangling o 란stropeo de nombre. Para ello, en realidad opera internamente con otra variable, cuyo nombre es el resultado de concatenar un gui칩n bajo, el nombre de la clase y el nombre del atributo 랋rivado. Por ejemplo:\n&gt;&gt;&gt; e._Estudiante__nombre\n'Macarena Gianetti'\n\n\n\n\nAtributos (aparentes) con @property\nPython ofrece un decorador built-in llamado property que permite definir un m칠todo que se comporta como si fuera un atributo, de modo que al accederlo desde fuera parece una variable de instancia, aunque en realidad est치 ejecutando c칩digo dentro de la clase.\nCon este decorador se pueden definir dos m칠todos: un getter y un setter.\n\nEl getter se declara con @property, y su nombre determina el nombre de la propiedad que se utilizar치 desde el c칩digo externo.\nEl setter se declara con @&lt;nombre&gt;.setter y permite asignar valores a esa misma propiedad.\n\nVeamos un ejemplo:\n\nclass Estudiante:\n    def __init__(self, nombre):\n3        self.nombre = nombre\n\n1    @property\n    def nombre(self):\n        return self._nombre\n\n2    @nombre.setter\n    def nombre(self, valor):\n        if isinstance(valor, str):\n            self._nombre = valor\n        else:\n            print(\"El nombre debe ser de tipo 'str'\")\n\n    def resumen(self):\n4        return f\"Estudiante(nombre={self.nombre})\"\n\n\n1\n\nCon @property se indica que los objetos de la clase tendr치n un 라tributo llamado nombre. Al acceder a 칠l, Python ejecuta el m칠todo decorado y devuelve el valor de la variable protegida _nombre.\n\n2\n\nCon @nombre.setter se declara el m칠todo setter, que recibe self y el nuevo valor a asignar (valor). As칤, cada vez que se asigna un nuevo valor al atributo, Python ejecuta este m칠todo y verifica el tipo de dato.\n\n3\n\nIncluso dentro de la clase puede usarse nombre como si fuera un atributo com칰n, sin necesidad de llamar manualmente al m칠todo decorado.\n\n4\n\n칈dem al punto anterior.\n\n\n\n\n\ne = Estudiante(\"Fernanda Cattalini\")\ne.resumen()\n\n'Estudiante(nombre=Fernanda Cattalini)'\n\n\nEs posible acceder al 라tributo nombre:\n\ne.nombre\n\n'Fernanda Cattalini'\n\n\nTambi칠n modificarlo:\n\ne.nombre = \"Mar칤a Fernanda Cattalini\"\ne.resumen()\n\n'Estudiante(nombre=Mar칤a Fernanda Cattalini)'\n\n\nY si se intenta asignarle un valor del tipo incorrecto, no se realiza la operaci칩n:\n\ne.nombre = True\n\nEl nombre debe ser de tipo 'str'\n\n\n\ne.resumen()\n\n'Estudiante(nombre=Mar칤a Fernanda Cattalini)'\n\n\n\n\nResumen\nPython no ofrece un control absoluto sobre el estado interno de los objetos, pero s칤 dispone de mecanismos que permiten gestionarlo mejor, como las convenciones de nombres, los getters y setters, o el uso de @property. Estas herramientas ayudan a ocultar detalles internos, validar datos y mantener la coherencia del objeto.\nSin embargo, por la naturaleza din치mica del lenguaje, siempre existe la posibilidad de modificar clases y objetos desde el exterior, por lo que el encapsulamiento funciona m치s como una convenci칩n para un uso correcto que como una barrera estricta.",
    "crumbs": [
      "Teor칤a",
      "U3 - Programaci칩n Orientada a Objetos",
      "2 - Encapsulamiento"
    ]
  },
  {
    "objectID": "teoria/03_oop/02_encapsulamiento.html#atributos-y-m칠todos-de-clase",
    "href": "teoria/03_oop/02_encapsulamiento.html#atributos-y-m칠todos-de-clase",
    "title": "2 - Encapsulamiento",
    "section": "Atributos y m칠todos de clase",
    "text": "Atributos y m칠todos de clase\nEn Python, no solo los objetos pueden encapsular estado: las clases tambi칠n.\nUn atributo de clase est치 asociado a la clase en s칤 y es compartido por todas sus instancias, en lugar de pertenecer a un objeto espec칤fico.\nUn m칠todo de clase, en cambio, recibe la propia clase como primer argumento (cls) en lugar de la instancia (self), lo que permite operar sobre la clase en su conjunto.\n\nAtributos\nEs posible asignar un atributo de clase en el c칩digo que implementa a la clase misma. Simplemente hay que asignar una variable en el bloque de definci칩n de la clase.\nEn el ejemplo a continuaci칩n, creamos una clase Gato que representa animales de la especie Felis catus. Como todos los gatos son de la misma especie, tiene sentido utilizar un atributo de clase en vez de un atributo de instancia.\n\nclass Gato:\n1    especie = \"Felis catus\"\n\n    def __init__(self, nombre, raza=None):\n        self.nombre = nombre\n        self.raza = raza\n\n    def resumen(self):\n        return f\"Gato(nombre={self.nombre}, raza={self.raza})\"\n\n\n1\n\nCreaci칩n del atributo de clase especie.\n\n\n\n\nLuego de instanciar dos objetos, podemos ver que ambos tienen asociados el mismo valor de especie.\n\ng1 = Gato(\"Chispitas\")\ng2 = Gato(\"Bigotes\", \"Siam칠s\")\n\n\nprint(g1.especie)\nprint(g2.especie)\nprint(g1.especie == g2.especie)\n\nFelis catus\nFelis catus\nTrue\n\n\nPodr칤amos utilizar un atributo de clase an치logo para otra especie de animales: Canis lupus familiaris, popularmente conocidos como perro.\n\nclass Perro:\n    especie = \"Canis lupus familiaris\"\n\n    def __init__(self, nombre, raza=None):\n        self.nombre = nombre\n        self.raza = raza\n\n    def resumen(self):\n        return f\"Perro(nombre={self.nombre}, raza={self.raza})\"\n\n\nperro = Perro(\"Bruno\")\nprint(perro.resumen())\nprint(perro.especie)\n\nPerro(nombre=Bruno, raza=None)\nCanis lupus familiaris\n\n\nOtro escenario donde tiene sentido pr치ctico utilizar un atributo de clase es cuando se necesita mantener un estado global.\nLa clase Usuario define usuarios de una cierta aplicaci칩n. En ella, se tiene la variable total_usuarios que es un contador de los usuarios que se han creado a partir de la clase.\n\nclass Usuario:\n1    total_usuarios = 0\n\n    def __init__(self, nombre):\n        self.nombre = nombre\n2        Usuario.total_usuarios += 1\n\n\n1\n\nInicialmente, el atributo de clase total_usuarios tiene el valor 0.\n\n2\n\nCada vez que se crea un nuevo usuario, se incrementa el valor del atributo de la clase total_usuarios en 1.\n\n\n\n\n\nu1 = Usuario(\"Ana\")\nu2 = Usuario(\"Luis\")\n\nprint(Usuario.total_usuarios)\n\n2\n\n\nDado que las instancias tambi칠n pueden acceder a los atributos de clase, se tiene:\n\nprint(u1.total_usuarios)\nprint(u2.total_usuarios)\n\n2\n2\n\n\n\n\nM칠todos\nPara definir un m칠todo de clase se usa el decorador @classmethod, incluido en Python. Al aplicarlo, el m칠todo recibe como primer argumento a la clase en lugar de a una instancia, por lo que la convenci칩n es nombrar ese par치metro como cls en vez de self.\n\nclass Estudiante:\n    def __init__(self, nombre, ingreso):\n        self.nombre = nombre\n        self.ingreso = ingreso\n\n1    @classmethod\n2    def desde_texto(cls, texto):\n        nombre, ingreso = texto.split(\",\")\n3        return cls(nombre, int(ingreso))\n\n    def resumen(self):\n        return f\"Estudiante(nombre={self.nombre}, ingreso={self.ingreso})\"\n\n\n1\n\nLa decoraci칩n @classmethod indica que el m칠todo desde_texto se invoca desde la clase y reciba a la clase como primer argumento.\n\n2\n\nPor convenci칩n, ese primer argumento se llama cls.\n\n3\n\nA partir de cls, se crea y devuelve una nueva instancia de la clase (en este caso, Estudiante) utilizando los valores requeridos por su m칠todo __init__.\n\n\n\n\nAunque exista exista un m칠todo de clase para crear objetos, se puede seguir creando objetos de la manera usual:\n\ne1 = Estudiante(\"El Nombre\", 2023)\ne1.resumen()\n\n'Estudiante(nombre=El Nombre, ingreso=2023)'\n\n\nLa diferencia es que ahora podemos usar el m칠todo desde_texto para crear un objeto Estudiante a partir de una cadena de texto con un formato espec칤fico.\n\ne2 = Estudiante.desde_texto(\"El Estudiante, 2024\")\ne2.resumen()\n\n'Estudiante(nombre=El Estudiante, ingreso=2024)'\n\n\nLos atributos del objeto muestran los valores que esperamos en este caso.\n\ne2.nombre, e2.ingreso\n\n('El Estudiante', 2024)\n\n\nOtro escenario en el que resulta 칰til usar m칠todos de clase es cuando queremos crear objetos 랋reconfigurados.\nPor ejemplo, si tenemos una clase que representa s치ndwiches con una cantidad arbitraria de ingredientes, podemos definir m칠todos de clase que construyan instancias con combinaciones de ingredientes preestablecidas:\n\nclass Sandwich:\n    def __init__(self, *ingredientes):\n        self.ingredientes = ingredientes\n\n    @classmethod\n    def jyq(cls):\n        return cls(\"jam칩n\", \"queso\")\n\n    @classmethod\n    def mediterraneo(cls):\n        return cls(\"tomate\", \"mozzarella\", \"r칰cula\", \"aceitunas\")\n\n    def resumen(self):\n        return f\"Sandwich de: {', '.join(self.ingredientes)}\"\n\n\ns1 = Sandwich(\"tomate\", \"lechuga\", \"queso\")\ns1.resumen()\n\n'Sandwich de: tomate, lechuga, queso'\n\n\n\nSandwich.jyq().resumen()\n\n'Sandwich de: jam칩n, queso'\n\n\n\nSandwich.mediterraneo().resumen()\n\n'Sandwich de: tomate, mozzarella, r칰cula, aceitunas'\n\n\n\n\n\n\n\n\nAtributos y m칠todos a posteriori\n\n\n\nPython es tan flexible como lenguaje que incluso podemos asignar atributos y m칠todos luego de su definici칩n.\nclass Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\ndef f(self):\n    return self.base * self.altura\n\nRectangulo.area = f\nRectangulo.atributo = \"Algo\"\n\nr = Rectangulo(3, 2)\nr.area()\n# 6",
    "crumbs": [
      "Teor칤a",
      "U3 - Programaci칩n Orientada a Objetos",
      "2 - Encapsulamiento"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/03_ordenamiento.html",
    "href": "teoria/04_estructuras_y_algoritmos/03_ordenamiento.html",
    "title": "3 - Algoritmos de ordenamiento",
    "section": "",
    "text": "Ordenar significa reorganizar un conjunto de elementos seg칰n alg칰n criterio, por ejemplo, de menor a mayor, alfab칠ticamente o por fecha.\nOrdenar es una de las tareas m치s importantes y estudiadas en inform치tica. Almacenar un conjunto de datos de manera ordenada permite realizar b칰squedas y otras operaciones de forma m치s eficiente. Muchos algoritmos avanzados dependen del ordenamiento como parte de su funcionamiento interno.\nPython incluye funciones y m칠todos para ordenar que ya est치n muy optimizados y, salvo raras excepciones, siempre deber칤amos utilizar estas implementaciones. Pero sigue siendo fundamental comprender c칩mo funcionan los algoritmos detr치s de esas operaciones.\nPor ejemplo, en el trabajo pr치ctico grupal se usaron dos funciones de ordenamiento, con tiempos de ejecuci칩n notablemente distintos. 쯈u칠 podr칤a explicar semejante diferencia en el desempe침o de los algoritmos utilizados? 쮺u치l es la complejidad temporal de cada uno de ellos? 쯉iempre es mejor uno que el otro?\nComo veremos en este apunte, existe una gran variedad de algoritmos de ordenamiento, que realizan diferentes operaciones y se basan en distintas estrategias con un mismo objetivo: obtener una secuencia de valores ordenados.",
    "crumbs": [
      "Teor칤a",
      "U4 - Estructuras de Datos y Algoritmos",
      "3 - Algoritmos de ordenamiento"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/03_ordenamiento.html#introducci칩n",
    "href": "teoria/04_estructuras_y_algoritmos/03_ordenamiento.html#introducci칩n",
    "title": "3 - Algoritmos de ordenamiento",
    "section": "",
    "text": "Ordenar significa reorganizar un conjunto de elementos seg칰n alg칰n criterio, por ejemplo, de menor a mayor, alfab칠ticamente o por fecha.\nOrdenar es una de las tareas m치s importantes y estudiadas en inform치tica. Almacenar un conjunto de datos de manera ordenada permite realizar b칰squedas y otras operaciones de forma m치s eficiente. Muchos algoritmos avanzados dependen del ordenamiento como parte de su funcionamiento interno.\nPython incluye funciones y m칠todos para ordenar que ya est치n muy optimizados y, salvo raras excepciones, siempre deber칤amos utilizar estas implementaciones. Pero sigue siendo fundamental comprender c칩mo funcionan los algoritmos detr치s de esas operaciones.\nPor ejemplo, en el trabajo pr치ctico grupal se usaron dos funciones de ordenamiento, con tiempos de ejecuci칩n notablemente distintos. 쯈u칠 podr칤a explicar semejante diferencia en el desempe침o de los algoritmos utilizados? 쮺u치l es la complejidad temporal de cada uno de ellos? 쯉iempre es mejor uno que el otro?\nComo veremos en este apunte, existe una gran variedad de algoritmos de ordenamiento, que realizan diferentes operaciones y se basan en distintas estrategias con un mismo objetivo: obtener una secuencia de valores ordenados.",
    "crumbs": [
      "Teor칤a",
      "U4 - Estructuras de Datos y Algoritmos",
      "3 - Algoritmos de ordenamiento"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/03_ordenamiento.html#bubble-sort",
    "href": "teoria/04_estructuras_y_algoritmos/03_ordenamiento.html#bubble-sort",
    "title": "3 - Algoritmos de ordenamiento",
    "section": "Bubble sort",
    "text": "Bubble sort\nSupongamos que tenemos un arreglo de valores num칠ricos sin ning칰n orden particular.\n\n\n\nA simple vista, podemos determinar que el arreglo ordenado ser칤a [2, 4, 5, 7].\nSin embargo, para que una computadora llegue al mismo resultado, necesitamos un algoritmo: una secuencia de pasos que garantice que, al ejecutarse, la lista quede ordenada.\nEn una lista ordenada, cada elemento est치 seguido por uno mayor o igual. M치s formalmente, si tenemos una secuencia \\(\\boldsymbol{S} = [s_1, s_2, \\dots, s_n]\\), diremos que est치 ordenada si se cumple que \\(s_i \\le s_{i + 1}\\) para todo \\(i \\in \\{1, 2, \\dots, n - 1\\}\\).\nPor ejemplo, la siguiente lista est치 ordenada:\n[10, 14, 99, 99, 1000]\nmientras que esta no:\n[50, 60, 10, 214]\nEn el primer caso, cada elemento tiene a su derecha un valor mayor o igual; en el segundo, el valor 60 tiene a su derecha un n칰mero menor (10), lo que rompe el orden.\nUna forma sencilla de obtener un algoritmo de ordenamiento consiste en comparar cada valor con el siguiente. Si el siguiente es menor, se intercambian; si no, se mantienen en su lugar. El procedimiento contin칰a con el elemento siguiente, repiti칠ndose hasta llegar al final de la lista.\nVeamos c칩mo funciona este procedimiento con la lista original [7, 2, 4, 5]:\n\n\n        \n\n\n\n\n\n\n\n        \n            \n         \n            Inicialmente, la lista se encuentra desordenada.\n         \n        \n\n            \n         \n            Se comparan los valores en las posiciones 0 y 1.\n         \n        \n\n            \n         \n            Como el primero (7) es mayor que el segundo (2), se intercambian.\n         \n        \n\n            \n         \n            Se comparan los valores en las posiciones 1 y 2.\n         \n        \n\n            \n         \n            Como el primero (7) es mayor que el segundo (4), se intercambian.\n         \n        \n\n            \n         \n            Se comparan los valores en las posiciones 2 y 3.\n         \n        \n\n            \n         \n            Como el primero (7) es mayor que el segundo (5), se intercambian.\n         \n        \n\n            \n         \n            Finalmente, la lista se encuentra ordenada.\n         \n        \n\n        \n          \n          Previous\n        \n\n        \n          \n          Next\n        \n\n      \n\nEl proceso que acabamos de observar es la base del algoritmo bubble sort. M치s adelante volveremos sobre el origen del nombre.\nAhora, debemos notar que obtuvimos una lista ordenada en tan pocos pasos de pura suerte. Para ver por qu칠, apliquemos el mismo conjunto de pasos sobre una lista con la misma cantidad de elementos, en un orden apenas diferente.\n\n        \n\n\n\n\n\n\n        \n            \n         \n            La lista contiene los mismos valores, en otro orden.\n         \n        \n\n            \n         \n            Se comparan los valores en las posiciones 0 y 1.No hay intercambio: el primero (4) es menor que el segundo (7).\n         \n        \n\n            \n         \n            Se comparan los valores en las posiciones 1 y 2.\n         \n        \n\n            \n         \n            Como el primero (7) es mayor que el segundo (2), se intercambian.\n         \n        \n\n            \n         \n            Se comparan los valores en las posiciones 2 y 3.\n         \n        \n\n            \n         \n            Como el primero (7) es mayor que el segundo (5), se intercambian.\n         \n        \n\n            \n         \n            Al final, sin embargo, la lista no se encuentra ordenada.\n         \n        \n\n        \n          \n          Previous\n        \n\n        \n          \n          Next\n        \n\n      \nLa primera vez que usamos el algoritmo, obtuvimos una lista ordenada. En la segunda, la lista qued칩 m치s ordenada que al inicio, pero a칰n no completamente.\nComo mencionamos anteriormente, que en el primer caso se obtenga una lista ordenada al realizar una sola pasada fue simplemente una coincidencia.\nEl algoritmo bubble sort funciona realizando pasadas sucesivas sobre la lista, comparando pares de valores consecutivos, de principio a fin. En cada comparaci칩n, si un valor es mayor que el siguiente, se intercambian sus posiciones. Este proceso se repite hasta completar una pasada en la que no se realiza ning칰n intercambio; solo entonces puede concluirse que la lista est치 completamente ordenada.\nContinuando el ejemplo, tenemos:\n\n        \n\n\n\n\n\n\n\n        \n            \n         \n            Se vuelven a comparar los valores en las posiciones 0 y 1.\n         \n        \n\n            \n         \n            Como el primero (4) es mayor que el segundo (2), se intercambian.\n         \n        \n\n            \n         \n            Se comparan los valores en las posiciones 1 y 2.No hay intercambio: el primero (4) es menor que el segundo (5).\n         \n        \n\n            \n         \n            Se comparan los valores en las posiciones 2 y 3.Tampoco se intercambia: el primero (5) es menor que el segundo (7).\n         \n        \n\n            \n         \n            Comienza otra pasada, comparando los primeros dos valores, que no se intercambian.\n         \n        \n\n            \n         \n            Se contin칰a comparando los de las posiciones 1 y 2, que tampoco se intercambian.\n         \n        \n\n            \n         \n            Se comparan los 칰ltimos dos valores, quedan en su lugar, y se finaliza una pasada sin intercambios.\n         \n        \n\n            \n         \n            Finalmente, la lista se encuentra ordenada.\n         \n        \n\n        \n          \n          Previous\n        \n\n        \n          \n          Next\n        \n\n      \n\nImplementaci칩n\ndef bubble_sort(arr):\n    arr = arr[:] # Hacer copia\n    n = len(arr)\n1    intercambiado = True\n\n2    while intercambiado:\n3        intercambiado = False\n4        for i in range(n - 1):\n5            if arr[i] &gt; arr[i + 1]:\n                # Se intercambian los valores\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n                intercambiado = True\n\n    return arr\n\n1\n\nSe usa una variable booleana intercambiado para indicar si en la pasada anterior se hizo un intercambio de elementos, y por lo tanto se debe realizar una pasada m치s. Inicialmente, este valor es True para que se ejecute el bucle while al menos una vez.\n\n2\n\nMientras se haya intercambiado en la pasada anterior.\n\n3\n\nEl primer paso de cada pasada es igualar intercambiado a False. Solo cuando se haga un intercambio se lo convierte a True.\n\n4\n\nSe itera a trav칠s de todos los valores en la secuencia, excepto el 칰ltimo, ya que se comapran de a pares.\n\n5\n\nSi el valor de la posici칩n i es mayor que el de la posici칩n i + 1, se intercambian y se iguala intercambiado a True.\n\n\nbubble_sort([12,9,3,6,11,5])\n[3, 5, 6, 9, 11, 12]\nEsta versi칩n repite pasadas completas hasta que no se produce ning칰n intercambio, lo que indica que la lista est치 ordenada.\n\n\n\n\n\n\nPor qu칠 bubble sort\n\n\n\nEn cada pasada, el algoritmo ubica el mayor valor fuera de orden en su posici칩n correcta, al final de la lista. Este proceso hace que los valores m치s grandes 랍uban gradualmente hacia la parte superior, como burbujas que ascienden en el agua, lo que da origen al nombre bubble sort.\n\n\n\n\n\n\n\n\nImplementaci칩n eficiente\n\n\n\nEn cada pasada, el mayor valor fuera de orden se coloca en su posici칩n definitiva. Esto implica que en la primera pasada el valor m치ximo llega a la 칰ltima posici칩n, en la segunda el segundo mayor queda en la pen칰ltima, y as칤 sucesivamente.\nPor lo tanto, en cada nueva pasada puede omitirse la 칰ltima comparaci칩n, ya que los elementos finales ya est치n ordenados.\n\n\n\n\n\n\n\n\nVersi칩n interactiva\n\n\n\nHacer clic aqu칤.\n\n\n\n\nAn치lisis de la eficiencia\nEl algoritmo bubble sort tiene dos tipos principales de pasos:\n\nComparaciones: se comparan n칰meros de a pares para determinar cu치l es mayor.\nIntercambios: se intercambian n칰meros para ordenarlos.\n\nSupongamos que tenemos una lista de 5 n칰meros y usamos una implementaci칩n eficiente, que omite las comparaciones innecesarias al final del arreglo.\nEn la primera pasada se realizan 4 comparaciones, en la segunda 3, en la tercera 2 y en la 칰ltima 1. En total, se efect칰an 4 + 3 + 2 + 1 = 10 comparaciones.\nDe manera general, si el arreglo tiene \\(N\\) elementos, el n칰mero m치ximo de comparaciones es:\n\\[\n(N - 1) + (N - 2) + \\cdots + 2 + 1 = \\frac{N(N - 1)}{2} = \\frac{N^2}{2} - \\frac{N}{2}\n\\]\nAdem치s, en el peor de los casos (cuando la lista est치 ordenada en forma descendente), ser치 necesario realizar tantos intercambios como comparaciones, ya que en cada comparaci칩n habr치 un valor mayor a su derecha. El total de comparaciones e intercambios posibles es entonces:\n\\[\n2 \\left[\\frac{N^2}{2} - \\frac{N}{2}\\right] = N^2 - N\n\\]\nAs칤, se concluye que la complejidad temporal de bubble sort \\(O(N^2)\\). Aunque la cantidad de pasos no solo dependa \\(N^2\\), sino tambi칠n de \\(N\\), la notaci칩n Big O se centra en el orden del t칠rmino dominante y, en este caso, se dice que buble sort es de complejidad cuadr치tica.\nLa siguiente tabla muestra lo r치pido que crece la cantidad m치xima de pasos conforme se incrementa la cantidad de elementos a ordenar:\n\n\n\n\n\\(N\\)\nCantidad m치xima de pasos\n\n\n\n\n5\n20\n\n\n10\n90\n\n\n20\n380\n\n\n30\n870\n\n\n50\n2450\n\n\n100\n9900",
    "crumbs": [
      "Teor칤a",
      "U4 - Estructuras de Datos y Algoritmos",
      "3 - Algoritmos de ordenamiento"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/03_ordenamiento.html#selection-sort",
    "href": "teoria/04_estructuras_y_algoritmos/03_ordenamiento.html#selection-sort",
    "title": "3 - Algoritmos de ordenamiento",
    "section": "Selection sort",
    "text": "Selection sort\nOtro algoritmo sencillo para ordenar una secuencia es selection sort. Al igual que bubble sort, realiza m칰ltiples pasadas a trav칠s de la lista.\nSu particularidad es que en cada pasada selecciona el menor valor de la parte desordenada y lo coloca en la posici칩n que le corresponde.\nLuego, contin칰a con el resto de la lista, repitiendo el proceso hasta que todos los elementos quedan ordenados.\n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n            \n         \n            Se cuenta con una lista desordenada.\n         \n        \n\n            \n         \n            Se inspecciona el primer valor, que es por ahora el m칤nimo.\n         \n        \n\n            \n         \n            Se avanza a la segunda posici칩n. Como 8 es mayor que 5, este 칰ltimo contin칰a siendo el m칤nimo.\n         \n        \n\n            \n         \n            Se avanza a la tercera posici칩n, donde se encuentra un nuevo m칤nimo (4).\n         \n        \n\n            \n         \n            Se avanza a la 칰ltima posici칩n, donde se encuentra un nuevo m칤nimo (3).\n         \n        \n\n            \n         \n            Se intercambia el m칤nimo con el valor de la primera posici칩n.\n         \n        \n\n            \n         \n            Ahora se procede a buscar el m칤nimo de la parte desordenada.\n         \n        \n\n            \n         \n            Se inspecciona el primer valor, que es por ahora el m칤nimo.\n         \n        \n\n            \n         \n            Se avanza a la segunda posici칩n, donde se encuentra un nuevo m칤nimo (4).\n         \n        \n\n            \n         \n            Se avanza a la 칰ltima posici칩n. Como 5 es mayor que 4, este 칰ltimo contin칰a siendo el m칤nimo.\n         \n        \n\n            \n         \n            Se intercambia el m칤nimo con el valor de la segunda posici칩n.\n         \n        \n\n            \n         \n            Ahora se procede a buscar el m칤nimo de la parte desordenada.\n         \n        \n\n            \n         \n            Se inspecciona el primer valor, que es por ahora el m칤nimo.\n         \n        \n\n            \n         \n            Se avanza a la 칰ltima posici칩n, donde se encuentra un nuevo m칤nimo (5).\n         \n        \n\n            \n         \n            Se intercambia el m칤nimo con el valor de la tercera posici칩n.\n         \n        \n\n            \n         \n            Como la parte desordenada de la lista contiene un solo elemento, debe ser mayor que todo el resto.\n         \n        \n\n            \n         \n            Finalmente, se obtiene una lista ordenada.\n         \n        \n\n        \n          \n          Previous\n        \n\n        \n          \n          Next\n        \n\n      \n\nImplementaci칩n\ndef selection_sort(arr):\n    arr = arr[:]\n\n1    for i in range(len(arr) - 1):\n2        indice_menor_numero = i\n\n3        for j in range(i + 1, len(arr)):\n            if arr[j] &lt; arr[indice_menor_numero]:\n                indice_menor_numero = j\n\n4        if indice_menor_numero != i:\n            arr[i], arr[indice_menor_numero] = arr[indice_menor_numero], arr[i]\n\n    return arr\n\n1\n\nEl puntero i itera desde el primer hasta el pen칰ltimo elemento. Este es el que realiza las pasadas.\n\n2\n\nEn cada pasada, se toma al primer valor como el m칤nimo, por eso indice_menor_numero se iguala a i.\n\n3\n\nOtro puntero, j, recorre la lista a partir de i, hasta el final. Si el valor en la posici칩n j es mejor que en el m칤nimo actual, se toma a j como el 칤ndice con el m칤nimo.\n\n4\n\nSi el m칤nimo no est치 al principio de la sublista que se recorre, se intercambian las posiciones de los elementos para que el m칤nimo est칠 al principio.\n\n\nselection_sort([95,50,20,13,17,100])\n# [13, 17, 20, 50, 95, 100]\n\n\n\n\n\n\nVersi칩n interactiva\n\n\n\nHacer clic aqu칤.\n\n\n\n\nAn치lisis de eficiencia\nAl igual que bubble sort, el algoritmo selection sort tambi칠n utiliza dos tipos de operaciones: comparaciones e intercambios. En cada pasada, se compara cada valor de la parte desordenada con el m칤nimo actual, y al finalizar se coloca dicho m칤nimo en su posici칩n correcta (intercambi치ndolo con el valor que estaba all칤).\nLa cantidad de comparaciones que realiza es id칠ntica a la del algoritmo bubble sort. Para un arreglo de longitud \\(N\\), se efect칰an \\(\\frac{N^2}{2} - \\frac{N}{2}\\) comparaciones.\nPor otro lado, y a diferencia del algoritmo bubble sort, se realiza a lo sumo un intercambio por pasada, por lo que en total pueden realizar hasta \\(N - 1\\) intercambios y la cantidad m치xima de pasos del algoritmo insertion sort es:\n\\[\n\\frac{N^2}{2} - \\frac{N}{2} + (N - 1),\n\\]\nlo que indica que la complejidad temporal de selection sort tambi칠n es cuadr치tica.\nLa siguiente tabla muestra una comparaci칩n lado a lado entre los dos algoritmos estudiados:\n\n\n\n\n\n\n\n\nN\nPasos m치ximos en bubble sort\nPasos m치ximos en selection sort\n\n\n\n\n5\n20\n14 (10 comparaciones + 4 intercambios)\n\n\n10\n90\n54 (45 comparaciones + 9 intercambios)\n\n\n20\n380\n209 (190 comparaciones + 19 intercambios)\n\n\n30\n870\n464 (435 comparaciones + 29 intercambios)\n\n\n50\n2450\n1274 (1225 comparaciones + 49 intercambios)\n\n\n100\n9900\n5049 (4950 comparaciones + 99 intercambios)\n\n\n\nDe esta comparaci칩n se observa que selection sort requiere aproximadamente la mitad de los pasos que bubble sort, lo que indica que, en promedio, resulta alrededor de dos veces m치s r치pido.\n\n\n\n\n\n\n쮺omplejidad \\(O(N^2 / 2)\\)?\n\n\n\nA pesar de que el algoritmo selection sort realiza aproximadamente la mitad de pasos que bubble sort, ambos se consideran algoritmos de complejidad cuadr치tica.\nAl analizar la eficiencia mediante la notaci칩n Big O, solo importa c칩mo crece el n칰mero de pasos con el tama침o del problema, no la constante que los multiplica.\nSi un algoritmo realiza \\(N^2\\) pasos y otro realiza \\(N^2 / 2\\), ambos crecen de manera proporcional a \\(N^2\\) cuando \\(N\\) aumenta.\nPor lo tanto, tanto bubble sort como selection sort se describen como algoritmos de orden \\(O(N^2)\\).",
    "crumbs": [
      "Teor칤a",
      "U4 - Estructuras de Datos y Algoritmos",
      "3 - Algoritmos de ordenamiento"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/03_ordenamiento.html#insertion-sort",
    "href": "teoria/04_estructuras_y_algoritmos/03_ordenamiento.html#insertion-sort",
    "title": "3 - Algoritmos de ordenamiento",
    "section": "Insertion sort",
    "text": "Insertion sort\nEn esta secci칩n estudiaremos otro algoritmo, llamado insertion sort. Es un m칠todo de ordenamiento simple que inserta los elementos de la lista en una sublista ordenada que ocupa las primeras posiciones.\nInicialmente, esta sublista ordenada contiene un solo elemento, el primero de la lista. A medida que se procesan los siguientes elementos, se van insertando en la posici칩n correcta dentro de la sublista, manteniendo el orden. De esta forma, la parte ordenada va creciendo progresivamente hasta abarcar todos los elementos, momento en el cual la lista queda completamente ordenada.\n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n            \n         \n            Todo comienza con una lista desordenada.\n         \n        \n\n            \n         \n            Se extrae el elemento en la segunda posici칩n.\n         \n        \n\n            \n         \n            Se lo compara con los valores a su izquierda.Si estos son mayores, se los traslada a la derecha dejando un hueco para el valor extra칤do.\n         \n        \n\n            \n         \n            Como 9 es mayor a 4, se lo traslada a la derecha.\n         \n        \n\n            \n         \n            Dado que no hay m치s n칰meros a comparar, se inserta el 4 en el hueco generado y se finaliza la primera iteraci칩n.\n         \n        \n\n            \n         \n            Con la lista en este estado, se repite el proceso.\n         \n        \n\n            \n         \n            Ahora se extrae el valor de la tercera posici칩n.\n         \n        \n\n            \n         \n            Se lo compara con el primer valor a su izquierda, que es mayor y por lo tanto se traslada a la derecha.\n         \n        \n\n            \n         \n            Se lo compara con el segundo valor a su izquierda, que tambi칠n es mayor y se los traslada a la derecha.\n         \n        \n\n            \n         \n            No habiendo valores por comparar, se inserta el valor extra칤do en el hueco generado.\n         \n        \n\n            \n         \n            Ahora se extrae el 칰ltimo valor en la secuencia.\n         \n        \n\n            \n         \n            Su primer valor a la izquierda es mayor, por lo tanto se traslada.\n         \n        \n\n            \n         \n            Su segundo valor a la izquierda tambi칠n es mayor y se traslada a la derecha.\n         \n        \n\n            \n         \n            El 칰ltimo valor a comparar es menor, por lo tanto no se traslada.\n         \n        \n\n            \n         \n            Se coloca el valor extra칤do en el hueco generado.\n         \n        \n\n            \n         \n            Finalmente, se tiene la secuencia ordenada.\n         \n        \n\n        \n          \n          Previous\n        \n\n        \n          \n          Next\n        \n\n      \n\nImplementaci칩n\ndef insertion_sort(arr):\n    arr = arr[:]\n\n1    for i in range(1, len(arr)):\n        valor_i = arr[i]\n\n2        puntero = i - 1\n3        while puntero &gt;= 0 and arr[puntero] &gt; valor_i:\n            arr[puntero + 1] = arr[puntero]\n            puntero -= 1\n\n4        arr[puntero + 1] = valor_i\n\n    return arr\n\n1\n\nLa variable i es la posici칩n original del elemento a insertar en la lista ordenada. Se empieza del segundo elemento. Su valor lo representa valor_i.\n\n2\n\nUn puntero recorre de derecha a izquierda los elementos a la izquierda de la posici칩n i.\n\n3\n\nSi el puntero no lleg칩 al final y el valor en su posici칩n es mayor al valor a insertar en la sublista ordenada (valor_i), se mueve el valor en la posici칩n del puntero a la derecha y se decrementa el puntero en 1 unidad.\n\n4\n\nUna vez que termina el proceso de traslaci칩n de valores, se inserta el valor_i en la posici칩n que le corresponde, que es a la derecha del puntero.\n\n\ninsertion_sort([9,7,5,999, 1,10,25])\n# [1, 5, 7, 9, 10, 25, 999]\n\n\n\n\n\n\nVersi칩n interactiva\n\n\n\nHacer clic aqu칤.\n\n\n\n\nAn치lisis de eficiencia\nEl algoritmo insertion sort realiza cuatro tipos de operaciones: extracciones, comparaciones, desplazamientos e inserciones.\nLas comparaciones ocurren cada vez que se compara el valor_actual con los elementos que tiene a su izquierda. En el peor de los casos, cuando la lista est치 ordenada en sentido descendente, todos los valores a la izquierda son mayores que valor_actual, lo que obliga con compararlo con todos ellos antes de volver a insertarlo.\nEn la primera pasada se realiza 1 comparaci칩n, en la segunda 2, y as칤 sucesivamente, hasta la 칰ltima pasada donde se realizan \\(N - 1\\) comparaciones. Por lo tanto, el n칰mero m치ximo de comparaciones es:\n\\[\n1 + 2 + 3 + \\dots + (N - 1) = \\frac{N^2}{2} - \\frac{N}{2}\n\\]\nLos desplazamientos ocurren cada vez que un valor se mueve a la derecha para dejar lugar al valor_actual. En el peor de los casos, el n칰mero de desplazamientos es igual al n칰mero de comparaciones. Sumando ambos tipos de operaciones, el n칰mero total de pasos es \\(N^2 - N\\).\nPor su parte, las extracciones e inserciones se realizan una vez por pasada, es decir, \\(N - 1\\) veces cada una. Estas operaciones tienen un peso menor frente al crecimiento cuadr치tico de las comparaciones y desplazamientos.\nEl n칰mero total de pasos es entonces:\n\\[\nN^2 - N + 2N - 2 = N^2 + N - 2\n\\]\nEn t칠rminos de notaci칩n Big O, que no solo descarta t칠rminos constantes, sino que tambi칠n se concentra en el t칠rmino de mayor orden, concluimos que el algoritmo es de orden \\(O(N^2)\\).\n\nAnalizando el 띾aso promedio렢nHasta ahora, el an치lisis se centr칩 siempre en el peor escenario, pero el desempe침o de insertion sort depende en gran medida del orden inicial de los datos.\nEn el peor de los casos, cuando el arreglo est치 ordenado de manera decreciente, insertion sort tiene una complejidad de \\(O(N^2)\\). En esta situaci칩n, su desempe침o resulta inferior al de selection sort, que requiere menos operaciones (alrededor de \\(O(N^2/2)\\)).\nSi los datos ya est치n ordenados, insertion sort solo realiza una comparaci칩n por pasada y ning칰n desplazamiento, sumando en total \\(N - 1\\) comparaciones. Selection sort, por su parte, efectuar칤a igualmente unas \\(\\frac{N^2}{2} - \\frac{N}{2}\\) comparaciones.\nCuando los datos no siguen ning칰n orden en particular, insertion sort tiene pasadas en las que compara y traslada todos, algunos o ninguno de los valores. Si en el peor caso se comparan y trasladan todos los elementos, y en el mejor no se traslada ninguno, podemos estimar que, en un caso promedio, se comparar치 y trasladar치 aproximadamente la mitad de los elementos. Por eso se representa con una complejidad de \\(O(N^2/2)\\).\nEn resumen, mientras selection sort mantiene una complejidad constante de \\(O(N^2/2)\\) sin importar el orden inicial de los datos, _insertion sort? var칤a entre \\(O(N)\\) en el mejor de los casos, \\(O(N^2/2)\\) en el promedio y \\(O(N^2)\\) en el peor.\nLa elecci칩n de cu치l usar depende, en definitiva, de las caracter칤sticas de los datos a ordenar. Por su eficiencia en listas casi ordenadas, insertion sort suele utilizarse dentro de algoritmos m치s complejos como parte de etapas finales de ordenamiento.",
    "crumbs": [
      "Teor칤a",
      "U4 - Estructuras de Datos y Algoritmos",
      "3 - Algoritmos de ordenamiento"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/03_ordenamiento.html#divide-y-vencer치s",
    "href": "teoria/04_estructuras_y_algoritmos/03_ordenamiento.html#divide-y-vencer치s",
    "title": "3 - Algoritmos de ordenamiento",
    "section": "Divide y vencer치s",
    "text": "Divide y vencer치s\nLos tres algoritmos que estudiamos hasta ahora nos sirvieron para comprender los fundamentos de los algoritmos de ordenamiento, practicar el an치lisis de la complejidad temporal y reforzar la idea de que no existe una 칰nica forma de ordenar.\nSin embargo, la complejidad temporal de todos ellos est치 lejos de ser ideal. Cuando un algoritmo tiene complejidad cuadr치tica, incluso un peque침o incremento en el tama침o \\(N\\) de la secuencia puede hacer que el n칰mero de pasos necesarios crezca de manera considerable.\nPor estos motivos, y dado que existen alternativas m치s eficientes, ning칰n lenguaje de programaci칩n maduro utiliza alguno de estos algoritmos como m칠todo de ordenamiento por defecto.\nEn la pr치ctica, se prefieren algoritmos m치s elaborados que logran una mejora sustancial en el desempe침o computacional. Dos ejemplos cl치sicos de estos son merge sort y quick sort.\nAmbos se basan en un mismo paradigma de dise침o algor칤tmico conocido como divide y vencer치s (del ingl칠s, divide and conquer). Este enfoque consiste en resolver un problema grande de forma recursiva, dividi칠ndolo en subproblemas m치s peque침os del mismo tipo.\nLa idea clave es que ordenar secuencias peque침as resulta mucho m치s r치pido que ordenar una grande, y que ordenar una secuencia parcialmente ordenada es m치s eficiente que hacerlo sobre una totalmente desordenada.\nDe manera general, el m칠todo divide y vencer치s se desarrolla en tres etapas, que en el contexto del ordenamiento pueden describirse as칤:\n\nDividir: Si la secuencia \\(S\\) es lo suficientemente peque침a (por ejemplo, contiene uno o dos elementos), se la ordena directamente y se devuelve un resultado. En caso contrario, se divide \\(S\\) en dos o m치s subsecuencias disjuntas.\nConquistar: se aplica el mismo procedimiento recursivamente sobre cada subsecuencia hasta que todas est칠n ordenadas.\nCombinar: se toman las subsecuencias ordenadas y se las une para formar una 칰nica secuencia ordenada, que constituye la soluci칩n final al problema original.\n\nA continuaci칩n veremos c칩mo estos pasos se materializan en un caso particular: merge sort.",
    "crumbs": [
      "Teor칤a",
      "U4 - Estructuras de Datos y Algoritmos",
      "3 - Algoritmos de ordenamiento"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/03_ordenamiento.html#merge-sort",
    "href": "teoria/04_estructuras_y_algoritmos/03_ordenamiento.html#merge-sort",
    "title": "3 - Algoritmos de ordenamiento",
    "section": "Merge sort",
    "text": "Merge sort\nMerge sort es un algoritmo recursivo que divide continuamente una lista por la mitad. Si la lista est치 vac칤a o contiene un solo elemento, se considera ordenada por definici칩n (caso base). En cambio, si tiene m치s de un elemento, se divide y se aplica recursivamente merge sort a cada mitad (caso recursivo).\nUna vez que ambas mitades est치n ordenadas, se realiza la operaci칩n fundamental del algoritmo, llamada fusi칩n (del ingl칠s, merge). La fusi칩n consiste en combinar dos listas ordenadas m치s peque침as en una 칰nica lista nueva y ordenada.\nEl procedimiento general del algoritmo puede resumirse as칤:\n\nDividir: si la secuencia \\(S\\) tiene 0 o 1 elementos, se devuelve directamente porque ya est치 ordenada. En otro caso, se divide en dos subsecuencias: la primera mitad en \\(S_1\\) y la segunda en \\(S_2\\).\nOrdenar (Conquistar): aplicar recursivamente merge sort sobre \\(S_1\\) y \\(S_2\\).\nFusionar: combinar las secuencias ordenadas \\(S_1\\) y \\(S_2\\) para obtener una nueva secuencia ordenada que contiene todos los elementos de \\(S\\).\n\nVisualmente:\n\n        \n\n\n\n\n        \n            \n         \n            Se tiene una lista desordenada.\n         \n        \n\n            \n         \n            Como su longitud es mayor a 1,se la parte en dos mitades.\n         \n        \n\n            \n         \n            A su vez, estas listas tambi칠n se parten a la mitad. Ahora que todas son de longitud 1, comienza la fusi칩n.\n         \n        \n\n            \n         \n            Hacia la izquierda, se fusionan 7 y 3 en [3, 7];hacia la derecha, 4 y 1 en [1, 4].\n         \n        \n\n            \n         \n            Finalmente, se fusionan ambas sublistas en la lista ordenada.\n         \n        \n\n        \n          \n          Previous\n        \n\n        \n          \n          Next\n        \n\n      \nEsta representaci칩n esquem치tica ayuda a visualizar la aplicaci칩n del principio divide y vencer치s en un algoritmo de ordenamiento como merge sort.\nSin embargo, esta representaci칩n no refleja fielmente el funcionamiento del algoritmo, considerando su naturaleza recursiva.\nEl siguiente conjunto de im치genes nos ayudar치n a entender como fuciona merge sort de manera recursiva.\n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n            \n         \n            Todo empieza con una lista desordenada.Como su longitud es mayor a 1, se parte a la mitad.\n         \n        \n\n            \n         \n            Se aplica el algoritmo recursivamente, comenzando por la primera sublista, que se parte a la mitad.\n         \n        \n\n            \n         \n            Se repite el mismo proceso, y se parte la lista de la izquierda.\n         \n        \n\n            \n         \n            Ahora, que se opera sobre listas de longitud 1,se comienza a devolverlas y fusionarlas en listas ordenadas.\n         \n        \n\n            \n         \n            Las listas [69] y [45] se fusionan en [45, 69].\n         \n        \n\n            \n         \n            Se finaliza la ejecuci칩n del algoritmo sobre [87, 50], que se parte en dos.\n         \n        \n\n            \n         \n            Las listas de longitud 1 se devuelven y fusionan en [50, 87].\n         \n        \n\n            \n         \n            Ahora se fusionan las listas ordenadas de longitud 2 en una lista ordenada de longitud 4.\n         \n        \n\n            \n         \n            Antes de devolver la lista ordenada de la izquierda, se debe ordenar la lista de la derecha.\n         \n        \n\n            \n         \n            Como es de longitud mayor 1, se parte en dos.Y se aplica el procedimiento recursivamente.\n         \n        \n\n            \n         \n            Se parte la lista de la izquierda.\n         \n        \n\n            \n         \n            Como se obtienen listas de longitud 1, ordenadas, se fusionan en una lista de longitud 2.\n         \n        \n\n            \n         \n            Ahora se parte la lista de la derecha.\n         \n        \n\n            \n         \n            Se obtienen listas de longitud 1, ordenadas, que se fusionan en una lista de longitud 2.\n         \n        \n\n            \n         \n            Se fusionan las listas ordenadas de longitud 2 en otra de longitud 4, tambi칠n ordenada.\n         \n        \n\n            \n         \n            Se realiza la 칰ltima fusi칩n ordenada.\n         \n        \n\n            \n         \n            Y se obtiene, finalmente, la lista ordenada.\n         \n        \n\n        \n          \n          Previous\n        \n\n        \n          \n          Next\n        \n\n      \nEl algoritmo merge sort se basa principalmente en particiones y fusiones. Las particiones son sencillas de entender e implementar.\nPor otro lado, no es trivial obtener una secuencia ordenada a partir de la fusi칩n de dos secuencias tambi칠n ordenadas. La operaci칩n excede a una simple concatenaci칩n.\nPara resolver este problema, merge sort usa un algoritmo conocido como fusi칩n de arreglos (merging arrays). En este contexto, fusionar arreglos significa tomar dos arreglos que ya est치n ordenados, copiar todos sus valores en un tercer arreglo y obtener como resultado un tercer arreglo completamente ordenado.\n\n\n\nPara fusionar dos arreglos ordenados \\(S_1\\) y \\(S_2\\), el algoritmo de fusi칩n sigue estos pasos:\n\nSe inicializa un puntero izq, que apunta al primer 칤ndice de \\(S_1\\) , y otro puntero der que apunta al primer 칤ndice de \\(S_2\\).\nSe crea un tercer arreglo vac칤o. Este ser치 el arreglo con los datos fusionados, tendr치 todos los valores de \\(S_1\\) y \\(S_2\\), en orden ascendente\nSe ejecuta un bucle hasta que el puntero izquierdo o el puntero derecho lleguen al final de su respectivas secuencias. Dentro del bucle, realiza lo siguiente:\n\nComparar el valor apuntado por el puntero izquierdo con el valor apuntado por el puntero derecho y determina cu치l es menor.\nTomar el valor menor y a침adirlo al arreglo fusionado.\nIncrementar el puntero que estaba apuntando al valor menor para que se침ale el siguiente 칤ndice de su arreglo. Si en alg칰n momento los dos valores que se comparan son iguales, se puede a침adir arbitrariamente el valor del arreglo izq e incrementar su puntero.\n\nUna vez que el bucle termina, uno de los dos arreglos (\\(S_1\\) o \\(S_2\\)) quedar치 랄ncompleto, es decir, a칰n tendr치 valores que no se copiaron al arreglo fusionado. Esto da inicio al 칰ltimo paso del algoritmo.\nSe toman todos los valores restantes del arreglo 랄ncompleto y es a침aden, en orden, al arreglo fusionado.\n\nVeamos el ejemplo desarrollado paso a paso:\n\n        \n\n\n\n\n\n\n\n\n\n\n\n        \n            \n         \n            Se inicializa un puntero que apunta al principio de cada arreglo y se crea un tercer arreglo vac칤o.\n         \n        \n\n            \n         \n            El valor del puntero derecho es el menor, por lo que se agrega a la lista definitiva.\n         \n        \n\n            \n         \n            Se mueve el puntero derecho un casillero a la derecha.\n         \n        \n\n            \n         \n            El valor del puntero derecho es el menor, por lo que se agrega a la lista definitiva.\n         \n        \n\n            \n         \n            Se mueve el puntero derecho un casillero a la derecha.\n         \n        \n\n            \n         \n            Ahora, el valor del puntero izquierdo es menor y se agrega su valor a la lista definitiva.\n         \n        \n\n            \n         \n            Se mueve el puntero izquierdo un casillero a la derecha.\n         \n        \n\n            \n         \n            El valor del puntero izquierdo es el menor, se agrega su valor a la lista definitiva y se mueve un casillero a la derecha.\n         \n        \n\n            \n         \n            El valor del puntero derecho es menor, se agrega a la lista y el puntero se mueve a la derecha.\n         \n        \n\n            \n         \n            El valor del puntero derecho es menor, se agrega a la lista y se mueve el puntero a la derecha, finalizando su recorrido.\n         \n        \n\n            \n         \n            Se agregan los valores remanentes de la lista izquierda\n         \n        \n\n            \n         \n            Se obtiene una lista ordenada.\n         \n        \n\n        \n          \n          Previous\n        \n\n        \n          \n          Next\n        \n\n      \n\nImplementaci칩n\nUna implementaci칩n en Python es la siguiente:\ndef merge(izquierda, derecha):\n    n_i = len(izquierda)\n    n_j = len(derecha)\n    resultado = [None] * (n_i + n_j)\n\n    i = 0\n    j = 0\n    k = 0\n\n    while True:\n        if izquierda[i] &lt; derecha[j]:\n            valor = izquierda[i]\n            i += 1\n        else:\n            valor = derecha[j]\n            j += 1\n\n        resultado[k] = valor\n        k += 1\n\n        if i == n_i:\n            resultado[k:] = derecha[j:]\n            break\n\n        if j == n_j:\n            resultado[k:] = izquierda[i:]\n            break\n\n    return resultado\nY luego, tenemos la funci칩n merge_sort:\ndef merge_sort(arr):\n    if len(arr) &lt;= 1:\n        return arr\n\n    mitad = len(arr) // 2\n    izquierda = merge_sort(arr[:mitad])\n    derecha = merge_sort(arr[mitad:])\n\n    return merge(izquierda, derecha)\nmerge([2,2,3,11,50],[3,10,15,20])\n# [2, 2, 3, 3, 10, 11, 15, 20, 50]\nmerge_sort([50, 3, 10, 11, 20, 99, 155, 8, 5, 9])\n# [3, 5, 8, 9, 10, 11, 20, 50, 99, 155]\n\n\n\n\n\n\nVersi칩n interactiva\n\n\n\nHacer clic aqu칤.\n\n\n\n\n\n\n\n\nTop-down, bottom-up\n\n\n\nLa versi칩n de merge sort que acabamos de ver se conoce como top-down, y utiliza recursi칩n.\nSin embargo, no es la 칰nica forma de implementar este algoritmo. Existe tambi칠n una versi칩n llamada bottom-up, que no emplea recursi칩n.\nEn la pr치ctica, suele ser algo m치s eficiente, ya que evita mantener un stack de llamadas y la memoria asociada a cada una de ellas.\n\n\n\n\nAn치lisis de eficiencia\nEl an치lisis de la complejidad de merge sort se basa en entender los dos procesos principales que componen el algoritmo:\n\nLa divisi칩n recursiva de la lista en mitades.\nLa fusi칩n (merge) de las sublistas ordenadas en una nueva lista.\n\n\nEl proceso de fusi칩n\nEl coraz칩n del algoritmo est치 en la operaci칩n de fusi칩n, donde dos listas ordenadas se combinan en una sola lista tambi칠n ordenada. Si consideramos que entre ambas listas hay un total de \\(N\\) elementos, entonces el proceso completo de fusi칩n requiere, en el peor de los casos, alrededor de \\(2N\\) pasos:\n\n\\(N\\) operaciones para copiar los elementos en la lista final,\ny hasta \\(N - 1\\) comparaciones para decidir el orden en que se insertan.\n\nAl sumar ambos tipos de operaciones, tenemos un total de \\(2N - 1\\) pasos, que en notaci칩n Big O se escribe como \\(O(N)\\). En otras palabras, fusionar dos listas ordenadas es una operaci칩n de complejidad lineal.\n\n\nEl n칰mero de divisiones\nAhora bien, merge sort no realiza una 칰nica fusi칩n. El algoritmo divide recursivamente la lista original en mitades, aplicando el mismo proceso a cada parte. Cada divisi칩n parte la lista en dos, y la cantidad m치xima de veces que puede hacerse esto es proporcional al logaritmo del tama침o de la lista. Es decir, si la lista tiene \\(N\\) elementos, podemos dividirla como mucho \\(\\log_2 N\\) veces, hasta que llegamos a sublistas de tama침o 1 (que ya est치n ordenadas por definici칩n).\n\n\nCombinando ambos procesos\nEn cada 랉ivel de la recursi칩n se realizan fusiones que, en conjunto, procesan todos los elementos de la lista. Por lo tanto, cada nivel tiene un costo de complejidad \\(O(N)\\), y como hay \\(\\log N\\) niveles, el costo total del algoritmo es:\n\\[\nO(N) \\times O(\\log N) = O(N \\log N)\n\\]\nEsta complejidad temporal indica que merge sort es m치s eficiente, en cantidad de pasos, que todos los algoritmos que estudiamos previamente.\n\n\nComplejidad espacial\nLa eficiencia en tiempo tiene un costo adicional, el uso de memoria. Durante la fusi칩n, el algoritmo necesita espacio extra para almacenar las sublistas temporales que se van creando y combinando. Esto implica una complejidad espacial de \\(O(N)\\), ya que se debe reservar memoria proporcional al tama침o total de la lista.",
    "crumbs": [
      "Teor칤a",
      "U4 - Estructuras de Datos y Algoritmos",
      "3 - Algoritmos de ordenamiento"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/03_ordenamiento.html#quick-sort",
    "href": "teoria/04_estructuras_y_algoritmos/03_ordenamiento.html#quick-sort",
    "title": "3 - Algoritmos de ordenamiento",
    "section": "Quick sort",
    "text": "Quick sort\nEl algoritmo quick sort tambi칠n se basa en el paradigma de dividir y conquistar. La idea es dividir la secuencia en partes m치s peque침as, ordenarlas de forma recursiva y luego combinarlas mediante una simple concatenaci칩n.\n\nVersi칩n b치sica\nEl algoritmo puede describirse en tres pasos:\n\nDividir: se elige un elemento de la secuencia, llamado pivote. En la pr치ctica, suele seleccionarse el 칰ltimo elemento o uno al azar (que se mueve al final). Luego, se recorre la secuencia y se distribuyen sus elementos en tres nuevas subsecuencias:\n\n\\(L\\): que contiene los valores menores que el pivote.\n\\(E\\): que contiene los valores iguales al pivote.\n\\(G\\): que contiene los valores mayores que el pivote.\n\nConquistar: se ordenan recursivamente las subsecuencias \\(L\\) y \\(G\\), aplicando el mismo procedimineto\nCombinar: se unen las subsecuencias en una sola secuencia ordenada, concatenando los elementos de \\(L\\), \\(E\\) y \\(G\\) en ese orden.\n\n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n            \n         \n            \n         \n        \n\n            \n         \n            \n         \n        \n\n            \n         \n            \n         \n        \n\n            \n         \n            \n         \n        \n\n            \n         \n            \n         \n        \n\n            \n         \n            \n         \n        \n\n            \n         \n            \n         \n        \n\n            \n         \n            \n         \n        \n\n            \n         \n            \n         \n        \n\n            \n         \n            \n         \n        \n\n            \n         \n            \n         \n        \n\n            \n         \n            \n         \n        \n\n            \n         \n            \n         \n        \n\n            \n         \n            \n         \n        \n\n        \n          \n          Previous\n        \n\n        \n          \n          Next\n        \n\n      \nEn Python:\ndef quicksort_basico(arr):\n    if len(arr) &lt;= 1:\n        return arr\n\n    pivote = arr[-1]\n\n    menores = []\n    iguales = []\n    mayores = []\n\n    for x in arr:\n        if x &lt; pivote:\n            menores.append(x)\n        elif x == pivote:\n            iguales.append(x)\n        else:\n            mayores.append(x)\n\n    return quicksort_basico(menores) + iguales + quicksort_basico(mayores)\nquicksort_basico([33,1,2,5,4,3,20,10])\n# [1, 2, 3, 4, 5, 10, 20, 33]\nEsta versi칩n es conceptualmente sencilla, pero utiliza memoria adicional para almacenar las tres subsecuencias creadas en cada paso recursivo.\n\n\nVersi칩n in place\nExiste otra implementaci칩n, m치s eficiente en el uso de memoria, conocida como versi칩n in place. En lugar de crear nuevas subsecuencias, modifica la secuencia original intercambiando elementos de lugar. En ese sentido, se asemeja a algoritmos como bubble sort, selection sort o insertion sort.\nLa partici칩n se realiza utilizando dos punteros, izq y der, que comienzan en los extremos de la parte de la secuencia que se est치 procesando, luego de haber seleccionado el pivote.\n\nEl puntero izq avanza hacia la derecha hasta encontrar un valor mayor o igual al pivote.\nEl puntero der avanza hacia la izquierda hasta encontrar un valor menor o igual al pivote.\n\nCuando ambos punteros se detienen:\n\nSi no se han cruzado, se intercambian los valores y el proceso se repite.\nSi se cruzan, se intercambia el pivote con el elemento apuntado por izq.\n\nEn ese momento se completa una partici칩n: los valores menores al pivote quedan a su izquierda y los mayores, a su derecha. Luego, el algoritmo se aplica recursivamente sobre cada una de las dos partes resultantes.\n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n            \n         \n            Todo comienza con una lista desordenada.\n         \n        \n\n            \n         \n            Se selecciona el 칰ltimo valor como pivote y se inicializan los punteros a la izquierda y a la derecha\n         \n        \n\n            \n         \n            Se compara el valor del puntero izquierdo con el pivote. Es menor, se mueve a la derecha.\n         \n        \n\n            \n         \n            Se compara el valor del puntero izquierdo con el pivote. No es menor, se detiene.\n         \n        \n\n            \n         \n            Se compara el valor del puntero derecho con el pivote. Es mayor, se mueve a la izquierda.\n         \n        \n\n            \n         \n            Se compara el valor del puntero derecho con el pivote. No es mayor, se detiene.\n         \n        \n\n            \n         \n            Como ambos punteros se detuvieron, y no se cruzaron, se intercambian sus valores.\n         \n        \n\n            \n         \n            Contin칰a el proceso de comparaci칩n de punteros con el pivote.\n         \n        \n\n            \n         \n            Se compara el puntero izquierdo con el pivote. Es menor, se mueve a la derecha.\n         \n        \n\n            \n         \n            Se compara el puntero izquierdo con el pivote. Es menor, se mueve a la derecha.\n         \n        \n\n            \n         \n            Se compara el puntero derecho con el pivote. Es mayor, se mueve a la izquierda.\n         \n        \n\n            \n         \n            Se compara el puntero derecho con el pivote. No es mayor, se detiene.\n         \n        \n\n            \n         \n            Como los punteros se cruzaron, se intercambia el valor del puntero izquierdo con el pivote, que ocupa su lugar definitivo en la lista ordenada.\n         \n        \n\n            \n         \n            El candado sobre el '3' indica que esa es su posici칩n definitiva.\n         \n        \n\n        \n          \n          Previous\n        \n\n        \n          \n          Next\n        \n\n      \nEl proceso que acabamos de describir es una partici칩n. El valor del pivote ahora se encuentra en su lugar definitivo en la lista ordenada. Ahora, el algoritmo quick sort particiona recursivamente las secciones restantes.\n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n            \n         \n            Se comienza por la sublista a la izquierda del anterior pivote. El puntero izquiero es menor al pivote y se mueve a la derecha.\n         \n        \n\n            \n         \n            Se compara el puntero izquierdo con el pivote. Es menor, se mueve a la derecha.\n         \n        \n\n            \n         \n            Podr칤a trasladarse el puntero dereecho a la izquierda, pero como se cruzaron, no hace falta.\n         \n        \n\n            \n         \n            Se intercambia el valor del puntero izquierdo con el pivote. Como son el mismo, se queda en su lugar. Finaliza otra partici칩n.\n         \n        \n\n            \n         \n            Se particiona la sublista [0, 1]. El valor del puntero izquiero es menor al pivote, por lo que se mueve a la derecha.\n         \n        \n\n            \n         \n            Como el puntero izquierdo cruz칩 al puntero derecho, no hace falta comparar el valor del puntero derecho con el pivote.\n         \n        \n\n            \n         \n            Se intercambia el valor del puntero izquierdo con el pivote.\n         \n        \n\n            \n         \n            Se finaliz칩 otra partici칩n. Se continua por la sublista izquierda.\n         \n        \n\n            \n         \n            Una sublista de longitud 1 ya est치 ordenada por definici칩n. Se contin칰a por la sublista derecha.\n         \n        \n\n            \n         \n            El valor del puntero izquierdo es menor al pivote, no se realizan movimientos.\n         \n        \n\n            \n         \n            Como los punteros se cruzaron, se intercambia el valor del puntero izquierdo con el pivote.\n         \n        \n\n            \n         \n            Ahora solo resta ordenar la 칰ltima sublista de la derecha.\n         \n        \n\n            \n         \n            Como es de longitud 1, ya se considera ordenada.\n         \n        \n\n            \n         \n            Finalmente, se obtiene una lista ordenada mediante el algoritmo quick sort.\n         \n        \n\n        \n          \n          Previous\n        \n\n        \n          \n          Next\n        \n\n      \n\n\nImplementaci칩n\ndef _quick_sort(arr, inicio, fin):\n    \"\"\"Ordena la lista 'arr' _in place_ usando el algoritmo quicksort.\"\"\"\n    if fin - inicio &lt;= 0:\n        return\n\n    # Realizar la partici칩n y obtener la posici칩n final del pivote\n    pivote_idx = particionar(arr, inicio, fin)\n\n    # Ordenar recursivamente las dos mitades\n    _quick_sort(arr, inicio, pivote_idx - 1)\n    _quick_sort(arr, pivote_idx + 1, fin)\n\ndef particionar(arr, izq_idx, der_idx):\n    pivote_idx = der_idx\n    pivote = arr[pivote_idx]\n    der_idx -= 1\n\n    while True:\n        while arr[izq_idx] &lt; pivote:\n            izq_idx += 1\n\n        while arr[der_idx] &gt; pivote:\n            der_idx -= 1\n\n        if izq_idx &gt;= der_idx:\n            break\n        else:\n            arr[izq_idx], arr[der_idx] = arr[der_idx], arr[izq_idx]\n            izq_idx += 1\n\n    # Finalizar particion\n    arr[izq_idx], arr[pivote_idx] = arr[pivote_idx], arr[izq_idx]\n\n    return izq_idx\n\ndef quick_sort(arr):\n    arr_copia = arr[:]\n    _quick_sort(arr_copia, inicio=0, fin=len(arr) - 1) # Ordena _in place_\n    return arr_copia\nquick_sort([8, 3, 1, 7, 0, 10, 2])\n# [0, 1, 2, 3, 7, 8, 10]\n\n\n\n\n\n\nVersi칩n interactiva\n\n\n\nHacer clic aqu칤.\n\n\n\n\nAn치lisis de eficiencia\nEl costo de quick sort proviene principalmente del proceso de partici칩n, en el que cada elemento de la lista se compara con el pivote.\nSe realizan unas \\(N\\) comparaciones por partici칩n y un n칰mero menor de intercambios, ya que cada intercambio reubica dos elementos a la vez.\nPor lo tanto, una partici칩n completa cuesta tiene una complejidad de orden \\(O(N)\\).\nEn el mejor escenario, los pivotes dividen la lista en mitades iguales. Primero se hacen particiones de tama침o \\(N\\), luego de \\(N/2\\), luego de \\(N/4\\), y as칤 sucesivamente, hasta llegar a sublistas de un solo elemento. Eso genera \\(\\log N\\) niveles de partici칩n, y como cada nivel cuesta \\(O(N)\\) el tiempo total resulta \\(O(N \\log N)\\).\nEn el peor caso, los pivotes dividen la lista de manera muy desbalanceada, por ejemplo cuando siempre se elige como pivote el elemento m치s peque침o o el m치s grande. En ese caso, despu칠s de ordenar un pivote, queda una sublista con \\(N-1\\) elementos, luego otra con \\(N-2\\), y as칤 hasta llegar a 1. El n칰mero total de operaciones forma la suma \\(N + (N-1) + (N-2) + \\dots + 1\\), que equivale a \\(O(N^2)\\).\nRespecto al espacio, la versi칩n in place no crea nuevas listas; todo se hace dentro de la secuencia original. Sin embargo, cada llamada recursiva debe mantenerse en la pila de ejecuci칩n mientras espera que terminen las llamadas siguientes. Como la profundidad de la recursi칩n depende de la altura del 치rbol de particiones (a lo sumo \\(\\log N\\) en promedio), el uso de memoria adicional es \\(O(\\log N)\\).",
    "crumbs": [
      "Teor칤a",
      "U4 - Estructuras de Datos y Algoritmos",
      "3 - Algoritmos de ordenamiento"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/03_ordenamiento.html#resumen",
    "href": "teoria/04_estructuras_y_algoritmos/03_ordenamiento.html#resumen",
    "title": "3 - Algoritmos de ordenamiento",
    "section": "Resumen",
    "text": "Resumen\nLos primeros algoritmos de ordenamiento, como bubble sort, selection sort e insertion sort, son sencillos de entender e implementar, pero presentan una complejidad temporal cuadr치tica, \\(O(N^2)\\). Esto significa que el n칰mero de pasos necesarios crece de manera proporcional al cuadrado de la cantidad de elementos a ordenar. En consecuencia, cuando el tama침o de la lista aumenta, el tiempo de ejecuci칩n se vuelve r치pidamente impr치ctico. Aun as칤, estos algoritmos son 칰tiles para introducir los fundamentos del an치lisis de eficiencia y para comprender las diferencias entre comparaciones, intercambios y desplazamientos.\nPara superar esas limitaciones, surgieron algoritmos m치s sofisticados basados en el paradigma de dividir y conquistar, como merge sort y quick sort. Ambos logran reducir la complejidad temporal promedio a \\(O(N \\log N)\\) al dividir el problema en partes m치s peque침as, ordenarlas por separado y luego combinarlas. Esta mejora implica que el n칰mero de operaciones crece mucho m치s lentamente con el tama침o del conjunto de datos, lo que los hace adecuados para ordenar listas grandes.\nSin embargo, la mayor eficiencia en tiempo suele implicar un costo en memoria. Merge sort, por ejemplo, necesita espacio adicional para almacenar las sublistas temporales generadas durante el proceso de fusi칩n, lo que le otorga una complejidad espacial de \\(O(N)\\). Quick sort, en cambio, puede implementarse in place, sin crear nuevas listas, pero requiere cierta cantidad de memoria para mantener las llamadas recursivas en la pila de ejecuci칩n. As칤, elegir un algoritmo no depende solo de su velocidad, sino tambi칠n de los recursos disponibles y del tipo de datos a procesar.\nEn s칤ntesis, los algoritmos m치s simples son did치cticos y apropiados para listas peque침as o casi ordenadas, mientras que los m치s complejos ofrecen un desempe침o muy superior en escenarios reales. Comprender sus ventajas y limitaciones permite tomar decisiones m치s informadas al momento de seleccionar el m칠todo de ordenamiento adecuado para cada situaci칩n.",
    "crumbs": [
      "Teor칤a",
      "U4 - Estructuras de Datos y Algoritmos",
      "3 - Algoritmos de ordenamiento"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/08_io.html",
    "href": "teoria/01_programacion_en_python/08_io.html",
    "title": "8 - Lectura y escritura de archivos",
    "section": "",
    "text": "En nuestros programas de Python utilizamos variables para almacenar datos durante la ejecuci칩n. Estos datos pueden estar escritos directamente en el c칩digo o ser ingresados por el usuario (por ejemplo, mediante la funci칩n input()). Por otro lado, cuando necesitamos mostrar una salida en pantalla, usamos la funci칩n print().\nSin embargo, el uso exclusivo de input() y print() para la entrada y salida de datos tiene limitaciones. Por ejemplo:\n\nSi trabajamos con m치s de unos pocos datos, o ni siquiera sabemos cu치les datos necesitaremos al momento de ejecutar el programa, no resulta pr치ctico declararlos en el c칩digo o ingresarlos manualmente.\nSi el resultado de nuestro programa consiste en una gran cantidad de datos que no pueden analizarse visualmente con rapidez, o si necesitamos reutilizarlos en otro programa o proceso m치s adelante, se hace necesario almacenarlos de manera persistente.\n\nEn resumen, para resolver problemas de mayor complejidad, vamos a necesitar leer y guardar archivos en la computadora.",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "8 - Lectura y escritura de archivos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/08_io.html#introducci칩n",
    "href": "teoria/01_programacion_en_python/08_io.html#introducci칩n",
    "title": "8 - Lectura y escritura de archivos",
    "section": "",
    "text": "En nuestros programas de Python utilizamos variables para almacenar datos durante la ejecuci칩n. Estos datos pueden estar escritos directamente en el c칩digo o ser ingresados por el usuario (por ejemplo, mediante la funci칩n input()). Por otro lado, cuando necesitamos mostrar una salida en pantalla, usamos la funci칩n print().\nSin embargo, el uso exclusivo de input() y print() para la entrada y salida de datos tiene limitaciones. Por ejemplo:\n\nSi trabajamos con m치s de unos pocos datos, o ni siquiera sabemos cu치les datos necesitaremos al momento de ejecutar el programa, no resulta pr치ctico declararlos en el c칩digo o ingresarlos manualmente.\nSi el resultado de nuestro programa consiste en una gran cantidad de datos que no pueden analizarse visualmente con rapidez, o si necesitamos reutilizarlos en otro programa o proceso m치s adelante, se hace necesario almacenarlos de manera persistente.\n\nEn resumen, para resolver problemas de mayor complejidad, vamos a necesitar leer y guardar archivos en la computadora.",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "8 - Lectura y escritura de archivos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/08_io.html#lectura-y-escritura",
    "href": "teoria/01_programacion_en_python/08_io.html#lectura-y-escritura",
    "title": "8 - Lectura y escritura de archivos",
    "section": "Lectura y escritura",
    "text": "Lectura y escritura\n\nArchivos de texto vs archivos binarios\nEn esta secci칩n vamos a aprender a leer y escribir archivos de texto plano.\nLos archivos de texto plano contienen 칰nicamente caracteres b치sicos de texto, sin ning칰n tipo de informaci칩n adicional. Algunos ejemplos son:\n\nArchivos de texto gen칠ricos con extensi칩n .txt\nArchivos de c칩digo Python con extensi칩n .py\n\nEstos archivos pueden abrirse sin dificultad en cualquier editor de texto como el Notepad o Positron, y Python puede leer su contenido y tratarlo como cadenas de texto normales (str).\nEn contraste, existen los archivos binarios, que contienen secuencias de bits que no se limitan a representar caracteres de texto. Estos pueden almacenar cualquier tipo de datos, como im치genes, sonidos, videos, PDFs, ejecutables, etc. Aunque en este apunte nos enfocamos en los archivos de texto plato, muchos de los principios que veremos tambi칠n se aplican a los archivos binarios.\n\n\nLos tres pasos fundamentales\nA la hora de trabajar con archivos en Python, normalmente se siguen tres pasos:\n\nAbrir el archivo con la funci칩n open(), que devuelve un objeto de tipo TextIOWrapper.\nLeer o escribir en el archivo con los m칠todos read() o write() del objeto TextIOWrapper.\nCerrar el archivo con el m칠todo close() para liberar los recursos y asegurarse de que todos los cambios se guarden correctamente.\n\n\n\nLeer archivos\nPara abrir un archivo en Python se utiliza la funci칩n open(), a la cual se le pasa como argumento la ruta del archivo. Esta ruta puede estar representada con una cadena de texto str o un objeto Path del m칩dulo pathlib (que veremos en una secci칩n m치s adelante). La funci칩n open() devuelve un objeto de tipo TextIOWrapper que representa al archivo abierto y permite interactuar con 칠l.\nSupongamos que tenemos un archivo llamado pensamientos.txt con el siguiente contenido:\nEstoy aprendiendo a leer archivos en Python.\nNo se con qu칠 me voy a encontrar.\nPero ac치 vamos.\ny usamos la funci칩n open() para abrir el archivo.\narchivo = open(\"pensamientos.txt\")\narchivo\n&lt;_io.TextIOWrapper name='pensamientos.txt' mode='r' encoding='cp1252'&gt;\nVemos que el objeto devuelto por open() no solo incluye el nombre del archivo (pensamientos.txt), sino tambi칠n mode=\"r\" y encoding=\"cp1252\".\nTanto mode como encoding son argumentos de la funci칩n open(). El primero indica el modo en el que se abre el archivo. Por defecto, este valor es \"r\", lo que significa que el archivo se abre en modo lectura de texto plano. En este modo es posible leer su contenido, pero no escribir sobre 칠l.\nEl segundo argumento, encoding, especifica la codificaci칩n que se usar치 para convertir los bytes del archivo en cadenas de texto de Python. En macOS y Linux el valor por defecto es \"utf-8\". En cambio, en Windows, la codificaci칩n predeterminada es \"cp1252\" (ASCII extendido). Como esto puede generar errores al leer archivos de texto UTF-8 que contengan caracteres no ingleses en Windows, se recomienda siempre incluir expl칤citamente el argumento encoding=\"utf-8\".\nEl objeto de la variable archivo es de tipo TextIOWrapper. A pesar de que el nombre pueda parecer complicado, no es m치s que otro tipo de objeto en Python, como son las listas o los diccionarios. Cada vez que necesitemos leer o escribir en el archivo, lo haremos a trav칠s de los m칠todos asociados a este objeto.\n\n\n\n\n\n\nPuede fallar\n\n\n\nSi le pasamos a la funci칩n open() un nombre de un archivo que no existe, ya sea porque escribimos mal la ruta o cometimos un error de tipeo, obtendremos un FileNotFoundError.\nopen(\"pensamiento.txt\")\n\nFileNotFoundError: [Errno 2] No such file or directory: 'pensamiento.txt'\n\n\n\n\nLeer todo el contenido\nUna forma de leer un archivo de texto plano en Python es cargar todo su contenido de una sola vez como una 칰nica cadena de texto. Para ello se utiliza el m칠todo .read() del objeto TextIOWrapper.\n\narchivo = open(\"pensamientos.txt\", encoding=\"utf-8\")\ncontenido = archivo.read()\ncontenido\n\n'Estoy aprendiendo a leer archivos en Python.\\nNo se con qu칠 me voy a encontrar.\\nPero ac치 vamos.'\n\n\nSe puede observar que, salvo la 칰ltima, cada l칤nea termina con un car치cter de nueva l칤nea (\\n). Si hubi칠ramos agregado un salto de l칤nea al final del archivo pensamientos.txt, la cadena resultante tambi칠n habr칤a terminado en \"\\n\".\n\n\nLeer l칤nea a l칤nea\nUna alternativa al m칠todo .read(), que carga todo el contenido como una 칰nica cadena de texto, es el m칠todo .readlines(). Este devuelve una lista de cadenas, donde cada elemento corresponde a una l칤nea del archivo.\n\narchivo = open(\"pensamientos.txt\", encoding=\"utf-8\")\narchivo.readlines()\n\n['Estoy aprendiendo a leer archivos en Python.\\n',\n 'No se con qu칠 me voy a encontrar.\\n',\n 'Pero ac치 vamos.']\n\n\nTrabajar con una lista de cadenas suele ser m치s c칩modo que manejar un 칰nico bloque de texto, ya que te permite acceder directamente a cada l칤nea por separado.\n\n\nLeer solo algunas l칤neas\nTambi칠n es posible leer un n칰mero limitado de l칤neas en lugar de cargar todo el archivo de una sola vez. Para ello se utiliza el m칠todo .readline(), en singular. Cada vez que se invoca, se obtiene la siguiente l칤nea del archivo. Cuando ya no quedan m치s l칤neas, devuelve una cadena vac칤a.\n\narchivo = open(\"pensamientos.txt\", encoding=\"utf-8\")\nwhile True:\n    linea = archivo.readline()\n    if linea == \"\":\n        break\n    print(linea, end=\"\") # `end=\"\"` para que Python no agregue salto de l칤nea\n\nEstoy aprendiendo a leer archivos en Python.\nNo se con qu칠 me voy a encontrar.\nPero ac치 vamos.\n\n\nEste m칠todo tambi칠n acepta un argumento opcional size, que permite especificar la cantidad de caracteres a leer en cada llamada.\n\n\nCerrar archivo\nCuando terminamos de trabajar con un archivo, es importante cerrarlo con el m칠todo .close(). Esto libera los recursos asociados y, en caso de escritura, asegura que todo lo que estaba en el b칰fer se guarde correctamente.\nAunque Python suele cerrar los archivos autom치ticamente al final del programa, es una buena pr치ctica hacerlo de forma expl칤cita para evitar comportamientos inesperados.\n\n\n\n\n\n\nLecturas sucesivas\n\n\n\nCuando se lee un archivo en Python, existe un puntero interno (a veces llamado posici칩n en el b칰fer) que avanza a medida que se consume el contenido. Por eso, despu칠s de una primera lectura completa, las siguientes llamadas a m칠todos como .read() o .readlines() no devuelven nada: el puntero ya est치 al final del archivo.\narchivo = open(\"pensamientos.txt\")\narchivo.read()\n'Estoy aprendiendo a leer archivos en Python.\\nNo se con qu칠 me voy a encontrar.\\nPero ac치 vamos.'\narchivo.read()\n''\narchivo.readlines()\n[]\nPara volver a leer desde el inicio, hay dos opciones:\n\nCerrar y volver a abrir el archivo.\nUsar el m칠todo .seek(0) para mover el puntero de vuelta al principio.\n\n\n\n\n\n\nEscribir archivos\nPara escribir un archivo en Python, primero debemos abrirlo con la funci칩n open(), de la misma manera que al leer. Sin embargo, no podemos usar los argumentos por defecto, ya que en ese caso el archivo se abre en modo lectura, lo que impide escribir en 칠l.\nPara poder escribir, el archivo debe abrirse en uno de los siguientes modos:\n\nModo escritura (\"w\"): sobrescribe por completo el archivo existente, de forma similar a cuando asignamos un nuevo valor a una variable reemplazando el anterior.\nModo adici칩n (\"a\"): agrega nuevo contenido al final del archivo existente, sin borrar lo que ya conten칤a.\n\nSi el archivo indicado en open() no existe, tanto el modo escritura como el modo adici칩n crear치n un archivo nuevo y vac칤o.\nDebajo, abrimos un archivo llamado conclusiones.txt en modo escritura. Como el archivo todav칤a no existe, Python lo crea autom치ticamente. Luego, llamamos a write() sobre el archivo abierto y le pasamos la cadena \"Escribir en Python no es tan grave como parece.\\n\" y el texto se escribe dentro del archivo.\n\narchivo = open(\"conclusiones.txt\", mode=\"w\", encoding=\"utf-8\") # Este paso ya crea el archivo\narchivo.write(\"Escribir en Python no es tan grave como parece.\\n\")\n\n48\n\n\nEl m칠todo .write() devuelve el n칰mero de caracteres escritos, incluyendo el salto de l칤nea \\n. Despu칠s, cerramos el archivo.\n\narchivo.close()\n\nPara agregar texto sin reemplazar el contenido existente, abrimos el archivo en modo adici칩n. Escribimos la cadena \"Es solo cuesti칩n de practica.\" y lo cerramos nuevamente.\n\narchivo = open(\"conclusiones.txt\", mode=\"a\", encoding=\"utf-8\")\narchivo.write(\"Es solo cuesti칩n de practica.\")\narchivo.close()\n\nFinalmente, para mostrar en pantalla el contenido de conclusiones.txt, abrimos el archivo en modo lectura, cargamos su contenido con .read(), lo guardamos en la variable texto, cerramos el archivo y luego imprimimos texto.\n\narchivo = open(\"conclusiones.txt\", mode=\"r\", encoding=\"utf-8\")\ntexto = archivo.read()\narchivo.close()\nprint(texto)\n\nEscribir en Python no es tan grave como parece.\nEs solo cuesti칩n de practica.\n\n\n\n\n\n\n\n\nSaltos de l칤nea\n\n\n\nEs importante tener presente que el m칠todo .write() no agrega un salto de l칤nea al final del texto de forma autom치tica, a diferencia de print(). Si queremos que el contenido se escriba en una nueva l칤nea dentro del archivo, debemos incluir manualmente el car치cter \\n.\n\n\n\n\nUso de la sentencia with\nCuando abrimos un archivo con open(), debemos cerrarlo despu칠s con .close(). El problema es que a veces podemos olvidarlo o que el programa falle antes de llegar a esa l칤nea.\nPara evitarlo, Python ofrece la sentencia with, que se encarga de cerrar el archivo autom치ticamente al terminar el bloque de c칩digo, incluso si ocurre un error en el medio.\nDebajo, utilizamos la sentencia with para crear un archivo y escribir texto en 칠l.\n\nwith open(\"ejemplo.txt\", mode=\"w\", encoding=\"utf-8\") as archivo:\n    archivo.write(\"춰Hola, mundo!\\n\")\n\nprint(archivo.closed) # Verificar que el archivo est치 cerrado\n\nTrue\n\n\nLuego, podemos utilizar un patr칩n similar, pero pasando mode=\"r\", para leer el contenido del archivo.\n\nwith open(\"ejemplo.txt\", mode=\"r\", encoding=\"utf-8\") as archivo:\n    contenido = archivo.read()\n\nprint(contenido)\nprint(archivo.closed)\n\n춰Hola, mundo!\n\nTrue\n\n\n\n\n\n\n\n\nContext managers\n\n\n\nLa sentencia with no es exclusiva para leer o escribir archivos: en realidad funciona con un objeto especial llamado context manager.\nUn context manager se usa en Python para manejar recursos que necesitan ser adquiridos y luego liberados de forma segura, como archivos, conexiones de red o bloqueos de concurrencia.\nLa clave es que with define un bloque de c칩digo dentro del cual el recurso est치 disponible. Al entrar en el bloque, el recurso se prepara (por ejemplo, se abre un archivo) y, al salir, se libera autom치ticamente, sin importar si la salida fue normal, si hubo un return o si se produjo una excepci칩n.\nEsto permite que el c칩digo sea m치s claro y seguro, ya que todo el ciclo de vida del recurso queda encapsulado dentro de ese bloque.",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "8 - Lectura y escritura de archivos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/08_io.html#archivos-y-rutas",
    "href": "teoria/01_programacion_en_python/08_io.html#archivos-y-rutas",
    "title": "8 - Lectura y escritura de archivos",
    "section": "Archivos y rutas",
    "text": "Archivos y rutas\nUn archivo tiene dos caracter칤sticas principales: su nombre y su ruta.\nLa ruta indica la ubicaci칩n exacta del archivo dentro de la computadora y puede incluir directorios, subdirectorios y el nombre del archivo con su extensi칩n (por ejemplo, .txt, .csv, .py).\nA modo de ejemplo, supongamos que tenemos un archivo con el nombre reporte.docx, que se encuentra en la ruta:\nC:\\Users\\Tomi\\Documentos\nLa parte C:\\ de la ruta es la carpeta ra칤z (conocida como root directory en ingl칠s), la cual contiene a todas las dem치s carpetas.\nEn Windows, la carpeta ra칤z se llama C:\\ y tambi칠n se le conoce como la unidad C:. En macOS y Linux, la carpeta ra칤z se representa con una simple barra inclinada: /.\nPor otro lado, Users, Tomi y Documentos son carpetas, tambi칠n llamadas directorios. Las carpetas pueden contener archivos y tambi칠n otras carpetas (llamadas subcarpetas o subdirectorios).\n\nEspecificaci칩n de rutas con pathlib.Path\n\nPor qu칠 no es suficiente con str\nPor defecto, Python busca los archivos en el directorio de trabajo actual (current working directory). Por ejemplo:\nopen(\"archivo.txt\")\nEn este caso, archivo.txt debe estar en la misma carpeta desde donde se ejecuta el programa. Si no est치 all칤, hay que indicar su ruta absoluta o relativa.\nAunque se pueden usar cadenas de texto (str) para definir rutas, esto puede generar problemas porque los sistemas operativos usan separadores distintos. Mientras que Windows usa la barra inclinada hacia atr치s \\, macOS y Linux usan la barra inclinada hacia delante /.\n\n\nLa soluci칩n\nPara evitar errores y escribir c칩digo que funcione en cualquier sistema, conviene usar Path del m칩dulo pathlib, que maneja autom치ticamente las diferencias entre las formas de especificar rutas entre los distintos sistemas operativos.\nfrom pathlib import Path\nruta = Path(\"Users/Tomi/Documentos/projecto.docx\")\nprint(ruta)\nEn Windows se mostrar치 como:\nUsers\\Tomi\\Documentos\\project.docx\nY en macOS o Linux como:\nUsers/Tomi/Documentos/projecto.docx\nSi en Windows convertimos al objeto ruta a una cadena de caracteres, nos encontraremos con el siguiente resultado:\nstr(ruta)\n\"Users\\\\Tomi\\\\Documentos\\\\projecto.docx\"\nLas barras invertidas aparecen como dobles barras invertidas porque en Python cada barra invertida debe escaparse con otra barra invertida.\n\n\n\nCombinaci칩n de rutas con el operador /\nEl operador /, que normalmente usamos para dividir n칰meros, tambi칠n sirve en Python para combinar rutas cuando trabajamos con pathlib.Path. Esto permite construir rutas de forma clara y sin preocuparse por los separadores que cambian seg칰n el sistema operativo. Por ejemplo:\nfrom pathlib import Path\n\nruta = Path(\"datos\") / \"usuarios\" / \"reporte.txt\"\nprint(ruta)\nEl resultado ser치 distinto seg칰n el sistema:\nEn Windows:\ndatos\\usuarios\\reporte.txt\nEn macOS/Linux:\ndatos/usuarios/reporte.txt\nDe esta manera, podemos ir 랋egando carpetas y archivos paso a paso, evitando concatenar cadenas manualmente y asegurando compatibilidad multiplataforma.\n\n\nRutas absolutas y relativas\nExisten dos formas principales de escribir la ruta de un archivo:\n\nRuta absoluta: indica la ubicaci칩n completa desde la carpeta ra칤z. En Windows comienza con la letra de unidad, por ejemplo C:\\, y en macOS/Linux comienza con /.\nRuta relativa: se interpreta a partir del directorio de trabajo actual del programa.\n\nAdem치s, es com칰n usar dos 라tajos especiales dentro de una ruta:\n\n.: indica el directorio actual.\n..: indica el directorio padre, del ingles parent directory, que es el directorio que contiene al directorio actual.\n\nPor ejemplo, si el directorio de trabajo es C:\\trabajo y queremos acceder al archivo C:\\trabajo\\datos.txt mediante una ruta relativa, podemos usar simplemente:\ndatos.txt\no\n.\\datos.txt\nPor otro lado, si queremos acceder al archivo C:\\estudio\\reporte.txt, la ruta relativa ser칤a:\n..\\estudio\\reporte.txt\nEsto facilita moverse entre carpetas sin necesidad de escribir rutas absolutas cada vez.\n\n\nAcceso a directorios de inter칠s\n\nDirectorio de trabajo actual\nEl directorio de trabajo actual es la carpeta desde la cual Python busca los archivos cuando usamos rutas relativas. En Python se puede obtener como una cadena de texto usando el m칠todo .cwd() (del ingl칠s, current working directory) de Path:\nfrom pathlib import Path\nprint(Path.cwd())\nSi necesitamos cambiar el directorio de trabajo actual, se puede usar chdir del m칩dulo os:\nimport os\nos.chdir(\"nueva_ruta\")\n\n\n\n\n\n\nPrecauciones\n\n\n\nHay que tener en cuenta que al modificar el directorio de trabajo cambian todas las rutas relativas en el programa. Por eso, en proyectos grandes suele ser m치s seguro usar rutas absolutas o construirlas a partir de un directorio base bien definido.\n\n\n\n\nDirectorio personal (home)\nCada usuario tiene un directorio personal que depende del sistema operativo: en Windows suele estar en C:\\Users\\&lt;usuario&gt;, en macOS en /Users/&lt;usuario&gt; y en Linux en /home/&lt;usuario&gt;.\nEn Python se puede acceder a este directorio con el m칠todo Path.home():\nfrom pathlib import Path\nprint(Path.home())\nNormalmente, los programas tienen permisos de lectura y escritura dentro de este directorio, por lo que es un lugar seguro y conveniente para guardar archivos y configuraciones creadas por tus scripts.\n\n\n\nUtilidades\n\nObtenci칩n ruta absoluta y normalizada\nEl m칠todo .resolve() de Path convierte una ruta relativa en absoluta y, cuando es posible, normaliza la ruta colapsando los atajos . y ... En el siguiente ejemplo, el directorio de trabajo actual es C:\\Users\\Tomi\\Desktop\\proyecto:\nfrom pathlib import Path\n\nruta = Path(\"../datos.txt\")\nprint(ruta.resolve()) # ruta absoluta y normalizada\nC:\\Users\\Tomi\\Desktop\\datos.txt\n\n\nCreaci칩n de directorios\nEl m칠todo .mkdir() de los objetos Path permite crear un directorio a partir de una ruta.\nfrom pathlib import Path\n\nPath(\"nueva_carpeta\").mkdir(exist_ok=True)\nCon exist_ok=True evitamos errores si la carpeta ya existe.\nPara crear todos los directorios en una ruta de m칰ltiples directorios en una sola llamada, se puede a침adir parents=True:\nPath(\"datos/limpios/2025\").mkdir(parents=True, exist_ok=True)\n\n\nVerificaci칩n de validez y tipo de rutas\nLos objetos Path permiten comprobar si una ruta existe y qu칠 tipo de recurso representa:\nfrom pathlib import Path\n\nruta = Path(\"C:/Users/Tomi/Documentos/projecto.docx\")\n\nprint(ruta.exists())   # True si existe\nprint(ruta.is_file())  # True si existe y es archivo\nprint(ruta.is_dir())   # True si existe y es directorio",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "8 - Lectura y escritura de archivos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/08_io.html#ap칠ndice",
    "href": "teoria/01_programacion_en_python/08_io.html#ap칠ndice",
    "title": "8 - Lectura y escritura de archivos",
    "section": "Ap칠ndice",
    "text": "Ap칠ndice\n\nEl arugmento mode de open()\n\nCaracteres v치lidos\n\n\n\n\n\n\n\nCaracter\nSignificado\n\n\n\n\nr\nabrir para lectura (predeterminado)\n\n\nw\nabrir para escritura, truncando primero el archivo\n\n\nx\ncrear un archivo nuevo y abrirlo para escritura\n\n\na\nabrir para escritura, agregando al final del archivo si existe\n\n\nb\nmodo binario\n\n\nt\nmodo texto (predeterminado)\n\n\n+\nabrir un archivo en disco para actualizaci칩n (lectura y escritura)\n\n\n\n\n\nEjemplos\n\n\n\n\n\n\n\n\nModo\nEjemplo\nDescripci칩n\n\n\n\n\nr\nopen(\"datos.txt\", \"r\")\nAbre datos.txt para leer en modo texto.\n\n\nrb\nopen(\"imagen.png\", \"rb\")\nAbre imagen.png para leer en modo binario (칰til para im치genes, PDFs, etc).\n\n\nw\nopen(\"salida.txt\", \"w\")\nAbre salida.txt para escritura en texto, truncando el archivo si existe.\n\n\nwb\nopen(\"audio.raw\", \"wb\")\nAbre audio.raw para escritura en binario, truncando si existe.\n\n\na\nopen(\"log.txt\", \"a\")\nAbre log.txt para a침adir texto al final del archivo.\n\n\nab\nopen(\"video.mp4\", \"ab\")\nAbre video.mp4 en binario para a침adir datos al final.\n\n\nx\nopen(\"nuevo.txt\", \"x\")\nCrea nuevo.txt y lo abre para escritura en texto. Falla si ya existe.\n\n\nxb\nopen(\"nuevo.dat\", \"xb\")\nCrea nuevo.dat y lo abre para escritura en binario. Falla si ya existe.\n\n\nr+\nopen(\"datos.txt\", \"r+\")\nAbre datos.txt para leer y escribir en texto.\n\n\nrb+\nopen(\"imagen.png\", \"rb+\")\nAbre imagen.png para leer y escribir en binario.\n\n\nw+\nopen(\"datos.txt\", \"w+\")\nAbre datos.txt para leer y escribir en texto, truncando si existe.\n\n\nwb+\nopen(\"datos.bin\", \"wb+\")\nAbre datos.bin para leer y escribir en binario, truncando si existe.",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "8 - Lectura y escritura de archivos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html",
    "title": "4 - Colecciones de datos",
    "section": "",
    "text": "Adem치s de los tipos de datos elementales que se presentaron en cap칤tulos anteriores, Python proporciona estructuras de datos m치s complejas que permiten almacenar colecciones de objetos. Estas estructuras facilitan la organizaci칩n de m칰ltiples valores bajo un mismo nombre, posibilitando, entre otras tareas, su manipulaci칩n de manera conjunta.\nEn este cap칤tulo exploraremos tres colecciones b치sicas de Python:\n\nListas (list)\nTuplas (tuple)\nDiccionarios (dict)\n\nEstas estructuras tienen en com칰n que permiten agrupar varios objetos, aunque presentan diferencias importantes en cuanto a la sintaxis utilizada para definirlas, su mutabilidad (capacidad de modificarse tras su creaci칩n) y las operaciones disponibles para manipular sus elementos. En definitiva, cada estructura est치 especialmente dise침ada para representar relaciones particulares entre los datos, adapt치ndose as칤 a diversas situaciones y necesidades de programaci칩n.\nSupongamos que contamos con el nombre y la edad de 4 personas y queremos utilizar estos datos en nuestro programa. Si solamente tenemos acceso a los tipos de datos elementales de Python, una alternativa para almacenar esta informaci칩n consiste en crear 4 variables para las edades y 4 variables para los nombres:\n\nnombre_1 = \"Juan\"\nnombre_2 = \"Carla\"\nnombre_3 = \"Evelina\"\nnombre_4 = \"Leandro\"\n\nedad_1 = 29\nedad_2 = 34\nedad_3 = 33\nedad_4 = 38\n\nEn este caso, el c칩digo es legible e incluso permite intuir la relaci칩n entre los nombres y las edades.\nSin embargo, vale preguntarse qu칠 ocurrir칤a si quisi칠ramos almacenar la informaci칩n de muchas m치s personas. Python nos permitir칤a crear tantas variables como necesitemos, pero trabajar de esa manera no ser칤a pr치ctico ni sostenible.\nPor eso, el lenguaje ofrece estructuras de datos que facilitan el manejo de grandes cantidades de valores del mismo tipo, de forma m치s organizada y eficiente.",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#introducci칩n",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#introducci칩n",
    "title": "4 - Colecciones de datos",
    "section": "",
    "text": "Adem치s de los tipos de datos elementales que se presentaron en cap칤tulos anteriores, Python proporciona estructuras de datos m치s complejas que permiten almacenar colecciones de objetos. Estas estructuras facilitan la organizaci칩n de m칰ltiples valores bajo un mismo nombre, posibilitando, entre otras tareas, su manipulaci칩n de manera conjunta.\nEn este cap칤tulo exploraremos tres colecciones b치sicas de Python:\n\nListas (list)\nTuplas (tuple)\nDiccionarios (dict)\n\nEstas estructuras tienen en com칰n que permiten agrupar varios objetos, aunque presentan diferencias importantes en cuanto a la sintaxis utilizada para definirlas, su mutabilidad (capacidad de modificarse tras su creaci칩n) y las operaciones disponibles para manipular sus elementos. En definitiva, cada estructura est치 especialmente dise침ada para representar relaciones particulares entre los datos, adapt치ndose as칤 a diversas situaciones y necesidades de programaci칩n.\nSupongamos que contamos con el nombre y la edad de 4 personas y queremos utilizar estos datos en nuestro programa. Si solamente tenemos acceso a los tipos de datos elementales de Python, una alternativa para almacenar esta informaci칩n consiste en crear 4 variables para las edades y 4 variables para los nombres:\n\nnombre_1 = \"Juan\"\nnombre_2 = \"Carla\"\nnombre_3 = \"Evelina\"\nnombre_4 = \"Leandro\"\n\nedad_1 = 29\nedad_2 = 34\nedad_3 = 33\nedad_4 = 38\n\nEn este caso, el c칩digo es legible e incluso permite intuir la relaci칩n entre los nombres y las edades.\nSin embargo, vale preguntarse qu칠 ocurrir칤a si quisi칠ramos almacenar la informaci칩n de muchas m치s personas. Python nos permitir칤a crear tantas variables como necesitemos, pero trabajar de esa manera no ser칤a pr치ctico ni sostenible.\nPor eso, el lenguaje ofrece estructuras de datos que facilitan el manejo de grandes cantidades de valores del mismo tipo, de forma m치s organizada y eficiente.",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#listas",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#listas",
    "title": "4 - Colecciones de datos",
    "section": "Listas",
    "text": "Listas\n\nDefinici칩n\nEl siguiente bloque de c칩digo genera una lista con los n칰meros 1, 2, 3, 4 y 5.\n\n[1, 2, 3, 4, 5]\n\n[1, 2, 3, 4, 5]\n\n\nUna lista de Python es una secuencia ordenada de objetos mutable. De manera menos t칠cnica, podemos decir que una lista es un objeto que contiene otros objetos en un orden determinado y cuyo contenido puede modificarse.\nLas listas son una de las estructuras m치s utilizadas en Python. De hecho, programar en este lenguaje implica trabajar constantemente con listas: crearlas, modificarlas, recorrerlas y transformarlas.\nAs칤 que si queremos ser buenos Pythonistas, 춰a aprender de listas!\n\n\nCreaci칩n de listas\nLas listas en Python se crean escribiendo los elementos entre corchetes ([]), separ치ndolos con comas.\nCreemos una lista que contenga los nombres de nuestras cafeterias de especialidad preferidas: Orlan, Infinita, Arto, Crist칩bal, Ruffo y Heroica.\n\ncafeterias = [\"Orlan\", \"Infinita\", \"Arto\", \"Crist칩bal\", \"Ruffo\", \"Heroica\"]\nprint(cafeterias)\n\n['Orlan', 'Infinita', 'Arto', 'Crist칩bal', 'Ruffo', 'Heroica']\n\n\nCuando imprimimos una lista, Python muestra una representaci칩n muy parecida a la que usamos al definirla: con corchetes para encerrar los elementos y comas para separarlos.\nSi consultamos el tipo de una lista, no hay sorpresas: es del tipo list.\n\ntype(cafeterias)\n\nlist\n\n\n\n\nObjetos permitidos en una lista\nEn Python, una lista puede contener objetos de cualquier tipo. Incluso es posible mezclar distintos tipos en una misma lista.\nCon los tipos de datos que vimos hasta ahora, podr칤amos tener listas con n칰meros, cadenas de texto, valores booleanos e incluso el valor nulo.\nPor ejemplo, la siguiente lista contiene elementos de cuatro tipos distintos:\n\npopurri = [1, \"dos\", True, None, \"dos\"]\npopurri\n\n[1, 'dos', True, None, 'dos']\n\n\nSi bien las listas pueden mezclar objetos de distinto tipo, y algunas veces hacerlo tiene sentido, en general vamos a trabajar con listas donde todos sus objetos son del mismo tipo.\n\n\nQu칠 significa que una lista sea ordenada\nConsideremos las listas [1, 2, 3] y [2, 1, 3]. Vale preguntarse si ambas listas son iguales o no. Veamos que dice Python:\n\n[1, 2, 3] == [2, 1, 3]\n\nFalse\n\n\nDado que una lista es una secuencia en la que el orden de los elementos es relevante, dos listas son iguales solo si contienen los mismos elementos y en el mismo orden. A continuaci칩n se muestra un ejemplo en el que ambas condiciones se cumplen.\n\n[1, 2, 3] == [1, 2, 3]\n\nTrue\n\n\nTambi칠n vale la pena preguntarse si dos listas iguales son, en memoria, el mismo objeto. Debajo definimos dos listas x e y con los mismos elementos, en el mismo orden. Como es de esperarse, ambas listas son iguales en valor.\n\nx = [\"a\", \"b\", \"c\"]\ny = [\"a\", \"b\", \"c\"]\n\nprint(x == y)\nprint(x is y)\n\nTrue\nFalse\n\n\nSin embargo, estas listas no son iguales en memoria, es decir, no son el mismo objeto.\n\nprint(\"id(x):\", id(x))\nprint(\"id(y):\", id(y))\n\nid(x): 139718308051328\nid(y): 139718306480896\n\n\n\n\n\n\n\n\nConclusi칩n 游닇\n\n\n\nDos listas son iguales (en valor) si en cada posici칩n contienen elementos que tambi칠n son iguales en valor. Sin embargo, que dos listas sean iguales no implica que sean el mismo objeto en memoria.\n\n\n\n\n\n\n\n\nPara pensar 游\n\n\n\n쮺u치l es el resultado de la siguiente comparaci칩n?\n[1, 2, 3] == [1.0, 2, 3.0]\n\n\n\n\nAcceder a elementos\nDado que una lista es una secuencia ordenada, cada objeto tiene una posici칩n determinada. Podemos acceder a cualquiera de los elementos de la lista indicando la posici칩n del objeto que deseamos. Esta posici칩n se conoce como 칤ndice (o index, en ingl칠s).\nPara acceder a un elemento de una lista, escribimos el nombre de la lista seguido de la posici칩n del objeto que queremos seleccionar, encerrada entre corchetes [].\nVeamos un ejemplo utilizando la lista cafeterias que creamos anteriormente.\n\ncafeterias = [\"Orlan\", \"Infinita\", \"Arto\", \"Crist칩bal\", \"Ruffo\", \"Heroica\"]\ncafeterias\n\n['Orlan', 'Infinita', 'Arto', 'Crist칩bal', 'Ruffo', 'Heroica']\n\n\nIntentemos seleccionar el primer objeto de la lista:\n\ncafeterias[1]\n\n'Infinita'\n\n\nCuando accedemos a un elemento individual de una lista, el resultado no es, en principio, otra lista, sino el objeto que se encuentra en esa posici칩n. Ese objeto puede ser de cualquier tipo: un n칰mero, una cadena de texto, otra lista, etc.\nPor lo tanto, si el elemento obtenido es una cadena de caracteres, podemos aplicar directamente los m칠todos que corresponden a ese tipo de dato. Por ejemplo, podemos encadenar la selecci칩n del elemento en la posici칩n 1 con una llamada al m칠todo .upper(), sabiendo que es v치lido porque ese elemento es de tipo str.\n\ncafeterias[1].upper()\n\n'INFINITA'\n\n\nComo es de esperarse, tambi칠n podemos incluir una operaci칩n de indexaci칩n dentro de una f-string.\n\nf\"춰Qu칠 rico que es el caf칠 de {cafeterias[1]}!\"\n\n'춰Qu칠 rico que es el caf칠 de Infinita!'\n\n\n\n\n\n\n\n\nIndexaci칩n desde cero 0勇뮾n\n\n\nObservamos que cafeterias[1] devuelve \"Infinita\", que es el elemento de la segunda posici칩n, y no \"Orlan\", que aparece primero. Este resultado no es un error, sino una consecuencia de que Python usa indexaci칩n desde cero (zero-based indexing, en ingl칠s). Esto significa que, si una lista contiene 6 elementos, sus posiciones van desde el 0 al 5. En general:\n\nEl primer elemento est치 en la posici칩n 0.\nEl 칰ltimo elemento est치 en la posici칩n n - 1.\n\n\n\n\n\n\n\n\n\nMisma sintaxis, significados distintos 游꿠\n\n\n\nEn Python, los corchetes no siempre significan lo mismo. Sus dos funciones principales son la creaci칩n de listas y la indexaci칩n de secuencias. Un ejemplo curioso que combina ambos usos es el siguiente:\n[0][0]\n0\n\n\nEn el siguiente diagrama se muestra que la variable cafeterias referencia a un objeto de tipo list, que a su vez contiene referencias a distintos objetos de tipo str. Cada uno de estos elementos est치 asociado a un 칤ndice, comenzando desde el 0.\n\n\n\nRepresentaci칩n gr치fica de la lista cafeterias en Python.\n\n\n\n칈ndices negativos\nPython tambi칠n permite utilizar valores negativos como 칤ndices para seleccionar elementos.\n\nEl 칤ndice -1 indica el 칰ltimo elemento.\nEl 칤ndice -2 indica el pen칰ltimo elemento.\nY as칤 sucesivamente.\n\n\ncafeterias[-1]\n\n'Heroica'\n\n\n\ncafeterias[-2]\n\n'Ruffo'\n\n\n\n\n\nRepresentaci칩n gr치fica de cafeterias utilizando 칤ndices negativos para cada elemento.\n\n\n\n\n\nAcceder a sub-listas\nHasta ahora vimos que, al usar corchetes con un n칰mero entero, podemos acceder a un 칰nico elemento de una lista. Si en cambio queremos obtener varios elementos a la vez, necesitamos usar una herramienta llamada slice (o rebanada) que permite seleccionar un subconjunto de elementos de una secuencia.\nLa sintaxis para usar slices es la siguiente:\nlista[inicio:fin]\nEsto crea una nueva lista con los elementos que van desde la posici칩n inicio hasta la posici칩n fin, sin incluir esta 칰ltima.\nPor ejemplo:\n\ncafeterias[1:4]\n\n['Infinita', 'Arto', 'Crist칩bal']\n\n\n\n\n\nSelecci칩n de sublista de cafeterias usando el slice 1:4.\n\n\nComo los slices incluyen el 칤ndice de inicio pero excluyen el de fin, el siguiente c칩digo funciona correctamente:\n\ncafeterias[4:6]\n\n['Ruffo', 'Heroica']\n\n\n\n\n\nSelecci칩n de sublista de cafeterias usando el slice 4:6.\n\n\nEn Python, la sintaxis de los slices permite omitir de forma impl칤cita los valores de inicio o fin cuando se desea tomar una porci칩n desde el principio o hasta el final de la lista. Por ejemplo:\n\n:n es equivalente a 0:n y selecciona los primeros n elementos.\nn: es equivalente a n:len(lista) y selecciona desde la posici칩n n hasta el final.\n\nEstas formas abreviadas hacen el c칩digo m치s conciso sin perder claridad. Por ejemplo:\n\ncafeterias[:3]\n\n['Orlan', 'Infinita', 'Arto']\n\n\n\n\n\nSelecci칩n de sublista de cafeterias hasta el 칤ndice 3 usando el slice de inicio impl칤cito :3.\n\n\n\ncafeterias[3:]\n\n['Crist칩bal', 'Ruffo', 'Heroica']\n\n\n\n\n\nSelecci칩n de sublista de cafeterias desde el 칤ndice 3 usando el slice con fin impl칤cito 3:.\n\n\n\n\nModificar, agregar y eliminar elementos\nEn general, nuestros programas utilizan las listas como objetos din치micos, es decir, como estructuras cuyo contenido puede cambiar a lo largo del tiempo mediante la modificaci칩n, agregaci칩n o eliminaci칩n de sus elementos.\nPor ejemplo, supongamos que desarrollamos una p치gina web que permite el registro de usuarios. En este caso, es natural usar una lista para almacenar los nombres de quienes se registran. A medida que pase el tiempo, se espera que se registren nuevos usuarios, otros se den de baja, o algunos incluso decidan cambiar su nombre. Esto implica realizar operaciones sobre la lista, como agregar, eliminar o modificar sus elementos.\n\nModificar elementos\nPara modificar un elemento se utiliza una sintaxis muy similar a la que utilizamos para acceder a un elemento.\nEscribimos el nombre de la lista seguido del 칤ndice del objeto que queremos modificar y el valor que queremos asignar.\nSupongamos que tenemos una lista con diferentes marcas de caf칠: Puerto Blest, Mart칤nez y Fuego Tostadores.\n\nmarcas = [\"Puerto Blest\", \"Mart칤nez\", \"Fuego Tostadores\"]\nmarcas\n\n['Puerto Blest', 'Mart칤nez', 'Fuego Tostadores']\n\n\n쮺칩mo hacemos para cambiar el valor del primer elemento?\n\nmarcas[0] = \"Cabrales\"\nmarcas\n\n['Cabrales', 'Mart칤nez', 'Fuego Tostadores']\n\n\n\n\n\n\n\n\nUna dosis de precisi칩n 游꿢\n\n\n\nEn esta secci칩n, cuando hablamos de modificar un elemento, nos referimos a reemplazar el objeto que se encuentra en una posici칩n determinada de la lista. Observemos el siguiente ejemplo:\ningredientes = [\"azucar\", \"flores\", \"colores\"]\nid_original = id(ingredientes[0])\n\n# \"Modifico\" el primer elemento\ningredientes[0] = \"pimienta\"\nid_nuevo = id(ingredientes[0])\n\nprint(\"ID original:\", id_original)\nprint(\"ID nuevo:\", id_nuevo)\nID original: 139872198862160\nID nuevo: 139872198582832\nEste ejemplo muestra que la operaci칩n no modific칩 el objeto que se encontraba originalmente en el 칤ndice 0, sino que lo reemplaz칩 por uno nuevo.\n\n\n\n\n\n\n\n\n\n\n\n\n\n춰Atenci칩n! 游뱁\n\n\n\nEl ejemplo del bloque anterior demuestra que la sintaxis lista[indice] = objeto reemplaza el objeto que se encuentra en una determinada posici칩n, en vez de modificarlo. Sin embargo, vale la pena destacar que s칤 es posible modificar un elemento de una lista. Para ello, es necesario que el elemento sea un objeto mutable.\n\n\n\n\nAgregar elementos\nSupongamos que queremos construir una lista con los nombres de las ciudades que forman parte del Gran Rosario. Para ello, vamos a utilizar el siguiente mapa como referencia. A medida que identifiquemos las distintas localidades, las vamos a ir incorporando a una lista de Python.\nAgregar elementos a una lista es una tarea com칰n en programaci칩n, y Python nos ofrece varias formas de hacerlo. En esta secci칩n vamos a explorar algunos de estos m칠todos, entendiendo en qu칠 se diferencian y cu치ndo conviene utilizar cada uno.\n\n\n\nMapa ilustrado del Gran Rosario.\n\n\nPrimero vamos a armar una lista que contenga los vecinos de Rosario, considerando solo aquellas localidades que limitan con la ciudad.\nSupongamos que empezamos con una lista que contiene 칰nicamente a la localidad de Funes. A partir de ah칤, iremos agregando otras localidades vecinas utilizando distintos m칠todos que ofrece Python.\n\nvecinos_de_rosario = [\"Funes\"]\nvecinos_de_rosario\n\n['Funes']\n\n\n\nAgregar elementos al final de la lista\nLa manera m치s sencilla de agregar un nuevo elemento a una lista es utilizando el m칠todo .append().\nEste m칠todo recibe un 칰nico elemento como argumento y lo agrega al final de la lista.\n\nvecinos_de_rosario.append(\"Soldini\")\n\nLa llamada a este m칠todo parece no devolver ning칰n resultado. Observemos la lista nuevamente:\n\nvecinos_de_rosario\n\n['Funes', 'Soldini']\n\n\nEl m칠todo .append() agreg칩 \"Soldini\" al final de la lista sin retornar ning칰n valor. En lugar de crear una nueva lista, modific칩 directamente la que referencia nuestra variable vecinos_de_rosario. En otras palabras, el m칠todo .append() no crea una nueva lista, sino que modifica directamente la lista existente.\nVeamos el siguiente ejemplo:\n\nvecinos_de_rosario = []\nprint(\"ID:\", id(vecinos_de_rosario))\nprint(vecinos_de_rosario, \"\\n\")\n\nvecinos_de_rosario.append(\"Funes\")\nprint(\"ID:\", id(vecinos_de_rosario))\nprint(vecinos_de_rosario, \"\\n\")\n\nvecinos_de_rosario.append(\"Soldini\")\nprint(\"ID:\", id(vecinos_de_rosario))\nprint(vecinos_de_rosario)\n\nID: 139718307382528\n[] \n\nID: 139718307382528\n['Funes'] \n\nID: 139718307382528\n['Funes', 'Soldini']\n\n\nComo se puede observar, Python oper칩 siempre sobre la misma lista. Esto se debe a que el m칠todo .append() modifica la lista existente, en lugar de crear una nueva en cada paso.\n\n\nInsertar elementos en cualquier posici칩n de una lista\nPara insertar elementos en una lista tambi칠n podemos utilizar el m칠todo .insert().\n쮺u치l es la diferencia entre .append() e .insert()?\n\n.append() agrega el nuevo elemento al final de la lista.\n.insert() permite insertar un elemento en cualquier posici칩n, indicando el 칤ndice donde queremos ubicarlo.\n\nPor ejemplo, si queremos insertar \"Villa Gobernador G치lvez\" al principio de la lista, podemos hacerlo con .insert(0, \"Villa Gobernador G치lvez\").\n\nvecinos_de_rosario.insert(0, \"Villa Gobernador G치lvez\")\nvecinos_de_rosario\n\n['Villa Gobernador G치lvez', 'Funes', 'Soldini']\n\n\nEl m칠todo .insert() agreg칩 a \"Villa Gobernador G치lvez\" en el inicio de la lista y corri칩 o traslad칩 al resto de los elementos hacia la derecha.\nY si ahora queremos agregar a \"P칠rez\" en la tercera posici칩n de la lista, simplemente:\n\nvecinos_de_rosario.insert(2, \"P칠rez\")\nvecinos_de_rosario\n\n['Villa Gobernador G치lvez', 'Funes', 'P칠rez', 'Soldini']\n\n\nAl igual que .append(), .insert() tambi칠n modifica la lista existente en vez de devolver una lista nueva.\n\n\n\n\n\n\n쯈u칠 significa in-place? 游뱂\n\n\n\nQue una operaci칩n sea in-place significa que la operaci칩n modifica directamente el objeto original, sin crear uno nuevo. Por ejemplo, objetos.append(e) agrega el elemento e a la lista existente objetos en lugar de crear y devolver una lista nueva.\n\n\n\n\n\nCombinar listas\nEn la secci칩n anterior vimos c칩mo insertar elementos individuales en una lista. Ahora vamos a explorar otra operaci칩n muy com칰n: combinar listas.\nSupongamos que ya tenemos una lista llamada vecinos_de_rosario, y otra llamada vecinos_al_norte. Queremos unir ambas listas para tener toda la informaci칩n en una sola. Para lograrlo, una opci칩n es usar el m칠todo .extend(), que nos permite agregar todos los elementos de una lista al final de otra, modificando directamente la lista original.\n\nprint(vecinos_de_rosario)\n\n['Villa Gobernador G치lvez', 'Funes', 'P칠rez', 'Soldini']\n\n\n\nvecinos_al_norte = [\"Granadero Baigorria\", \"Ibarlucea\"]\n\nvecinos_de_rosario.extend(vecinos_al_norte)\nvecinos_de_rosario\n\n['Villa Gobernador G치lvez',\n 'Funes',\n 'P칠rez',\n 'Soldini',\n 'Granadero Baigorria',\n 'Ibarlucea']\n\n\nDe la misma manera que .append() agrega un elemento al final de una lista, el m칠todo .extend() permite agregar todos los elementos de otra lista al final.\nOtra forma de combinar listas es utilizando el operador de suma +, que realiza una concatenaci칩n de listas. A diferencia de .extend(), este operador no modifica las listas originales, sino que devuelve una nueva lista con los elementos de las dos listas originales concatenados en una nueva.\nPara ver c칩mo funciona, primero vamos a construir una lista llamada otras_localidades, que contiene localidades del Gran Rosario que no est치n pegadas a Rosario. Luego, vamos a concatenar esa lista a la que ya tenemos.\n\notras_localidades = [\n    \"Puerto San Mart칤n\",\n    \"San Lorenzo\",\n    \"Fray Luis Beltr치n\",\n    \"Capit치n Bermudez\",\n    \"Ricardone\",\n    \"Rold치n\",\n    \"Alvear\",\n    \"Pueblo Esther\",\n    \"General Lagos\",\n    \"Arroyo Seco\"\n]\n\nPrimero, observemos los IDs de las listas que vamos a combinar:\n\nprint(id(vecinos_de_rosario))\nprint(id(otras_localidades))\n\n139718307382528\n139718306450176\n\n\nY concatenemos ambas listas utilizando el operador de suma:\n\nvecinos_de_rosario + otras_localidades\n\n['Villa Gobernador G치lvez',\n 'Funes',\n 'P칠rez',\n 'Soldini',\n 'Granadero Baigorria',\n 'Ibarlucea',\n 'Puerto San Mart칤n',\n 'San Lorenzo',\n 'Fray Luis Beltr치n',\n 'Capit치n Bermudez',\n 'Ricardone',\n 'Rold치n',\n 'Alvear',\n 'Pueblo Esther',\n 'General Lagos',\n 'Arroyo Seco']\n\n\nPodemos notar que la operaci칩n s칤 retorna una lista como resultado, la cual podr칤amos guardar en una nueva variable.\n\ngran_rosario = vecinos_de_rosario + otras_localidades\ngran_rosario\n\n['Villa Gobernador G치lvez',\n 'Funes',\n 'P칠rez',\n 'Soldini',\n 'Granadero Baigorria',\n 'Ibarlucea',\n 'Puerto San Mart칤n',\n 'San Lorenzo',\n 'Fray Luis Beltr치n',\n 'Capit치n Bermudez',\n 'Ricardone',\n 'Rold치n',\n 'Alvear',\n 'Pueblo Esther',\n 'General Lagos',\n 'Arroyo Seco']\n\n\nY finalmente, se puede ver que las listas originales no se han modificado y que gran_rosario referencia una lista nueva.\n\nprint(id(vecinos_de_rosario))\nprint(vecinos_de_rosario, \"\\n\")\n\nprint(id(otras_localidades))\nprint(otras_localidades, \"\\n\")\n\nprint(id(gran_rosario))\nprint(gran_rosario, \"\\n\")\n\n139718307382528\n['Villa Gobernador G치lvez', 'Funes', 'P칠rez', 'Soldini', 'Granadero Baigorria', 'Ibarlucea'] \n\n139718306450176\n['Puerto San Mart칤n', 'San Lorenzo', 'Fray Luis Beltr치n', 'Capit치n Bermudez', 'Ricardone', 'Rold치n', 'Alvear', 'Pueblo Esther', 'General Lagos', 'Arroyo Seco'] \n\n139718306451456\n['Villa Gobernador G치lvez', 'Funes', 'P칠rez', 'Soldini', 'Granadero Baigorria', 'Ibarlucea', 'Puerto San Mart칤n', 'San Lorenzo', 'Fray Luis Beltr치n', 'Capit치n Bermudez', 'Ricardone', 'Rold치n', 'Alvear', 'Pueblo Esther', 'General Lagos', 'Arroyo Seco'] \n\n\n\n\n\nEliminar elementos\nAs칤 como es com칰n agregar elementos a una lista o combinar listas para crear nuevas, tambi칠n lo es eliminar elementos.\nPor ejemplo, si en una p치gina web guardamos los nombres de los usuarios en una lista, y uno de ellos se da de baja, necesitaremos eliminar su nombre de esa lista.\nPara ilustrarlo, vamos a crear una lista de usuarios ficticios:\n\nusuarios = [\"cyberwolf\", \"neo_404\", \"pixelbyte\", \"alphaX\", \"quantum.dev\"]\nusuarios\n\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX', 'quantum.dev']\n\n\n\nEliminar elementos utilizando del\nLa sentencia del, que ya usamos para eliminar variables, tambi칠n puede usarse para eliminar elementos de una lista.\nPara hacerlo, necesitamos conocer la posici칩n del elemento que queremos eliminar.\nPor ejemplo, si queremos eliminar a \"neo_404\", que est치 en la segunda posici칩n, podemos hacerlo con:\n\nprint(usuarios)\n\ndel usuarios[1]\n\nprint(usuarios)\n\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX', 'quantum.dev']\n['cyberwolf', 'pixelbyte', 'alphaX', 'quantum.dev']\n\n\n\n\nEliminar elementos con .pop()\nSi bien la sentencia del permite eliminar elementos de una lista, no nos da acceso al elemento eliminado.\nSin embargo, en muchos casos queremos extraer un elemento de una lista para utilizarlo en otra parte de nuestro programa. Por ejemplo, si tenemos una lista de usuarios, tal vez nos interesa guardar el nombre del usuario que se elimina en otra lista que registre los usuarios dados de baja.\nPara eso podemos usar el m칠todo .pop(), que elimina un elemento de la lista y, al mismo tiempo, lo devuelve.\n\nusuarios = [\"cyberwolf\", \"neo_404\", \"pixelbyte\", \"alphaX\", \"quantum.dev\"]\nusuario_eliminado = usuarios.pop(2)\n\nprint(usuarios) # \"pixelbyte\" es 'extraido'\nprint(usuario_eliminado)\n\n['cyberwolf', 'neo_404', 'alphaX', 'quantum.dev']\npixelbyte\n\n\nEn resumen, usuarios.pop(2) busca el valor en la tercera posici칩n, lo extrae de la lista y lo devuelve.\nTambi칠n es posible usar .pop() sin indicar una posici칩n. En ese caso, extrae el 칰ltimo elemento de la lista por defecto.\n\nusuarios = [\"cyberwolf\", \"neo_404\", \"pixelbyte\", \"alphaX\", \"quantum.dev\"]\nprint(usuarios, \"\\n\")\n\nusuario_eliminado = usuarios.pop()\nprint(usuario_eliminado)\nprint(usuarios, \"\\n\")\n\nusuario_eliminado = usuarios.pop()\nprint(usuario_eliminado)\nprint(usuarios)\n\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX', 'quantum.dev'] \n\nquantum.dev\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX'] \n\nalphaX\n['cyberwolf', 'neo_404', 'pixelbyte']\n\n\nY podr칤amos continuar as칤 hasta vaciar la lista.\n\n\nEliminar elementos con .remove()\nEl m칠todo .remove() es 칰til para cuando queremos eliminar elementos de una lista a partir de su valor, en lugar de su posici칩n. Por ejemplo:\n\nusuarios = [\"cyberwolf\", \"neo_404\", \"pixelbyte\", \"alphaX\", \"quantum.dev\"]\nprint(usuarios)\n\nusuarios.remove(\"cyberwolf\")\nprint(usuarios)\n\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX', 'quantum.dev']\n['neo_404', 'pixelbyte', 'alphaX', 'quantum.dev']\n\n\nAl igual que del, remove no devuelve el valor que se remueve.\n\n\n\n\n\n\nResumen 游늷\n\n\n\n\n\n\n\n\n\n\n\n\nHerramienta\nQu칠 hace\nC칩mo se usa\nDevuelve\n\n\n\n\ndel\nElimina un elemento por 칤ndice o un segmento por slicing\ndel lista[i]  del lista[i:j]\nNada\n\n\n.pop()\nElimina un elemento por 칤ndice (por defecto el 칰ltimo)\nlista.pop(i)  lista.pop()\nEl elemento eliminado\n\n\n.remove()\nElimina la primera ocurrencia de un valor dado\nlista.remove(valor)\nNada\n\n\n\n\n\n\n\n\n\nFunciones y m칠todos 칰tiles\n\nOrdenamiento\nEs com칰n que las listas se creen sin seguir un orden particular. Sin embargo, en algunas situaciones puede ser importante conservar el orden en que se agregaron los elementos, mientras que en otras puede resultar 칰til trabajar con los datos ordenados, por ejemplo, para facilitar su presentaci칩n.\nEn Python existen al menos dos formas de obtener listas ordenadas.\n\nEl m칠todo .sort()\nPara ordenar una lista de manera sencilla, podemos usar el m칠todo .sort(). Veamos un par de ejemplos para entender c칩mo funciona.\n\nproductos = [\"Fanta\", \"Coca Cola\", \"Sprite\"]\nproductos.sort()\nprint(productos)\n\n['Coca Cola', 'Fanta', 'Sprite']\n\n\n\nprecios = [100, 110, 80.0, 70]\nprecios.sort()\nprint(precios)\n\n[70, 80.0, 100, 110]\n\n\nPodemos concluir que el m칠todo .sort() realiza un ordenamiento permanente, ya que modifica directamente la lista sobre la que se aplica y no devuelve una nueva. Esto significa que, una vez ejecutado, no es posible recuperar la lista original a menos que la hayamos guardado previamente.\nPor defecto, el ordenamiento se hace de menor a mayor: en el caso de cadenas de texto, se compara caracter por caracter, y en el caso de n칰meros, se ordenan a partir de su valor.\n쮺칩mo hacemos para ordenar de manera decreciente?\nEl m칠todo .sort() tiene un argumento llamado reverse. Si este valor es igual a True, se ordenan los elementos de mayor a menor.\n\nproductos = [\"Fanta\", \"Coca Cola\", \"Sprite\"]\nproductos.sort(reverse=True)\nprint(productos)\n\n['Sprite', 'Fanta', 'Coca Cola']\n\n\n\nprecios = [100, 110, 80, 70]\nprecios.sort(reverse=True)\nprint(precios)\n\n[110, 100, 80, 70]\n\n\n\n\nLa funci칩n sorted()\nAl igual que el m칠todo .sort(), la funci칩n sorted() permite ordenar una lista. La diferencia principal es que sorted() no modifica la lista original, sino que devuelve una nueva lista ordenada. Esto resulta 칰til cuando queremos conservar tanto el orden original como una versi칩n ordenada de la misma lista.\nVeamos algunos ejemplos breves:\n\njuegos = [\"Counter Strike\", \"The Sims\", \"Age of Empires II\", \"League of Legends\", \"Among Us\"]\njuegos_ordenados = sorted(juegos)\n\nprint(\"Esta es la lista original:\")\nprint(juegos, \"\\n\")\n\nprint(\"Esta es la lista ordenada:\")\nprint(juegos_ordenados)\n\nEsta es la lista original:\n['Counter Strike', 'The Sims', 'Age of Empires II', 'League of Legends', 'Among Us'] \n\nEsta es la lista ordenada:\n['Age of Empires II', 'Among Us', 'Counter Strike', 'League of Legends', 'The Sims']\n\n\n\nprint(\"id(juegos):\".ljust(22), id(juegos))\nprint(\"id(juegos_ordenados):\".ljust(22), id(juegos_ordenados))\n\nid(juegos):            139718306677440\nid(juegos_ordenados):  139718306597952\n\n\nAl igual que .sort(), sorted() tambi칠n tiene un argumento que determina el orden:\n\nsorted(juegos, reverse=True)\n\n['The Sims',\n 'League of Legends',\n 'Counter Strike',\n 'Among Us',\n 'Age of Empires II']\n\n\n\n\n\nInvertir el orden con .reverse()\nHasta ahora vimos c칩mo ordenar listas de menor a mayor y de mayor a menor.\nOtra operaci칩n com칰n es invertir el orden de los elementos, y para eso podemos usar el m칠todo .reverse().\nAl igual que .sort(), esta operaci칩n modifica la lista original de forma permanente.\n\nproductos = [\"Fanta\", \"Coca Cola\", \"Sprite\"]\nproductos.reverse()\nprint(productos)\n\n['Sprite', 'Coca Cola', 'Fanta']\n\n\nSi nos arrepentimos de haber invertido el orden, podemos usar .reverse() nuevamente y recuperamos el orden original.\n\nproductos.reverse()\nprint(productos)\n\n['Fanta', 'Coca Cola', 'Sprite']\n\n\n\n\n\n\n\n\n쯏 la funci칩n reversed()? 游뱂\n\n\n\nAs칤 como tenemos .sort() y sorted(), uno podr칤a preguntarse si existe un reversed() que complemente .reverse().\nLa respuesta es s칤, reversed() existe. Sin embargo, su resultado no es una lista, sino un tipo de objeto que a칰n no hemos explorado.\nSin embargo, lo vamos a ver m치s adelante 游땕\n\n\n\n\nCantidad de elementos\nPara saber cuantos elementos hay en una lista utilizamos la funci칩n len().\nPor ejemplo, para obtener la cantidad de usuarios de manera program치tica:\n\nusuarios = [\"cyberwolf\", \"neo_404\", \"pixelbyte\", \"alphaX\", \"quantum.dev\"]\nprint(usuarios)\nlen(usuarios)\n\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX', 'quantum.dev']\n\n\n5\n\n\nY para obtener la cantidad de ciudades del Gran Rosario (aunque falte una 游땔):\n\nprint(gran_rosario)\nlen(gran_rosario)\n\n['Villa Gobernador G치lvez', 'Funes', 'P칠rez', 'Soldini', 'Granadero Baigorria', 'Ibarlucea', 'Puerto San Mart칤n', 'San Lorenzo', 'Fray Luis Beltr치n', 'Capit치n Bermudez', 'Ricardone', 'Rold치n', 'Alvear', 'Pueblo Esther', 'General Lagos', 'Arroyo Seco']\n\n\n16\n\n\n\n\nExistencia de elemento\nPara evaluar si un determinado elemento se encuentra en una lista utilizamos el operador in.\n\nnuevo_usuario = \"pepito\"\nnuevo_usuario in usuarios\n\nFalse\n\n\nQue correctamente indica que \"pepito\" no est치 en nuestra base de usuarios. Por otro lado,\n\n\"cyberwolf\" in usuarios\n\nTrue\n\n\n쯏 c칩mo preguntar si alg칰n elemento no est치 dentro de la lista? Para eso, utilizamos el operador not in.\n\n\"Col칩n\" not in gran_rosario\n\nTrue\n\n\nLa respuesta es True porque efectivamente \"Col칩n\" no pertenece al Gran Rosario.\nEste es uno de los tantos ejemplos donde Python se parece mucho mas al lenguaje humano que al lenguaje de las computadoras.\n\n\nPosici칩n de un elemento\nSi queremos conocer la posici칩n de un elemento en la lista podemos utilizar el m칠todo .index(). Por ejemplo:\n\nvocales = [\"a\", \"e\", \"i\", \"o\", \"u\"]\nvocales\n\n['a', 'e', 'i', 'o', 'u']\n\n\n\nvocales.index(\"i\")\n\n2\n\n\nAl igual que .remove(), el m칠todo .index() act칰a sobre el primer elemento de la lista que coincide con el valor indicado. Es decir, si hay m칰ltiples apariciones del mismo valor, solo se considera la primera.\n\n[\"a\", \"a\", \"a\"].index(\"a\")\n\n0\n\n\nEl resultado es 0 porque esa es la primera posici칩n en la que aparece \"a\" en la lista. Sin embargo, esto no quiere decir que \"a\" aparezca una sola vez; simplemente indica la ubicaci칩n de su primera ocurrencia.\n\n\nFrecuencia de un elemento\nSi queremos saber cu치ntas veces aparece un elemento en una lista, podemos usar el m칠todo .count(). Este m칠todo devuelve la cantidad de ocurrencias del valor indicado dentro de la lista.\n\n[\"a\", \"a\", \"a\"].count(\"a\")\n\n3\n\n\n\n[\"a\", \"a\", \"a\"].count(\"b\")\n\n0\n\n\n\n\nEstad칤sticas b치sicas\nPython ofrece funciones que nos permiten calcular f치cilmente algunas estad칤sticas b치sicas o medidas resumen, como el m칤nimo, el m치ximo y la suma de los elementos de una lista.\nSe destacan:\n\nmin(), que devuelve el valor m칤nimo\nmax(), que devuelve el valor m치ximo\nsum(), que devuelve la suma total\n\nVeamos algunos ejemplos:\n\nnumeros = [3, 7.5, 12, 1.2, 9, 4.8, 6, 15.3, 2.1, 8]\nnumeros\n\n[3, 7.5, 12, 1.2, 9, 4.8, 6, 15.3, 2.1, 8]\n\n\n\nprint(\"Valor m칤nimo:\", min(numeros))\nprint(\"Valor m치ximo:\", max(numeros))\nprint(\"Suma de valores:\", sum(numeros))\n\nValor m칤nimo: 1.2\nValor m치ximo: 15.3\nSuma de valores: 68.9\n\n\n\n\n\nResumen de m칠todos in-place\n\n\n\n\n\n\n\nM칠todo\nDescripci칩n\n\n\n\n\n.append(x)\nInserta el valor x al final de la lista\n\n\n.pop(i)\nRemueve y devuelve el elemento en la posici칩n i\n\n\n.insert(i, x)\nInserta el valor x en la posici칩n i\n\n\n.extend(iterable)\nInserta todos los valores de iterable al final de la lista\n\n\n.index(x)\nDevuelve el la posici칩n donde x aparece por primera vez en la lista\n\n\n.count(x)\nDevuelve la cantidad de veces que aparece x en la lista\n\n\n.sort()\nOrdena los elementos de la lista, de menor a mayor\n\n\n.reverse()\nInvierte el orden de los elementos en la lista",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#tuplas",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#tuplas",
    "title": "4 - Colecciones de datos",
    "section": "Tuplas",
    "text": "Tuplas\n\nDefinici칩n\nEl siguiente bloque de c칩digo genera una tupla con los n칰meros 1, 2, 3, 4 y 5.\n\n(1, 2, 3, 4, 5)\n\n(1, 2, 3, 4, 5)\n\n\nUna tupla es una secuencia ordenada de objetos inmutable. Al igual que las listas, permite almacenar m칰ltiples elementos de cualquier tipo y acceder a ellos por posici칩n. Muchas de las operaciones que usamos con listas tambi칠n funcionan con tuplas. La diferencia clave es que las listas son mutables (se pueden modificar), mientras que las tuplas son inmutables (no se pueden cambiar una vez creadas).\nLas tuplas suelen utilizarse para representar registros o estructuras simples. En general, las tuplas se utilizan para representar:\n\nUna colecci칩n fija de valores posibles para un cierto atributo (e.g., Identificaciones v치lidas), o\nLos distintos atributos de un objeto. En este caso, cada tupla es como un registro de una base de datos (e.g., Baraja espa침ola).\n\n\n\nEjemplos\n\nIdentificaciones v치lidas\nSupongamos que trabajamos en un aeropuerto internacional y estamos implementando un programa de autenticaci칩n de personas. Para ello, necesitamos definir los tipos de identificaci칩n que se aceptan. Por ejemplo: LE, LC, DNI, CUIT, CUIL y Pasaporte.\nComo esperamos que estos tipos no vayan a cambiar con el tiempo (춰al menos mientras corre nuestro programa!), tiene sentido utilizar una tupla (inmutable) en vez de una lista (mutable).\n\ntipos_identificacion = (\"LE\", \"LC\", \"DNI\", \"CUIT\", \"CUIL\", \"Pasaporte\")\ntipos_identificacion\n\n('LE', 'LC', 'DNI', 'CUIT', 'CUIL', 'Pasaporte')\n\n\n\ntype(tipos_identificacion)\n\ntuple\n\n\nAl igual que con las listas, podemos utilizar los 칤ndices para acceder a los elementos de la tupla:\n\nprint(tipos_identificacion[0])\nprint(tipos_identificacion[-1])\n\nLE\nPasaporte\n\n\nAl contrario de lo que sucede con las listas, no es posible modificar ninguno de sus elementos existentes:\ntipos_identificacion[0] = \"NUEVO_TIPO\"\n\n    tipos_identificacion[0] = \"NUEVO_TIPO\"\n    ~~~~~~~~~~~~~~~~~~~~^^^\nTypeError: 'tuple' object does not support item assignment\n\nSin embargo, si necesitamos combinar una o m치s tuplas en otra tupla, sigue siendo posible utilizar el operador de suma (+) para concatenar tuplas y as칤 crear una nueva, con sus elementos concatenados.\n\ntupla_nueva = tipos_identificacion + (\"NT1\", \"NT2\")\ntupla_nueva\n\n('LE', 'LC', 'DNI', 'CUIT', 'CUIL', 'Pasaporte', 'NT1', 'NT2')\n\n\n\nprint(\"id(tipos_identificacion):\", id(tipos_identificacion))\nprint(\"id(tupla_nueva):\".ljust(25), id(tupla_nueva))\n\nid(tipos_identificacion): 139718618931520\nid(tupla_nueva):          139718306406336\n\n\nAs칤, se genera una nueva tupla mientras que la original se mantiene intacta.\n\n\nBaraja espa침ola\nSupongamos que queremos desarrollar un software para jugar al truco en l칤nea con nuestros amigos. Tarde o temprano, vamos a necesitar una forma de representar las cartas de la baraja espa침ola.\nEsta baraja est치 compuesta por 40 cartas, divididas en 4 palos: oros, copas, espadas y bastos. Cada palo incluye las siguientes cartas: 1, 2, 3, 4, 5, 6, 7, 10, 11 y 12.\nUna forma simple y efectiva de representar esta baraja en Python es utilizando una lista de tuplas: la lista representa el mazo completo, y cada tupla representa una carta individual. Cada tupla tiene dos elementos: el palo y el valor. Es decir, cada carta se representa as칤:\n(palo, valor)\nPor ejemplo: (\"espadas\", 7) representa el 7 de espadas.\n\nbaraja = [\n    (\"oros\", 1), (\"oros\", 2), (\"oros\", 3), (\"oros\", 4), (\"oros\", 5),\n    (\"oros\", 6),  (\"oros\", 7), (\"oros\", 10), (\"oros\", 11), (\"oros\", 12),\n    (\"copas\", 1), (\"copas\", 2), (\"copas\", 3), (\"copas\", 4), (\"copas\", 5),\n    (\"copas\", 6), (\"copas\", 7), (\"copas\", 10), (\"copas\", 11), (\"copas\", 12),\n    (\"espadas\", 1), (\"espadas\", 2), (\"espadas\", 3), (\"espadas\", 4), (\"espadas\", 5),\n    (\"espadas\", 6), (\"espadas\", 7), (\"espadas\", 10), (\"espadas\", 11), (\"espadas\", 12),\n    (\"bastos\", 1), (\"bastos\", 2), (\"bastos\", 3), (\"bastos\", 4), (\"bastos\", 5),\n    (\"bastos\", 6), (\"bastos\", 7), (\"bastos\", 10), (\"bastos\", 11), (\"bastos\", 12)\n]\n\nDe este modo, cada tupla representa una carta y resalta su caracter칤stica de inmutable.\n\n\n\nCu치ndo usar tuplas\nSi las tuplas se parecen tanto a las listas, 쯣ara qu칠 existen?\nLas tuplas son apropiadas cuando se necesita una colecci칩n inmutable, es decir, una secuencia que no debe cambiar ni en contenido ni en tama침o. Esto evita modificaciones accidentales y, adem치s, es m치s eficiente en memoria que una lista.\nAunque suelen usarse con datos heterog칠neos, el criterio m치s importante es la inmutabilidad. Si la colecci칩n va a cambiar, no corresponde usar una tupla, independientemente del tipo de datos que esta contenga.\nFinalmente, aunque usar una lista en lugar de una tupla no afecte significativamente el rendimiento de un programa particular, elegir la estructura adecuada mejora la legibilidad: una tupla deja en claro que esa secuencia no se modifica en ning칰n momento.\n\n\nDiferencias entre listas y tuplas\nC칩mo las creamos:\n\nPara crear listas usamos [].\nPara crear tuplas usamos () (no es del todo cierto, ver Definici칩n de tuplas 游댌).\n\nComportamiento 띿in치mico vs 란st치tico:\n\nEl tama침o de las listas puede ser modificado luego de ser creado (din치mico).\nEl tama침o de las tuplas no puede ser modificado luego de ser creado (est치tico).\n\nObjetos 랈utables vs 랄nmutables:\n\nLos elementos de la lista se pueden modificar luego de ser creada (mutable).\nLos elementos de una tupla no se pueden modificar (inmutable).\n\nM치s all치 de sus diferencias, las listas y las tuplas tienen muchas similitudes:\n\nSon secuencias ordenadas.\nPueden contener objetos de distintos tipos al mismo tiempo.\nPermiten acceder a los elementos mediante su 칤ndice.\nAdmiten operaciones de slicing para obtener subconjuntos.\n\n\n\n\n\n\n\nDefinici칩n de tuplas 游댌\n\n\n\nHasta ahora dijimos que las tuplas se crean utilizando par칠ntesis y separando los elementos con comas. Pero eso no es del todo cierto.\nEn realidad, los par칠ntesis no son necesarios para definir una tupla. Lo que define a una tupla en Python es la coma, no los par칠ntesis. Por ejemplo:\nt = 10, 25.0, 50\nprint(t)\nprint(type(t))\n(10, 25.0, 50)\n&lt;class 'tuple'&gt;\nLos par칠ntesis en Python se usan principalmente para agrupar expresiones y modificar el orden de evaluaci칩n, pero no son lo que convierte una serie de valores en una tupla. Si pens치ramos a los par칠ntesis como una funci칩n, simplemente devuelven el mismo objeto que encierran.\nDicho esto, el uso de par칠ntesis es una convenci칩n ampliamente aceptada a la hora de definir tuplas. De hecho, por m치s que los par칠ntesis no sean necesarios para su definici칩n, Python siempre muestra a las tuplas entre par칠ntesis.",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#diccionarios",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#diccionarios",
    "title": "4 - Colecciones de datos",
    "section": "Diccionarios",
    "text": "Diccionarios\nEn el ejemplo al inicio de este apunte presentamos el siguiente bloque de c칩digo:\nnombre_1 = \"Juan\"\nnombre_2 = \"Carla\"\nnombre_3 = \"Evelina\"\nnombre_4 = \"Leandro\"\n\nedad_1 = 29\nedad_2 = 34\nedad_3 = 33\nedad_4 = 38\nA simple vista, se pudo concluir que exist칤a una relaci칩n entre los nombres y las edades. Por ejemplo, pudimos deducir que la edad de Juan es de 29 a침os.\nCon las herramientas adquiridas en este apunte podr칤amos representar esta informaci칩n de las siguientes dos maneras:\n\nnombres = [\"Juan\", \"Carla\", \"Evelina\", \"Leandro\"]\nedades = [29, 34, 33, 38]\n\nAs칤, el elemento ubicado en la posici칩n i-칠sima de la lista nombres se corresponde con el elemento de la misma posici칩n en la lista edades.\nEn principio, este enfoque resuelve el problema de tener que crear una variable distinta para cada valor. Sin embargo, mantener dos colecciones mutables e independientes en sincron칤a puede convertirse en un verdadero dolor de cabeza. De hecho, podemos estar casi seguros de que, tarde o temprano, esa sincron칤a se va a romper.\nOtra alternativa es la siguiente:\n\npersonas = [(\"Juan\", 29), (\"Carla\", 34), (\"Evelina\", 33), (\"Leandro\", 38)]\n\nAhora, contamos con un 칰nico objeto de Python que re칰ne toda la informaci칩n de las personas. En esta lista de tuplas, cada tupla representa a una persona: el primer elemento es su nombre y el segundo, su edad. Una de las ventajas de este enfoque es que permite agregar o quitar registros sin preocuparse por mantener la sincronizaci칩n entre distintas colecciones.\nSin embargo, existe otra estructura de datos que puede resultar a칰n m치s adecuada para este escenario: el diccionario.\nLos diccionarios son estructuras que establecen un mapeo (del ingl칠s, mapping) o relaci칩n entre dos conjuntos de elementos: claves y valores (keys y values en Python). En nuestro caso, podemos crear un diccionario donde las claves sean los nombres y los valores, las edades.\nEn Python, los diccionarios se definen entre llaves ({}). Dentro de ellas, cada elemento se escribe como un par clave: valor, separado por comas para distinguirlo de los dem치s.\n\npersonas = {\"Juan\": 29, \"Carla\": 34, \"Evelina\": 33, \"Leandro\": 38}\npersonas\n\n{'Juan': 29, 'Carla': 34, 'Evelina': 33, 'Leandro': 38}\n\n\n\ntype(personas)\n\ndict\n\n\n\nlen(personas)\n\n4\n\n\nPodemos usar este ejemplo para destacar algunos puntos clave sobre los diccionarios:\n\nLa longitud de un diccionario corresponde a la cantidad de pares clave: valor que contiene, no a la suma de la cantidad de claves y valores.\nAunque es com칰n usar cadenas de texto como claves, no es obligatorio: cualquier objeto que sea hashable puede ser una clave (lo veremos m치s adelante).\nLos valores pueden ser de cualquier tipo de objeto en Python.\nLas claves deben ser 칰nicas, pero los valores pueden repetirse.\n\nPor 칰ltimo, veremos con un ejemplo que, aunque desde Python 3.7 los diccionarios mantienen un orden, este no es relevante al compararlos.\n\nd1 = {\"nombre\": \"Juan\", \"apellido\": \"P칠rez\"}\nd2 = {\"apellido\": \"P칠rez\", \"nombre\": \"Juan\"}\n\nprint(d1)\nprint(d2)\nprint(d1 == d2)\n\n{'nombre': 'Juan', 'apellido': 'P칠rez'}\n{'apellido': 'P칠rez', 'nombre': 'Juan'}\nTrue\n\n\nAunque d1 y d2 tengan las claves en distinto orden, para Python son diccionarios equivalentes; lo que importa no es el orden de los elementos en los diccionarios, sino los pares clave: valor que contienen.\n\n\n\n\n\n\n쯇or qu칠 se llaman diccionarios? 游뱂\n\n\n\nEl nombre proviene de la idea de que en un diccionario real, uno busca la definici칩n de una palabra (su valor) a partir de la palabra misma (la clave).\n\n\n\nAcceder a los elementos\nA diferencia de las listas y las tuplas, que son objetos donde el orden importa y se puede acceder a sus elementos por posici칩n, los diccionarios no utilizan posiciones: en ellos, el acceso a los elementos se realiza mediante sus claves. Por ejemplo, si queremos acceder a la edad de Juan utilizando el 칤ndice 0, vamos a obtener un error:\npersonas[0]\n\n    personas[0]\n    ~~~~~~~~^^^\nKeyError: 0\n\nEn cambio, si usamos la clave \"Juan\", que es lo que corresponde:\n\npersonas[\"Juan\"]\n\n29\n\n\n\n\nVerificar la existencia de un elemento\nLos operadores in y not in permiten determinar si un diccionario contiene a un elemento con una determinada clave.\n\nd = {\"color\": \"azul\", \"forma\": \"cuadrado\"}\n\n\"color\" in d\n\nTrue\n\n\n\n\"area\" in d\n\nFalse\n\n\n\n\"area\" not in d\n\nTrue\n\n\n\n\"azul\" in d\n\nFalse\n\n\nAunque \"azul\" aparece como valor de uno de los elementos del diccionario d, \"azul\" in d retorna False porque no hay ninguna clave que sea \"azul\".\n\n\nAcceder a claves y valores\nEs posible acceder solo a las claves:\n\nd = {\"color\": \"azul\", \"forma\": \"cuadrado\"}\nd.keys()\n\ndict_keys(['color', 'forma'])\n\n\nO a los valores:\n\nd.values()\n\ndict_values(['azul', 'cuadrado'])\n\n\nO a las claves y los valores:\n\nd.items()\n\ndict_items([('color', 'azul'), ('forma', 'cuadrado')])\n\n\nEn todos los casos se obtiene una estructura de datos especial: dict_keys, dict_values o dict_items. No profundizaremos en ellas, ya que rara vez es necesario interactuar directamente con estos objetos. En la pr치ctica, lo relevante es que permiten iterar sobre sus elementos y convertirse f치cilmente a tipos m치s comunes, como las listas.\n\n\nModificar, agregar y eliminar elementos\nLos diccionarios son objetos mutables, lo que significa que podemos modificar, agregar o eliminar elementos. Su funcionamiento es muy similar al de las listas. La diferencia m치s notable es que, en vez de usar 칤ndices, se usan claves.\n\nModificar elementos\nAl igual que en una lista, podemos modificar un elemento seleccion치ndolo y asign치ndole un nuevo valor.\n\npersonas\n\n{'Juan': 29, 'Carla': 34, 'Evelina': 33, 'Leandro': 38}\n\n\n\npersonas[\"Juan\"] = 54\n\n\npersonas\n\n{'Juan': 54, 'Carla': 34, 'Evelina': 33, 'Leandro': 38}\n\n\n\n\nAgregar elementos\nPara agregar un elemento, se utiliza la misma sintaxis que para modificar uno: se asigna un valor a una nueva clave en el diccionario.\n\npersonas[\"Marisa\"] = 29\n\nEn resumen, al asignar un valor a una clave, Python primero verifica si existe: si la encuentra, reemplaza su valor; si no, agrega un nuevo par clave-valor.\n\n\nEliminar elementos\nEn un diccionario, es posible eliminar elementos de distintas maneras. Las m치s comunes son:\n\nLa sentencia del.\nEl m칠todo .pop().\n\nLa sentencia del elimina un elemento asociado a una clave sin devolver su valor, por lo que no puede usarse posteriormente.\nPor ejemplo:\n\ndescuentos = {\n    \"Lunes\": 0,\n    \"Martes\": 20,\n    \"Miercoles\": 10,\n    \"Jueves\": 20,\n    \"Viernes\": 30,\n    \"S치bado\": 30,\n    \"Domingo\": 0\n}\ndescuentos\n\n{'Lunes': 0,\n 'Martes': 20,\n 'Miercoles': 10,\n 'Jueves': 20,\n 'Viernes': 30,\n 'S치bado': 30,\n 'Domingo': 0}\n\n\n\ndel descuentos[\"Domingo\"]\ndescuentos\n\n{'Lunes': 0,\n 'Martes': 20,\n 'Miercoles': 10,\n 'Jueves': 20,\n 'Viernes': 30,\n 'S치bado': 30}\n\n\nEs como si el elemento \"Domingo\": 0 se hubiera esfumado.\nEn cambio, el m칠todo .pop() extrae el valor del diccionario y lo devuelve, lo que permite almacenarlo o utilizarlo m치s adelante en el programa.\n\ndescuento_lunes = descuentos.pop(\"Lunes\")\nprint(descuento_lunes)\nprint(descuentos)\n\n0\n{'Martes': 20, 'Miercoles': 10, 'Jueves': 20, 'Viernes': 30, 'S치bado': 30}\n\n\n\n\nActualizar diccionarios\nLos diccionarios tienen acceso a un m칠todo .update() que permiten actualizar un diccionario a partir de otro diccionario. Supongamos que tenemos un diccionario con informaci칩n relacionada a una persona y otro diccionario con informaci칩n actualizada de esa persona.\n\ndatos = {\"nombre\": \"Guillermina\", \"ciudad\": \"Rosario\", \"estado civil\": \"soltera\"}\ndatos_nuevos = {\"ciudad\": \"Rold치n\", \"estado civil\": \"casada\", \"hijos\": 2}\n\nSe puede actualizar el contenido del diccionario datos con el contenido del diccionario datos_nuevos de la sigiuente manera:\n\ndatos.update(datos_nuevos)\ndatos\n\n{'nombre': 'Guillermina',\n 'ciudad': 'Rold치n',\n 'estado civil': 'casada',\n 'hijos': 2}\n\n\nEste m칠todo modifica el diccionario datos in-place.\nSi se quiere realizar la operaci칩n sin alterar el diccionario original, se puede usar el operador pipe (|), que devuelve un nuevo diccionario.\n\nd1 = {\"a\": 1, \"b\": 2}\nd2 = {\"b\": 10, \"c\": 25}\nd3 = d1 | d2\n\nprint(d1)\nprint(d2)\nprint(d3)\n\n{'a': 1, 'b': 2}\n{'b': 10, 'c': 25}\n{'a': 1, 'b': 10, 'c': 25}\n\n\nPor 칰ltimo, vale la pena notar que al actualizar un diccionario podemos modificar elementos existentes o agregar otros nuevos.\n\n\n\nEstructuras anidadas\nAnteriormente mencionamos que los diccionarios pueden contener cualquier tipo de objeto de Python. Por lo tanto, significa que puede contener n칰meros, cadenas, listas 춰e incluso otros diccionarios!\nVeamos un ejemplo donde esta idea resulta 칰til. Supongamos que queremos representar la informaci칩n de una persona llamada Julia, que tiene 33 a침os y realiz칩 tres cursos de Python: Introducci칩n a Python, An치lisis de datos con Python y Python avanzado. El tipo de dato para el nombre y la edad es evidente: str e int, respectivamente. En cambio, para los cursos necesitamos una colecci칩n de valores, ya que no se trata de un 칰nico elemento. As칤, podemos crear el siguiente diccionario:\n\npersona = {\n    \"nombre\": \"Julia\",\n    \"edad\": 33,\n    \"cursos\": [\"Introducci칩n a Python\", \"An치lisis de datos con Python\", \"Python avanzado\"]\n}\n\nprint(persona)\n\n{'nombre': 'Julia', 'edad': 33, 'cursos': ['Introducci칩n a Python', 'An치lisis de datos con Python', 'Python avanzado']}\n\n\n\nprint(f\"Nombre: {persona['nombre']}\")\nprint(f\"Edad: {persona['edad']}\")\nprint(f\"Cursos: {persona['cursos']}\")\n\nNombre: Julia\nEdad: 33\nCursos: ['Introducci칩n a Python', 'An치lisis de datos con Python', 'Python avanzado']\n\n\nTambi칠n es posible representar estructuras de datos m치s complejas, como registros. En el siguiente ejemplo, el diccionario usuarios tiene como valores otros diccionarios. Las claves de usuarios corresponden a nombres de usuario (por ejemplo, \"aeinstein\"), mientras que los valores son diccionarios que almacenan atributos de ese usuario, como su nombre, apellido y ciudad de residencia.\n\nusuarios = {\n    \"aeinstein\": {\n        \"nombre\": \"albert\",\n        \"apellido\": \"einstein\",\n        \"ciudad\": \"princenton\"\n    },\n    \"mcurie\": {\n        \"nombre\": \"marie\",\n        \"apellido\": \"curie\",\n        \"ciudad\": \"paris\"\n    },\n    \"afleming\": {\n        \"nombre\": \"alexander\",\n        \"apellido\": \"fleming\",\n        \"ciudad\": \"londres\"\n    }\n}\n\nPara acceder a un elemento dentro de un diccionario anidado, se encadenan los accesos usando [] tantas veces como sea necesario: primero para obtener el diccionario interno y luego para acceder a la clave deseada dentro de 칠l.\n\nprint(usuarios[\"aeinstein\"])\nprint(usuarios[\"aeinstein\"][\"ciudad\"])\n\n{'nombre': 'albert', 'apellido': 'einstein', 'ciudad': 'princenton'}\nprincenton\n\n\n\nusuario = \"aeinstein\"\ndatos = usuarios[usuario]\nf\"El usuario '{usuario}' se llama {datos['nombre'].capitalize()} {datos['apellido'].capitalize()}.\"\n\n\"El usuario 'aeinstein' se llama Albert Einstein.\"",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#secuencias",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#secuencias",
    "title": "4 - Colecciones de datos",
    "section": "Secuencias",
    "text": "Secuencias\nLos tres tipos de datos que presentamos en este apunte pertenecen a la categor칤a de las colecciones, ya que permiten almacenar una colecci칩n o conjunto de objetos.\nOtra categor칤a muy interesante de tipos de datos son las secuencias.\nUna secuencia es una estructura de datos que contiene elementos organizados en orden, y se puede acceder a cada elemento mediante un 칤ndice entero que representa su posici칩n en la secuencia. Por lo tanto, las listas y las tuplas son ejemplos de secuencias; los diccionarios, en cambio, no lo son.\nAunque pueda parecer sorprendente al principio, las cadenas de texto tambi칠n son secuencias.\nVale la pena destacar a las secuencias, ya que todos los tipos de datos que abarca comparten un conjunto com칰n de operaciones, que se resumen en la siguiente tabla:\n\n\n\n\n\n\n\n\nOperaci칩n\nResultado\nComentarios\n\n\n\n\ne in s\nIndica si el valor e se encuentra en s\n\n\n\ne not in s\nIndica si el valor e no se encuentra en s\n\n\n\ns + t\nConcatena las secuencias s y t\n\n\n\ns * n\nConcatena n copias de s\n\n\n\ns[i]\nObtiene el elemento i de s\n\n\n\ns[i:j]\nPorci칩n de la secuencia s desde i hasta j (no inclusive)\n\n\n\ns[i:j:k]\nPorci칩n de la secuencia s desde i hasta j (no inclusive), con paso k\n\n\n\nlen(s)\nCantidad de elementos en la secuencia s\n\n\n\nmin(s)\nM칤nimo elemento en la secuencia s\nRequiere elementos comparables\n\n\nmax(s)\nM치ximo elemento de la secuencia s\nRequiere elementos comparables\n\n\nsum(s)\nSuma de los elementos de la secuencia s\nNo aplica a str\n\n\nsorted(s)\nOrdena los elementos de la secuencia s y los devuelve en una lista\nRequiere elementos comparables\n\n\nenumerate(s)\nIterador sobre los elementos de s junto con sus posiciones\nPermite iterar con (칤ndice, valor)\n\n\nreversed(s)\nIterador inverso sobre los elementos de s\n\n\n\nall(s)\nIndica si bool(e) es True para todos los elementos de s\n\n\n\nany(s)\nIndica si bool(e) es True para al menos un elemento de s\n\n\n\ns.index(e)\nPosici칩n del elemento e en la secuencia s\n\n\n\ns.count(e)\nCantidad de veces que el elemento e aparece la secuencia s\n\n\n\n\nPor ejemplo:\n\ntexto = \"Esto es un texto cualquiera\"\notro = \"y esto es otro texto\"\nprint(\"texto[0]:\", texto[0])\n\ntexto[0]: E\n\n\n\nprint(\"texto[-1]:\", texto[-1])\n\ntexto[-1]: a\n\n\n\nprint(\"texto[0:3]:\", texto[0:3])\n\ntexto[0:3]: Est\n\n\n\nprint(\"texto[0:10:2]:\", texto[0:20:2])\n\ntexto[0:10:2]: Et su et u\n\n\n\nprint(\"texto + otro:\", texto + otro)\n\ntexto + otro: Esto es un texto cualquieray esto es otro texto\n\n\n\nprint(\"texto * 2:\", texto * 2)\n\ntexto * 2: Esto es un texto cualquieraEsto es un texto cualquiera\n\n\n\nprint(\"len(texto):\", len(texto))\n\nlen(texto): 27\n\n\n\nprint(\"sorted(texto):\", sorted(texto))\n\nsorted(texto): [' ', ' ', ' ', ' ', 'E', 'a', 'a', 'c', 'e', 'e', 'e', 'i', 'l', 'n', 'o', 'o', 'q', 'r', 's', 's', 't', 't', 't', 'u', 'u', 'u', 'x']\n\n\nAdem치s, es posible crear una secuencia (o colecci칩n) a partir de otra secuencia (o colecci칩n) utilizando el tipo de dato como constructor. Por ejemplo:\n\nlist(\"texto\")\n\n['t', 'e', 'x', 't', 'o']\n\n\n\ntuple(\"texto\")\n\n('t', 'e', 'x', 't', 'o')\n\n\n\nlist((1, 2, 3, 4))\n\n[1, 2, 3, 4]\n\n\nSin embargo, el resultado puede no ser de lo m치s intuitivo incialmente:\n\nstr([\"1\", \"2\", \"3\"]) # 춰Notar que no concatena los elementos!\n\n\"['1', '2', '3']\"\n\n\n\nlist({\"a\": 1, \"b\": 2}) # Crea una lista a partir de las claves\n\n['a', 'b']\n\n\n\nlist({\"a\": 1, \"b\": 2}.values()) # Es posible crear una lista a partir de los valores\n\n[1, 2]\n\n\nSi intentamos crear un diccionario a partir de una lista (o tupla) 랋lana, obtendremos un error, ya que no hay una forma clara de identificar las claves y los valores.\ndict([1, 2, 3])\n\n    dict([1, 2, 3])\n    ~~~~^^^^^^^^^^^\nTypeError: cannot convert dictionary update sequence element #0 to a sequence\n\nEn cambio, si usamos una lista (o tupla) compuesta por listas (o tuplas) de longitud 2, la conversi칩n es posible:\n\ndict([[\"x\", 1], [\"y\", 2]])\n\n{'x': 1, 'y': 2}\n\n\n\ndict([(\"A\", \"aaa\"), (\"B\", \"bbb\")])\n\n{'A': 'aaa', 'B': 'bbb'}",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#resumen-1",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#resumen-1",
    "title": "4 - Colecciones de datos",
    "section": "Resumen",
    "text": "Resumen\n\nLista (list)\n\nSintaxis: [a, b, c]\nEs mutable\nTiene orden\nSe accede a los elementos por 칤ndice\nEs secuencia\nAdmite cualquier objeto\n\nTupla (tuple)\n\nSintaxis: (a, b, c) o a, b, c\nEs inmutable\nTiene orden\nSe accede a los elementos por 칤ndice\nEs secuencia\nAdmite cualquier objeto\n\nDiccionario (dict)\n\nSintaxis: {clave: valor, ...}\nEs mutable\nTiene orden, pero no importa para evaluar igualdad\nSe accede a los elementos por clave\nNo es secuencia\nLas claves admiten objetos hashable, los valores pueden ser cualquier objeto\n\nCadena (str)\n\nSintaxis: \"texto\" o 'texto'\nEs inmutable\nTiene orden\nSe accede a los elementos por 칤ndice\nEs secuencia\nSolo admite caracteres",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html",
    "title": "3 - Ejecuci칩n condicional",
    "section": "",
    "text": "Las computadoras son muy buenas para much칤simas cosas. En particular:\n\nDeterminar autom치ticamente que secciones de un programa se debe ejecutar.\nRealizar tareas repetitivas.\n\nEl primer punto se refiere a la ejecuci칩n condicional de c칩digo y el segundo a la ejecuci칩n repetitiva de c칩digo.\nEstos dos puntos pueden ser vistos de manera general como control de flujo del c칩digo.\nEn este apunte hablamos de la ejecuci칩n condicional de c칩digo.",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "3 - Ejecuci칩n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#introducci칩n",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#introducci칩n",
    "title": "3 - Ejecuci칩n condicional",
    "section": "",
    "text": "Las computadoras son muy buenas para much칤simas cosas. En particular:\n\nDeterminar autom치ticamente que secciones de un programa se debe ejecutar.\nRealizar tareas repetitivas.\n\nEl primer punto se refiere a la ejecuci칩n condicional de c칩digo y el segundo a la ejecuci칩n repetitiva de c칩digo.\nEstos dos puntos pueden ser vistos de manera general como control de flujo del c칩digo.\nEn este apunte hablamos de la ejecuci칩n condicional de c칩digo.",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "3 - Ejecuci칩n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if",
    "title": "3 - Ejecuci칩n condicional",
    "section": "Bloques if",
    "text": "Bloques if\nLos bloques if utilizan la keyword if para evaluar una condici칩n y ejecutar una secci칩n de c칩digo en base al resultado de esta evaluaci칩n.\n\n\n\n\n\nVeamos un ejemplo.\n\ncondicion = True\nif condicion:\n    print(\"Se ejecuta el bloque if\")\n\nSe ejecuta el bloque if\n\n\n\ncondicion = False\nif condicion:\n    print(\"Se ejecuta el bloque if\")\n\nDe manera mas general, un bloque if es de la siguiente forma:\n\n\n\n\n\nTiene los siguientes componentes:\n\nLa palabra clave if.\nLa condici칩n a evaluar, que tiene que ser True o False. Esta va seguida de los dos puntos : que indican el fin de la condici칩n a evaluar y que lo siguiente es el bloque de c칩digo a ejecutar condicionalmente.\nEl bloque de c칩digo a evaluar si condici칩n es verdadera.\n\nVeamos otro ejemplo.\n\ncondicion = True\nif condicion:\n    print(\"Se ejecuta el bloque if\")\n\nprint(\"Esto se imprime siempre\")\n\nSe ejecuta el bloque if\nEsto se imprime siempre\n\n\nEl segundo print() se imprime siempre porque est치 por fuera del bloque de ejecuci칩n condicional.\n쮺칩mo nos damos cuenta que no est치 dentro del bloque condicional?\nSimplemente la indentaci칩n vuelve a ser normal. El fin de la indentaci칩n indica el fin del bloque de c칩digo.\n\nvalor = 12\nif valor &gt; 10:\n    print(\"Se ejecuta el bloque if\")\n\nSe ejecuta el bloque if",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "3 - Ejecuci칩n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if---else",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if---else",
    "title": "3 - Ejecuci칩n condicional",
    "section": "Bloques if - else",
    "text": "Bloques if - else\nVimos que el bloque if nos permite ejecutar un bloque de c칩digo de manera condicional, y que luego el programa sigue su ejecuci칩n normal.\nTambi칠n es posible que necesitemos ejecutar un bloque de c칩digo cuando las condiciones resulten en True y un bloque distinto en el caso contrario.\nPara eso, utilizamos el bloque if-else.\nUn bloque if-else es muy similar a un bloque if.\nLa diferencia es que nos permite definir otro bloque de c칩digo que se ejecuta cuando la prueba condicional es False.\n\n\n\n\n\n\nedad = 21\nif edad &gt;= 16:\n    print(\"Ten칠s la edad suficiente para votar\")\nelse:\n    print(\"Lo siento, a칰n sos demasiado j칩ven para votar\")\n\nTen칠s la edad suficiente para votar\n\n\n\n\n\n\n\nAl igual que con el bloque if, cualquier parte del c칩digo que se escriba luego del bloque if-else es ejecutada sin importar el valor de las condiciones.\nVeamos otro ejemplo donde evaluamos si un n칰mero es par o impar.\n\nvalor = 10\nprint(valor)\n\nif valor % 2 == 0:\n    mensaje = \"Es par\"\nelse:\n    mensaje = \"Es impar\"\n\nprint(mensaje)\n\n10\nEs par\n\n\nEn este caso, print(mensaje) se ejecuta siempre.\nLo que var칤a es el valor de la variable mensaje, que depende de si el n칰mero es par o impar.",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "3 - Ejecuci칩n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if-elif-else",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if-elif-else",
    "title": "3 - Ejecuci칩n condicional",
    "section": "Bloques if-elif-else",
    "text": "Bloques if-elif-else\nEs muy probable que tengamos situaciones donde necesitemos considerar m치s de dos escenarios posibles.\nPara esto, Python ofrece los bloques if-elif-else.\nEste tipo de programa considera varias condiciones y las eval칰a de a una a la vez hasta que alguna es verdadera. Luego se ejecuta solamente el bloque de c칩digo que corresponde a la primer condici칩n verdadera.\n\n\n\n\n\nSupongamos que viene un parque de diversiones a Rosario y tiene los siguientes precios para la entrada:\n\nMenores de 4 a침os, gratis.\nPersonas entre 4 y 18 a침os, $400.\nPersonas de 18 o mas a침os, $600.\n\n\nedad = 3\n\nif edad &lt; 4:\n    print(\"El costo de entrada para vos es de $0.\")\nelif edad &lt; 18:\n    print(\"El costo de entrada para vos es de $400.\")\nelse:\n    print(\"El costo de entrada para vos es de $600.\")\n\nEl costo de entrada para vos es de $0.",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "3 - Ejecuci칩n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#m칰ltiples-bloques-elif",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#m칰ltiples-bloques-elif",
    "title": "3 - Ejecuci칩n condicional",
    "section": "M칰ltiples bloques elif",
    "text": "M칰ltiples bloques elif\nHasta ahora utilizamos un 칰nico bloque elif, pero podemos usar tantos como sea necesario.\nPor ejemplo, si el parque de diversiones decide realizar un descuento para adultos mayores, dejando el precio en $350, podriamos agregar otro bloque elif que represente la evaluaci칩n de esta condici칩n.\n\nedad = 68\n\nif edad &lt; 4:\n    precio = 0\nelif edad &lt; 18:\n    precio = 400\nelif edad &lt; 65:\n    precio = 600\nelse:\n    precio = 350\n\nprint(f\"El precio de entrada para vos es de ${precio}.\")\n\nEl precio de entrada para vos es de $350.",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "3 - Ejecuci칩n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#omitir-el-bloque-else",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#omitir-el-bloque-else",
    "title": "3 - Ejecuci칩n condicional",
    "section": "Omitir el bloque else",
    "text": "Omitir el bloque else\nNo hay ninguna regla que nos obligue a terminar un bloque de if-elif con un bloque else.\nUtilizar el bloque else a veces es lo correcto, pero otras veces puede ser mejor poner una condici칩n expl칤cita en un 칰ltimo elif que contemple solamente la condici칩n que realmente nos interesa.\n\nedad = 10\n\nif edad &lt; 4:\n    precio = 0\nelif edad &lt; 18:\n    precio = 400\nelif edad &lt; 65:\n    precio = 600\nelif edad &gt;= 65:\n    precio = 350\n\nprint(f\"El precio de entrada para vos es de ${precio}.\")\n\nEl precio de entrada para vos es de $400.\n\n\nEl bloque elif que agregamos indica que el precio ser치 de $350 cuando la edad de la persona sea mayor o igual a 65 a침os.\nEsta condici칩n es m치s expl칤cita y f치cil de entender que el bloque else que us치bamos antes.\nSin embargo, todav칤a hay un problema: el programa sigue funcionando incluso si se ingresan edades fuera de un rango razonable. A continuaci칩n se muestra una versi칩n m치s completa:\n\nedad = 125\n\nif edad &lt; 0:\n    print(\"춰Error!\")\n    precio = None\nelif edad &lt; 4:\n    precio = 0\nelif edad &lt; 18:\n    precio = 400\nelif edad &lt; 65:\n    precio = 600\nelif edad &gt;= 65 and edad &lt;= 120:\n    precio = 350\nelse:\n    print(\"춰Error!\")\n    precio = None\n\nprint(f\"El precio de entrada para vos es ${precio}.\")\n\n춰Error!\nEl precio de entrada para vos es $None.\n\n\nEl diagrama y el c칩digo para el caso solo con elif se ven de la siguiente manera:",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "3 - Ejecuci칩n condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html",
    "href": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html",
    "title": "6 - Uso de c칩digo externo",
    "section": "",
    "text": "En la mayor칤a de los proyectos de programaci칩n no alcanza con el c칩digo que escribimos nosotros mismos. Con frecuencia necesitamos utilizar c칩digo externo y/o de terceros, ya sea para resolver problemas comunes de manera m치s r치pida o para aprovechar el trabajo de la comunidad.\nPython facilita este proceso a trav칠s de m칩dulos y paquetes, que nos permiten organizar, compartir e integrar c칩digo de forma sencilla. Gracias a ellos podemos sumar nuevas funcionalidades sin tener que programar todo desde cero, mantener el c칩digo m치s ordenado y evitar errores innecesarios.",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "6 - Uso de c칩digo externo"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#introducci칩n",
    "href": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#introducci칩n",
    "title": "6 - Uso de c칩digo externo",
    "section": "",
    "text": "En la mayor칤a de los proyectos de programaci칩n no alcanza con el c칩digo que escribimos nosotros mismos. Con frecuencia necesitamos utilizar c칩digo externo y/o de terceros, ya sea para resolver problemas comunes de manera m치s r치pida o para aprovechar el trabajo de la comunidad.\nPython facilita este proceso a trav칠s de m칩dulos y paquetes, que nos permiten organizar, compartir e integrar c칩digo de forma sencilla. Gracias a ellos podemos sumar nuevas funcionalidades sin tener que programar todo desde cero, mantener el c칩digo m치s ordenado y evitar errores innecesarios.",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "6 - Uso de c칩digo externo"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#m칩dulos-y-paquetes",
    "href": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#m칩dulos-y-paquetes",
    "title": "6 - Uso de c칩digo externo",
    "section": "M칩dulos y paquetes",
    "text": "M칩dulos y paquetes\nUn m칩dulo es un archivo de Python (por ejemplo, modulo.py) que contiene c칩digo que se puede reutilizar. En general, los m칩dulos definen funciones, clases y objetos que representan datos de distinta complejidad. Estos pueden ir desde estructuras simples, como una constante num칠rica, hasta otras m치s elaboradas, como una tabla de datos con columnas de diferentes tipos.\nUn paquete, por otro lado, es una colecci칩n de m칩dulos, generalmente interdependientes. En la pr치ctica, un paquete es una carpeta que contiene varios m칩dulos e, incluso, subpaquetes (carpetas con m칩dulos). Por lo general, los paquetes ofrecen un conjunto de herramientas m치s amplio que un m칩dulo individual. Adem치s, suelen distribuirse de forma que puedan ser instalados y utilizados por otros usuarios.\n\nPor qu칠 existen\nAs칤 como las funciones ayudan a reutilizar un programa sin repetir el c칩digo y los bucles permiten repetir la misma acci칩n muchas veces, los m칩dulos y paquetes tambi칠n permiten la reutilizaci칩n de c칩digo.\nDe este modo se evita, por ejemplo, tener que crear una funci칩n cada vez que la queremos usar. Simplemente la importamos o la 랎raemos de un m칩dulo o paquete. Se ahorra tiempo, se reduce la probabilidad de errores y se mejora la mantenibilidad del c칩digo.\nAdem치s, los paquetes y m칩dulos nos ayudan a mantener el c칩digo organizado y modular. Al dividir el c칩digo en 랋artes m치s peque침as y manejables, facilitamos su comprensi칩n y mantenimiento.\nPor 칰ltimo pero no menos importante, los m칩dulos paquetes nos permiten aprovechar el trabajo de otros. De esta manera, podemos hacer mucho m치s sin tener que programar todo desde cero.\n\n\n\n\n\n\nGlosario 游꿢\n\n\n\nLa documentaci칩n de Python 3 provee un glosario con definiciones precisas para t칠rminos relevantes en el universo de Python. Entre ellas, podemos destacar las de m칩dulo y paquete:\n\nM칩dulo: Un objeto que funciona como una unidad de organizaci칩n de c칩digo de Python. Los m칩dulos tienen un espacio de nombres (namespace) que contiene objetos de Python arbitrarios. Los m칩dulos se cargan en Python a trav칠s del proceso de importaci칩n.\nPaquete: Un m칩dulo de Python que puede contener subm칩dulos o, de forma recursiva, subpaquetes. T칠cnicamente, un paquete es un m칩dulo de Python con un atributo __path__.",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "6 - Uso de c칩digo externo"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#c칩mo-importar-c칩digo",
    "href": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#c칩mo-importar-c칩digo",
    "title": "6 - Uso de c칩digo externo",
    "section": "C칩mo importar c칩digo",
    "text": "C칩mo importar c칩digo\n\nLa sentencia import\nPara importar un m칩dulo usamos la sentencia import seguida del nombre del m칩dulo a importar.\nimport nombre\nDe esta manera, podemos importar el m칩dulo math que pertenece a la librer칤a est치ndar de Python.\n\nimport math\n\nLuego, podemos acceder a los objetos dentro del namespace math utilizando math.nombre_objeto. Por ejemplo, para usar la funci칩n sqrt(), que calcula la ra칤z cuadrada de un numero n, escribimos math.sqrt(n).\n\nmath.sqrt(16)\n\n4.0\n\n\nSi quisi칠ramos importar m치s de una m칩dulo, solo tenemos que agregar una nueva l칤nea con el import correspondiente. As칤, podemos tambi칠n importar el m칩dulo random que provee herramientas para generar n칰meros aleatorios.\n\nimport math\nimport random\n\n\nrandom.random() # n칰mero aleatorio entre 0 y 1\n\n0.02007022378062895\n\n\n\n\n\n\n\n\nLibrer칤a est치ndar de Python 游닄\n\n\n\nLa librer칤a est치ndar de Python es un conjunto de m칩dulos y paquetes incluidos por defecto con cualquier instalaci칩n oficial de Python, listos para usar sin necesidad de hacer instalaciones adicionales.\n\n\n\n\n\n\n\n\nDiferencias con R 游꿠\n\n\n\nA diferencia de la carga de paquetes en R, que pone a disposici칩n objetos del paquete en el ambiente global, el comando import math en Python no carga los objetos del m칩dulo math directamente en el ambiente donde se ejecuta; solo carga el m칩dulo en s칤.\nPara acceder a las funciones de math, es necesario hacerlo mediante el nombre del m칩dulo. Por este motivo, el siguiente bloque de c칩digo produce un error:\nimport math\nsqrt(16)\n\nNameError: name 'sqrt' is not defined\n\n\n\n\n\nListar nombres disponibles\nPara obtener un listado con los nombres de los objetos disponibles dentro de un m칩dulo, podemos usar la funci칩n dir().\ndir(math)\n['__doc__',\n '__file__',\n '__loader__',\n '__name__',\n '__package__',\n '__spec__',\n 'acos',\n 'acosh',\n 'asin',\n 'asinh',\n...\n 'tan',\n 'tanh',\n 'tau',\n 'trunc',\n 'ulp']\nSin embargo, en la pr치ctica, esta funci칩n no suele usarse demasiado para explorar los nombres disponibles en un m칩dulo.\nPor lo general, trabajamos en editores de c칩digo que muestran autom치ticamente la lista de variables disponibles en un m칩dulo.\nEn Positron, si escribimos math seguido de un punto (math.), el editor desplegar치 un listado de los objetos disponibles en dicho m칩dulo.\n\n\n\n\n\n\n\nImportar objetos de un m칩dulo\nLa flexibilidad en la carga de m칩dulos en Python permite importar uno o m치s objetos de un m칩dulo (o subm칩dulo) sin necesidad de importar el m칩dulo completo.\nLa sintaxis para traer un objeto de un m칩dulo llamado cosas es:\nfrom cosas import objeto\nDe este modo, podemos cargar la constante pi del m칩dulo math.\n\nfrom math import pi\n\nLuego, es posible acceder a la variable pi sin tener que pasar por el nombre del m칩dulo donde se define.\n\npi\n\n3.141592653589793\n\n\nEn nuestro caso, como anteriormente tambi칠n importamos el m칩dulo math, seguimos teniendo acceso a pi a trav칠s de math.\n\nprint(math.pi)\nprint(pi)\n\n3.141592653589793\n3.141592653589793\n\n\nPara importar varios objetos a la vez, se utiliza una sintaxis similar a la anterior, separando sus nombres con comas. A modo de ejemplo, importemos las funciones mean() y median() de otro m칩dulo est치ndar llamado statistics.\n\nfrom statistics import mean, median\n\n\nnumeros = [4, 5, 9, 30, 3, 8, 6]\n\nprint(\"La media es:\", mean(numeros))\nprint(\"La mediana es:\", median(numeros))\n\nLa media es: 9.285714285714286\nLa mediana es: 6\n\n\n\n\nImportar con alias\nPython no solo permite decidir que objetos importar de un m칩dulo, si no que tambi칠n hace posible asignar un alias al objeto o m칩dulo que se importa.\nPara un m칩dulo:\nimport modulo as alias\nY para un objeto dentro de un m칩dulo:\nfrom modulo import objeto as alias\nPodemos importar el m칩dulo math usando el alias mates:\n\nimport math as mates\n\nprint(mates.cos(mates.pi)) # coseno(pi)\n\n-1.0\n\n\nO importar la funcion sqrt con el nombre raiz:\n\nfrom math import sqrt as raiz\n\nraiz(81)\n\n9.0\n\n\n\n\n\n\n\n\nEl problema de importar todo\n\n\n\nPython permite cargar todos los objetos definidos en un m칩dulo o paquete directamente en el ambiente actual. La sintaxis es:\nfrom nombre import *\nEsta no es una pr치ctica recomendable, ya que no sabemos cu치ntos elementos se importar치n ni qu칠 conflictos podr칤an surgir entre los nombres definidos en el m칩dulo y los que ya tenemos en nuestro programa.\nEl uso de from nombre import * produce un efecto similar al de library(paquete) en R, pero en Python se desaconseja.",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "6 - Uso de c칩digo externo"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#m칩dulos-propios",
    "href": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#m칩dulos-propios",
    "title": "6 - Uso de c칩digo externo",
    "section": "M칩dulos propios",
    "text": "M칩dulos propios\nLa sintaxis para importar un m칩dulo propio, u objetos definidos en 칠l, es la misma que la que se utiliza para importar cualquier otro m칩dulo.\nSupongamos que tenemos un archivo llamado funciones.py con el siguiente contenido:\n\n\nfunciones.py\n\ndef es_par(n):\n    if n % 2 == 0:\n        return True\n    return False\n\n\ndef es_primo(n):\n    if n &lt;= 1:\n        return False\n\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n\n    return True\n\ny queremos usar las funciones es_par y es_primo en nuestro programa principal.\nUn aspecto fundamental a tener en cuenta para poder importar el m칩dulo funciones desde nuestro programa principal es su ubicaci칩n.\nSi el archivo funciones.py no se encuentra en alguno de los directorios que Python recorre al ejecutar la sentencia import, obtendremos un error.\nUno de los directorios en los que Python busca m칩dulos al importar es el directorio actual, es decir, aquel desde donde se ejecuta nuestro programa principal.\nSupongamos una carpeta (es decir, un proyecto) con la siguiente estructura de archivos:\nproyecto/                  # Carpeta\n較럭較 funciones.py           # M칩dulo\n較덕較 programa.py            # Programa principal\nAqu칤, programa.py es nuestro programa principal y contiene el siguiente c칩digo:\nimport funciones\n\nprint(funciones.es_par(12))\nprint(funciones.es_par(15))\n\nprint(funciones.es_primo(1))\nprint(funciones.es_primo(11))\nprint(funciones.es_primo(15))\nAl ejecutarlo, obtendremos la siguiente salida:\nTrue\nFalse\nFalse\nTrue\nFalse\nUn programa equivalente es el siguiente:\nfrom funciones import es_par, es_primo\n\nprint(es_par(12))\nprint(es_par(15))\n\nprint(es_primo(1))\nprint(es_primo(11))\nprint(es_primo(15))\nLa salida de este programa ser치 la misma que la del ejemplo anterior. La diferencia es que en este segundo programa se importan directamente las funciones es_par y es_primo desde el m칩dulo funciones, en lugar de importar el m칩dulo y luego acceder a las funciones a trav칠s de funciones.es_par y funciones.es_primo.",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "6 - Uso de c칩digo externo"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#paquetes-externos",
    "href": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#paquetes-externos",
    "title": "6 - Uso de c칩digo externo",
    "section": "Paquetes externos",
    "text": "Paquetes externos\nLa instalaci칩n de paquetes en Python se realiza mediante un sistema de gesti칩n de paquetes que se encarga de instalar y administrar paquetes.\nEstos paquetes se encuentran alojados en repositorios p칰blicos (o privados) a los que los gestores acceden para descargar y actualizar el software.\nEn el ecosistema de Python existe una gran variedad de sistemas de gesti칩n de paquetes, cuya adopci칩n depende de las necesidades de cada usuario o proyecto.\nEn cuanto a los repositorios, tambi칠n hay varias alternativas. Sin embargo, a diferencia de los gestores, el Python Package Index (PyPI) es el m치s utilizado por la gran mayor칤a de la comunidad.\n\n\n\n\n\n\nNota 游닇\n\n\n\nSe puede considerar al Python Package Index (PyPI) como el equivalente del Comprehensive R Archive Network (CRAN) en el ecosistema de R.\n\n\n\nInstalaci칩n de paquetes con pip\nLa instalaci칩n oficial de Python incluye un administrador de paquetes est치ndar llamado pip. Esta herramienta permite instalar y gestionar paquetes que no forman parte de la biblioteca est치ndar de Python.\nEs importante resaltar que pip se utiliza desde la terminal, no desde el int칠rprete de Python.\nEn Windows, es posible usar el comando where pip para localizar la ubicaci칩n del programa. Otra opci칩n es ejecutar pip --version, que muestra la versi칩n instalada de pip junto con la ruta de la instalaci칩n de Python a la que est치 vinculado.\nAntes de instalar paquetes con pip, es posible consultar qu칠 paquetes ya se encuentran instalados mediante esta herramienta con el comando list:\npip list\nEste comando muestra un listado con los paquetes instalados y sus respectivas versiones.\nC:\\Users\\tutoriales&gt;pip list\nPackage Version\n------- -------\npip     25.1.1\nComo a칰n no hemos instalado ning칰n paquete adicional a los que vienen con Python, solo se muestra pip.\nLa instalaci칩n de paquetes se hace con el comando install. Luego, para instalar el paquete NumPy hacemos:\npip install numpy\nDebajo se incluye una captura de la terminal de Windows donde se muestra la ejecuci칩n de los comandos antes mencionados y sus respectivas salidas:\n\n\n\n\n\n\n\n\n\n\n\nEjecutar pip como m칩dulo de Python\n\n\n\nLa herramienta pip es simplemente un m칩dulo de Python. Si tenemos m칰ltiples instalaciones de Python y/o pip, es posible que la versi칩n de pip a la que se accede en nuestra terminal no sea la que est치 asociada a la versi칩n de Python que queremos utilizar. Para evitar este tipo de problemas, se puede ejecutar el programa pip como un m칩dulo de Python. De este modo, la instalaci칩n de NumPy se ver칤a de la siguiente manera:\npython -m pip install numpy\nLa opci칩n -m le indica a Python que ejecute un m칩dulo como si fuera un programa dentro del int칠rprete de Python.\n\n\n\n\n\n\n\n\n쮼n qu칠 momento seleccionamos a PyPI? 游뱂\n\n\n\nNo es necesario que manualmente selccionemos a PyPI como repositorio de c칩digo. Por defecto, pip ya instala los paquetes desde PyPI.\n\n\n\n\nCreaci칩n de ambientes con venv\nCuando instalamos paquetes con la versi칩n de pip que se incluye por defecto en Python, estos se instalan de forma global. Esto no siempre representa un problema, pero suele complicarse cuando trabajamos en varios proyectos distintos.\nCada proyecto puede depender de diferentes paquetes, e incluso de diferentes versiones de Python. Si todos comparten una misma instalaci칩n global, es muy probable que aparezcan conflictos: algunos programas podr칤an dejar de funcionar o comportarse de manera incorrecta.\nUna soluci칩n ser칤a reinstalar todas las dependencias desde cero cada vez, pero esto implica una p칠rdida de tiempo innecesaria y, adem치s, no garantiza el correcto funcionamiento. La soluci칩n m치s aceptada por la comunidad es usar ambientes virtuales.\nUn ambiente virtual en Python permite aislar dependencias y paquetes para evitar conflictos entre proyectos.\nExisten distintas herramientas para crear y administrar ambientes virtuales; la que se incluye en la instalaci칩n oficial de Python es venv.\nPara crear un ambiente virtual con venv, primero debemos ubicarnos en la carpeta de nuestro proyecto y ejecutar en la terminal:\npython -m venv .venv\nEl nombre .venv es una convenci칩n adoptada por la comunidad, aunque puede usarse cualquier nombre v치lido de directorio.\nEste comando genera una carpeta con la siguiente estructura:\n.venv\n較럭較 Include\n較럭較 Lib\n較   較덕較 site-packages\n較       較럭較 pip\n較       較덕較 pip-25.1.1.dist-info\n較럭較 Scripts\n較   較럭較 Activate.ps1\n較   較럭較 activate\n較   較럭較 activate.bat\n較   較럭較 activate.fish\n較   較럭較 deactivate.bat\n較   較럭較 pip.exe\n較   較럭較 pip3.13.exe\n較   較럭較 pip3.exe\n較   較럭較 python.exe\n較   較덕較 pythonw.exe\n較덕較 pyvenv.cfg\nDentro de .venv/Lib/site-packages se almacenan los paquetes instalados en el ambiente, y en .venv/Scripts se encuentra el ejecutable de Python (python.exe) junto con otros scripts de utilidad.\nPara usar el int칠rprete de Python del ambiente e instalar paquetes en 칠l, es necesario activarlo con el comando:\n.venv\\Scripts\\activate\nAl hacerlo, se mostrar치 (.venv) al inicio de la l칤nea de la terminal.\nFinalmente, para desactivar el ambiente, basta con ejecutar:\ndeactivate\n\n\nEjemplo: NumPy\nNumPy es una paquete de Python especializado en el c치lculo num칠rico y el an치lisis de datos.\nProvee un nuevo tipo de objeto llamado array que permite representar colecciones de datos de un mismo tipo en varias dimensiones y funciones muy eficientes para su manipulaci칩n.\n\n\n\n\n\nPara crear un proyecto, un ambiente con venv e instalar NumPy, seguimos los siguientes pasos:\nmkdir proyecto          # Crear directorio\ncd proyecto             # Mover la terminal al directorio del proyecto\npython -m venv .venv    # Crear ambiente virtual llamado .venv\n.venv\\Scripts\\activate  # Activar ambiente\npip install numpy       # Instalar numpy en el ambiente del proyecto\npython                  # Iniciar el int칠rprete interactivo de Python\nEl siguiente video muestra los pasos realizados en la terminal de Windows:\n\n\n\n\n\nLos paquetes de Python suelen importarse utilizando un alias. En el caso de los m치s populares, como NumPy, la mayor칤a de la comunidad usa el alias np.\n\nimport numpy as np\n\narray = np.array([1, 2, 3, 4])\narray\n\narray([1, 2, 3, 4])\n\n\n\ntype(array)\n\nnumpy.ndarray\n\n\nLa propiedad .ndim nos devuelve el n칰mero de dimensiones del array.\n\narray.ndim\n\n1\n\n\nY .shape nos devuelve la 랁orma del array. Es decir, la cantidad de elementos por cada dimensi칩n. Se puede notar que el .shape de un array es una tupla.\n\narray.shape\n\n(4,)\n\n\nEn este caso creamos un array a partir de una lista, pero tambi칠n es posible crear arrays a partir de otros objetos.\nSi continuamos utilizando listas, el n칰mero de dimensiones del array va a depender del anidamiento que tengamos en las listas que utilizamos.\nA modo de ejemplo, podemos crear un array de dos dimensiones de la siguiente manera:\n\narray_2d = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])\narray_2d\n\narray([[1, 2, 3, 4],\n       [5, 6, 7, 8]])\n\n\n\nprint(array_2d.ndim)\nprint(array_2d.shape)\n\nUna de las caracter칤sticas m치s atractivas de NumPy es que las operaciones matem치ticas con arrays est치n vectorizadas, es decir, se realizan al nivel del arreglo.\n\nprint(array * 10)\nprint(array - 5)\nprint(array / 10)\nprint(array ** 2.4)\n\n[10 20 30 40]\n[-4 -3 -2 -1]\n[0.1 0.2 0.3 0.4]\n[ 1.          5.27803164 13.96661017 27.85761803]\n\n\nNumPy tambi칠n provee much칤simas funciones para hacer c치lculos com칰nmente realizados con los arrays.\n\nprint(np.mean(array))\nprint(np.median(array))\nprint(np.std(array))\nprint(np.exp(array))\n\n2.5\n2.5\n1.118033988749895\n[ 2.71828183  7.3890561  20.08553692 54.59815003]",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "6 - Uso de c칩digo externo"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#ap칠ndice",
    "href": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#ap칠ndice",
    "title": "6 - Uso de c칩digo externo",
    "section": "Ap칠ndice",
    "text": "Ap칠ndice\n\nAlgunos comandos de pip\n\n\n\n\n\n\n\nComando\nDescripci칩n\n\n\n\n\npip install pkg1 pkg2\nInstala uno o varios paquetes.\n\n\npip install pkg==1.2.3pip install pkg&gt;=1.0,&lt;=2.0\nInstala una versi칩n espec칤fica o un rango de versiones de un paquete.\n\n\npip install pkg --upgrade\nActualiza un paquete a la 칰ltima versi칩n disponible.\n\n\npip freeze\nMuestra todos los paquetes instalados y sus versiones en formato compatible con requirements.txt.\n\n\npip uninstall pkg\nDesinstala un paquete instalado.\n\n\npip show pkg\nMuestra informaci칩n detallada sobre un paquete (versi칩n, ubicaci칩n, dependencias).\n\n\npip help\nMuestra la ayuda general de pip o de un subcomando espec칤fico.\n\n\npip install -r dependencias.txt\nInstala todas las dependencias listadas en un archivo.\n\n\n\n\nEjemplos\npip install requests flask        # Instala varios paquetes\npip install numpy==1.25.0         # Instala una versi칩n exacta\npip install pandas&gt;=1.0,&lt;2.0      # Instala dentro de un rango de versiones\npip install requests --upgrade    # Actualiza un paquete\npip freeze                        # Lista paquetes instalados y versiones\npip uninstall flask               # Desinstala un paquete\npip show numpy                    # Muestra informaci칩n de un paquete\npip help install                  # Muestra ayuda sobre 'install'\npip install -r requirements.txt   # Instala dependencias desde un archivo",
    "crumbs": [
      "Teor칤a",
      "U1 - Programaci칩n en Python",
      "6 - Uso de c칩digo externo"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/01_fundamentos.html",
    "href": "teoria/02_programacion_funcional/01_fundamentos.html",
    "title": "1 - Fundamentos",
    "section": "",
    "text": "La programaci칩n funcional es un paradigma de programaci칩n que se centra en el uso de funciones puras y en concebir la computaci칩n como la evaluaci칩n de funciones. En lugar de dar instrucciones paso a paso que cambian variables o estados (como ocurre en la programaci칩n imperativa), la idea es construir programas a partir de funciones que transforman datos.\nExisten lenguajes dise침ados espec칤ficamente para la programaci칩n funcional (como Haskell), pero Python no es uno de ellos. Python es un lenguaje multiparadigma, lo que significa que nos permite combinar diferentes estilos de programaci칩n. Por este motivo, la programaci칩n funcional en Python no suele ser el enfoque principal, pero puede ser muy 칰til para escribir c칩digo m치s claro, conciso y f치cil de probar.",
    "crumbs": [
      "Teor칤a",
      "U2 - Programaci칩n Funcional",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/01_fundamentos.html#introducci칩n",
    "href": "teoria/02_programacion_funcional/01_fundamentos.html#introducci칩n",
    "title": "1 - Fundamentos",
    "section": "",
    "text": "La programaci칩n funcional es un paradigma de programaci칩n que se centra en el uso de funciones puras y en concebir la computaci칩n como la evaluaci칩n de funciones. En lugar de dar instrucciones paso a paso que cambian variables o estados (como ocurre en la programaci칩n imperativa), la idea es construir programas a partir de funciones que transforman datos.\nExisten lenguajes dise침ados espec칤ficamente para la programaci칩n funcional (como Haskell), pero Python no es uno de ellos. Python es un lenguaje multiparadigma, lo que significa que nos permite combinar diferentes estilos de programaci칩n. Por este motivo, la programaci칩n funcional en Python no suele ser el enfoque principal, pero puede ser muy 칰til para escribir c칩digo m치s claro, conciso y f치cil de probar.",
    "crumbs": [
      "Teor칤a",
      "U2 - Programaci칩n Funcional",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/01_fundamentos.html#funciones-puras",
    "href": "teoria/02_programacion_funcional/01_fundamentos.html#funciones-puras",
    "title": "1 - Fundamentos",
    "section": "Funciones puras",
    "text": "Funciones puras\nUna funci칩n es pura cuando su salida depende 칰nicamente de los valores de entrada y no produce ning칰n efecto secundario o colateral (side effect, en ingl칠s).\nLa funci칩n sumar, que calcula y devuelve la suma de dos n칰meros, es un ejemplo de funci칩n pura: su resultado depende solo de sus argumentos y no genera efectos colaterales.\n\ndef sumar(x, y):\n    return x + y\n\nsumar(3, 11)\n\n14\n\n\nEn cambio, la funci칩n agregar no es una funci칩n pura. Esto se debe a que modifica un objeto global, lo que se conoce como un efecto secundario. Adem치s, el valor de su salida no depende 칰nicamente de la entrada, sino tambi칠n de un estado global: la cantidad de elementos en lista.\n\nlista = []\n\ndef agregar(x):\n    \"\"\"Agrega el elemento `x` al final de `lista` y devuelve la longitud de `lista`\"\"\"\n    lista.append(x)\n    return len(lista)\n\n\nagregar(\"azucar\")\n\n1\n\n\n\nagregar(\"flores\")\n\n2\n\n\n\nagregar(\"colores\")\n\n3\n\n\n\nlista\n\n['azucar', 'flores', 'colores']\n\n\n\nEfectos secundarios\nUn efecto secundario (side effect) es cualquier cambio de estado observable que ocurre fuera del 치mbito local de una funci칩n. En otras palabras, se trata de una modificaci칩n del entorno externo de la funci칩n que va m치s all치 de simplemente devolver un valor.\nAlgunos ejemplos de side effects son:\n\nModificar una variable global o un objeto mutable.\nImprimir en la consola.\nEscribir en un archivo.\nRealizar una llamada a una API o a una base de datos.\n\nLas funciones con efectos secundarios pueden ser problem치ticas porque, al modificar elementos externos, hacen que el c칩digo sea impredecible y dif칤cil de probar.\nEn el ejemplo de la funci칩n agregar que creamos anteriormente, no es posible predecir el valor de salida para un valor de entrada determinado.\nPor eso, la programaci칩n funcional promueve el uso de funciones puras, que no producen efectos secundarios. De esta manera, con las mismas entradas siempre se obtiene la misma salida, logrando un c칩digo m치s confiable, predecible y sencillo de mantener.",
    "crumbs": [
      "Teor칤a",
      "U2 - Programaci칩n Funcional",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/01_fundamentos.html#sec-ciudadanos",
    "href": "teoria/02_programacion_funcional/01_fundamentos.html#sec-ciudadanos",
    "title": "1 - Fundamentos",
    "section": "Ciudadanos de primera clase",
    "text": "Ciudadanos de primera clase\nDefinamos otra funci칩n muy sencilla, restar, que calcula y devuelve la diferencia entre dos objetos.\n\ndef restar(x, y):\n    return x - y\n\nrestar(10, 5)\n\n5\n\n\nPodemos observar que esta funci칩n es un objeto de tipo function.\nprint(type(restar))\nprint(restar)\nrestar\n&lt;class 'function'&gt;\n&lt;function restar at 0x7f71cee62020&gt;\n&lt;function __main__.restar(x, y)&gt;\nAl imprimir la funci칩n, Python nos muestra su nombre y la direcci칩n de memoria donde est치 almacenada (en formato hexadecimal). En cambio, al mostrar su representaci칩n, obtenemos informaci칩n adicional: el m칩dulo en el que fue definida (en este caso __main__) y la lista de par치metros que recibe (x e y).\nDado que la funci칩n restar es un objeto de Python, podemos asignarla a una nueva variable y realizar una llamada utilizando esa nueva etiqueta en vez de la original.\n\nresta_especial = restar\nresta_especial(10, 5)\n\n5\n\n\nNotemos que resta_especial no es una nueva funci칩n; es solamente una nueva referencia a la funci칩n antes definida.\n\nresta_especial # muestra 'restar', no 'resta_especial'\n\n&lt;function __main__.restar(x, y)&gt;\n\n\n\nresta_especial is restar\n\nTrue\n\n\nEn Python, las funciones son ciudadanos de primera clase. Esto significa que son objetos, al igual que las cadenas o los n칰meros. Por lo tanto, todo lo que se puede hacer con una cadena o un n칰mero tambi칠n puede hacerse con una funci칩n.\nPor ejemplo, se pueden almacenar dentro de una lista junto con otros objetos de distintos tipos:\npopurri = [128, restar, None]\nprint(popurri[0])\nprint(popurri[1])\nprint(popurri[2])\n128\n&lt;function restar at 0x7f71cee62020&gt;\nNone\nIncluso una funci칩n puede ser almacenada como valor en un diccionario:\n\nmapeo = {\n    \"sum\": sumar,\n    \"sub\": restar,\n}\n\nLuego, se las puede usar de la siguiente manera:\n\nmapeo[\"sum\"](25, 4)\n\n29\n\n\n\nmapeo[\"sub\"](25, 4)\n\n21\n\n\n\nFunciones de orden superior\nComo cualquier objeto de Python, una funci칩n puede ser pasada como argumento de otra funci칩n. Debajo definimos dos funciones muy simples. Una imprime un mensaje de bienvenida y la otra uno de despedida.\n\ndef bienvenida():\n    print(\"춰Hola!\")\n\ndef despedida():\n    print(\"춰Chau!\")\n\n\nbienvenida()\ndespedida()\n\n춰Hola!\n춰Chau!\n\n\nSe puede definir otra funci칩n, que llamaremos externa (del ingl칠s outer function), que tiene un 칰nico par치metro interna. En su cuerpo, la funci칩n externa llama a la funci칩n interna y devuelve lo que sea que interna devuelva.\n\ndef externa(interna):\n    return interna()\n\nDe este modo, si llamamos a externa pas치ndole como argumento a bienvenida, se imprimir치 춰Hola!; y si lo hacemos con despedida, se imprimir치 춰Chau!.\n\nexterna(bienvenida)\n\n춰Hola!\n\n\n\nexterna(despedida)\n\n춰Chau!\n\n\nComo ni bienvenida ni despedida devuelven nada, lo mismo ocurre con externa en los dos ejemplos anteriores.\nA esta funci칩n podemos pasarle cualquier funci칩n que pueda ser llamada sin ning칰n argumento. Por ejemplo:\n\ndef crear_lista():\n    return []\n\nexterna(crear_lista)\n\n[]\n\n\nTambi칠n es posible que una funci칩n devuelva como resultado otra funci칩n. La funci칩n fabricar construye y devuelve una funci칩n que computa la suma de dos objetos.\n\ndef fabricar():\n    def interna(x, y):\n        return x + y\n    return interna\n\n# La llamada a 'fabricar' genera y devuelve una funci칩n\nf = fabricar()\n\n# La funci칩n obtenida puede ser tratada como cualquier otra funci칩n\nf(10, 15)\n\n25\n\n\nUna funci칩n que fabrica otras funciones puede recibir par치metros que luego son utilizados dentro de la funci칩n interna. En el bloque siguiente, la funci칩n crear_multiplicador recibe un par치metro x, que define el valor por el cual se multiplicar치 el argumento de la funci칩n interna que se devuelve.\n\ndef crear_multiplicador(x):\n    def interna(y):\n        return y * x\n    return interna\n\nAs칤, es posible crear funciones para duplicar, triplicar, etc.\n\nduplicar = crear_multiplicador(2)\ntriplicar = crear_multiplicador(3)\n\nprint(duplicar(5))\nprint(triplicar(5))\nprint(triplicar(18))\n\n10\n15\n54\n\n\n\n\n\n\n\n\nObservaci칩n 游\n\n\n\nCada vez que se invoca la funci칩n fabricar, se crea y devuelve una nueva funci칩n. Por eso, el resultado de la comparaci칩n en el siguiente bloque es False.\nf1 = fabricar()\nf2 = fabricar()\nprint(f1 is f2)\nFalse\n\n\n\n\n\n\n\n\nFunction factory 游낈\n\n\n\nA las funciones que crean y devuelven funciones se las conoce como f치brica de funciones, del ingl칠s function factory.\n\n\n\n\nAtributos de una funci칩n\nEn Python, las funciones tambi칠n cuentan con atributos, del mismo modo que otros objetos. En el siguiente ejemplo definimos la funci칩n resolvente, que recibe las constantes a, b y c de un polinomio de segundo grado, calcula sus ra칤ces usando la f칩rmula resolvente y las devuelve en una tupla.\n\ndef resolvente(a, b, c):\n    discriminante = b ** 2 - 4 * a * c\n    x0 = (-b + (discriminante) ** 0.5) / (2 * a)\n    x1 = (-b - (discriminante) ** 0.5) / (2 * a)\n\n    return x0, x1\n\nresolvente(2, 5, -3)\n\n(0.5, -3.0)\n\n\nA trav칠s del atributo especial __code__ es posible consultar ciertos atributos o detalles internos de una funci칩n:\n\nprint(resolvente.__code__.co_argcount) # Cantidad de argumentos\nprint(resolvente.__code__.co_name)     # Nombre de la funci칩n\nprint(resolvente.__code__.co_varnames) # Variables en el 치mbito local\n\n3\nresolvente\n('a', 'b', 'c', 'discriminante', 'x0', 'x1')\n\n\nAcceder a la informaci칩n de una funci칩n a trav칠s de __code__ puede resultar poco pr치ctico, ya que los atributos disponibles son t칠cnicos y no siempre coinciden directamente con lo que solemos necesitar (por ejemplo, obtener solo los nombres de los argumentos).\nPara facilitar esta tarea, la librer칤a est치ndar de Python incluye el m칩dulo inspect, que ofrece herramientas m치s claras e intuitivas para explorar los atributos y detalles de una funci칩n.\nA modo ilustrativo tomemos la funci칩n signature, que devuelve un objeto que representa la firma de la funci칩n resolvente.\n\nimport inspect\n\nfirma = inspect.signature(resolvente)\nfirma\n\n&lt;Signature (a, b, c)&gt;\n\n\nA partir de esta firma podemos consultar distintos aspectos de los par치metros, como sus valores por defecto:\n\nfirma.parameters[\"a\"].default # 'a' no tiene asignado un valor por defecto\n\ninspect._empty\n\n\nFinalmente, inspect tambi칠n permite acceder al c칩digo fuente de la funci칩n en forma de cadena de texto:\n\nprint(inspect.getsource(resolvente))\n\ndef resolvente(a, b, c):\n    discriminante = b ** 2 - 4 * a * c\n    x0 = (-b + (discriminante) ** 0.5) / (2 * a)\n    x1 = (-b - (discriminante) ** 0.5) / (2 * a)\n\n    return x0, x1",
    "crumbs": [
      "Teor칤a",
      "U2 - Programaci칩n Funcional",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/01_fundamentos.html#funciones-an칩nimas",
    "href": "teoria/02_programacion_funcional/01_fundamentos.html#funciones-an칩nimas",
    "title": "1 - Fundamentos",
    "section": "Funciones an칩nimas",
    "text": "Funciones an칩nimas\nLa programaci칩n funcional se basa en llamar funciones y pasarlas, por lo que, naturalmente, puede implicar definir muchas funciones. En Python, adem치s de usar def, podemos crear funciones an칩nimas de forma r치pida con una expresi칩n lambda.\nLa sintaxis es la siguiente:\nlambda &lt;argumentos&gt;: &lt;expresi칩n&gt;\ny devuelve como resultado una funci칩n an칩nima. Un ejemplo es el siguiente:\n\nlambda x, y: x + y\n\n&lt;function __main__.&lt;lambda&gt;(x, y)&gt;\n\n\nComo la funci칩n an칩nima que acabamos de crear no fue asignada a ninguna variable, ya no podemos usarla.\nUna posibilidad es invocarla inmediatamente al momento de su creaci칩n:\n\n(lambda x, y: x + y)(7, 15)\n\n22\n\n\nOtra opci칩n es asignarla a una variable para poder llamarla m치s adelante:\n\nsumar = lambda x, y: x + y\nsumar(7, 15)\n\n22\n\n\n\n\n\n\n\n\nAusencia de return\n\n\n\nA diferencia de las funciones definidas con def, las expresiones lambda no requieren la sentencia return. De forma impl칤cita, siempre devuelven el resultado de la 칰nica expresi칩n que contienen.\n\n\n\nUsos de funciones an칩nimas\nEn ninguno de los ejemplos anteriores parece que obtengamos alguna ventaja frente a usar def para definir una funci칩n. De hecho, da la impresi칩n de que estamos complicando el c칩digo innecesariamente.\nLo cierto es que las funciones an칩nimas no est치n pensadas para emplearse de la manera expuesta en nuestros ejemplos. Su uso principal es en operaciones simples y puntuales, cuando no resulta pr치ctico definir una funci칩n regular con def.\nUn caso de uso t칤pico de la funciones an칩nimas es cuando se tiene que pasar una funci칩n como argumento de otra funci칩n.\nSupongamos que queremos ordenar la siguiente lista de refranes seg칰n diferentes criterios.\n\nrefranes = [\n    \"Al mal tiempo, buena cara\",\n    \"Perro que ladra no muerde\",\n    \"A caballo regalado no se le miran los dientes\",\n    \"Cada loco con su tema\",\n    \"El que mucho abarca, poco aprieta\",\n    \"M치s vale p치jaro en mano que cien volando\",\n]\n\nPor defecto, la funci칩n sorted ordena una lista de cadenas de manera alfab칠tica.\n\nsorted(refranes)\n\n['A caballo regalado no se le miran los dientes',\n 'Al mal tiempo, buena cara',\n 'Cada loco con su tema',\n 'El que mucho abarca, poco aprieta',\n 'M치s vale p치jaro en mano que cien volando',\n 'Perro que ladra no muerde']\n\n\nSi quisi칠ramos ordenar los refranes por su longitud, podemos usar el argumento opcional key de sorted. Este argumento recibe una funci칩n que, aplicada a cada elemento, devuelve el valor a utilizar en el ordenamiento. En nuestro caso, basta con usar len, ya que solo nos interesa la cantidad de caracteres de cada cadena.\n\nsorted(refranes, key=len)\n\n['Cada loco con su tema',\n 'Al mal tiempo, buena cara',\n 'Perro que ladra no muerde',\n 'El que mucho abarca, poco aprieta',\n 'M치s vale p치jaro en mano que cien volando',\n 'A caballo regalado no se le miran los dientes']\n\n\nAs칤, obtenemos una lista donde las frases se ordenan seg칰n la cantidad de caracteres.\n쯏 si quisi칠ramos ordenarlos seg칰n la cantidad de palabras? Para eso necesitamos una funci칩n que reciba una cadena, la divida en palabras y cuente cu치ntas tiene.\nSin funciones an칩nimas podr칤amos hacer lo siguiente:\n\ndef contar_palabras(x):\n    return len(x.split())\n\nsorted(refranes, key=contar_palabras)\n\n['Al mal tiempo, buena cara',\n 'Perro que ladra no muerde',\n 'Cada loco con su tema',\n 'El que mucho abarca, poco aprieta',\n 'M치s vale p치jaro en mano que cien volando',\n 'A caballo regalado no se le miran los dientes']\n\n\nEn cambio, con una funci칩n an칩nima podemos escribir todo el programa en una sola l칤nea:\n\nsorted(refranes, key=lambda x: len(x.split()))\n\n['Al mal tiempo, buena cara',\n 'Perro que ladra no muerde',\n 'Cada loco con su tema',\n 'El que mucho abarca, poco aprieta',\n 'M치s vale p치jaro en mano que cien volando',\n 'A caballo regalado no se le miran los dientes']\n\n\nDe esta forma el c칩digo es m치s conciso y evitamos definir funciones 띿escartables que no volver치n a usarse.\n\n\n\n\n\n\nOrigen del nombre lambda 풭九\n\n\n\nEl t칠rmino lambda proviene del c치lculo lambda, un sistema formal de l칩gica matem치tica para expresar c치lculos basados en la abstracci칩n y aplicaci칩n de funciones.\nSe le dio ese nombre porque Alonzo Church, creador del c치lculo lambda en la d칠cada de 1930, us칩 la letra griega 풭 para denotar la operaci칩n de abstracci칩n de funciones.\n\n\n\n\n\n\n\n\nFunciones an칩nimas sin par치metros\n\n\n\nUna funci칩n lambda normalmente recibe uno o m칰ltiples par치metros, pero no es obligatorio, por lo que es posibile escribir una funci칩n an칩nima sin par치metros:\ncrear_numero_magico = lambda: 128\ncrear_numero magico()\n128\nLa funci칩n an칩nima crear_numero_magico es equivalente a la siguiente funci칩n\ndef f():\n    return 128",
    "crumbs": [
      "Teor칤a",
      "U2 - Programaci칩n Funcional",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/01_fundamentos.html#funciones-vari치dicas",
    "href": "teoria/02_programacion_funcional/01_fundamentos.html#funciones-vari치dicas",
    "title": "1 - Fundamentos",
    "section": "Funciones vari치dicas",
    "text": "Funciones vari치dicas\nLas funciones vari치dicas son funciones que pueden recibir una cantidad variable de argumentos.\nA lo largo de estos apuntes hemos utilizado funciones vari치dicas en tant칤simas oportunidades. Un ejemplo de funci칩n vari치dica es print, que acepta tantos argumentos posicionales como necesitemos.\n\nprint(\"Primero\")\n\nPrimero\n\n\n\nprint(\"Primero\", \"segundo\")\n\nPrimero segundo\n\n\n\nprint(\"Primero\", \"segundo\", \"tercero\")\n\nPrimero segundo tercero\n\n\nAfortunadamente, no solo las funciones built-in pueden ser vari치dicas, sino que tambi칠n podemos implementarlas nosotros mismos.\n\nCantidad variable de argumentos posicionales *args\nSupongamos que queremos una funci칩n que recibe una cantidad arbitraria de gustos de helado e imprime un mensaje como si lo agregase a un pedido. Por ejemplo:\narmar_pedido(\"Dulce de leche\")\nAgregando 'Dulce de leche'\narmar_pedido(\"Dulce de leche\", \"Sambay칩n\", \"Frutos del bosque\")\nAgregando 'Dulce de leche'\nAgregando 'Sambay칩n'\nAgregando 'Frutos del bosque'\nUna posible implementaci칩n para tal funci칩n es:\ndef armar_pedido(gusto_1=None, gusto_2=None, gusto_3=None):\n    if gusto_1 is not None:\n        print(f\"Agregando '{gusto_1}'\")\n    if gusto_2 is not None:\n        print(f\"Agregando '{gusto_2}'\")\n    if gusto_3 is not None:\n        print(f\"Agregando '{gusto_3}'\")\nAunque funciona en los ejemplos anteriores, esta soluci칩n est치 lejos de ser ideal. Requiere definir un argumento separado para cada gusto, asignarle un valor por defecto y luego verificar si es distinto de None antes de agregarlo al pedido.\nAdem치s, el c칩digo resulta repetitivo y restrictivo: solo permite un m치ximo de tres gustos.\nEn cambio, podemos crear una funci칩n que reciba una cantidad arbitraria de argumentos posicionales. Para ello se utiliza un argumento especial precedido por un asterisco (*), lo que le permite recibir una cantidad arbitraria de valores no nombrados.\n\ndef armar_pedido(*args):\n    for gusto in args:\n        print(f\"Agregando '{gusto}'\")\n\n\narmar_pedido(\"Dulce de leche\", \"Sambay칩n\", \"Frutos del bosque\", \"Menta granizada\")\n\nAgregando 'Dulce de leche'\nAgregando 'Sambay칩n'\nAgregando 'Frutos del bosque'\nAgregando 'Menta granizada'\n\n\n\narmar_pedido(\"gusto 1\", \"gusto 2\", \"gusto 3\", \"gusto 4\", \"gusto 5\", \"gusto 6\", \"gusto 7\")\n\nAgregando 'gusto 1'\nAgregando 'gusto 2'\nAgregando 'gusto 3'\nAgregando 'gusto 4'\nAgregando 'gusto 5'\nAgregando 'gusto 6'\nAgregando 'gusto 7'\n\n\nPor convenci칩n, este argumento suele escribirse como *args, aunque en realidad el nombre del argumento puede ser cualquiera que resulte apropiado. En nuestro caso, resulta m치s intuitivo usar *gustos, y la funci칩n quedar칤a as칤:\n\ndef armar_pedido(*gustos):\n    for gusto in gustos:\n        print(f\"Agregando '{gusto}'\")\n\n\narmar_pedido(\"gusto 1\", \"gusto 2\", \"gusto 3\", \"gusto 4\", \"gusto 5\", \"gusto 6\", \"gusto 7\")\n\nAgregando 'gusto 1'\nAgregando 'gusto 2'\nAgregando 'gusto 3'\nAgregando 'gusto 4'\nAgregando 'gusto 5'\nAgregando 'gusto 6'\nAgregando 'gusto 7'\n\n\n\n\n\n\n\n\nQu칠 hay debajo de *args 游댌\n\n\n\nPython agrupa autom치ticamente en una tupla los valores pasados mediante el argumento especial *args. Esto permite acceder a todos los argumentos como miembros de una colecci칩n inmutable.\ndef fun(*args):\n    print(len(args))\n    print(args)\n    print(type(args))\n\nfun(\"que\", \"es\", \"esto\", True, None)\n5\n('que', 'es', 'esto', True, None)\n&lt;class 'tuple'&gt;\n\n\n\n\nCantidad variable de argumentos nombrados **kwargs\nAs칤 como recibimos una cantidad arbitraria de argumentos posicionales, tambi칠n podemos recibir una cantidad arbitraria de argumentos nombrados.\nEn este caso, se utilizan dos aster칤scos (**) en vez de uno (*) en la definici칩n de los par치metros de la funci칩n.\nLa convenci칩n es usar el nombre **kwargs, pero tambi칠n es v치lido usar cualquier otro nombre que sea adecuado en nuestro contexto.\nComencemos por un ejemplo elemental, que solo imprime el objeto kwargs y su tipo:\n\ndef ejemplo(**kwargs):\n    print(kwargs)\n    print(type(kwargs))\n\nejemplo(nombre=\"Mariano\", apellido=\"P칠rez\")\n\n{'nombre': 'Mariano', 'apellido': 'P칠rez'}\n&lt;class 'dict'&gt;\n\n\nCuando usamos una cantidad variable de argumentos nombrados, Python los agrupa en un diccionario, ya que esta estructura permite asociar cada nombre con su valor de forma natural.\nDentro de la funci칩n, se puede manipular al diccionario kwargs como a cualquier otro diccionario de Python.\nImaginemos, por ejemplo, una funci칩n que registra informaci칩n de distintos departamentos. En este caso, no sabemos de antemano qu칠 atributos se van a proporcionar, pero s칤 sabemos que ciertos atributos deben contar con un valor por defecto si no se especifican.\n\ndef registrar_propiedad(**kwargs):\n    print(\"Diccionario original:\")\n    print(kwargs)\n\n    # Si no se especifica la cantidad de cocheras, se pone 0 por defecto\n    if \"cochera\" not in kwargs:\n        kwargs[\"cochera\"] = 0\n\n    # Si no se especifica la ciudad, se pone 'Desconocido' por defecto\n    if \"ciudad\" not in kwargs:\n        kwargs[\"ciudad\"] = \"Desconocido\"\n\n    return kwargs\n\nCuando no se especifician la cantidad de cocheras, la funci칩n nos devuelve un diccionario donde la cantidad de cocheras es 0.\n\ndatos = registrar_propiedad(ambientes=2, ciudad=\"Rosario\")\n\nprint(\"\\nDiccionario sanitizado\")\nprint(datos)\n\nDiccionario original:\n{'ambientes': 2, 'ciudad': 'Rosario'}\n\nDiccionario sanitizado\n{'ambientes': 2, 'ciudad': 'Rosario', 'cochera': 0}\n\n\nSi los atributos requeridos son especificados, se devuelve el diccionario sin cambios.\n\ndatos = registrar_propiedad(ambientes=2, ciudad=\"Santa Fe\", cochera=2)\n\nprint(\"\\nDiccionario sanitizado\")\nprint(datos)\n\nDiccionario original:\n{'ambientes': 2, 'ciudad': 'Santa Fe', 'cochera': 2}\n\nDiccionario sanitizado\n{'ambientes': 2, 'ciudad': 'Santa Fe', 'cochera': 2}\n\n\nY si se pasan otros atributos, tambi칠n se incluyen en la salida.\n\ndatos = registrar_propiedad(ambientes=4, dormitorios=2)\n\nprint(\"\\nDiccionario sanitizado\")\nprint(datos)\n\nDiccionario original:\n{'ambientes': 4, 'dormitorios': 2}\n\nDiccionario sanitizado\n{'ambientes': 4, 'dormitorios': 2, 'cochera': 0, 'ciudad': 'Desconocido'}\n\n\n\n\nCombinando *args y **kwargs\nLas funciones en Python pueden recibir simult치neamente una cantidad variable de argumentos posicionales y nombrados. Para lograrlo, se combinan *args y **kwargs. Es importante recordar que, al definir la funci칩n, *args debe colocarse antes que **kwargs, ya que los argumentos posicionales siempre se pasan antes que los nombrados.\n\ndef superfuncion(*args, **kwargs):\n    for arg in args:\n        print(f\"Me pasaron el argumento posicional '{arg}'\")\n\n    for key, value in kwargs.items():\n        print(f\"Me pasaron el argumento con nombre '{key}' y valor '{value}'\")\n\nsuperfuncion(True, 64, nombre=\"Elsa\", apellido=\"Pato\")\n\nMe pasaron el argumento posicional 'True'\nMe pasaron el argumento posicional '64'\nMe pasaron el argumento con nombre 'nombre' y valor 'Elsa'\nMe pasaron el argumento con nombre 'apellido' y valor 'Pato'\n\n\nSi se intenta pasar un argumento posicional (sin nombre) despu칠s de un argumento nombrado, obtendr칤amos un error:\nsuperfuncion(True, nombre=\"Elsa\", apellido=\"Pato\", 64)\n\n    superfuncion(True, nombre=\"Elsa\", apellido=\"Pato\", 64)\n                                                         ^\nSyntaxError: positional argument follows keyword argument\n\n\n\n\n\n\n\n쯏 para qu칠 me sirven? 游뱂\n\n\n\nA primera vista, los ejemplos de *args y **kwargs pueden dar la impresi칩n de que estas herramientas solo complican la escritura del c칩digo. Sin embargo, su verdadero valor aparece al trabajar en programas m치s complejos, donde se vuelven fundamentales para simplificar la l칩gica y aportar flexibilidad en la resoluci칩n de una gran variedad de problemas.\nYa llegaremos뵢n\n\n\n\n\n\n\n\nEs solo una convenci칩n 游뱋\n\n\n\nPara reforzar que los nombres *args y **kwargs son solamente una convenci칩n, podr칤amos escribir la funci칩n superfuncion como:\ndef superfuncion(*posicionales, **nombrados):\n    for arg in posicionales:\n        print(f\"Me pasaron el argumento posicional '{arg}'\")\n\n    for key, value in nombrados.items():\n        print(f\"Me pasaron el argumento con nombre '{key}' y valor '{value}'\")\ny funcionar칤a de igual modo.",
    "crumbs": [
      "Teor칤a",
      "U2 - Programaci칩n Funcional",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/01_fundamentos.html#closures",
    "href": "teoria/02_programacion_funcional/01_fundamentos.html#closures",
    "title": "1 - Fundamentos",
    "section": "Closures",
    "text": "Closures\nEn la Secci칩n3.1 vimos el siguiente ejemplo:\ndef crear_multiplicador(x):\n    def interna(y):\n        return y * x\n    return interna\n\nduplicar = crear_multiplicador(2)\ntriplicar = crear_multiplicador(3)\n\nprint(duplicar(5))\nprint(triplicar(5))\n10\n15\nLa funci칩n crear_multiplicador es una f치brica de funciones que devuelve otra funci칩n que se encarga de realizar la multiplicaci칩n. Lo interesante de esta implementaci칩n es que la funci칩n interna solo recibe uno de los dos valores necesarios para la multiplicaci칩n; el otro queda que fijado cuando se ejecuta la funci칩n externa crear_multiplicador.\nPara que duplicar y triplicar funcionen correctamente, ambas funciones internas deben conservar acceso al entorno en el que est치 definido el valor de x. Ese mecanismo, que permite a una tener acceso a las variables de su contexto incluso despu칠s de que la ejecuci칩n de la funci칩n externa haya conclu칤do, es precisamente lo que se conoce como un closure.\n\ndef crear_multiplicador(x):\n    def interna(y):\n        return y * x\n    return interna\n\nduplicar = crear_multiplicador(2)\ntriplicar = crear_multiplicador(3)\n\nprint(duplicar(5))\nprint(triplicar(5))\n\n10\n15\n\n\nEl siguiente ejemplo hace a칰n m치s evidente el funcionamiento de este mecanismo.\nDentro del cuerpo de la function factory externa, se define valor con el n칰mero 256. Luego, la funci칩n interna hace uso de esta variable valor dentro de print.\n\ndef externa():\n    valor = 256\n    def closure():\n        print(f\"춰El valor es: {valor}!\")\n    return closure\n\nrevelar_numero = externa()\nrevelar_numero()\n\n춰El valor es: 256!\n\n\nAunque desde fuera no podemos acceder directamente a valor:\nvalor\n\nNameError: name 'valor' is not defined\n\nla funci칩n interna s칤 puede hacerlo tantas veces como sea necesario:\n\nrevelar_numero()\nrevelar_numero()\nrevelar_numero()\n\n춰El valor es: 256!\n춰El valor es: 256!\n춰El valor es: 256!\n\n\nPara finalizar, veamos un ejemplo similar al anterior, pero donde el valor de la variable numero es desconocido para nosotros. Dicho valor se genera de manera aleatoria cuando se ejecuta la f치brica de funciones crear_funcion.\n\nimport random\n\ndef crear_funcion():\n    numero = random.randint(1, 1000)\n    def closure():\n        print(\"El valor es...\", numero)\n    return closure\n\nreveladora = crear_funcion()\n\nLuego, sin importar cu치ntas veces llamemos a reveladora, el mensaje ser치 siempre el mismo, ya que el valor de numero se defini칩 una sola vez en el momento en que se cre칩 la funci칩n.\n\nreveladora()\n\nEl valor es... 393\n\n\n\nreveladora()\n\nEl valor es... 393\n\n\n\n\n\n\n\n\nUna dosis de precisi칩n 游꿢游땸\n\n\n\nA menudo se dice que un closure es una funci칩n. As칤, en el siguiente ejemplo, duplicar ser칤a considerado un closure:\ndef crear_multiplicador(x):\n    def interna(y):\n        return y * x\n    return interna\n\nduplicar = crear_multiplicador(2)\nSin embargo, esa definici칩n es un tanto imprecisa. Un closure no es simplemente una funci칩n, sino el mecanismo que permite a las funciones acceder a las variables del entorno en el que fueron definidas, incluso cuando ese entorno ya dej칩 de existir (por ejemplo, despu칠s de que termina la ejecuci칩n de la funci칩n externa que las cre칩).\nUf 춰qu칠 complicado!\n\n\n\n\n\n\n\n\nobject of type 'closure' is not subsettable 游땻\n\n\n\nSi en R intentamos seleccionar filas o columnas de data sin haberle asignado un objeto previamente, obtendremos el siguiente error:\n\nError in data[1] : object of type 'closure' is not subsettable\n\nEsto ocurre porque data es en realidad una funci칩n en R. En este lenguaje, el tipo de los objetos funci칩n se denomina closure, haciendo referencia la capacidad que tienen las funciones de acceder a valores del ambiente donde fueron definidas.",
    "crumbs": [
      "Teor칤a",
      "U2 - Programaci칩n Funcional",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html",
    "href": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html",
    "title": "4 - Estrategias de evaluaci칩n 游빌",
    "section": "",
    "text": "En este breve cap칤tulo vamos a explorar las diferentes estrategias de evaluaci칩n que utiliza Python. En programaci칩n, una estrategia de evaluaci칩n es el conjunto de reglas que define c칩mo y cu치ndo se calculan las expresiones.\nAnalizaremos la evaluaci칩n inmediata (eager) y la evaluaci칩n perezosa (lazy), as칤 como la diferencia entre evaluaci칩n estricta y no estricta.",
    "crumbs": [
      "Teor칤a",
      "U2 - Programaci칩n Funcional",
      "4 - Estrategias de evaluaci칩n 游빌"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#introducci칩n",
    "href": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#introducci칩n",
    "title": "4 - Estrategias de evaluaci칩n 游빌",
    "section": "",
    "text": "En este breve cap칤tulo vamos a explorar las diferentes estrategias de evaluaci칩n que utiliza Python. En programaci칩n, una estrategia de evaluaci칩n es el conjunto de reglas que define c칩mo y cu치ndo se calculan las expresiones.\nAnalizaremos la evaluaci칩n inmediata (eager) y la evaluaci칩n perezosa (lazy), as칤 como la diferencia entre evaluaci칩n estricta y no estricta.",
    "crumbs": [
      "Teor칤a",
      "U2 - Programaci칩n Funcional",
      "4 - Estrategias de evaluaci칩n 游빌"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluaci칩n-estricta",
    "href": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluaci칩n-estricta",
    "title": "4 - Estrategias de evaluaci칩n 游빌",
    "section": "Evaluaci칩n estricta",
    "text": "Evaluaci칩n estricta\nSupongamos una funci칩n a la que le pasamos dos n칰meros a y b y nos devuelve una lista con todos los enteros entre a y b.\n\ndef intervalo(a, b):\n    return list(range(a, b + 1))\n\nintervalo(5, 12)\n\n[5, 6, 7, 8, 9, 10, 11, 12]\n\n\nPara cumplir su objetivo, esta funci칩n solo necesita los valores a y b. Pero, 쯤u칠 pasar칤a si por error le agregamos otro par치metro y despu칠s la llamamos sin darle ning칰n valor para ese par치metro?\n\ndef intervalo(a, b, c):\n    return list(range(a, b + 1))\n\nintervalo(5, 12)\n\n    intervalo(5, 12)\n    ~~~~~~~~~^^^^^^^\nTypeError: intervalo() missing 1 required positional argument: 'c'\n\nPython devuelve un error indicando que la funci칩n intervalo no puede ejecutarse porque falta un valor para el par치metro c. Aunque sepamos que dicho par치metro no se utiliza dentro de la funci칩n, Python igualmente exige que se le pase un valor.\nEsta exigencia se debe a que las funciones de Python se eval칰an bajo las reglas de la evaluaci칩n estricta. Bajo este enfoque, una funci칩n no puede producir un resultado si alguno de sus par치metros no est치 definido. Por eso, aun cuando el valor de c nunca se use en el cuerpo de la funci칩n, la ausencia de un valor para 칠l provoca un error.\nPara que la funci칩n se ejecute correctamente, basta con pasarle cualquier valor:\n\nintervalo(5, 12, None)\n\n[5, 6, 7, 8, 9, 10, 11, 12]\n\n\nEn Python, todas las llamadas a funciones siguen la estrategia de evaluaci칩n estricta, y esto no es algo que podamos modificar: forma parte del dise침o del lenguaje. De todas formas, como veremos m치s adelante, existen ciertas construcciones del propio lenguaje que aplican una estrategia de evaluaci칩n no estricta.",
    "crumbs": [
      "Teor칤a",
      "U2 - Programaci칩n Funcional",
      "4 - Estrategias de evaluaci칩n 游빌"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluaci칩n-inmediata",
    "href": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluaci칩n-inmediata",
    "title": "4 - Estrategias de evaluaci칩n 游빌",
    "section": "Evaluaci칩n inmediata",
    "text": "Evaluaci칩n inmediata\nOtro aspecto interesante al trabajar con funciones es el momento en que se eval칰an los argumentos que se pasan en las llamadas.\nTomemos de nuevo nuestra funci칩n original:\ndef intervalo(a, b):\n    return list(range(a, b + 1))\ny la siguiente llamada:\nintervalo(1 + 3, 5 + 12)\nLa pregunta es: 쯤u칠 pasa primero? 쯉e ejecuta la funci칩n intervalo y reci칠n ah칤 se resuelven las expresiones 1 + 3 y 5 + 12, o esas expresiones se calculan antes y luego se pasan sus resultados a la funci칩n?\nPara aclarar esta duda, en lugar de usar una suma directa podemos probar con una funci칩n que sume pero que, adem치s, imprima los argumentos que recibe. Del mismo modo, podemos modificar la funci칩n intervalo para que muestre un mensaje cuando sea llamada y as칤 ver con m치s claridad el orden en que ocurren las cosas.\n\ndef suma(x, y):\n    print(f\"suma(x={x}, y={y})\")\n    return x + y\n\n\ndef intervalo(a, b):\n    print(f\"intervalo(a={a}, b={b})\")\n    return list(range(a, b + 1))\n\nintervalo(suma(1, 3), suma(5, 12))\n\nsuma(x=1, y=3)\nsuma(x=5, y=12)\nintervalo(a=4, b=17)\n\n\n[4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]\n\n\nPor el orden en que aparecen los mensajes impresos, vemos que Python primero ejecut칩 la llamada suma(1, 3), luego suma(5, 12) y reci칠n despu칠s invoc칩 a la funci칩n intervalo, ya recibiendo los valores resultantes de las llamadas a suma.\nEn otras palabras, antes de llamar a intervalo, Python evalu칩 las expresiones que se pasaron como argumentos.\nA esta estrategia de evaluaci칩n, donde los argumentos se resuelven antes de ejecutar la funci칩n, se la conoce como evaluaci칩n inmediata, o por su nombre en ingl칠s, eager evaluation.",
    "crumbs": [
      "Teor칤a",
      "U2 - Programaci칩n Funcional",
      "4 - Estrategias de evaluaci칩n 游빌"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluaci칩n-no-estricta",
    "href": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluaci칩n-no-estricta",
    "title": "4 - Estrategias de evaluaci칩n 游빌",
    "section": "Evaluaci칩n no estricta",
    "text": "Evaluaci칩n no estricta\nEn contraste con la evaluaci칩n estricta, la evaluaci칩n no estricta es una estrategia en la que se puede determinar el resultado de una expresi칩n sin necesidad de evaluar todos sus argumentos u operandos.\nEn Python, solo tres tipos de expresiones siguen esta estrategia: and, or y las expresiones condicionales.\nEn los siguientes ejemplos, vamos a utilizar una funci칩n que imprime el valor ingresado y lo devuelve:\n\ndef f(x):\n    print(f\"el valor es {x}\")\n    return x\n\n\nExpresi칩n and\nUna expresi칩n and devuelve True 칰nicamente cuando todos sus argumentos son verdaderos. Por eso, en el siguiente ejemplo, se imprime el valor es True antes de obtener el resultado de la operaci칩n and, ya que fue necesario evaluar la funci칩n f.\n\nTrue and f(True)\n\nel valor es True\n\n\nTrue\n\n\nEn cambio, cuando el primero de sus argumentos es False, se puede anticipar que el resultado de la operaci칩n and ser치 False, sin necesidad de evaluar el segundo argumento. Por este motivo, la funci칩n f no se ejecuta en ninguno de los siguientes casos, al punto de que podemos pasarle argumentos absurdos:\n\nFalse and f(True)\n\nFalse\n\n\n\nFalse and f(1 / 0)\n\nFalse\n\n\nEn Python, este mecanismo tambi칠n se conoce como cortocircuito. Al detectar que el resultado de la operaci칩n ya est치 decidido con el primer argumento, el int칠rprete 띾orta camino y decide no evaluar al resto.\n\n\nExpresi칩n or\nEl mecanismo de cortocircuito tambi칠n funciona para el operador or:\n\n# El primer argumento es True, el resultado es True\nTrue or f(True)\n\nTrue\n\n\n\n# El primer arugmento es False, hay que evaluar el segundo para determinar el resultado\nFalse or f(True)\n\nel valor es True\n\n\nTrue\n\n\nLas mismas reglas de evaluaci칩n se mantienen en expresiones m치s complejas. En el siguiente ejemplo, es necesario ejecutar f(True) para poder resolver el primer or, pero no hace falta evaluar 1 + [2, 3], que provocar칤a un error, porque el valor True ya alcanza para determinar el resultado de toda la operaci칩n.\n\nFalse or f(True) or (1 + [2, 3])\n\nel valor es True\n\n\nTrue\n\n\n\n\nExpresiones condicionales\nFinalmente, esta estrategia de evaluaci칩n no estricta (o cortocircuito) tambi칠n se aplica en las expresiones condicionales.\nEn el siguiente ejemplo, la expresi칩n devuelve 10 porque la condici칩n es verdadera, sin necesidad de ejecutar f(20).\n\n10 if True else f(20)\n\n10\n\n\nEn cambio, esta segunda expresi칩n s칤 requiere que se ejecute la llamada en la parte else de la expresi칩n.\n\n10 if False else f(20)\n\nel valor es 20\n\n\n20",
    "crumbs": [
      "Teor칤a",
      "U2 - Programaci칩n Funcional",
      "4 - Estrategias de evaluaci칩n 游빌"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluaci칩n-perezosa",
    "href": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluaci칩n-perezosa",
    "title": "4 - Estrategias de evaluaci칩n 游빌",
    "section": "Evaluaci칩n perezosa",
    "text": "Evaluaci칩n perezosa\nPara terminar, veamos una 칰ltima estrategia de evaluaci칩n: la evaluaci칩n perezosa (en ingl칠s, lazy evaluation).\nPartimos de una funci칩n que recibe un valor, imprime un mensaje con 칠l y lo devuelve:\ndef identidad(x):\n    print(\"Devuelvo\", x)\n    return x\nSi usamos map para aplicar la funci칩n identidad a los n칰meros 0, 1, 2 y 3:\nmap_obj = map(identidad, range(4))\nmap_obj\n&lt;map at 0x7fedb41f3cd0&gt;\nvemos que se crea un objeto map, pero no aparece ning칰n mensaje de la funci칩n identidad. Esto pasa porque map no ejecuta la funci칩n sobre los elementos hasta que realmente hace falta.\nPor ejemplo, si convertimos el objeto map en una lista, reci칠n ah칤 se produce la evaluaci칩n:\nlista = list(map_obj)\nDevuelvo 0\nDevuelvo 1\nDevuelvo 2\nDevuelvo 3\nlista\n[0, 1, 2, 3]\nA esta estrategia, en la que se retrasa la evaluaci칩n de las expresiones hasta el 칰ltimo momento posible, se la llama evaluaci칩n perezosa o lazy evaluation.\nDe manera similar, filter tambi칠n utiliza una estrategia de evaluaci칩n perezosa. Reci칠n cuando queremos materializar los elementos se aplica la funci칩n de filtro.\n\ndef es_multiplo_5(x):\n    print(f\"x={x}\")\n    return x % 5  ==0\n\nfilter_obj = filter(es_multiplo_5, [12, 10, 8, 5, 125, 55, 11, 9])\n\n\nfor x in filter_obj:\n    print(f\"El numero {x} es m칰ltiplo de 5\")\n\nx=12\nx=10\nEl numero 10 es m칰ltiplo de 5\nx=8\nx=5\nEl numero 5 es m칰ltiplo de 5\nx=125\nEl numero 125 es m칰ltiplo de 5\nx=55\nEl numero 55 es m칰ltiplo de 5\nx=11\nx=9\n\n\nComo se puede ver, la funci칩n es_multiplo_5 se ejecut칩 para cada valor de la lista num칠rica, pero filter 칰nicamente devolvi칩 aquellos que efectivamente son m칰ltiplos de 5.\nEn el pr칩ximo y 칰ltimo cap칤tulo vamos a explorar los generadores, un tipo especial de iterador que implementa una estrategia de evaluaci칩n perezosa y nos permite recorrer secuencias incluso potencialmente infinitas.",
    "crumbs": [
      "Teor칤a",
      "U2 - Programaci칩n Funcional",
      "4 - Estrategias de evaluaci칩n 游빌"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/05_generadores.html",
    "href": "teoria/02_programacion_funcional/05_generadores.html",
    "title": "5 - Generadores 游빌",
    "section": "",
    "text": "En este cap칤tulo vamos a introducirnos en los generadores, tanto en las funciones como en las expresiones generadoras. A diferencia de las funciones regulares, que devuelven un resultado con return, los generadores no devuelven un 칰nico resultado, sino que van entregando valores de a uno a medida que se lo solicita. Cada vez que se entrega un valor, la ejecuci칩n queda en pausa y se conserva el estado de las variables, de modo que puede reanudarse m치s adelante. De este modo, los generadores resultan ideales para definir iteradores y trabajar con grandes vol칰menes de datos sin necesidad de almacenarlos al mismo tiempo en memoria.",
    "crumbs": [
      "Teor칤a",
      "U2 - Programaci칩n Funcional",
      "5 - Generadores 游빌"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/05_generadores.html#introducci칩n",
    "href": "teoria/02_programacion_funcional/05_generadores.html#introducci칩n",
    "title": "5 - Generadores 游빌",
    "section": "",
    "text": "En este cap칤tulo vamos a introducirnos en los generadores, tanto en las funciones como en las expresiones generadoras. A diferencia de las funciones regulares, que devuelven un resultado con return, los generadores no devuelven un 칰nico resultado, sino que van entregando valores de a uno a medida que se lo solicita. Cada vez que se entrega un valor, la ejecuci칩n queda en pausa y se conserva el estado de las variables, de modo que puede reanudarse m치s adelante. De este modo, los generadores resultan ideales para definir iteradores y trabajar con grandes vol칰menes de datos sin necesidad de almacenarlos al mismo tiempo en memoria.",
    "crumbs": [
      "Teor칤a",
      "U2 - Programaci칩n Funcional",
      "5 - Generadores 游빌"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/05_generadores.html#funciones-generadoras",
    "href": "teoria/02_programacion_funcional/05_generadores.html#funciones-generadoras",
    "title": "5 - Generadores 游빌",
    "section": "Funciones generadoras",
    "text": "Funciones generadoras\nUna funci칩n generadora se define igual que una funci칩n com칰n con def, pero en lugar de devolver un valor con return, lo hace con yield.\nCuando se ejecuta una funci칩n generadora, no se ejecuta el c칩digo en su cuerpo de manera inmediata ni se obtiene un resultado. En cambio, se obtiene un generador que luego puede entregar valores.\n\ndef gen():\n    yield \"춰Resultado!\"\n\ng = gen()\ng\n\n&lt;generator object gen at 0x7f90c8738ca0&gt;\n\n\nComo los generadores son iteradores (ver Iterables e iteradores), se puede usar next para obtener el siguiente valor de manera manual:\n\nnext(g)\n\n'춰Resultado!'\n\n\nEste primer ejemplo es demasiado simple para apreciar la verdadera utilidad de los generadores. Si solo necesit치ramos devolver un 칰nico valor, bastar칤a con usar una funci칩n com칰n.\nLa ventaja de los generadores est치 en que pueden entregar varios valores de a uno, a medida que se los solicita, mientras conservan el estado de las variables.\nVeamos ahora una segunda funci칩n generadora, esta vez con dos instrucciones yield en lugar de una. En la primera llamada a next, obtenemos \"Primer resultado\".\n\ndef gen():\n    yield \"Primer resultado\"\n    yield \"Segundo resultado\"\n\ng = gen()\nnext(g)\n\n'Primer resultado'\n\n\nY en la segunda llamada a next el generador entrega el segundo valor: \"Segundo resultado\".\n\nnext(g)\n\n'Segundo resultado'\n\n\nEn la primera llamada a next, la funci칩n se ejecuta hasta llegar a la primera instrucci칩n yield. All칤 el generador devuelve un valor y suspende su ejecuci칩n. Con la segunda llamada, la ejecuci칩n se reanuda desde ese punto y contin칰a hasta encontrar el siguiente yield, entregando otro valor.\nAhora bien, 쯤u칠 ocurre si llamamos a next cuando el generador ya entreg칩 todos los valores disponibles?\nnext(g)\n\n    next(g)\n    ~~~~^^^\nStopIteration\n\nUna vez que un generador se agota, cualquier llamada adicional a next elevar치 la excepci칩n StopIteration, que se침ala que ya no quedan valores por producir.\nPara observar con m치s detalle c칩mo funciona la ejecuci칩n y suspensi칩n en los generadores, vamos a implementar una funci칩n que mantiene el estado de una variable num칠rica e imprime un mensaje justo antes de cada yield.\n\ndef generador(x):\n    print(\"Recib칤 el valor\", x)\n\n    x = x + 18\n    print(\"Entrego el valor\", x)\n    yield x\n\n    x = x - 5\n    print(\"Esto una entrega siguiente, devuelvo el valor\", x)\n    yield x\n\n    print(\"Este mensaje est치 bien al final\")\n\ng = generador(7)\n\nComo se puede observar, la ejecuci칩n de la funci칩n generadora no imprimi칩 ning칰n mensaje, ya que esto no ejecuta el cuerpo de la funci칩n. Reci칠n al pedir el primer valor se ejecutan los dos print previos al primer yield. Adem치s, el valor inicial 7 se incrementa en 18 y luego es devuelto.\n\nnext(g)\n\nRecib칤 el valor 7\nEntrego el valor 25\n\n\n25\n\n\nEn la segunda llamada a next(g) se imprime un mensaje y se entrega el valor 25 - 5 = 20. Esto muestra que el generador conserva el estado de las variables: en lugar de usar el valor original de x, utiliza el valor actualizado en la entrega anterior.\n\nnext(g)\n\nEsto una entrega siguiente, devuelvo el valor 20\n\n\n20\n\n\nSin embargo, el print al final, debajo del 칰ltimo yield, a칰n no se ejecut칩. Para eso, usamos next(g) nuevamente.\nnext(g)\n\nEste mensaje est치 bien al final\n\n    next(g)\n    ~~~~^^^\nStopIteration\n\nComo no hay ning칰n otro valor por entregar, se imprime el mensaje y luego se obtiene la excepci칩n StopIteration.\n\nEjemplo 1: Secuencia de n칰meros naturales\nLos generadores tambi칠n permiten crear secuencias infinitas. Para ello, basta con escribir un bucle infinito dentro de la funci칩n generadora. Esto no representa un problema, ya que el generador produce un valor a la vez, 칰nicamente cuando se le solicita.\n\ndef numeros_naturales():\n    n = 0\n    while True:\n        yield n\n        n = n + 1\n\nsecuencia = numeros_naturales()\n\nLuego, pedimos los valores de a uno:\n\nprint(next(secuencia))\nprint(next(secuencia))\nprint(next(secuencia))\nprint(next(secuencia))\nprint(next(secuencia))\n\n0\n1\n2\n3\n4\n\n\nVale la pena notar que un generador no tiene longitud, ya que podr칤a ser infinito, ni permite acceder a sus elementos por 칤ndice. Solo sabe c칩mo producir el pr칩ximo valor, sin conocer de antemano cu치ntos quedan por generar.\nlen(secuencia)\n\n    len(secuencia)\n    ~~~^^^^^^^^^^\nTypeError: object of type 'generator' has no len()\n\nsecuencia[0]\n\n    secuencia[0]\n    ~~~~~~~~~^^^\nTypeError: 'generator' object is not subscriptable\n\nComo los generadores son iteradores, podemos recorrerlos con un bucle for. En el caso de secuencias infinitas, es necesario usar un break para evitar que el bucle nunca termine.\n\ni = 0\nfor n in secuencia:\n    print(n)\n    i += 1\n    if i &gt;= 5:\n        break\n\n5\n6\n7\n8\n9\n\n\nSi nuestro 칰nico objetivo es recorrer los elementos del generador, podemos inicializarlo directamente en el bucle for.\n\nfor n in numeros_naturales():\n    print(n)\n    if n &gt;= 7:\n        break\n\n0\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\nEjemplo 2: Secuencia de Fibonacci\nLas secuencias infinitas no se limitan a los n칰meros naturales. Como los generadores conservan el estado de las variables dentro de la funci칩n, tambi칠n pueden usarse para producir otras secuencias, como la de Fibonacci.\n\\[\nF_n =\n\\begin{cases}\n0 & \\text{si } n = 0 \\\\\n1 & \\text{si } n = 1 \\\\\nF_{n-1} + F_{n - 2} & \\text{si } n \\ge 2 \\\\\n\\end{cases}\n\\]\n\ndef fibonacci():\n    a = 0\n    b = 1\n    while True:\n        yield a\n        a, b = b, a + b\n\nSi queremos los primeros 10 n칰meros de la secuencia, podemos utilizar un bucle for que ejecuta next(g) 10 veces seguidas.\n\ng = fibonacci()\nfor _ in range(10):\n    print(next(g))\n\n0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n\n\nAl volver a pedir un nuevo valor a nuestro generador, este contin칰a avanzando en la secuencia de Fibonacci.\n\nnext(g)\n\n55\n\n\n\nnext(g)\n\n89\n\n\n\n\nEjemplo 3: Promedio acumulado\nEn este ejemplo se muestra un generador que procesa una secuencia num칠rica y va devolviendo el promedio acumulado a medida que avanza.\nComo los valores se producen bajo demanda, en memoria solo se conserva la secuencia original y el 칰ltimo promedio calculado.\n\ndef promedio_acumulado(numeros):\n    numerador = 0\n    for i, numero in enumerate(numeros):\n        numerador += numero\n        yield numerador / (i + 1)\n\nvalores = [2, 4, 9, 1, 7, 11] # Supongamos una lista muy grande de n칰meros\n\nfor m in promedio_acumulado(valores):\n    print(f\"Promedio acumulado: {m:.2f}\")\n\nPromedio acumulado: 2.00\nPromedio acumulado: 3.00\nPromedio acumulado: 5.00\nPromedio acumulado: 4.00\nPromedio acumulado: 4.60\nPromedio acumulado: 5.67",
    "crumbs": [
      "Teor칤a",
      "U2 - Programaci칩n Funcional",
      "5 - Generadores 游빌"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/05_generadores.html#expresiones-generadoras",
    "href": "teoria/02_programacion_funcional/05_generadores.html#expresiones-generadoras",
    "title": "5 - Generadores 游빌",
    "section": "Expresiones generadoras",
    "text": "Expresiones generadoras\nLas expresiones generadoras, del ingl칠s generator expressions, proveen una manera concisa para construir generadores. Se parecen a las list comprehensions, pero usan par칠ntesis en vez de corchetes.\nSupongamos una lista de n칰meros cualquiera y que usamos una list comprehension para obtener el triple de cada n칰mero.\n\nnumeros = [3, 14, 2, 7, 1, 28]\ntriples = [n * 3 for n in numeros]\n\nprint(numeros)\nprint(triples)\n\n[3, 14, 2, 7, 1, 28]\n[9, 42, 6, 21, 3, 84]\n\n\nLa expresi칩n generadora equivalente es la siguiente:\n\ntriples = (n * 3 for n in numeros)\ntriples\n\n&lt;generator object &lt;genexpr&gt; at 0x7f90c87702b0&gt;\n\n\nComo todo generador, implementa la estrategia de evaluaci칩n perezosa. Esto quiere decir que el triple de cada n칰mero se calcula justo en el momento en que se solicita, no antes.\nAs칤, podemos obtener los valores mediante un bucle:\n\nfor n in triples:\n    print(n)\n\n9\n42\n6\n21\n3\n84\n\n\nUn generador creado con una expresi칩n generadora es equivalente a uno definido con una funci칩n generadora. En ambos casos, si se intenta obtener un valor de un generador ya agotado, se producir치 un error.\nnext(triples)\n\n    next(triples)\n    ~~~~^^^^^^^^^\nStopIteration\n\nY al intentar obtener una lista a partir de un generador agotado, obtendremos una lista vac칤a.\n\nlist(triples)\n\n[]\n\n\nAdem치s de ser perezosos, los generadores son de 칰nico uso. Sus valores se generan a medida que se solicitan y no se guardan en memoria, de modo que, una vez consumidos, no es posible volver a iterarlos.\nEsta aparente limitaci칩n es en realidad una ventaja. A diferencia de una lista, que construye y guarda todos sus elementos en memoria, un generador solo define una receta para producirlos cuando se necesiten. En el siguiente ejemplo se muestra c칩mo esto impacta en el consumo de memoria frente a una lista.\n\nimport sys\n\n# Enteros divisibles por 3 o 5 entre 1 y 10,000,000\nlista = [n for n in range(1, 10_000_001) if n % 3 == 0 or n % 5 == 0]\ngenexpr = (n for n in range(1, 10_000_001) if n % 3 == 0 or n % 5 == 0)\n\nprint(sys.getsizeof(lista))   # bytes\nprint(sys.getsizeof(genexpr)) # bytes\n\n39064728\n200\n\n\nY a partir de ambos objetos se puede computar, por ejemplo, la suma.\n\nsum(lista), sum(genexpr)\n\n(23333341666668, 23333341666668)\n\n\nEn resumen, mientras que una lista es una colecci칩n de valores, un generador es una receta para producir valores.",
    "crumbs": [
      "Teor칤a",
      "U2 - Programaci칩n Funcional",
      "5 - Generadores 游빌"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/05_generadores.html#sec-iteradores",
    "href": "teoria/02_programacion_funcional/05_generadores.html#sec-iteradores",
    "title": "5 - Generadores 游빌",
    "section": "Iterables e iteradores",
    "text": "Iterables e iteradores\nA lo largo de este cap칤tulo dijimos varias veces que los generadores son iteradores, aunque todav칤a no definimos con precisi칩n qu칠 significa eso.\nLo que s칤 sabemos es que un objeto es iterable cuando puede recorrerse con un bucle for. En Python, las listas, las cadenas y los diccionarios son ejemplos de objetos iterables, por lo que los siguientes bloques de c칩digo funcionan sin problemas:\nfor i in [10, 55, 2]:\n    print(i + 5)\n\nfor c in \"palabras\":\n    print(c.upper())\n\nfor k in {\"nombre\": \"Juan\", \"apellido\": \"P칠rez\"}:\n    print(k)\nComo ya vimos que una lista se puede recorrer con un bucle, podr칤amos preguntarnos si tambi칠n es posible usar la funci칩n next para obtener su siguiente elemento.\n\nnums = [-10, 0, 10]\n\nnext(nums)\n\n    next(nums)\n    ~~~~^^^^^^\nTypeError: 'list' object is not an iterator\n\nSin embargo, al hacerlo obtenemos un TypeError que indica que la lista no es un iterador. Lo mismo ocurre si intentamos usar next directamente con una cadena o un diccionario.\nnext(\"palabra\")\n\n    next(\"palabra\")\n    ~~~~^^^^^^^^^^^\nTypeError: 'str' object is not an iterator\n\nnext({\"nombre\": \"Juan\", \"apellido\": \"P칠rez\"})\n\n    next({\"nombre\": \"Juan\", \"apellido\": \"P칠rez\"})\n    ~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: 'dict' object is not an iterator\n\nEl error que aparece al usar next sobre una lista, una cadena o un diccionario muestra que no basta con que un objeto sea iterable para poder aplicarle next directamente.\nLo que sucede, es que, en realidad, nuestra definici칩n inicial de iterable era incompleta: un objeto es iterable cuando puede generar un iterador a partir de 칠l.\nLuego, es el iterador que conoce c칩mo producir los valores uno a uno y, por eso, es sobre el iterador (y no sobre el iterable) que Python puede aplicar next para avanzar en la secuencia.\nPara crear un iterador a partir de un iterable usamos iter.\n\niterador = iter(nums)\niterador\n\n&lt;list_iterator at 0x7f90c87337f0&gt;\n\n\nY ahora s칤 es posible avanzar a trav칠s de los elementos de la lista original:\n\nnext(iterador)\n\n-10\n\n\n\nnext(iterador)\n\n0\n\n\n\nnext(iterador)\n\n10\n\n\nnext(iterador)\n\n    next(iterador)\n    ~~~~^^^^^^^^^^\nStopIteration\n\nPor 칰ltimo, vale la pena se침alar que los iteradores solo pueden construirse a partir de objetos iterables. Por ejemplo, un n칰mero entero no es iterable, por lo que no es posible obtener un iterador a partir de 칠l.\niter(10)\n\n    iter(10)\n    ~~~~^^^^\nTypeError: 'int' object is not iterable\n\nEn resumen, en Python solo se puede iterar sobre iteradores. Un objeto es iterable cuando puede generar un iterador a partir de 칠l, y es este 칰ltimo el que sabe c칩mo devolver los elementos uno a uno mediante la funci칩n next. Cuando ya no quedan m치s valores por producir, el iterador eleva la excepci칩n StopIteration.\nLos generadores son un caso particular de iteradores: producen sus valores bajo demanda y mantienen el estado entre llamadas.\nFinalmente, al usar un bucle for con un iterable, todo este mecanismo ocurre de forma autom치tica: Python crea el iterador por nosotros y se encarga de avanzar en la secuencia hasta agotarla.",
    "crumbs": [
      "Teor칤a",
      "U2 - Programaci칩n Funcional",
      "5 - Generadores 游빌"
    ]
  },
  {
    "objectID": "recursos/tutoriales/tutorial_02.html",
    "href": "recursos/tutoriales/tutorial_02.html",
    "title": "F치brica de decoradores",
    "section": "",
    "text": "La funci칩n fabrica_decoradores se usa como decorador, pero es en realidad una f치brica de decoradores. Si el argumento fun es una funci칩n, tal como suecede cuando se usa @fabrica_decoradores, se devuelve fun ya decorada.\nEn cambio, si fun no es una funci칩n, como cuando se usa @fabrica_decoradores(mensaje='Procesando datos con'), se devuelve el decorador.\nimport time\n\ndef fabrica_decoradores(fun=None, mensaje=\"Ejecutando funci칩n\"):\n    def decorador(fun):\n        def wrapper(*args, **kwargs):\n            print(f\"{mensaje}: {fun.__name__}\")\n            inicio = time.perf_counter()\n            resultado = fun(*args, **kwargs)\n            fin = time.perf_counter()\n            print(f\"{fun.__name__} termin칩 en {fin - inicio:.3f} s\")\n            return resultado\n        return wrapper\n\n    # Si fun es callable (i.e., algo que se puede llamar, una funcion), el decorador\n    # se llam칩 sin argumentos. Por lo tanto, aplicamos el decorador manualmente.\n    if callable(fun):\n        return decorador(fun)\n\n    # Caso contrario, se us칩 con par칠ntesis y solo se devuelve el decorador.\n    # Python luego lo aplica autom치ticamente.\n    return decorador\nEjemplos\n# Ejemplo de uso SIN argumentos\n@fabrica_decoradores\ndef tarea_simple():\n    time.sleep(0.2)\n    print(\"Hecho.\")\n\ntarea_simple()\nEjecutando funci칩n: tarea_simple\nHecho.\ntarea_simple termin칩 en 0.210 s\n# Ejemplo de uso CON argumentos\n@fabrica_decoradores(mensaje=\"Procesando datos con\")\ndef tarea_compleja():\n    time.sleep(2.2)\n    print(\"Listo.\")\n\ntarea_compleja()\nProcesando datos con: tarea_compleja\nListo.\ntarea_compleja termin칩 en 2.216 s",
    "crumbs": [
      "Recursos",
      "Tutoriales",
      "F치brica de decoradores"
    ]
  },
  {
    "objectID": "recursos/ejercicios/03_oop/index.html",
    "href": "recursos/ejercicios/03_oop/index.html",
    "title": "U3 - Programaci칩n Orientada a Objetos",
    "section": "",
    "text": "class Contador:\n    def __init__(self, valor_inicial=0):\n        self._inicial = valor_inicial   # se guarda para poder reiniciar\n        self._valor = valor_inicial     # estado actual del contador\n\n    def incrementar(self, paso=1):\n        self._valor += paso\n        return self._valor\n\n    def decrementar(self, paso=1):\n        self._valor -= paso\n        return self._valor\n\n    def valor(self):\n        return self._valor\n\n    def reiniciar(self):\n        self._valor = self._inicial\n        return self._valor\n\n    def __str__(self):\n        return f\"Contador(valor={self._valor})\"\n\n\nc = Contador()\nc.incrementar(5)    # 5\nc.decrementar(2)    # 3\nc.reiniciar()\nprint(c.valor())",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U3 - Programaci칩n Orientada a Objetos"
    ]
  },
  {
    "objectID": "recursos/ejercicios/03_oop/index.html#contador",
    "href": "recursos/ejercicios/03_oop/index.html#contador",
    "title": "U3 - Programaci칩n Orientada a Objetos",
    "section": "",
    "text": "class Contador:\n    def __init__(self, valor_inicial=0):\n        self._inicial = valor_inicial   # se guarda para poder reiniciar\n        self._valor = valor_inicial     # estado actual del contador\n\n    def incrementar(self, paso=1):\n        self._valor += paso\n        return self._valor\n\n    def decrementar(self, paso=1):\n        self._valor -= paso\n        return self._valor\n\n    def valor(self):\n        return self._valor\n\n    def reiniciar(self):\n        self._valor = self._inicial\n        return self._valor\n\n    def __str__(self):\n        return f\"Contador(valor={self._valor})\"\n\n\nc = Contador()\nc.incrementar(5)    # 5\nc.decrementar(2)    # 3\nc.reiniciar()\nprint(c.valor())",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U3 - Programaci칩n Orientada a Objetos"
    ]
  },
  {
    "objectID": "recursos/ejercicios/03_oop/index.html#magia-para-programadores",
    "href": "recursos/ejercicios/03_oop/index.html#magia-para-programadores",
    "title": "U3 - Programaci칩n Orientada a Objetos",
    "section": "2 Magia para programadores",
    "text": "2 Magia para programadores\nimport math\n\nclass Pocion:\n    def __init__(self, color, volumen):\n        self.color = color\n        self.volumen = volumen\n\n    def mezclar(self, other):\n        # NOTE: Se puede hacer de manera m치s sencilla\n        volumen_total = self.volumen + other.volumen\n        w1 = self.volumen / volumen_total\n        w2 = other.volumen / volumen_total\n\n        color = [math.ceil(c1 * w1 + c2 * w2) for c1, c2 in zip(self.color, other.color)]\n        return Pocion(color=color, volumen=volumen_total)\n\n\n\nfelix_felicis = Pocion([255, 255, 255],  7)\npocion_multijugos = Pocion([51, 102, 51], 12)\nnueva_pocion = felix_felicis.mezclar(pocion_multijugos)\n\nnueva_pocion.color # Devuelve [127, 159, 127]\nnueva_pocion.volumen # Devuelve 19",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U3 - Programaci칩n Orientada a Objetos"
    ]
  },
  {
    "objectID": "recursos/ejercicios/03_oop/index.html#mensaje-secreto",
    "href": "recursos/ejercicios/03_oop/index.html#mensaje-secreto",
    "title": "U3 - Programaci칩n Orientada a Objetos",
    "section": "3 Mensaje secreto",
    "text": "3 Mensaje secreto\nclass Cifrado:\n    def __init__(self, original, alternativo):\n        if len(original) != len(alternativo):\n            raise ValueError(\n                f\"len(original) != len(alternativo) ({len(original)} vs {len(alternativo)})\"\n            )\n\n        # Se usan tuplas para poder usar .index\n        self.original = tuple(original) \n        self.alternativo = tuple(alternativo)\n\n\n    def codificar(self, texto):\n        # Version corta:\n        caracteres_codificados = [\n            self.alternativo[self.original.index(caracter)] for caracter in texto\n        ]\n\n        # Version larga\n        caracteres_codificados = []\n        for caracter in texto:\n            indice = self.original.index(caracter)\n            caracteres_codificados.append(self.alternativo[indice])\n        return \"\".join(caracteres_codificados)\n\n    def decodificar(self, texto):\n        # An치logo al m칠todo anterior (pero usando generador)\n        return \"\".join(self.original[self.alternativo.index(caracter)] for caracter in texto)\n\n\nalfabeto = \"abcdefghijklmnopqrstuvwxyz\"\nalfabeto_mezclado = \"etaoinshrdlucmfwypvbgkjqxz\"\n\nmi_cifrado = Cifrado(alfabeto, alfabeto_mezclado)\n\nmi_cifrado.codificar(\"abc\")    # =&gt; \"eta\"\nmi_cifrado.codificar(\"xyz\")    # =&gt; \"qxz\"\nmi_cifrado.codificar(\"aeiou\")  # =&gt; \"eirfg\"\n\nmi_cifrado.decodificar(\"eta\")    # =&gt; \"abc\"\nmi_cifrado.decodificar(\"qxz\")    # =&gt; \"xyz\"\nmi_cifrado.decodificar(\"eirfg\")  # =&gt; \"aeiou\"",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U3 - Programaci칩n Orientada a Objetos"
    ]
  },
  {
    "objectID": "recursos/ejercicios/03_oop/index.html#real-envido",
    "href": "recursos/ejercicios/03_oop/index.html#real-envido",
    "title": "U3 - Programaci칩n Orientada a Objetos",
    "section": "4 Real envido",
    "text": "4 Real envido\nclass ManoDeTruco:\n    def __init__(self, cartas):\n        self.cartas = cartas\n\n    def comparar_con(self, other):\n        if self.puntos() &gt;= other.puntos():\n            return self\n        return other\n\n    def puntos(self):\n        n_altas = len([carta for carta in self.cartas if carta &gt;= 10])\n        if n_altas == 3:\n            # Si solo se tienen cartas altas, los puntos son 20.\n            return 20\n        elif n_altas == 2:\n            # Si se tienen 2 cartas altas los puntos son 20 + la carta que no esta en ese conjunto.\n            return 20 + min(self.cartas)\n        elif n_altas == 1:\n            # Si 1 cartas alta, los puntos son 20 + la suma de las dos cartas bajas\n            return 20 + sum(sorted(self.cartas)[:2])\n        # Caso contrario, es la suma de las dos cartas mas altas + 20\n        return 20 + sum(sorted(self.cartas)[-2:])\n\n\nmano1 = ManoDeTruco([7, 5, 6])\nmano2 = ManoDeTruco([4, 11, 2])\n\nmano1.comparar_con(mano2)\n\nmano1.puntos()\nmano2.puntos()",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U3 - Programaci칩n Orientada a Objetos"
    ]
  },
  {
    "objectID": "recursos/ejercicios/03_oop/index.html#la-muestra-infinita",
    "href": "recursos/ejercicios/03_oop/index.html#la-muestra-infinita",
    "title": "U3 - Programaci칩n Orientada a Objetos",
    "section": "5 La muestra infinita",
    "text": "5 La muestra infinita\nclass Muestra:\n    def __init__(self, iterable):\n        self._datos = list(iterable) # guardo el iterable en una lista\n\n    def agregar(self, x):\n        self._datos.append(x)\n\n    def n(self):\n        return len(self._datos)\n\n    def suma(self):\n        return sum(self._datos)\n\n    def media(self):\n        n = self.n()\n        return self.suma() / n\n\n    def varianza(self, muestral=False):\n        \"\"\"Varianza de la muestra\n\n        - Poblacional (por defecto): sum((xi - 풮)^2) / n\n        - Muestral (muestral=True):   sum((xi - x팫)^2) / (n - 1)\n        \"\"\"\n\n        n = self.n()\n        mu = self.media()\n        ssd = sum((x - mu) ** 2 for x in self._datos)  # suma de cuadrados\n\n        if muestral:\n            denom = n - 1\n        else:\n            denom = n\n\n        # otra opci칩n\n        # denom = n - 1 if muestral else n\n\n        return ssd / denom\n\n    @property\n    def valores(self):\n        \"\"\"Copia inmutable de los datos (evita exponer el interno).\"\"\"\n        return tuple(self._datos)\n\n\n\nif __name__ == \"__main__\":\n    m = Muestra([10, 12, 13, 15])\n    m.agregar(20)\n    print(m.n()) # 5\n    print(m.suma()) # 70\n    print(m.media()) # 14.0\n    print(m.varianza()) # 11.6\n    print(m.varianza(muestral=True)) # 14.5\n    print(m.valores)  # (10, 12, 13, 15, 20)",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U3 - Programaci칩n Orientada a Objetos"
    ]
  },
  {
    "objectID": "recursos/ejercicios/03_oop/index.html#orden-en-el-laboratorio",
    "href": "recursos/ejercicios/03_oop/index.html#orden-en-el-laboratorio",
    "title": "U3 - Programaci칩n Orientada a Objetos",
    "section": "6 춰Orden en el laboratorio!",
    "text": "6 춰Orden en el laboratorio!\nclass Experimento:\n    total_creados = 0  # atributo de clase compartido por **todas** las instancias\n\n    def __init__(self, nombre, responsable=None):\n        # Actualizamos el contador global y usamos ese valor como id\n        Experimento.total_creados += 1\n        self.id = Experimento.total_creados\n        self.nombre = nombre\n        self.responsable = responsable\n\n    @classmethod\n    def desde_dict(cls, datos):\n        # crea experimento a partir de diccionario\n        return cls(datos.get(\"nombre\"), responsable=datos.get(\"responsable\"))\n\n    def __repr__(self):\n        argumentos = (\n            f\"id={self.id}\",\n            f\"nombre={self.nombre}\",\n            f\"responsable={self.responsable}\",\n        )\n        return f\"Experimento({', '.join(argumentos)})\"\n\n\n\ne1 = Experimento(\"Piloto A\", responsable=\"Dolores\")\ne2 = Experimento.desde_dict({\"nombre\": \"Piloto B\", \"responsable\": \"Ana\"})\n\nprint(Experimento.total_creados)  # 2\nprint(repr(e1))                   # Experimento(id=1, nombre='Piloto A', responsable='Dolores')\nprint(e2)                         # usa __repr__",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U3 - Programaci칩n Orientada a Objetos"
    ]
  },
  {
    "objectID": "recursos/ejercicios/03_oop/index.html#sensores-descalibrados",
    "href": "recursos/ejercicios/03_oop/index.html#sensores-descalibrados",
    "title": "U3 - Programaci칩n Orientada a Objetos",
    "section": "7 Sensores descalibrados",
    "text": "7 Sensores descalibrados\nimport random\n\nclass Sensor:\n    def __init__(self, nombre):\n        self.nombre = nombre\n        self._offset = 0.0  # por defecto, sin correcci칩n\n\n    def calibrar(self, offset):\n        self._offset = float(offset)\n\n    def leer(self):\n        raise NotImplementedError(\"Esta clase no implementa 'leer'. Use una subclase.\")\n\n\nclass SensorTemperatura(Sensor):\n    # simula un sensor de temperatura (춿C)\n    def leer(self):\n        base = random.uniform(18, 28)    # simulaci칩n de medici칩n\n        return base + self._offset       # correcci칩n por calibraci칩n\n\n\nclass SensorHumedad(Sensor):\n    # Simula un sensor de humedad (%)\n    def leer(self):\n        base = random.uniform(30, 70)    # simulaci칩n de medici칩n\n        return base + self._offset       # correcci칩n por calibraci칩n\n\n\ndef promedio_lecturas(sensores, n=5):\n    \"\"\"\n    Toma n lecturas de cada sensor y devuelve un dict {nombre: promedio}.\n    Funciona con cualquier subclase de Sensor que implemente 'leer' (polimorfismo).\n    \"\"\"\n\n    if n &lt;= 0:\n        print(\"n debe ser un entero positivo (&gt;= 1).\")\n\n    resultados = {}\n\n    # para cada sensor\n    for sensor in sensores:\n        # n lecturas por sensor\n        acumulado = 0\n        for _ in range(n):\n            acumulado += sensor.leer() # sumamos los resultados de las lecturas\n        resultados[sensor.nombre] = acumulado / n\n    return resultados\n\n\n# --- Ejemplo de uso ---\nif __name__ == \"__main__\":\n    random.seed(0)  # reproducibilidad\n\n    t = SensorTemperatura(\"T1\")\n    h = SensorHumedad(\"H1\")\n\n    t.calibrar(0.5)\n\n    promedios = promedio_lecturas([t, h], n=3)\n    print(promedios)",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U3 - Programaci칩n Orientada a Objetos"
    ]
  },
  {
    "objectID": "recursos/ejercicios/03_oop/index.html#python-para-matem치ticos",
    "href": "recursos/ejercicios/03_oop/index.html#python-para-matem치ticos",
    "title": "U3 - Programaci칩n Orientada a Objetos",
    "section": "8 Python para matem치ticos",
    "text": "8 Python para matem치ticos\ndef mcd(a, b):\n    # Puede ser math.gcd\n    while b != 0:\n        a, b = b, a % b\n    return abs(a)\n\n\nclass Fraccion:\n    def __init__(self, numerador, denominador):\n        if denominador == 0:\n            raise ValueError(\"El denominador no puede ser cero\")\n        self.numerador = numerador\n        self.denominador = denominador\n        self._simplificar()\n\n    def _simplificar(self):\n        divisor = mcd(self.numerador, self.denominador)\n        self.numerador = self.numerador // divisor\n        self.denominador = self.denominador // divisor\n\n        # Normalizamos: denominador siempre positivo\n        if self.denominador &lt; 0:\n            self.numerador *= -1\n            self.denominador *= -1\n\n    def __str__(self):\n        return f\"{self.numerador}/{self.denominador}\"\n\n    def __repr__(self):\n        return f\"Fraccion({self.numerador}, {self.denominador})\"\n\n    def __add__(self, other):\n        if not isinstance(other, Fraccion):\n            return NotImplemented\n        num = self.numerador * other.denominador + other.numerador * self.denominador\n        den = self.denominador * other.denominador\n        return Fraccion(num, den)\n\n    def __sub__(self, other):\n        if not isinstance(other, Fraccion):\n            return NotImplemented\n        num = self.numerador * other.denominador - other.numerador * self.denominador\n        den = self.denominador * other.denominador\n        return Fraccion(num, den)\n\n    def __mul__(self, other):\n        if not isinstance(other, Fraccion):\n            return NotImplemented\n        num = self.numerador * other.numerador\n        den = self.denominador * other.denominador\n        return Fraccion(num, den)\n\n    def __truediv__(self, other):\n        if not isinstance(other, Fraccion):\n            return NotImplemented\n\n        if other.numerador == 0:\n            raise ZeroDivisionError(\"No se puede dividir por cero\")\n\n        num = self.numerador * other.denominador\n        den = self.denominador * other.numerador\n        return Fraccion(num, den)\n\n\nf1 = Fraccion(4, 5)\nf2 = Fraccion(1, 8)\n\nprint(f1 + f2)   # 37/40\nprint(f1 - f2)   # 27/40\nprint(f1 * f2)   # 1/10\nprint(f1 / f2)   # 32/5\n\n# Operandos no soportados:\nf1 + 2\nf1 - 2\nf1 * 2\nf1 / 2\n\n\nf1 / Fraccion(2, 1) # Pero esto s칤 :')\nf1 * Fraccion(5, 1) # Pero esto s칤 :')",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U3 - Programaci칩n Orientada a Objetos"
    ]
  },
  {
    "objectID": "recursos/ejercicios/03_oop/index.html#tiempo-al-tiempo",
    "href": "recursos/ejercicios/03_oop/index.html#tiempo-al-tiempo",
    "title": "U3 - Programaci칩n Orientada a Objetos",
    "section": "9 Tiempo al tiempo 낍",
    "text": "9 Tiempo al tiempo 낍\nDOM = {\n    1: 31,  # Enero\n    2: 28,  # Febrero (29 en a침o bisiesto)\n    3: 31,  # Marzo\n    4: 30,  # Abril\n    5: 31,  # Mayo\n    6: 30,  # Junio\n    7: 31,  # Julio\n    8: 31,  # Agosto\n    9: 30,  # Septiembre\n    10: 31, # Octubre\n    11: 30, # Noviembre\n    12: 31, # Diciembre\n}\n\nclass Date:\n    def __init__(self, year, month, day):\n        self.year = year\n        self.month = month\n        self.day = day\n\n    @property\n    def year(self):\n        return self._year\n\n    @year.setter\n    def year(self, value):\n        assert isinstance(value, int)\n        assert value &gt; 0\n        self._year = value\n\n    @property\n    def month(self):\n        return self._month\n\n    @month.setter\n    def month(self, value):\n        assert isinstance(value, int)\n        assert 1 &lt;= value &lt;= 12\n        self._month = value\n\n    @property\n    def day(self):\n        return self._day\n\n    @day.setter\n    def day(self, value):\n        assert isinstance(value, int)\n        assert 1 &lt;= value &lt;= Date._dias_del_mes(self.year, self.month)\n        self._day = value\n\n    @classmethod\n    def from_str(cls, value):\n        parts = value.split(\"-\")\n        assert len(parts) == 3\n        year, month, day = map(int, map(lambda x: x.lstrip(\"0\"), parts))\n\n        assert year &gt; 0\n        assert 1 &lt;= month &lt;= 12\n        assert 1 &lt;= day &lt;= Date._dias_del_mes(year, month)\n\n        return cls(year=year, month=month, day=day)\n\n    def __eq__(self, other):\n        if isinstance(other, type(self)):\n            return self.year == other.year and self.month == other.month and self.day == other.day\n        return False\n\n    def __neq__(self, other):\n        return not self == other\n\n    def __gt__(self, other):\n        if self.year &gt; other.year:\n            return True\n        elif self.year == other.year:\n            if self.month &gt; other.month:\n                return True\n            elif self.month == other.month:\n                return self.day &gt; other.day\n        return False\n\n    def __ge__(self, other):\n        return (self &gt; other) or (self == other)\n\n    def __lt__(self, other):\n        if self.year &lt; other.year:\n            return True\n        elif self.year == other.year:\n            if self.month &lt; other.month:\n                return True\n            elif self.month == other.month:\n                return self.day &lt; other.day\n        return False\n\n    def __le__(self, other):\n        return (self &lt; other) or (self == other)\n\n    def __str__(self):\n        year = str(self.year).rjust(4, \"0\")\n        month = str(self.month).rjust(2, \"0\")\n        day = str(self.day).rjust(2, \"0\")\n\n        return f\"{year}-{month}-{day}\"\n\n    def __repr__(self):\n        return f\"Date(year={self.year}, month={self.month}, day={self.day})\"\n\n    @staticmethod\n    def _es_bisiesto(year):\n        # Divisible por 4,\n        # excepto que sea divisible por 100,\n        # salvo que tambien sea divisibles por 400\n        return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)\n\n    @staticmethod\n    def _dias_del_mes(year, month):\n        if month == 2 and Date._es_bisiesto(year):\n            return 29\n        return DOM[month]\n\n\nd = Date(1995, 11, 6)\nd\nstr(d)\n\n\nDate.from_str(\"2025-05-06\")\n\nd = Date(2025, 11, 12)\nd2 = Date(2025, 11, 12)\nd3 = Date(2025, 11, 13)\n\nd == d3\nd &gt; d3\nd3 &gt; d\nd &lt; d3\n\nDate.from_str(\"2025-11-28\")\n\nDate(2000, 2, 29)\n\n# Como 'Date' soporta la operaci칩n de comparaci칩n, podemos usar sorted\nfechas = (Date(2022, 2, 28), Date(2025, 1, 31), Date(1816, 7, 9), Date(1810, 5, 25))\nsorted(fechas)\n\n# O max ... o min\nmax(fechas)\nmin(fechas)\n\n# NOTA: Los m칠todos est치ticos podr칤an ser tranquilamente funciones auxiliares.",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U3 - Programaci칩n Orientada a Objetos"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html",
    "title": "U2 - Programaci칩n funcional",
    "section": "",
    "text": "# 1\n# * Usa variable global\n# * Modifica variable global\n# * El resultado no depende de los valores de entrada\n\ndef incrementar(contador):\n    return contador + 1\n\n\n# 2\n# * El resultado no depende de la entrada, sino del momento de la llamada.\n# Se puede obtener una funci칩n similar, pero no exactamente igual.\nimport datetime\n\ndef hora(dt):\n    return dt.hour\n\nhora(datetime.datetime.now())\n\n# 3\n# Ac치 no estoy tan seguro, supongo que lo que es no puro no es `add_time``, sino que es\n# `increment_time`. Yo (tomi) propondr칤a\n\ndef add_time(time, hours, minutes, seconds):\n    return time + datetime.timedelta(hours=hours, minutes=minutes, seconds=seconds)\n\nadd_time(datetime.datetime(2025, 8, 12), 2, 12, 44)\n\n# 4\n# Modifica objeto global\n# Salida s칤 depende de la entrada, eso est치 OK.\n# Una alternativa posible\ndef registar_nombre(listado, nombre):\n    return listado + [nombre]\n\nhistorial_de_nombres = []\nhistorial_de_nombres = registar_nombre(historial_de_nombres, \"Mateo\")\nhistorial_de_nombres = registar_nombre(historial_de_nombres, \"Camila\")\nhistorial_de_nombres = registar_nombre(historial_de_nombres, \"Victoria\")\nhistorial_de_nombres\n\n# 5\n# No es pura, no signific que sea mala per se.\n# El problema es que su salida no depende de sus valores\n# Si cambia una variable fuera de ella, cammbia el resultado.\n# Una alternativa\ndef verificar_limite(valor, limite):\n    if valor &gt; limite:\n        return \"Excede el l칤mite\"\n    return \"Dentro del l칤mite\"\n\nLIMITE_MAXIMO = 100\nverificar_limite(88, LIMITE_MAXIMO)",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programaci칩n funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#trasfromando-funciones",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#trasfromando-funciones",
    "title": "U2 - Programaci칩n funcional",
    "section": "",
    "text": "# 1\n# * Usa variable global\n# * Modifica variable global\n# * El resultado no depende de los valores de entrada\n\ndef incrementar(contador):\n    return contador + 1\n\n\n# 2\n# * El resultado no depende de la entrada, sino del momento de la llamada.\n# Se puede obtener una funci칩n similar, pero no exactamente igual.\nimport datetime\n\ndef hora(dt):\n    return dt.hour\n\nhora(datetime.datetime.now())\n\n# 3\n# Ac치 no estoy tan seguro, supongo que lo que es no puro no es `add_time``, sino que es\n# `increment_time`. Yo (tomi) propondr칤a\n\ndef add_time(time, hours, minutes, seconds):\n    return time + datetime.timedelta(hours=hours, minutes=minutes, seconds=seconds)\n\nadd_time(datetime.datetime(2025, 8, 12), 2, 12, 44)\n\n# 4\n# Modifica objeto global\n# Salida s칤 depende de la entrada, eso est치 OK.\n# Una alternativa posible\ndef registar_nombre(listado, nombre):\n    return listado + [nombre]\n\nhistorial_de_nombres = []\nhistorial_de_nombres = registar_nombre(historial_de_nombres, \"Mateo\")\nhistorial_de_nombres = registar_nombre(historial_de_nombres, \"Camila\")\nhistorial_de_nombres = registar_nombre(historial_de_nombres, \"Victoria\")\nhistorial_de_nombres\n\n# 5\n# No es pura, no signific que sea mala per se.\n# El problema es que su salida no depende de sus valores\n# Si cambia una variable fuera de ella, cammbia el resultado.\n# Una alternativa\ndef verificar_limite(valor, limite):\n    if valor &gt; limite:\n        return \"Excede el l칤mite\"\n    return \"Dentro del l칤mite\"\n\nLIMITE_MAXIMO = 100\nverificar_limite(88, LIMITE_MAXIMO)",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programaci칩n funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#f치brica-de-promociones",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#f치brica-de-promociones",
    "title": "U2 - Programaci칩n funcional",
    "section": "2 F치brica de promociones",
    "text": "2 F치brica de promociones\n# Parte 1:\ndef crear_promocion(medio):\n    if medio == \"efectivo\":\n        multiplicador = 1\n    elif medio == \"d칠bito\":\n        multiplicador = (1 - 0.1)\n    elif medio == \"cr칠dito\":\n        multiplicador = (1 + 0.05)\n    else:\n        print(f\"El medio {medio} es desconocido.\")\n        multiplicador = 1\n\n    def f(x):\n        return x * multiplicador\n\n    return f\n\npromo_debito = crear_promocion(\"d칠bito\")\nprint(promo_debito(1000))\nprint(promo_debito(2700))\n\n\n# Parte 2\ndef crear_promocion_personalizada(medio, descuento=None):\n    if descuento is None:\n        if medio == \"efectivo\":\n            multiplicador = 1\n        elif medio == \"d칠bito\":\n            multiplicador = (1 - 0.1)\n        elif medio == \"cr칠dito\":\n            multiplicador = (1 + 0.05)\n        else:\n            print(f\"El medio {medio} es desconocido.\")\n            multiplicador = 1\n    else:\n        multiplicador = 1 - descuento / 100\n\n    def f(x):\n        return x * multiplicador\n\n    return f\n\npromo_debito = crear_promocion_personalizada(\"d칠bito\", 15)\npromo_debito(1000)\n\npromo_debito = crear_promocion_personalizada(\"d칠bito\")\npromo_debito(1000)",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programaci칩n funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#bendita-media",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#bendita-media",
    "title": "U2 - Programaci칩n funcional",
    "section": "3 Bendita media",
    "text": "3 Bendita media\ndef mean(valores, *args):\n    # Asume que 'valores' es coleccion de numeros\n    if not args:\n        return sum(valores) / len(valores)\n\n    # Asume que 'valores' es un solo numero\n    x = [valores] + list(args)\n    return sum(x) / len(x)\n\n\nmean([6.27, 8.11, 7.6, 5.2, 4.8])\nmean(7.3, 8.2, 11.0, 12.5)",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programaci칩n funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#sucesi칩n-de-fibonacci",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#sucesi칩n-de-fibonacci",
    "title": "U2 - Programaci칩n funcional",
    "section": "4 Sucesi칩n de Fibonacci",
    "text": "4 Sucesi칩n de Fibonacci\ndef fibonacci(n):\n    if n &lt; 2:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)\n\nfor i in range(15):\n    print(fibonacci(i))",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programaci칩n funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#pal칤ndromos-recursivos",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#pal칤ndromos-recursivos",
    "title": "U2 - Programaci칩n funcional",
    "section": "5 Pal칤ndromos recursivos",
    "text": "5 Pal칤ndromos recursivos\n# Parte 2\ndef palindromo(x):\n    if len(x) &lt; 2:\n        return True\n\n    if x[0] == x[-1]:\n        return palindromo(x[1:-1])\n\n    return False\n\npalindromo(\"hola amigo\")\npalindromo(\"somos\")\npalindromo(\"anilina\")\npalindromo(\"menem\")\npalindromo(\"neuquen\")\n\n\n\n# Parte 2\ndef _palindromo(x):\n    # Identica a la anterior, pero ahora es una funcion interna\n    if len(x) &lt; 2:\n        return True\n\n    if x[0] == x[-1]:\n        return palindromo(x[1:-1])\n\n    return False\n\ndef palindromo(x):\n    return _palindromo(x.lower().replace(\" \", \"\"))\n\npalindromo(\"Anita lava la tina\")\npalindromo(\"Luz azul\")\npalindromo(\"Cualquier cosa\")",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programaci칩n funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#치rea-de-aprendizaje",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#치rea-de-aprendizaje",
    "title": "U2 - Programaci칩n funcional",
    "section": "6 츼rea de aprendizaje",
    "text": "6 츼rea de aprendizaje\nrectangulos = [\n    (5, 8),\n    (2, 2),\n    (9, 2),\n    (3, 3),\n    (3, 7),\n    (6, 3)\n]\n\nsorted(rectangulos, key=lambda r: r[0] *  r[1])\n\n# Cuidado que esto funciona, pero hace otra cosa\nsorted(rectangulos)",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programaci칩n funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#socios-ordenados",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#socios-ordenados",
    "title": "U2 - Programaci칩n funcional",
    "section": "7 Socios ordenados",
    "text": "7 Socios ordenados\ndatos_socios = [\n    {\"nombre\": \"Bautista Carrara\", \"edad\": 22, \"altura_cm\": 178, \"record_100m\": 13.4},\n    {\"nombre\": \"Valentina Lucci\",  \"edad\": 23, \"altura_cm\": 163, \"record_100m\": 14.2},\n    {\"nombre\": \"Ger칩nimo Cuesta\",  \"edad\": 26, \"altura_cm\": 170, \"record_100m\": 14.0},\n    {\"nombre\": \"Lucio Borga\",      \"edad\": 28, \"altura_cm\": 186, \"record_100m\": 13.8},\n    {\"nombre\": \"Julia Spoglia\",    \"edad\": 21, \"altura_cm\": 163, \"record_100m\": 11.9},\n    {\"nombre\": \"Soledad Colombo\",  \"edad\": 22, \"altura_cm\": 170, \"record_100m\": 13.5}\n]\n\nsorted(datos_socios, key=lambda datum: datum[\"record_100m\"])\n\n# Punto extra\ndef ordenar_diccionario(data, key):\n    if key == \"nombre\":\n        return sorted(data, key=lambda datum: datum[\"nombre\"].split(\" \")[1])\n    return sorted(data, key=lambda datum: datum[key])\n\nordenar_diccionario(datos_socios, \"record_100m\")\nordenar_diccionario(datos_socios, \"edad\")\nordenar_diccionario(datos_socios, \"altura_cm\")\nordenar_diccionario(datos_socios, \"nombre\")",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programaci칩n funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#listado-de-rimas",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#listado-de-rimas",
    "title": "U2 - Programaci칩n funcional",
    "section": "8 Listado de rimas",
    "text": "8 Listado de rimas\npalabras_a_rimar = [\n    \"actividad\",\n    \"bendici칩n\",\n    \"cartelera\",\n    \"ciudad\",\n    \"escalera\",\n    \"estaci칩n\",\n    \"felicidad\",\n    \"funci칩n\",\n    \"reposera\"\n]\n\nsorted(palabras_a_rimar, key=lambda c: c[::-1])",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programaci칩n funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#analistas-de-temperaturas",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#analistas-de-temperaturas",
    "title": "U2 - Programaci칩n funcional",
    "section": "9 Analistas de temperaturas",
    "text": "9 Analistas de temperaturas\ntemperaturas_celsius = [\n    25.5, 28.0, 19.3, 31.5, 22.8, 17.0, 30.2, 35.6, 14.2,\n    32.4, 22.7, 10.1, 29.5, 33.9, 22.1, 38.9, 18.4, 16.3\n]\n\n# Enfoque funcional\n# 1\ntemperaturas_f = list(map(lambda c: c * 9 / 5 + 32, temperaturas_celsius))\n\n# 2\n# Opcion A:\nlist(filter(lambda f: f &gt; 80, temperaturas_f))\n\n# Opcion B --&gt; las devuelve en grados celsius\nlist(filter(lambda c: (c * 9 / 5 + 32) &gt; 80, temperaturas_celsius))\n\n# Enfoque idiom치tico\n[\n    c * 9 / 5 + 32 for c in temperaturas_celsius if c &gt; 22\n]",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programaci칩n funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#el-tiempo-vuela",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#el-tiempo-vuela",
    "title": "U2 - Programaci칩n funcional",
    "section": "10 El tiempo vuela",
    "text": "10 El tiempo vuela\nimport time\n\ndef crear_cronometro():\n    t_creacion = time.time()\n    def fun():\n        t_ejecucion = time.time()\n        return t_ejecucion - t_creacion\n    return fun\n\ncronometro1 = crear_cronometro()\n\nfor i in range(10**4):\n    i ** 2 # Calcula el cuadrado de un n칰mero pero no lo devuelve\n\nprint(f\"El bloque entero tard칩 {cronometro1()} segundos en ejecutarse.\")\n\n\ncronometro2 = crear_cronometro()\n\nfor j in range(10**6):\n    j // 2 # Calcula la divisi칩n entera por 2 pero no la devuelve\n\nprint(f\"El segundo bucle tard칩 {cronometro2()} segundos en ejecutarse.\")\n\n# Punto extra: 쯖ache?\ndef crear_cronometro():\n    t_creacion = time.time()\n    tiempos = [t_creacion]\n    def fun():\n        t_ejecucion = time.time()\n        t_anterior = tiempos[-1]\n        tiempos.append(t_ejecucion)\n        return t_ejecucion - t_anterior\n    return fun\n\ng = crear_cronometro()\n\ng()\ng()\ng()",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programaci칩n funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#no-perdamos-el-centro",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#no-perdamos-el-centro",
    "title": "U2 - Programaci칩n funcional",
    "section": "11 No perdamos el centro",
    "text": "11 No perdamos el centro\nnumeros = [\n    2.05, 1.09, None, 2.31, 2.28, 0.97, 2.59, 2.72, 0.76, None, 1.88, 2.04, 3.25, 1.88, None\n]\n\nnumeros_no_nulos = [n for n in numeros if n is not None]\nmedia = sum(numeros_no_nulos) / len(numeros_no_nulos)\n\n[n - media for n in numeros if n is not None]",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programaci칩n funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#en-python-es-mejor",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#en-python-es-mejor",
    "title": "U2 - Programaci칩n funcional",
    "section": "12 En Python es mejor",
    "text": "12 En Python es mejor\nnumeros = [\n    4.74346239e-01, -2.90877176e-01, -1.44377789e+00, -4.48680759e+01,\n    -1.21249801e+00, -3.32729317e-01,  2.21676912e-01,  1.05599711e+00,\n    -3.62372053e+00, -2.96441579e-01, -4.28304222e+00,  1.55908820e+02,\n    9.00858234e-01, -1.09384173e+00, -1.51083571e+00, -5.38491167e-01,\n    -3.84153084e-02,  1.20393395e+00,  1.82651406e-01,  2.05179405e+00\n]\n\ndef media(x):\n    return sum(x) / len(x)\n\ndef varianza(x):\n    numerador = 0\n    x_media = media(x)\n    for x_i in x:\n        numerador += (x_i - x_media) ** 2\n    return numerador / len(x)\n\nx_media = media(numeros)\nx_desvio = varianza(numeros) ** 0.5\n\nmap_obj = map(lambda x: (x - x_media) / x_desvio, numeros)\nlist(filter(lambda x: abs(x) &gt; 3, map_obj))\n\n# Respuesta 1: si queremos el numero transformado\n[(x - x_media) / x_desvio for x in numeros if abs((x - x_media) / x_desvio) &gt; 3]\n\n# Respuesta 2: si queremos el numero original\n[x for x in numeros if abs((x - x_media) / x_desvio) &gt; 3]",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programaci칩n funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#subiendo-de-rango",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#subiendo-de-rango",
    "title": "U2 - Programaci칩n funcional",
    "section": "13 Subiendo de rango",
    "text": "13 Subiendo de rango\ndef frange(start, stop, step):\n    while start &lt; stop:\n        yield start\n        start += step\n\nfor i in frange(3, 4, 0.2):\n    print(f\"{i:.2f}\")\n\nfor i in frange(3, 4, 0.15):\n    print(f\"{i:.2f}\")",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programaci칩n funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#la-cajita-musical",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#la-cajita-musical",
    "title": "U2 - Programaci칩n funcional",
    "section": "14 La cajita musical",
    "text": "14 La cajita musical\nimport random\n\ndef cajita_musical(versos):\n    versos = versos[:] # Para hacer una copia\n\n    while versos: # Mientras la lista no est칠 vac칤a\n        # Generar un 칤ndice al azar\n        i = random.randint(0, len(versos) - 1)\n\n        # Sacar y devolver el valor del 칤ndice al azar\n        yield versos.pop(i)\n\n\nversos = [\n    \"Tengo que confesar que a veces no me gusta tu forma de ser\",\n    \"Luego te me desapareces y no entiendo muy bien por qu칠\",\n\n    \"No dices nada rom치ntico cuando llega el atardecer\",\n    \"Te pones de un humor extra침o con cada luna llena al mes\",\n\n    \"Pero a todo lo dem치s le gana lo bueno que me das\",\n    \"S칩lo tenerte cerca, siento que vuelvo a empezar\"\n]\n\nfor verso in cajita_musical(versos):\n    print(verso)",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programaci칩n funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#el-mejor-precio",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#el-mejor-precio",
    "title": "U2 - Programaci칩n funcional",
    "section": "15 El mejor precio",
    "text": "15 El mejor precio\ndef promo_dia_semana(compra):\n  \"\"\"Aplica un 15% de descuento si la compra se realiza un lunes o mi칠rcoles.\"\"\"\n  if compra[\"dia\"] in (\"lunes\", \"mi칠rcoles\"):\n    return 0.85\n  return 1\n\ndef promo_monto_grande(compra):\n  \"\"\"Aplica un 10% de descuento si la compra tiene un monto superior a $50.000.\"\"\"\n  if compra[\"monto\"] &gt; 50_000:\n    return 0.9\n  return 1\n\ndef promo_edad(compra):\n  \"\"\"Aplica un 20% de descuento si el cliente tiene 65 a침os o m치s.\"\"\"\n  if compra[\"edad_cliente\"] &gt;= 65:\n    return 0.8\n  return 1\n\npromos = [promo_dia_semana, promo_monto_grande, promo_edad]\n\ndef mejor_promo(compra):\n  \"\"\"Ordena los descuentos de mayor a menor y aplica el mejor disponible.\"\"\"\n  multiplicador = sorted([promo(compra) for promo in promos])[0]\n\n  return {\n    \"monto_original\": compra[\"monto\"],\n    \"monto_final\": compra[\"monto\"] * multiplicador,\n    \"descuento\": f\"{round((1 - multiplicador) * 100)}%\"\n  }\n\nejemplo_compra = {\"dia\": \"mi칠rcoles\", \"edad_cliente\": 42, \"monto\": 66420}\nmejor_promo(ejemplo_compra)\n\n# Solucion (no se si esto es lo que Joaco tenia en mente)\nPROMOS = [] # mayusculas para indicar que es global, una convencion\ndef promo(fun):\n    def envoltura(*args, **kwargs):\n        return fun(*args, **kwargs)\n    PROMOS.append(envoltura)\n    return envoltura\n\n@promo\ndef promo_dia_semana(compra):\n    if compra[\"dia\"] in (\"lunes\", \"mi칠rcoles\"):\n        return 0.85\n    return 1\n\n@promo\ndef promo_monto_grande(compra):\n    if compra[\"monto\"] &gt; 50_000:\n        return 0.9\n    return 1\n\n@promo\ndef promo_edad(compra):\n    if compra[\"edad_cliente\"] &gt;= 65:\n        return 0.8\n    return 1\n\nPROMOS # ahora contiene a las funciones\n\ndef mejor_promo(compra):\n    multiplicador = sorted([promo(compra) for promo in PROMOS])[0]\n    return {\n        \"monto_original\": compra[\"monto\"],\n        \"monto_final\": compra[\"monto\"] * multiplicador,\n        \"descuento\": f\"{round((1 - multiplicador) * 100)}%\"\n    }\n\nejemplo_compra = {\"dia\": \"mi칠rcoles\", \"edad_cliente\": 42, \"monto\": 66420}\nmejor_promo(ejemplo_compra)\n\nejemplo_compra = {\"dia\": \"jueves\", \"edad_cliente\": 42, \"monto\": 28000}\nmejor_promo(ejemplo_compra)\n\nejemplo_compra = {\"dia\": \"jueves\", \"edad_cliente\": 67, \"monto\": 28000}\nmejor_promo(ejemplo_compra)",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programaci칩n funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#bromas-pesadas",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#bromas-pesadas",
    "title": "U2 - Programaci칩n funcional",
    "section": "16 Bromas pesadas 游땸",
    "text": "16 Bromas pesadas 游땸\ndef romper_cada(n):\n    def decorador(func):\n\n        if type(n) is not int or n &lt; 1: # Chequea que \"n\" sea un argumento v치lido\n            return func\n\n        contador = 0  # Cu치ntas veces se llam칩 a la funci칩n\n\n        def envoltura(*args, **kwargs):\n            nonlocal contador\n            contador += 1\n\n            if contador % n == 0: # Cada n veces...\n                return None       # ...se rompe\n\n            return func(*args, **kwargs)\n\n        return envoltura\n    return decorador\n\n# Ejemplo de uso\n@romper_cada(3)\ndef saludar(nombre):\n    print(f\"춰Hola, {nombre}!\")\n\nsaludar(\"Carlos\")     # \"춰Hola, Carlos!\"\nsaludar(\"Mar칤a Luz\")  # \"춰Hola, Mar칤a Luz!\"\nsaludar(\"Mirna\")      # Nada (la funci칩n devuelve None)\nsaludar(\"Diego\")      # \"춰Hola, Diego!\"",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programaci칩n funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#pipelines-de-procesamiento",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#pipelines-de-procesamiento",
    "title": "U2 - Programaci칩n funcional",
    "section": "17 Pipelines de procesamiento 游땸",
    "text": "17 Pipelines de procesamiento 游땸\nfrom math import log10\n\n# Sin usar filter\n\ndef eliminar_nulos(datos):\n    datos_sin_nulos = []\n    for fila in datos:\n        if None not in fila.values():\n            datos_sin_nulos.append(fila.copy())\n    return datos_sin_nulos\n\ndef calcular_log(datos, variable):\n    datos_log = []\n    for fila in datos:\n        copia_fila = fila.copy()\n        valor = copia_fila[variable]\n        copia_fila[variable] = round(log10(valor), 3) if (valor is not None) else None\n        datos_log.append(copia_fila)\n    return datos_log\n\ndef filtrar(datos, variable, funcion):\n    datos_filtrados = []\n    for fila in datos:\n        if fila[variable] is not None and funcion(fila[variable]):\n            datos_filtrados.append(fila.copy())\n    return datos_filtrados\n\n\n# Usando filter\n\ndef eliminar_nulos(datos):\n    return list(filter(lambda fila: None not in fila.values(), datos))\n\ndef filtrar(datos, variable, funcion):\n    return list(filter(lambda fila: fila[variable] is not None and funcion(fila[variable]), datos))",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programaci칩n funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#espacio-o-tiempo",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#espacio-o-tiempo",
    "title": "U2 - Programaci칩n funcional",
    "section": "18 쮼spacio o tiempo? 낍",
    "text": "18 쮼spacio o tiempo? 낍\n# 1 - PREPARACION DE DATOS\n\nimport random\n\nCATEGORIAS = (\"electr칩nica\", \"hogar\", \"accesorios\", \"deportes\")\n\ndef generar_ventas(n=100_000, seed=None):\n    rng = random.Random(seed)\n    return [\n        {\n            \"id\": f\"P{i+1:06d}\",\n            \"precio\": round(rng.uniform(5.0, 500.0), 2),\n            \"categoria\": CATEGORIAS[i % len(CATEGORIAS)],\n        }\n        for i in range(1, n + 1)\n    ]\n\nventas = generar_ventas(n=100_000, seed=1234)\n\n# 2- Precios con IVA (21%)\n\n# Versi칩n A - List comprehension (ejecuta y guarda todo):\nprecios_con_iva_1 = [venta[\"precio\"] * 1.21 for venta in ventas]\n# Versi칩n B - Generador (define la operaci칩n pero no la ejecuta):\nprecios_con_iva_2 = (venta[\"precio\"] * 1.21 for venta in ventas)\n\n# 3 - Filtrar ventas de electr칩nica\n\n# Versi칩n A - List comprehension:\nelectronica_1 = [venta for venta in ventas if venta[\"categoria\"] == \"electr칩nica\"]\n#Versi칩n B - Generador:\nelectronica_2 = (venta for venta in ventas if venta[\"categoria\"] == \"electr칩nica\")\n\n# 4 - An치lisis y comparaci칩n (tiempo y memoria)\n\nimport time\nimport sys\n\n# A - Lista materializada\nt1 = time.time()\ntotal_1 = sum(venta[\"precio\"] for venta in electronica_1)\nt2 = time.time()\nmem_1 = sys.getsizeof(electronica_1)\nprint(f\"electronica_1  total: {total_1:.2f}, tiempo: {t2 - t1:.4f}s, memoria: {mem_1} bytes\")\n\n# B - Generador (se consume al usar sum)\nt3 = time.time()\ntotal_2 = sum(venta[\"precio\"] for venta in electronica_2)\nt4 = time.time()\nmem_2 = sys.getsizeof(electronica_2)\nprint(f\"electronica_2  total: {total_2:.2f}, tiempo: {t4 - t3:.4f}s, memoria: {mem_2} bytes\")\n\n\n# 5- Reutilizaci칩n del objeto\n\n# Lista: se puede usar de nuevo\nprint(sum(venta[\"precio\"] for venta in electronica_1))  # OK\n\n# Generador: ya fue consumido, no devuelve nada\nprint(sum(venta[\"precio\"] for venta in electronica_2))  # 0.0\n\n# 6 - Reflexi칩n final (resumen corto)\n\n# List comprehension (Versi칩n A): usa m치s memoria, pero permite reutilizar los datos.\n# Ideal si vas a recorrer los resultados varias veces.\n\n# Generadores (Versi칩n B): consumen poca memoria, pero solo pueden recorrerse una vez.\n# Son m치s eficientes si solo necesit치s un recorrido r치pido.\n\n# En problemas donde el dataset es enorme o se usa solo una vez  mejor un generador.\n# Si necesit치s acceder varias veces al resultado o compartirlo entre funciones  mejor una lista.",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programaci칩n funcional"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_individual.html",
    "href": "trabajos_practicos/trabajo_individual.html",
    "title": "Trabajo pr치ctico final",
    "section": "",
    "text": "En el lenguaje R, los data frames son una de las estructuras de datos m치s utilizadas. Permiten almacenar y manipular informaci칩n tabular de forma sencilla, donde cada columna representa una variable y cada fila una observaci칩n.\nEn Python no existe una estructura built-in equivalente al data frame. En la pr치ctica, se utilizan librer칤as como pandas o polars, que implementan estructuras de datos dise침adas espec칤ficamente para este prop칩sito. Ambas librer칤as se apoyan en dos estructuras fundamentales: Series, que representa una columna, y DataFrame, que representa una tabla completa compuesta por varias series.\nEl objetivo de este trabajo es implementar de forma b치sica las clases Series y DataFrame, con el fin de profundizar en la programaci칩n orientada a objetos y en el uso de Python como lenguaje de desarrollo. Adem치s, busca comprender el funcionamiento interno de las estructuras de datos tabulares y los principios de dise침o que las hacen posibles.",
    "crumbs": [
      "Trabajos Pr치cticos",
      "Trabajo pr치ctico final"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_individual.html#introducci칩n",
    "href": "trabajos_practicos/trabajo_individual.html#introducci칩n",
    "title": "Trabajo pr치ctico final",
    "section": "",
    "text": "En el lenguaje R, los data frames son una de las estructuras de datos m치s utilizadas. Permiten almacenar y manipular informaci칩n tabular de forma sencilla, donde cada columna representa una variable y cada fila una observaci칩n.\nEn Python no existe una estructura built-in equivalente al data frame. En la pr치ctica, se utilizan librer칤as como pandas o polars, que implementan estructuras de datos dise침adas espec칤ficamente para este prop칩sito. Ambas librer칤as se apoyan en dos estructuras fundamentales: Series, que representa una columna, y DataFrame, que representa una tabla completa compuesta por varias series.\nEl objetivo de este trabajo es implementar de forma b치sica las clases Series y DataFrame, con el fin de profundizar en la programaci칩n orientada a objetos y en el uso de Python como lenguaje de desarrollo. Adem치s, busca comprender el funcionamiento interno de las estructuras de datos tabulares y los principios de dise침o que las hacen posibles.",
    "crumbs": [
      "Trabajos Pr치cticos",
      "Trabajo pr치ctico final"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_individual.html#clase-series",
    "href": "trabajos_practicos/trabajo_individual.html#clase-series",
    "title": "Trabajo pr치ctico final",
    "section": "2 Clase Series",
    "text": "2 Clase Series\nUna Series representa una estructura unidimensional de datos, similar a un vector o una columna. En nuestro caso, soportan cuatro tipos de datos: num칠ricos enteros (int), num칠ricos flotantes (float), texto (str) y booleanos (bool). Las series pueden tambi칠n incluir valores nulos, representados por None.\n\n2.1 Inicializaci칩n\nPara inicializar una Series se necesita una secuencia de valores del mismo tipo. Opcionalmente, se pasan valores para los argumentos name y dtype. El primero le asigna un nombre a la serie y el segundo un tipo de dato. El nombre de la serie es una cadena de texto y el tipo puede ser \"int\", \"float\", \"str\" o \"bool\".\n\nEjemplos\nSe muestran algunos bloques de c칩digo donde se inicializan objetos de la clase Series.\nEjemplo m칤nimo, donde se pasa una secuencia de enteros.\n# Ejemplo 1\nserie = Series([1, 2, 3, 4])\nserie\n# Series: ''\n# len: 4\n# dtype: int\n# [\n#     1\n#     2\n#     3\n#     4\n# ]\nSerie nombrada:\nserie = Series([1.0, 2.0, 3.0], name=\"x\")\nserie\n# Series: 'x'\n# len: 3\n# dtype: float\n# [\n#     1.0\n#     2.0\n#     3.0\n# ]\nSerie con nombre y tipo expl칤cito:\nserie = Series([1, 2, 3], name=\"cantidad\", dtype=\"float\")\nserie\n# Series: 'cantidad'\n# len: 3\n# dtype: float\n# [\n#     1.0\n#     2.0\n#     3.0\n# ]\nNotar que al utilizar dtype=\"float\" los valores enteros son convertidos a flotantes.\n\n\n\n2.2 Atributos\nLos objetos de la clase Series tienen los siguientes atributos p칰blicos:\n\n\n\n\n\n\n\nM칠todo\nDescripci칩n\n\n\n\n\ndtype\nTipo de dato (\"int\", \"float\", \"str\", \"bool\")\n\n\nname\nEl nombre de la serie\n\n\nlen\nLa longitud de la serie\n\n\n\n\n\n2.3 M칠todos para manipular de datos\nLa clase Series disponibiliza los siguientes m칠todos para la manipulaci칩n de datos:\n\n\n\n\n\n\n\nM칠todo\nDescripci칩n\n\n\n\n\nclone(self)\nDevuelve una nueva serie, id칠ntica a la original.\n\n\nhead(self, n=5)\nDevuelve una nueva serie con los primeros n valores.\n\n\ntail(self, n=5)\nDevuelve una nueva serie con los 칰ltimos n valores.\n\n\nappend(self, x)\nAgrega el elemento x al final de la serie.\n\n\nextend(self, s)\nExtiende la serie con los elementos de la serie s.\n\n\nfilter(self, f)\nDevuelve una nueva serie con los elementos de la serie que al ser pasados a f devuelven un valor verdadero. Por ejemplo, serie.filter(lambda x: x &gt; 5) devuelve una serie con los valores que son mayores a 5.\n\n\nwhere(self, f)\nDevuelve una nueva lista con los 칤ndices de los elementos que al ser pasados a f devuelven True\n\n\nis_null(self)\nDevuelve una serie de valores booleanos. Cada elemento ser치 True si el elemento original es nulo.\n\n\nis_not_null(self)\nDevuelve una serie de valores booleanos. Cada elemento ser치 True si el original es no nulo.\n\n\nfill_null(self, x)\nReemplaza los valores nulos por x.\n\n\nrename(self, name)\nCambia el nombre de la serie por name.\n\n\nsort(self, ...)\nOrdena la serie. El par치metro descending determina si se ordena de forma ascendente (por defecto) o descendente. y el par치metro in_place determina si se modifica la serie in-place o si se devuelve una nueva (por defecto).\n\n\nargsort(self, ...)\nDevuelve una lista con los 칤ndices que ordenan a la serie. El par치metro descending determina si se ordena de forma ascendente (por defecto) o descendente.\n\n\n\n\nEjemplos\nserie = Series([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\nserie.head()\n# Series: ''\n# len: 5\n# dtype: int\n# [\n#     1\n#     2\n#     3\n#     4\n#     5\n# ]\nserie = Series([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\nserie.tail(3)\n# Series: ''\n# len: 3\n# dtype: int\n# [\n#     8\n#     9\n#     10\n# ]\nserie = Series(list(\"ABCD\"))\nserie.clone()\n# Series: ''\n# len: 4\n# dtype: str\n# [\n#     A\n#     B\n#     C\n#     D\n# ]\ns1 = Series([True, True, False])\ns1.append(False)\ns1\n# Series: ''\n# len: 4\n# dtype: bool\n# [\n#     True\n#     True\n#     False\n#     False\n# ]\ns1 = Series([1, 2, 3])\ns2 = Series([4, 5, 6])\ns1.extend(s2)\ns1\n# Series: ''\n# len: 6\n# dtype: int\n# [\n#     1\n#     2\n#     3\n#     4\n#     5\n#     6\n# ]\ns = Series([1, 20, 50, 2, 100, 3])\ns.filter(lambda x: x &lt; 20)\n# Series: ''\n# len: 3\n# dtype: int\n# [\n#     1\n#     2\n#     3\n# ]\ns = Series([1, 20, 50, 2, 100, 3])\nindices = s.where(lambda x: x &lt; 20)\n\nindices\n# [0, 3, 5]\n\n[s[i] for indices in indices]\n# [1, 2, 3]\ns = Series([1, 20, 50, 2, 100, 3])\ns.is_null()\n# Series: ''\n# len: 6\n# dtype: bool\n# [\n#     False\n#     False\n#     False\n#     False\n#     False\n#     False\n# ]\ns = Series([5, None, None, 10])\ns.is_not_null()\n# Series: ''\n# len: 4\n# dtype: bool\n# [\n#     True\n#     False\n#     False\n#     True\n# ]\ns = Series([5, None, None, 10])\ns.fill_null(-1)\n# Series: ''\n# len: 4\n# dtype: int\n# [\n#     5\n#     -1\n#     -1\n#     10\n# ]\ns = Series(list(\"xyz\"))\ns.rename(\"letras\")\ns\n# Series: 'letras'\n# len: 3\n# dtype: str\n# [\n#     x\n#     y\n#     z\n# ]\ns = Series([128, 256.0, 42.5, 35])\ns.sort()\n# Series: ''\n# len: 4\n# dtype: float\n# [\n#     35.0\n#     42.5\n#     128.0\n#     256.0\n# ]\ns = Series([128, 256.0, 42.5, 35])\ns.sort(descending=True)\n# Series: ''\n# len: 4\n# dtype: float\n# [\n#     256.0\n#     128.0\n#     42.5\n#     35.0\n# ]\ns = Series([128, 256.0, 42.5, 35])\nindices = s.argsort()\nindices\n# [3, 2, 0, 1]\n\n[s[i] for i in indices] # Se utilizan los indices\n# [35.0, 42.5, 128.0, 256.0]\n\n\n\n\n\n\nSobre los tipos de datos\n\n\n\nTodas las operaciones que modifican una serie solo deben soportar valores del mismo tipo que el de la serie. Por ejemplo, debe ser posible usar append(125.5) en una serie de tipo flotante, pero no en una serie de tipo texto.\n\n\n\n\n\n2.4 M칠todos para calcular agregaciones\nLos siguientes m칠todos obtienen un valor a partir de todos los valores de la serie. En todos los casos se ignoran los valores nulos. Solo se pueden aplicar a series num칠ricas.\n\n\n\n\n\n\n\nM칠todo\nDescripci칩n\n\n\n\n\nmin(self)\nEl valor m치s peque침o.\n\n\nmax(self)\nEl valor m치s grande.\n\n\nsum(self)\nLa suma de los elementos.\n\n\nmean(self)\nEl promedio de los elementos.\n\n\nproduct(self)\nEl producto de los elementos.\n\n\nstd(self)\nEl desv칤o est치ndar.\n\n\nvar(self)\nLa varianza.\n\n\n\n\nEjemplos\ns1 = Series([1, 4, 5, 2, 10, 6, 3, 7, 8, 9])\ns2 = Series([True, True, False, True])\n\ns1.min()     # 1\ns1.max()     # 9\ns1.sum()     # 55\ns1.mean()    # 5.5\ns1.product() # 3628800\ns1.std()     # 2.87228\ns1.var()     # 8.25\n\n\n\n2.5 M칠todos especiales\n\nAritm칠ticos\nEstos operadores solo se pueden utilizar con series de tipo num칠rico. Si other es un n칰mero, se recicla para todos los elementos de la serie. Por ejemplo:\ns = Series([5, 6, 7])\ns * 3.0\n# Series: ''\n# len: 3\n# dtype: float\n# [\n#     15.0\n#     18.0\n#     21.0\n# ]\nSi other es otra Series, deben tener la misma longitud y la operaci칩n se hace elemento a elemento. Por ejemplo:\ns1 = Series([10, 20, 30])\ns2 = Series([5, 25, 28])\ns1 &gt; s2\n# Series: ''\n# len: 3\n# dtype: bool\n# [\n#     True\n#     False\n#     True\n# ]\nLos m칠todos a implementar se resumen en la siguiente tabla:\n\n\n\n\n\n\n\nM칠todo\nDescripci칩n\n\n\n\n\n__eq__(self, other)\nIgual a\n\n\n__gt__(self, other)\nMayor que\n\n\n__ge__(self, other)\nMayor o igual que\n\n\n__lt__(self, other)\nMenor que\n\n\n__le__(self, other)\nMenor o igual que\n\n\n__add__(self, other)\nSuma\n\n\n__sub__(self, other)\nResta\n\n\n__mul__(self, other)\nMultiplicaci칩n\n\n\n__truediv__(self, other)\nDivisi칩n flotante\n\n\n__pow__(self, other)\nPotencia\n\n\n\n\n\nAcceso e iteraci칩n\nEstos m칠todos permiten interactuar con la serie de forma natural.\n\n\n\n\n\n\n\nM칠todo\nDescripci칩n\n\n\n\n\n__repr__(self)\nRepresentaci칩n textual\n\n\n__len__(self)\nLongitud de la serie\n\n\n__contains__(self, item)\nDetermina si item se encuentra en la serie\n\n\n__getitem__(self, index)\nObtiene el elemento en la posici칩n index\n\n\n__iter__(self)\nPermite iterar sobre los elementos de la serie\n\n\n\n\nEjemplos\nEl m칠todo de representaci칩n es el que determina que la serie se vea de la siguiente manera al mostrarla en la terminal:\n# Series: ''\n# len: 3\n# dtype: float\n# [\n#     15.0\n#     18.0\n#     21.0\n# ]\nLa cantidad m치xima de elementos que se muestra es 10. Una serie con los n칰meros del 1 al 10 se ve de la siguiente manera:\n# Series: ''\n# len: 10\n# dtype: float\n# [\n#     1\n#     2\n#     3\n#     4\n#     5\n#     6\n#     7\n#     8\n#     9\n#     10\n# ]\nY si la serie tiene m치s elementos, se muestran los primeros cinco, luego tres puntos suspensivos, y finalmente los 칰ltimos cinco. Por ejemplo, una serie con los n칰meros del 1 al 100.\n# Series: ''\n# len: 100\n# dtype: float\n# [\n#     1\n#     2\n#     3\n#     4\n#     5\n#     ...\n#     96\n#     97\n#     98\n#     99\n#     100\n# ]\nEl m칠todo especial __len__ permite obtener la cantidad de elementos de la serie con len():\nlen(s)\n# 100\nPor su parte, __contains__(self, item) se ejecuta cuando utilizamos el operador in, de esta manera:\n20 in s\n# True\n\n200 in s\n# False\nEl m칠todo __getitem__(self, index) nos permite indexar la serie, tratandola como una secuencia (춰qu칠 es lo que es!):\ns = Series([-10, 10, -20, 20, -30, 30])\ns[0] # -10\ns[1] # 10\nFinalmente, el m칠todo __iter__(self) nos permite iterar a trav칠s de la secuencia.\ns = Series([-10, 10, -20, 20, -30, 30])\nfor s_i in s:\n    if s_i &gt; 0:\n        print(s_i)\n# 10\n# 20\n# 30",
    "crumbs": [
      "Trabajos Pr치cticos",
      "Trabajo pr치ctico final"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_individual.html#clase-dataframe",
    "href": "trabajos_practicos/trabajo_individual.html#clase-dataframe",
    "title": "Trabajo pr치ctico final",
    "section": "3 Clase DataFrame",
    "text": "3 Clase DataFrame\nUn DataFrame representa una estructura bidimensional de datos, organizada en filas y columnas, donde cada columna est치 asociada a una instancia de Series. Se trata de una tabla en la que cada columna tiene un nombre 칰nico y un tipo de dato consistente a lo largo de toda la columna.\nEn este trabajo, la clase DataFrame se construye a partir de un conjunto de objetos Series, todas con la misma longitud, o a partir de un diccionario que mapea nombres de columnas a secuencias de valores compatibles.\n\n3.1 Inicializaci칩n\nPara crear un DataFrame, se puede pasar:\n\nUn diccionario donde las claves son los nombres de las columnas y los valores son listas o instancias de Series.\nUna lista de Series, donde cada una tiene asignado un nombre (name) distinto.\n\nEl inicializador debe validar que todas las columnas tengan la misma cantidad de filas. Si alguna columna contiene valores nulos, estos se preservan.\n\nEjemplos\nA partir de listas:\ndf = DataFrame({\n    \"x\": [1, 2, 3, 4],\n    \"y\": [10, 20, 30, 40]\n})\ndf\n# shape: (4, 2)\n# 較꺽較較較석較較較較\n# 較 x 較 y  較\n# 較럭較較較쩍較較較較\n# 較 1 較 10 較\n# 較 2 較 20 較\n# 較 3 較 30 較\n# 較 4 較 40 較\n# 較덕較較較억較較較較\nA partir de Series:\ns1 = Series([1, 2, 3], name=\"x\")\ns2 = Series([True, False, True], name=\"condicion\")\n\ndf = DataFrame([s1, s2])\ndf\n# shape: (3, 2)\n# 較꺽較較較석較較較較較較較較較較較\n# 較 x 較 condicion 較\n# 較럭較較較쩍較較較較較較較較較較較\n# 較 1 較 True      較\n# 較 2 較 False     較\n# 較 3 較 True      較\n# 較덕較較較억較較較較較較較較較較較\n\n\n\n3.2 Atributos\nLos objetos DataFrame exponen los siguientes atributos p칰blicos:\n\n\n\n\n\n\n\nAtributo\nDescripci칩n\n\n\n\n\ncolumns\nLista con los nombres de las columnas, en orden\n\n\ndtypes\nLista con los tipos de datos de las columnas, en orden\n\n\nshape\nDimensi칩n de la tabla (filas, columnas)\n\n\nschema\nDiccionario que mapea las columnas a sus tipos\n\n\nheight\nCantidad de filas\n\n\nwidth\nCantidad de columnas\n\n\n\n\nEjemplos\ndf = DataFrame({\n    \"nombre\": [\"Ana\", \"Juan\", \"Mar칤a\", \"Luna\"],\n    \"edad\": [25, 32, 29, 18],\n    \"activo\": [True, False, True, True]\n})\n\ndf.columns   # [\"nombre\", \"edad\", \"activo\"]\ndf.dtypes    # [\"str\", \"int\", \"bool\"]\ndf.shape     # (4, 3)\ndf.schema    # {\"nombre\": \"str\", \"edad\": \"int\", \"activo\": \"bool\"}\ndf.height    # 4\ndf.width     # 3\n\n\n\n3.3 M칠todos\nLos DataFrame cuentan con un conjunto de m칠todos que permiten manipular y transformar los datos de manera sencilla.\n\n\n\n\n\n\n\nM칠todo\nDescripci칩n\n\n\n\n\nhead(self, n=5)\nDevuelve un nuevo DataFrame con las primeras n filas.\n\n\ntail(self, n=5)\nDevuelve un nuevo DataFrame con las 칰ltimas n filas.\n\n\nselect(self, *columns)\nDevuelve un nuevo DataFrame con solo las columnas indicadas.\n\n\nfilter(self, *predicates)\nDevuelve un DataFrame con las filas que cumplen todas las condiciones.\n\n\ndrop_nulls(self)\nElimina todas las filas que contengan valores nulos.\n\n\nsort(self, name, descending)\nDevuelve un nuevo DataFrame con las filas ordenadas seg칰n la columna name. Por defecto, descending es False.\n\n\n\n\nEjemplos\ndf = DataFrame({\n    \"x\": [1, 2, 3, 4, 5, 6],\n    \"y\": [10, 20, 30, 40, 50, 60],\n    \"z\": [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]\n})\n\ndf.head(3)\n# shape: (3, 3)\n# 較꺽較較較較석較較較較석較較較較\n# 較 x  較 y  較 z  較\n# 較럭較較較較쩍較較較較쩍較較較較\n# 較 1  較 10 較 a  較\n# 較 2  較 20 較 b  較\n# 較 3  較 30 較 c  較\n# 較덕較較較較억較較較較억較較較較\n\n```python\ndf.tail(1)\n# shape: (1, 3)\n# 較꺽較較較較석較較較較석較較較較\n# 較 x  較 y  較 z  較\n# 較럭較較較較쩍較較較較쩍較較較較\n# 較 6  較 60 較 f  較\n# 較덕較較較較억較較較較억較較較較\ndf.select(\"x\", \"z\")\n# shape: (6, 2)\n# 較꺽較較較較석較較較較\n# 較 x  較 z  較\n# 較럭較較較較쩍較較較較\n# 較 1  較 a  較\n# 較 2  較 b  較\n# 較 3  較 c  較\n# 較 4  較 d  較\n# 較 5  較 e  較\n# 較 6  較 f  較\n# 較덕較較較較억較較較較\nPara filtrar, se pasan tuplas de longitud dos. El primer valor es el nombre de la columna, y el segundo es una funci칩n que se aplica a cada elemento de esa columna y devuelve un valor booleano. Por ejemplo, se seleccionan las filas donde \"x\" es impar e \"y\" es mayor a 30.\ndf.filter((\"x\", lambda x: x % 2 != 0), (\"y\", lambda x: x &gt; 30))\n# shape: (1, 2)\n# 較꺽較較較較석較較較較석較較較較\n# 較 x  較 y  較 z  較\n# 較럭較較較較쩍較較較較쩍較較較較\n# 較 5  較 50 較 e  較\n# 較덕較較較較억較較較較억較較較較\ndf = DataFrame({\n    \"a\": [1, None, 3],\n    \"b\": [\"x\", \"y\", None]\n})\ndf.drop_nulls()\n# shape: (1, 2)\n# 較꺽較較較較석較較較較\n# 較 a  較 b  較\n# 較럭較較較較쩍較較較較\n# 較 1  較 x  較\n# 較덕較較較較억較較較較\ndf = DataFrame({\n    \"x\": [3, 1, 2],\n    \"y\": [5, 15, 20]\n})\ndf.sort(\"x\")\n# shape: (3, 2)\n# 較꺽較較較較석較較較較\n# 較 x  較 y  較\n# 較럭較較較較쩍較較較較\n# 較 1  較 15 較\n# 較 2  較 20 較\n# 較 3  較 5  較\n# 較덕較較較較억較較較較\n\n\n\n3.4 M칠todos especiales\nEstos m칠todos permiten interactuar con el DataFrame de manera natural y en sinton칤a con el comportamiento esperado de una colecci칩n de datos tabulares.\n\n\n\n\n\n\n\nM칠todo\nDescripci칩n\n\n\n\n\n__len__(self)\nDevuelve la cantidad de filas del DataFrame.\n\n\n__repr__(self)\nRepresentaci칩n textual del DataFrame.\n\n\n__getitem__(self, name)\nDevuelve la Series asociada a la columna name.\n\n\n__setitem__(self, name, value)\nAgrega o sobreescribe la columna name con la Series value.\n\n\n\n\nEjemplos\nEl m칠todo especial __len__ permite obtener la cantidad de filas del DataFrame mediante la funci칩n built-in len():\ndf = DataFrame({\n    \"nombre\": [\"Ana\", \"Juan\", \"Mar칤a\"],\n    \"edad\": [25, 32, 29]\n})\n\nlen(df)\n# 3\nEl m칠todo __repr__ define la representaci칩n textual del DataFrame, es decir, c칩mo se muestra al imprimirlo en la terminal o al evaluarlo en una celda interactiva.\ndf\n# shape: (3, 2)\n# 較꺽較較較較較較較較석較較較較較較\n# 較 nombre 較 edad 較\n# 較럭較較較較較較較較쩍較較較較較較\n# 較 Ana    較 25   較\n# 較 Juan   較 32   較\n# 較 Mar칤a  較 29   較\n# 較덕較較較較較較較較억較較較較較較\nCuando el DataFrame contiene m치s de diez filas, se muestran las primeras cinco y las 칰ltimas cinco, separadas por puntos suspensivos (...). Esto permite obtener una vista general del contenido sin saturar la salida.\n# shape: (20, 2)\n# 較꺽較較較較較較較較석較較較較較較\n# 較 nombre 較 edad 較\n# 較럭較較較較較較較較쩍較較較較較較\n# 較 Ana    較 25   較\n# 較 Juan   較 32   較\n# 較 Mar칤a  較 29   較\n# 較 David  較 24   較\n# 較 Pipo   較 12   較\n# 較 ...    較 ...  較\n# 較 Laura  較 45   較\n# 較 Marcos 較 17   較\n# 較 Lucas  較 41   較\n# 較 Nora   較 37   較\n# 較 Zoe    較 23   較\n# 較덕較較較較較較較較억較較較較較較\nPor su parte, __getitem__ permite acceder al objeto Series de una columna por su nombre:\ndf[\"nombre\"]\n# Series: 'nombre'\n# len: 3\n# dtype: str\n# [\n#     Ana\n#     Juan\n#     Mar칤a\n# ]\nEn conjunto con __setitem__, permiten crear o modificar columnas en la tabla:\ndf[\"edad_meses\"] = df[\"edad\"] * 12\ndf\n# shape: (3, 3)\n# 較꺽較較較較較較較較석較較較較較較넉較較較較較較較較較較較較\n# 較 nombre 較 edad 較 edad_meses 較\n# 較럭較較較較較較較較쩍較較較較較較벅較較較較較較較較較較較較\n# 較 Ana    較 25   較 300        較\n# 較 Juan   較 32   較 384        較\n# 較 Mar칤a  較 29   較 248        較\n# 較덕較較較較較較較較억較較較較較較떡較較較較較較較較較較較較",
    "crumbs": [
      "Trabajos Pr치cticos",
      "Trabajo pr치ctico final"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_individual.html#pruebas",
    "href": "trabajos_practicos/trabajo_individual.html#pruebas",
    "title": "Trabajo pr치ctico final",
    "section": "4 Pruebas",
    "text": "4 Pruebas\n\n4.1 Pruebas para Series\nCrear una serie y verificar operaciones b치sicas de acceso y longitud:\ns = Series([10, 20, 30, 40, 50], name=\"valores\")\ns.head(3)\ns.tail(2)\nlen(s)\nAgregar y extender una serie, manteniendo el tipo de datos:\ns1 = Series([1, 2, 3])\ns2 = Series([4, 5])\ns1.append(6)\ns1.extend(s2)\ns1\nFiltrar valores seg칰n una condici칩n y obtener sus 칤ndices:\ns = Series([10, 25, 50, 75, 90, 100])\ns.filter(lambda x: x &lt; 60) # Una Series\ns.where(lambda x: x % 25 == 0) # Una lista de enteros\nDetectar y reemplazar valores nulos:\ns = Series([5, None, 15, None])\ns.is_null() # Una Series de booleanos\ns.is_not_null() # Otra Series de booleanos\ns.fill_null(0) # Una series de enteros\nOrdenar y obtener 칤ndices de ordenamiento:\ns = Series([42, 7, 100, 3])\ns.sort() # Una serie de enteros\ns.argsort() # Una lista de indices enteros\nCombinar filtrado y agregaciones:\ns = Series([5, 10, 15, 20, 25, 30])\ns.filter(lambda x: x &gt; 10).mean() # Promedio de los valores mayores a 10\ns.filter(lambda x: x &gt; 10).sum() # Suma de los valores mayores a 10\nIterar a trav칠s de la serie:\nfor x in Series(list(\"xyz\")):\n    print(x)\nDeterminar si la serie contiene un valor:\ns = Series([\"a\", \"a\", \"a\", None, \"z\"])\n\"a\" in s\n\n\n4.2 Pruebas para DataFrame\nEste conjunto de datos de ejemplo permite probar los distintos m칠todos implementados en las clases Series y DataFrame.\ndf = DataFrame({\n    \"id\": list(range(1, 31)),\n    \"nombre\": [f\"persona_{i}\" for i in range(1, 31)],\n    \"edad\": [20 + (i % 15) for i in range(30)],\n    \"activo\": [i % 2 == 0 for i in range(30)],\n    \"puntaje\": [\n        round(50 + (i * 1.5) % 25, 1) if i not in (4, 11, 19, 25) else None\n        for i in range(30)\n    ]\n})\nVerificar atributos:\ndf.height\ndf.width\ndf.shape\ndf.columns\ndf.schema\nSeleccionar columnas:\ndf[\"edad\"] # Devuelve una Series\nAplicar filtros sobre una o m칰ltiples columnas:\ndf.filter((\"edad\", lambda e: e &gt; 30))\ndf.filter((\"activo\", lambda a: a), (\"puntaje\", lambda p: p &gt; 60))\nSeleccionar subconjunto de columnas:\ndf.select(\"nombre\", \"puntaje\")\nOrdenar filas seg칰n una columna:\ndf.sort(\"edad\")\ndf.sort(\"puntaje\", descending=True)\nCombinar varios m칠todos: filtrar, seleccionar una columna y calcular una agregaci칩n:\ndf.filter((\"activo\", lambda a: a))[\"puntaje\"].mean()\nEstandarizar el puntaje de las personas:\ndf[\"puntaje_z\"] = (df[\"puntaje\"] - df[\"puntaje\"].mean()) / df[\"puntaje\"].std()",
    "crumbs": [
      "Trabajos Pr치cticos",
      "Trabajo pr치ctico final"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_individual.html#entregable",
    "href": "trabajos_practicos/trabajo_individual.html#entregable",
    "title": "Trabajo pr치ctico final",
    "section": "5 Entregable",
    "text": "5 Entregable\nLa entrega de este trabajo pr치ctico debe consistir exclusivamente en un archivo comprimido (.zip) que contenga los siguientes archivos, con los nombres y contenidos indicados:\n\nseries.py: implementaci칩n de la clase Series. Puede incluir un bloque de c칩digo de prueba, siempre que no se ejecute autom치ticamente al importar la clase desde otro m칩dulo.\ndataframe.py: implementaci칩n de la clase DataFrame. Tambi칠n puede contener pruebas, que no deben ejecutarse al importar el m칩dulo.\ntest_series.py: incluye los ejemplos y pruebas correspondientes a la clase Series presentados en este trabajo pr치ctico.\ntest_dataframe.py: incluye los ejemplos y pruebas correspondientes a la clase DataFrame. Si se prueban Series obtenidas desde un DataFrame, tambi칠n deben incluirse en este archivo.\n\nNo se deben agregar otros archivos ni utilizar nombres diferentes a los especificados.\nEl nombre del archivo comprimido debe seguir el formato: {Apellido}_{Nombre}.zip. Por ejemplo: Alvarez_Julian.zip.",
    "crumbs": [
      "Trabajos Pr치cticos",
      "Trabajo pr치ctico final"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_individual.html#evaluaci칩n",
    "href": "trabajos_practicos/trabajo_individual.html#evaluaci칩n",
    "title": "Trabajo pr치ctico final",
    "section": "6 Evaluaci칩n",
    "text": "6 Evaluaci칩n\nLa evaluaci칩n consta de dos partes:\n\nEjecuci칩n y revisi칩n del c칩digo: Se verificar치 que los archivos test_series.py y test_dataframe.py se ejecuten correctamente. Se valorar치 la presencia de comentarios que faciliten la comprensi칩n de las pruebas, as칤 como la correcta implementaci칩n de las clases Series y DataFrame en series.py y dataframe.py. Tambi칠n se considerar치n la organizaci칩n del c칩digo, su claridad, robustez y la reutilizaci칩n de los m칠todos desarrollados. Esta instancia se califica de 0 a 10 y se aprueba con una nota m칤nima de 6. Quienes la aprueben pasar치n a la etapa de presentaci칩n individual. Quienes la desaprueben podr치n acceder al examen final en condici칩n regular.\nPresentaci칩n individual: Cada estudiante deber치 realizar una breve exposici칩n (hasta 10 minutos) en la que describa c칩mo implement칩 las estructuras de datos y muestre la ejecuci칩n correcta de las pruebas. Luego, el docente realizar치 preguntas sobre el c칩digo desarrollado, que el estudiante deber치 responder (hasta 10 minutos).\n\n\n\n\n\n\n\nNota importante\n\n\n\nLos archivos test_series.py y test_dataframe.py deber칤an incluir todos los ejemplos y pruebas mencionados en este trabajo. Dado que la complejidad y extensi칩n del trabajo puede dificultar este objetivo, se considerar치n v치lidas las entregas que incluyan al menos el 80 % de las pruebas y que todas se ejecuten correctamente.",
    "crumbs": [
      "Trabajos Pr치cticos",
      "Trabajo pr치ctico final"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_individual.html#ayuda",
    "href": "trabajos_practicos/trabajo_individual.html#ayuda",
    "title": "Trabajo pr치ctico final",
    "section": "7 Ayuda",
    "text": "7 Ayuda\n\nLa Series necesita una estructura de datos subyacente donde almacenar valores, se recomienda usar una lista.\nEl DataFrame tambi칠n necesita una estructura de datos subyacente, se recomienda un diccionario, donde las claves sean los nombres de las columnas y los valores las Series.\nEl m칠todo __repr__ de las Series y DataFrame requiere que nos amiguemos con los m칠todos de las cadenas de caracteres. Tengan presentes: .ljust(), .rjust() y .center().\nLos m칠todos __getitem__, __setitem__ e __iter__ no han sido explorados a lo largo del curso. Pueden consultar el recurso Contenedores.\nLos m칠todos where y argsort de Series pueden parecer confusos e in칰tiles, pero ser치n de gran ayuda a la hora de implementar filter y sort en DataFrame.\nEste trabajo pr치ctico describe la interface p칰blica de las clases a implementar, no los detalles internos. Se recomienda que reutilicen, en la medida de lo posible, m칠todos y propiedades para reducir el trabajo y evitar errores. Por ejemplo, el m칠todo drop_nulls de DataFrame puede ser visto como un caso particular de filter.",
    "crumbs": [
      "Trabajos Pr치cticos",
      "Trabajo pr치ctico final"
    ]
  }
]