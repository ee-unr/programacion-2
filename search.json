[
  {
    "objectID": "informacion/programa.html",
    "href": "informacion/programa.html",
    "title": "Programa",
    "section": "",
    "text": "Los profesionales en Estad√≠stica y Ciencia de Datos necesitan contar con habilidades avanzadas de programaci√≥n, que les permitan abordar problemas complejos y desarrollar soluciones eficientes y robustas.\nLa asignatura Programaci√≥n 2 introduce a los estudiantes a conceptos y pr√°cticas avanzadas de la programaci√≥n, incorporando herramientas y paradigmas que resultan fundamentales para el desarrollo profesional en Estad√≠stica y Ciencia de Datos.\nLa asignatura profundiza en enfoques como la programaci√≥n funcional y la programaci√≥n orientada a objetos, promoviendo el desarrollo de soluciones estructuradas, reutilizables, robustas y escalables. Adem√°s, se abordan conceptos fundamentales de estructuras de datos y algoritmos, relevantes para el dise√±o y an√°lisis de programas eficientes, as√≠ como para la comprensi√≥n de la complejidad computacional. Se focaliza en el lenguaje Python, ampliamente utilizado en la industria y la academia por su versatilidad, su ecosistema de librer√≠as y su capacidad para integrarse con diversas tecnolog√≠as.\nDictada en el segundo cuatrimestre del primer a√±o, Programaci√≥n 2 completa los contenidos del √°rea de Fundamentos Computacionales en el Ciclo de Formaci√≥n T√©cnica en Estad√≠stica y Ciencia de Datos, iniciada en el primer cuatrimestre con Programaci√≥n 1. De este modo, consolida las competencias inform√°ticas de los estudiantes y los prepara para afrontar asignaturas m√°s avanzadas y desaf√≠os profesionales que requieren un dominio s√≥lido de la programaci√≥n. Asimismo, fomenta buenas pr√°cticas de desarrollo de c√≥digo, el uso eficiente de los recursos computacionales y el pensamiento cr√≠tico en la resoluci√≥n de problemas.",
    "crumbs": [
      "Informaci√≥n",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/programa.html#fundamentaci√≥n",
    "href": "informacion/programa.html#fundamentaci√≥n",
    "title": "Programa",
    "section": "",
    "text": "Los profesionales en Estad√≠stica y Ciencia de Datos necesitan contar con habilidades avanzadas de programaci√≥n, que les permitan abordar problemas complejos y desarrollar soluciones eficientes y robustas.\nLa asignatura Programaci√≥n 2 introduce a los estudiantes a conceptos y pr√°cticas avanzadas de la programaci√≥n, incorporando herramientas y paradigmas que resultan fundamentales para el desarrollo profesional en Estad√≠stica y Ciencia de Datos.\nLa asignatura profundiza en enfoques como la programaci√≥n funcional y la programaci√≥n orientada a objetos, promoviendo el desarrollo de soluciones estructuradas, reutilizables, robustas y escalables. Adem√°s, se abordan conceptos fundamentales de estructuras de datos y algoritmos, relevantes para el dise√±o y an√°lisis de programas eficientes, as√≠ como para la comprensi√≥n de la complejidad computacional. Se focaliza en el lenguaje Python, ampliamente utilizado en la industria y la academia por su versatilidad, su ecosistema de librer√≠as y su capacidad para integrarse con diversas tecnolog√≠as.\nDictada en el segundo cuatrimestre del primer a√±o, Programaci√≥n 2 completa los contenidos del √°rea de Fundamentos Computacionales en el Ciclo de Formaci√≥n T√©cnica en Estad√≠stica y Ciencia de Datos, iniciada en el primer cuatrimestre con Programaci√≥n 1. De este modo, consolida las competencias inform√°ticas de los estudiantes y los prepara para afrontar asignaturas m√°s avanzadas y desaf√≠os profesionales que requieren un dominio s√≥lido de la programaci√≥n. Asimismo, fomenta buenas pr√°cticas de desarrollo de c√≥digo, el uso eficiente de los recursos computacionales y el pensamiento cr√≠tico en la resoluci√≥n de problemas.",
    "crumbs": [
      "Informaci√≥n",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/programa.html#objetivos",
    "href": "informacion/programa.html#objetivos",
    "title": "Programa",
    "section": "Objetivos",
    "text": "Objetivos\nQue los estudiantes logren:\n\nanalizar problemas computacionales y formular soluciones algor√≠tmicas adecuadas;\nimplementar esas soluciones mediante el desarrollo de programas en Python, seleccionando estructuras de datos apropiadas y evaluando la eficiencia de los algoritmos involucrados;\nidentificar y aplicar los paradigmas funcional y orientado a objetos cuando resulte pertinente, desarrollando programas que integren estos enfoques; y\nutilizar e integrar m√≥dulos y librer√≠as que permitan extender, organizar y mejorar las funcionalidades de sus programas.",
    "crumbs": [
      "Informaci√≥n",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/programa.html#contenidos",
    "href": "informacion/programa.html#contenidos",
    "title": "Programa",
    "section": "Contenidos",
    "text": "Contenidos\n\nUnidad 1: Introducci√≥n a Python\n\nLenguaje Python y su ecosistema. Uso de la interfaz Positron. Sintaxis de Python. Expresiones. Variables y asignaciones. Tipos de datos elementales. Operadores num√©ricos, de comparaci√≥n y l√≥gicos. Funciones. Ejecuci√≥n condicional de c√≥digo. Bucles definidos y no definidos. Listas, tuplas y diccionarios. Uso de c√≥digo externo. M√≥dulos y librer√≠as. Librer√≠a est√°ndar de Python. Instalaci√≥n y gesti√≥n de librer√≠as. Scripting. Lectura y escritura de archivos de texto plano. Modularizaci√≥n de programas.\n\nUnidad 2: Programaci√≥n funcional\n\nPrincipios fundamentales. Funciones como ciudadanos de primera clase. Funciones puras. Funciones an√≥nimas. Closures. Recursi√≥n. Funciones de orden superior: map, filter, reduce. Evaluaci√≥n estricta y no estricta. Evaluaci√≥n perezosa (lazy) e inmediata (eager). Generadores. Aplicaci√≥n parcial de funciones. Decoradores.\n\nUnidad 3: Programaci√≥n orientada a objetos\n\nPrincipios fundamentales. Objetos, clases e instancias. Atributos y m√©todos. Propiedades p√∫blicas y privadas. M√©todos de clase y m√©todos de instancia. Encapsulamiento. Herencia simple y m√∫ltiple. Polimorfismo. M√©todos especiales (dunder methods). Decoradores aplicados a m√©todos. Sobrecarga de operadores.\n\nUnidad 4: Estructuras de datos\n\nConcepto y clasificaci√≥n. Estructuras lineales: listas, listas enlazadas, pilas y colas. Operaciones b√°sicas: agregar, quitar y recorrer. Estructuras no lineales: √°rboles y grafos. Recorridos de √°rboles y grafos. Uso de colecciones de Python (list, deque, dict, set). Arreglos multidimensionales de NumPy.\n\nUnidad 5: Algoritmos de b√∫squeda y ordenamiento\n\nConcepto de algoritmo y complejidad. Notaci√≥n Big O. B√∫squeda lineal y binaria. Algoritmos de ordenamiento: bubble sort, insertion sort, selection sort, quick sort y merge sort. Comparaci√≥n de eficiencia. Funciones de b√∫squeda y ordenamiento en Python (sorted, sort, heapq).",
    "crumbs": [
      "Informaci√≥n",
      "Programa"
    ]
  },
  {
    "objectID": "practica/01_introduccion_a_python.html",
    "href": "practica/01_introduccion_a_python.html",
    "title": "P1 - Introducci√≥n a Python",
    "section": "",
    "text": "Pr√°ctica 1.",
    "crumbs": [
      "Pr√°ctica",
      "P1 - Introducci√≥n a Python"
    ]
  },
  {
    "objectID": "trabajos_practicos/descripcion.html",
    "href": "trabajos_practicos/descripcion.html",
    "title": "Descripci√≥n",
    "section": "",
    "text": "Ac√° explicamos las pautas para los TP.",
    "crumbs": [
      "Trabajos Pr√°cticos",
      "Descripci√≥n"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html",
    "href": "trabajos_practicos/trabajo_grupal.html",
    "title": "Trabajo Pr√°ctico",
    "section": "",
    "text": "Trabajo Pr√°ctico",
    "crumbs": [
      "Trabajos Pr√°cticos",
      "Trabajo Pr√°ctico"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_individual.html",
    "href": "trabajos_practicos/trabajo_individual.html",
    "title": "Trabajo Pr√°ctico Final",
    "section": "",
    "text": "Trabajo Pr√°ctico Final",
    "crumbs": [
      "Trabajos Pr√°cticos",
      "Trabajo Pr√°ctico Final"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programaci√≥n II",
    "section": "",
    "text": "Programaci√≥n II\n\n\n ¬† Ciclo de Formaci√≥n T√©cnica - Estad√≠stica y Ciencia de Datos\n ¬† Facultad de Ciencias Econ√≥micas y Estad√≠stica (UNR)\n ¬† 2¬∞ Cuatrimestre 2025"
  },
  {
    "objectID": "index.html#docentes",
    "href": "index.html#docentes",
    "title": "Programaci√≥n II",
    "section": "Docentes",
    "text": "Docentes\n\n\nTom√°s Capretto\n\n ¬† tomas.capretto@fcecon.unr.edu.ar\n ¬† Consultas: TBD\n\n\n\nLuciano Anselmino\n\n ¬† luciano.anselmino@fcecon.unr.edu.ar\n ¬† Consultas: TBD\n\n\n\nJoaqu√≠n Bermejo\n\n ¬† joaquin.bermejo@fcecon.unr.edu.ar\n ¬† Consultas: TBD\n\n\n\nDolores Sollberger\n\n ¬† dolores.sollberger@fcecon.unr.edu.ar\n ¬† Consultas: TBD"
  },
  {
    "objectID": "informacion/calendario.html",
    "href": "informacion/calendario.html",
    "title": "Calendario",
    "section": "",
    "text": "Semana\nFecha\nTemas\nOtras actividades\n\n\n\n\n1\n4 de agosto\n‚Ä¢ Lenguaje Python y su ecosistema.‚Ä¢ Uso de Python en la terminal.‚Ä¢ Uso de Positron.‚Ä¢ Python en Positron.‚Ä¢ Python: expresiones; variables y asignaciones; tipos de datos elementales; operadores num√©ricos, de comparaci√≥n y l√≥gicos.‚Ä¢ Jupyter Notebooks.‚Ä¢ Definici√≥n de funciones.‚Ä¢ Ejecuci√≥n condicional de c√≥digo.\n\n\n\n2\n11 de agosto\n‚Ä¢ Bucles definidos y no definidos: for, while, break, continue.‚Ä¢ Estructuras de datos nativas de Python: list, tuple, set y dict.‚Ä¢ Complemento: str, bytes, bytearray y range.\n\n\n\n3\n17 de agosto\n‚Ä¢ Uso de c√≥digo externo (propio y de terceros).‚Ä¢ M√≥dulos y librer√≠as.‚Ä¢ Librer√≠a est√°ndar de Python.‚Ä¢ Instalaci√≥n y gesti√≥n de librer√≠as.‚Ä¢ Scripting.‚Ä¢ Lectura y escritura de archivos de texto plano.‚Ä¢ Modularizaci√≥n de programas.\n\n\n\n4\n25 de agosto\n‚Ä¢ Funciones como ciudadanos de primera clase.‚Ä¢ Funciones puras.‚Ä¢ Funciones an√≥nimas.‚Ä¢ Closures.‚Ä¢ Recursi√≥n.\n\n\n\n5\n1 de septiembre\n‚Ä¢ Funciones de orden superior: map, filter, reduce.‚Ä¢ Evaluaci√≥n estricta y no estricta.‚Ä¢ Evaluaci√≥n perezosa (lazy) e inmediata (eager).‚Ä¢ Generadores.‚Ä¢ Aplicaci√≥n parcial de funciones.‚Ä¢ Decoradores.\n\n\n\n6\n15 de septiembre\n‚Ä¢ Objetos, clases e instancias.‚Ä¢ Atributos y m√©todos.‚Ä¢ Propiedades p√∫blicas y privadas.‚Ä¢ M√©todos de clase y m√©todos de instancia.\n\n\n\n7\n22 de septiembre\n‚Ä¢ Encapsulamiento.‚Ä¢ Herencia simple y m√∫ltiple.‚Ä¢ Polimorfismo.‚Ä¢ Abstracci√≥n.\n\n\n\n8\n29 de septiembre\n‚Ä¢ M√©todos especiales (dunder methods).‚Ä¢ Decoradores aplicados a m√©todos.‚Ä¢ Sobrecarga de operadores.\nParcial\n\n\n9\n6 de octubre\n‚Ä¢ Concepto y clasificaci√≥n.‚Ä¢ Estructuras lineales y no lineales.‚Ä¢ Listas y listas enlazadas.‚Ä¢ Operaciones b√°sicas: agregar, quitar y recorrer.\nPresentaci√≥n TP Grupal\n\n\n10\n13 de octubre\n‚Ä¢ Hashing.‚Ä¢ Diccionarios y conjuntos como estructuras asociativas.‚Ä¢ √Årboles y grafos.\nRecuperatorio\n\n\n11\n20 de octubre\n‚Ä¢ Arreglos multidimensionales de NumPy.\n\n\n\n12\n27 de octubre\n‚Ä¢ Concepto de algoritmo y complejidad.‚Ä¢ Algoritmos de b√∫squeda.‚Ä¢ B√∫squeda lineal y binaria.‚Ä¢ Notaci√≥n Big O.\nEntrega TP Grupal\n\n\n13\n3 de noviembre\n‚Ä¢ Algoritmos de ordenamiento.‚Ä¢ bubble sort, insert sort, select sort, quick sort y merge sort.‚Ä¢ Comparaci√≥n de algoritmos de ordenamiento.\nPresentaci√≥n TP Individual\n\n\n14\n10 de noviembre\n‚Ä¢ Funciones de b√∫squeda y ordenamiento en Python.\n\n\n\n15\n17 de noviembre\n\n\n\n\n16\n24 de noviembre\n\nEntrega y defensa TP Individual",
    "crumbs": [
      "Informaci√≥n",
      "Calendario"
    ]
  },
  {
    "objectID": "informacion/bibliografia.html",
    "href": "informacion/bibliografia.html",
    "title": "Bibliograf√≠a",
    "section": "",
    "text": "Principal\n\nCormen et¬†al. (2022) Downey (2024) Kalb (2022) Kubica (2022) Lott y Phillips (2021) Lott (2022) Mertz (2015) Miller, Ranum, y Yasinovskyy (2023) Sedgewick y Wayne (2011) Sedgewick, Wayne, y Dondero (2015) Sweigart (2020) Tuckfield (2021)\n\n\n\nCormen, Thomas H., Charles E. Leiserson, Ronald L. Rivest, y Clifford Stein. 2022. Introduction to Algorithms. 4th ed. MIT.\n\n\nDowney, Allen B. 2024. Think Python. 3.¬™ ed. O‚ÄôReilly Media. https://allendowney.github.io/ThinkPython/.\n\n\nKalb, Irv. 2022. Object-Oriented Python. No Starch Press.\n\n\nKubica, Jacek. 2022. Data Structures the Fun Way. 1st ed. No Starch Press.\n\n\nLott, Steven F. 2022. Functional Python Programming. 3rd ed. Packt Publishing.\n\n\nLott, Steven F., y Dusty Phillips. 2021. Python Object-Oriented Programming. 4th ed. Packt Publishing.\n\n\nMertz, David. 2015. Functional Programming in Python. O‚ÄôReilly Media.\n\n\nMiller, Bradley, David Ranum, y Jan Yasinovskyy. 2023. Problem Solving with Algorithms and Data Structures Using Python. 3rd ed. Franklin, Beedle & Associates.\n\n\nSedgewick, Robert, y Kevin Wayne. 2011. Algorithms. 4th ed. Addison-Wesley Professional.\n\n\nSedgewick, Robert, Kevin Wayne, y Robert Dondero. 2015. Introduction to Programming in Python. Addison-Wesley Professional.\n\n\nSweigart, Al. 2020. Beyond the Basic Stuff with Python. No Starch Press. https://inventwithpython.com/beyond/.\n\n\nTuckfield, Bradford. 2021. Dive Into Algorithms. No Starch Press.\n\n\n\n\nComplementaria\n\nHetland (2014) Mailund (2023) Sweigart (2021) Vaughan (2019) Wickham (2019)\n\n\n\n\n\nHetland, Magnus Lie. 2014. Python Algorithms. 2.¬™ ed. Apress.\n\n\nMailund, Thomas. 2023. Functional Programming in R 4. 2.¬™ ed. Apress.\n\n\nSweigart, Al. 2021. The Big Book of Small Python Projects. No Starch Press. https://inventwithpython.com/bigbookpython/.\n\n\nVaughan, Lee. 2019. Impractical Python Projects. No Starch Press.\n\n\nWickham, Hadley. 2019. Advanced R. 2.¬™ ed. Chapman & Hall/CRC. https://adv-r.hadley.nz/.",
    "crumbs": [
      "Informaci√≥n",
      "Bibliograf√≠a"
    ]
  },
  {
    "objectID": "informacion/aprobacion.html",
    "href": "informacion/aprobacion.html",
    "title": "Condiciones de aprobaci√≥n",
    "section": "",
    "text": "üìù Examen parcial: individual y escrito. Hay un recuperatorio, de similares caracter√≠sticas, que reemplaza la nota del parcial.\nü§ù Trabajo pr√°ctico grupal: se hace fuera de clase, en grupos de entre dos y tres integrantes.\nüßë‚Äçüíª Trabajo pr√°ctico individual: opcional para promoci√≥n, con presentaci√≥n y defensa oral.\nTodas las instancias se califican en una escala de 0 a 10 y se aprueban con 6.",
    "crumbs": [
      "Informaci√≥n",
      "Condiciones de aprobaci√≥n"
    ]
  },
  {
    "objectID": "informacion/aprobacion.html#instancias-de-evaluaci√≥n",
    "href": "informacion/aprobacion.html#instancias-de-evaluaci√≥n",
    "title": "Condiciones de aprobaci√≥n",
    "section": "",
    "text": "üìù Examen parcial: individual y escrito. Hay un recuperatorio, de similares caracter√≠sticas, que reemplaza la nota del parcial.\nü§ù Trabajo pr√°ctico grupal: se hace fuera de clase, en grupos de entre dos y tres integrantes.\nüßë‚Äçüíª Trabajo pr√°ctico individual: opcional para promoci√≥n, con presentaci√≥n y defensa oral.\nTodas las instancias se califican en una escala de 0 a 10 y se aprueban con 6.",
    "crumbs": [
      "Informaci√≥n",
      "Condiciones de aprobaci√≥n"
    ]
  },
  {
    "objectID": "informacion/aprobacion.html#condiciones-de-aprobaci√≥n",
    "href": "informacion/aprobacion.html#condiciones-de-aprobaci√≥n",
    "title": "Condiciones de aprobaci√≥n",
    "section": "Condiciones de aprobaci√≥n",
    "text": "Condiciones de aprobaci√≥n\n\nPromoci√≥n\n\nQuienes aprueben el parcial individual (con nota \\(\\text{P}\\)), el trabajo pr√°ctico grupal (con nota \\(\\text{T}\\)) y el trabajo pr√°ctico individual con defensa oral (con nota \\(\\text{O}\\)), adquieren la condici√≥n de estudiante promovido y su nota final se calcula como \\(0.5 \\times \\text{P} + 0.2 \\times \\text{T} + 0.3 \\times \\text{O}\\).\n\nRegularidad\n\nQuienes aprueben el parcial individual (o su recuperatorio) y el trabajo pr√°ctico grupal, pero no accedan o no aprueben el trabajo pr√°ctico individual, adquieren la condici√≥n de estudiante regular.\n\nLibres\n\nQuienes no aprueben el parcial individual (ni su recuperatorio) o el trabajo pr√°ctico grupal, adquieren la condici√≥n de estudiante libre.",
    "crumbs": [
      "Informaci√≥n",
      "Condiciones de aprobaci√≥n"
    ]
  },
  {
    "objectID": "teoria/01_introduccion_a_python/clase_1.html",
    "href": "teoria/01_introduccion_a_python/clase_1.html",
    "title": "Clase 1",
    "section": "",
    "text": "Python es un lenguaje de programaci√≥n. Pero podemos pensarlo intuitivamente como una super-calculadora. Python nos ayuda a hacer lo mismo que una calculadora, y como vamos a ver, mucho m√°s.\nEmpecemos utilizando a Python como si fuese una calculadora. Para eso vamos a crear un bloque de c√≥digo en la notebook y escribimos algunas cuentas tal como lo hacemos en cualquier calculadora.\n\n2 * 3\n\n6\n\n\nNo tenemos la necesidad de pisar el c√≥digo todo el tiempo. Podemos escribir nuevas celdas de c√≥digo, y as√≠ podemos ir mostrando diferentes c√≥mputos y sus resultados.\n\n100 / 3.5\n\n28.571428571428573\n\n\n\n20 + 5\n\n25\n\n\n\n13 - 3\n\n10\n\n\n\n10 * 5.5\n\n55.0",
    "crumbs": [
      "Teor√≠a",
      "U1 - Introducci√≥n a Python",
      "Clase 1"
    ]
  },
  {
    "objectID": "teoria/01_introduccion_a_python/clase_1.html#una-super-calculadora",
    "href": "teoria/01_introduccion_a_python/clase_1.html#una-super-calculadora",
    "title": "Clase 1",
    "section": "",
    "text": "Python es un lenguaje de programaci√≥n. Pero podemos pensarlo intuitivamente como una super-calculadora. Python nos ayuda a hacer lo mismo que una calculadora, y como vamos a ver, mucho m√°s.\nEmpecemos utilizando a Python como si fuese una calculadora. Para eso vamos a crear un bloque de c√≥digo en la notebook y escribimos algunas cuentas tal como lo hacemos en cualquier calculadora.\n\n2 * 3\n\n6\n\n\nNo tenemos la necesidad de pisar el c√≥digo todo el tiempo. Podemos escribir nuevas celdas de c√≥digo, y as√≠ podemos ir mostrando diferentes c√≥mputos y sus resultados.\n\n100 / 3.5\n\n28.571428571428573\n\n\n\n20 + 5\n\n25\n\n\n\n13 - 3\n\n10\n\n\n\n10 * 5.5\n\n55.0",
    "crumbs": [
      "Teor√≠a",
      "U1 - Introducci√≥n a Python",
      "Clase 1"
    ]
  },
  {
    "objectID": "teoria/01_introduccion_a_python/clase_1.html#tipos-de-datos",
    "href": "teoria/01_introduccion_a_python/clase_1.html#tipos-de-datos",
    "title": "Clase 1",
    "section": "Tipos de datos",
    "text": "Tipos de datos\nComo cualquier lenguaje de programaci√≥n, Python ofrece diferentes tipos de datos. ¬°Una super-calculadora no se puede rebajar a trabajar solo con n√∫meros!\nCada tipo de dato nos ayuda a resolver una tarea distinta. Por ejemplo, si quiero hacer operaciones matem√°ticas voy a necesitar de n√∫meros, pero si quiero escribir un correo electr√≥nico voy a necesitar de texto.\nA continuaci√≥n vamos a introducir los tipos de datos m√°s b√°sicos que Python nos ofrece.\nM√°s adelante tambi√©n veremos otros tipos de datos m√°s complejos que nos van a permitir resolver problemas m√°s interesantes.\n\nN√∫meros\nAcabamos de hacer cuentas matem√°ticas somo si tuvieramos una calculadora. Para eso usamos n√∫meros, los conocidos de toda la vida.\nSin notarlo, utilizamos dos tipos de n√∫meros distintos: los n√∫meros de tipo entero (int) y los n√∫meros de tipo flotante (float).\nLo siguiente es un n√∫mero entero:\n\n50\n\n50\n\n\nY el siguiente es un ejemplo de un n√∫mero flotante:\n\n36.8\n\n36.8\n\n\nUtilizando la funci√≥n type() Python nos devuelve el tipo del objeto.\n\ntype(10)\n\nint\n\n\n\ntype(10.5)\n\nfloat\n\n\n\ntype(10.0)\n\nfloat\n\n\n\ntype(10.)\n\nfloat\n\n\n\n\nCadenas de texto\nPara ser una super-calculadora, Python tiene que ser capaz de trabajar con objetos m√°s complejos que los n√∫meros.\nUn ejemplo de esto es el texto. El texto se representa con un objeto llamado cadena de texto.\nPara construir una cadena de texto se utilizan comillas.\nEstas se ponen al principio y al final del texto e indican el principio y el final de la cadena. Las comillas pueden ser dobles \" o simples '.\n\n\"Programando en Python\"\n\n'Programando en Python'\n\n\n\n'Con comillas simples, tambi√©n.'\n\n'Con comillas simples, tambi√©n.'\n\n\nNo hay diferencia entre las comillas simples ' y las dobles \". Sin embargo, debemos tener presente que hay que usar el mismo tipo de comillas para abrir y para cerrar la cadena.\nAl imprimir la cadena de texto, desaparecen las comillas.\nPara imprimir un objeto de Python se utiliza la funci√≥n print().\n\nprint('Con comillas simples, tambi√©n!')\n\nCon comillas simples, tambi√©n!\n\n\nTambi√©n se pueden crear cadenas de texto usando tres veces las comillas (le decimos comillas triples).\nEsto nos permite crear cadenas que est√°n escritas en m√∫ltiples l√≠neas.\n\nprint(\"\"\"Se puede escribir texto\nen varias lineas.\n¬°Est√° muy bueno!\"\"\")\n\nSe puede escribir texto\nen varias lineas.\n¬°Est√° muy bueno!\n\n\nUna alternativa para escribir texto en m√∫ltiples l√≠neas es utilizar el el caracter especial \\n que indica un salto de l√≠nea.\n\nprint(\"Primera l√≠nea\\nsegunda l√≠nea\\ntercera l√≠nea.\")\n\nPrimera l√≠nea\nsegunda l√≠nea\ntercera l√≠nea.\n\n\nPodemos ver que el caracter \\n no aparece ninguna vez en el texto.\nEn cambio, donde el texto contiene \\n, se introduce un salto de l√≠nea.\n\n\"Primera l√≠nea\\nsegunda l√≠nea\\ntercera l√≠nea.\"\n\n'Primera l√≠nea\\nsegunda l√≠nea\\ntercera l√≠nea.'\n\n\n\n\n\n\n\n\n¬°Atencion! ü§ì\n\n\n\n¬øCu√°l es la diferencia entre usar print() y no usarlo?\n\nCuando usamos print() se imprime el objeto de una manera humanamente legible.\nCuando no lo usamos, se muestra una representaci√≥n del objeto. Esta representaci√≥n tiene que ser lo menos ambigua posible.\n\nPor este motivo es que se muestran las comillas a la hora de representar una cadena.\n\n\n\n\nOtra situaci√≥n en la que usar print() genera una diferencia es cuando se quieren mostrar varios objetos. Por ejemplo, comparemos el resultado de los siguientes bloques:\n\n\"mensaje 1\"\n10\n\"mensaje 2\"\n\n'mensaje 2'\n\n\n\nprint(\"mensaje 1\")\nprint(10)\nprint(\"mensaje 2\")\n\nmensaje 1\n10\nmensaje 2\n\n\n\n\nL√≥gicos (o Booleanos)\nComo veremos m√°s adelante, nuestros programas suelen tener que decidir entre diferentes acciones a tomar seg√∫n se cumpla o no cierta condici√≥n.\nPara representar esta situaci√≥n utilizamos un tipo especial de dato conocido como l√≥gico o booleano, que puede tomar √∫nicamente dos valores: True o False.\nSi la condici√≥n se cumple, el resultado ser√° True; de lo contrario, ser√° False.\n\nTrue\n\nTrue\n\n\n\nFalse\n\nFalse\n\n\n\ntype(True)\n\nbool\n\n\n\ntype(False)\n\nbool\n\n\n\n\n\n\n\n\nRese√±a hist√≥rica üìú\n\n\n\nEste tipo de datos se llama Booleano en honor al matem√°tico George Boole.\n\n\n\n\nNulo\nEl valor nulo, llamado None en Python, representa la ausencia de valor o el vac√≠o.\nSe utiliza habitualmente para indicar que algo no tiene un valor asignado.\nSi intentamos mostrar el valor de None, veremos que no aparece nada.\n\nNone\n\nEn cambio, si imprimimos el objeto None, vemos el mensaje None.\n\nprint(None)\n\nNone\n\n\n¬øY cu√°l es su tipo?\n\ntype(None)\n\nNoneType\n\n\nSolamente los objetos None son del tipo NoneType.\n\n\n\n\n\n\n¬øPor qu√© existe el valor nulo? ü§î\n\n\n\nMuchas veces nuestro programa, o alguna parte del mismo, realiza una tarea que no devuelve ning√∫n resultado.\nPodr√≠amos ponernos de acuerdo en representar ‚Äúning√∫n resultado‚Äù usando un n√∫mero (0), una cadena vac√≠a (\"\") o algo parecido. Pero estos valores representan algo espec√≠fico, no la ausencia total de valor.\nPara expresar claramente que no hay ning√∫n resultado, Python incluye un valor especial llamado None.\n\n\nEjemplos\n\nUn usuario completa un formulario con datos personales, pero algunos campos no son obligatorios y quedan sin completar.\nUna funci√≥n busca un elemento en una lista; cuando no encuentra lo buscado, devuelve un valor especial indicando que el resultado est√° ausente.\n\nEn general, cuando se quiera representar la ausencia de informaci√≥n se utilizar√° None.\n\n\nConversi√≥n entre tipos de datos\nQue existan distintos tipos de datos no significa que un objeto de un tipo no pueda ‚Äúconvertirse‚Äù a otro.\nEn muchos casos es posible convertir entre tipos de datos. Por ejemplo, un n√∫mero siempre se puede convertir a una cadena de caracteres, pero no cualquier cadena puede convertirse a un n√∫mero.\nPara convertir un objeto a otro tipo utilizamos funciones con el nombre del tipo al que queremos convertir, como str(), int() o bool(). Estas funciones reciben como argumento el objeto a convertir.\nVeamos algunos ejemplos:\n\nstr(256)\n\n'256'\n\n\n\nstr(None)\n\n'None'\n\n\n\nint(165.5)\n\n165\n\n\n\nint(165.8)\n\n165\n\n\n\nint(\"165\")\n\n165\n\n\n\nfloat(\"165.0\")\n\n165.0\n\n\n\n\nResumen\n\nPython tiene distintos tipos de datos.\nCada tipo de dato es √∫til para resolver diferentes problemas.\n\nA lo largo del curso veremos much√≠simos ejemplos.\n\nAl principio, tener varios tipos de datos puede parecer complejo.\n\nSin embargo, nos resultar√°n muy naturales a medida que los usemos para resolver problemas concretos.\n\n\n\n\n\n\n\n\n\nTipo de dato\nEjemplos\n\n\n\n\nN√∫meros enteros (int)\n-2, -1, 0, 10, 200\n\n\nN√∫meros de punto flotante (float)\n-200.789, -1.0, 0.0, 17.8\n\n\nCadenas de texto (str)\n\"a\", \"abc\", \"Rosario, Santa Fe\"\n\n\nBooleanos (bool)\nTrue, False\n\n\nValor nulo (NoneType)\nNone",
    "crumbs": [
      "Teor√≠a",
      "U1 - Introducci√≥n a Python",
      "Clase 1"
    ]
  },
  {
    "objectID": "teoria/01_introduccion_a_python/clase_1.html#variables",
    "href": "teoria/01_introduccion_a_python/clase_1.html#variables",
    "title": "Clase 1",
    "section": "Variables",
    "text": "Variables\n¬øEs necesario escribir expl√≠citamente los valores con los que trabajamos cada vez que los usamos? Afortunadamente, la respuesta es no.\nLos lenguajes de programaci√≥n m√°s populares permiten usar variables.\nPodemos pensar las variables como etiquetas o nombres que asignamos a los objetos en nuestro programa.\nUna vez creada una variable con cierto valor, podemos usar directamente su nombre en lugar de volver a escribir el valor completo.\n\nmensaje = \"¬°Hola, curso!\"\nprint(mensaje)\n\n¬°Hola, curso!\n\n\n\nprint(\"¬°Hola, curso!\")\n\n¬°Hola, curso!\n\n\nPara crear una variable se necesita:\n\nEl nombre.\nEl operador de asignaci√≥n.\nEl valor que queremos asignar a la variable.\n\nEn nuestro caso, el nombre de la variable es mensaje y el valor es \"¬°Hola, curso!\".\nLuego, cuando accedemos a la variable mensaje dentro de la funci√≥n print(), Python nos devuelve el valor de la variable, es decir, ¬°Hola, curso!\".\nVeamos otros ejemplos‚Ä¶\n\npi = 3.14159\nfruta_favorita = \"manzana\"\npython_bueno = True\n\nEn el siguiente diagrama se muestra c√≥mo las variables que creamos funcionan simplemente como etiquetas para los valores asignados.\nCada vez que utilizamos una de estas etiquetas, accedemos directamente al valor que representa.\n\n\n\n\n\n\nprint(pi * 10)\n\n31.4159\n\n\n\nfruta_favorita\n\n'manzana'\n\n\n\npython_bueno\n\nTrue\n\n\nLas variables no solo evitan que escribamos repetidamente los mismos valores en nuestro programa, sino que tambi√©n permiten:\n\nGeneralizar el programa\n\nAl cambiar el valor de una variable, todas las partes del programa que la usan se actualizan autom√°ticamente.\n\nMejorar la legibilidad del c√≥digo\n\nSi elegimos nombres claros y descriptivos, el programa ser√° mucho m√°s f√°cil de leer y entender.\n\n\nPor ejemplo, los siguientes bloques de c√≥digo producen el mismo resultado, pero el segundo es mucho m√°s informativo:\n\n1500 * 8\n\n12000\n\n\n\nprecio = 1500\ncantidad = 8\nprecio * cantidad\n\n12000\n\n\n\nNombres permitidos\nNo todos los nombres que imaginemos se pueden utilizar como variables en Python.\nTenemos que tener en cuenta las siguientes reglas. Los nombres de variables‚Ä¶\n\nSolo pueden contener letras, n√∫meros y guiones bajos (_).\nDeben comenzar con una letra o un gui√≥n bajo, pero no con un n√∫mero.\n\nPor ejemplo, mensaje_1 es v√°lido, pero 1_mensaje no lo es.\n\nNo pueden contener espacios.\n\nPor eso usamos fruta_favorita en lugar de fruta favorita.\n\nNo pueden ser palabras reservadas de Python.\n\nLas palabras reservadas se encuentran al final de este apunte.\n\n\nAdem√°s, tambi√©n vale la pena tener presente estos consejos:\n\nUs√° nombres breves pero descriptivos.\n\nnombre es preferible a n.\nfruta_favorita es preferible a frut_fav.\n\nEvit√° utilizar tildes, la letra √± u otros caracteres espec√≠ficos del castellano.\n\n\n\nEliminar variables\nEs posible que, despu√©s de crear nuestras variables y realizar las operaciones necesarias, queramos eliminarlas.\nPara borrar una variable, Python ofrece la sentencia del (del ingl√©s delete, que significa eliminar o borrar).\n\ndel fruta_favorita",
    "crumbs": [
      "Teor√≠a",
      "U1 - Introducci√≥n a Python",
      "Clase 1"
    ]
  },
  {
    "objectID": "teoria/01_introduccion_a_python/clase_1.html#operadores",
    "href": "teoria/01_introduccion_a_python/clase_1.html#operadores",
    "title": "Clase 1",
    "section": "Operadores",
    "text": "Operadores\nLos operadores son s√≠mbolos que se utilizan para realizar operaciones o acciones sobre los objetos con los que estamos trabajando.\nHasta ahora, vimos que podemos tener n√∫meros, texto, y otras objetos un poco mas extra√±os como los booleanos e incluso algo que representa a la nada misma.\nA continuaci√≥n, comenzamos a ver algunas de las tareas que podemos hacer con ellos.\n\nOperadores aritm√©ticos\nPython incluye los mismos operadores aritm√©ticos que solemos utilizar en nuestro d√≠a a d√≠a para hacer operaciones matem√°ticas.\nEstos se parecen much√≠simo a los que usamos en una calculadora, por lo que podr√≠amos entenderlo incluso sin saber que es Python.\nAlgunos operadores son los siguientes:\n\nSuma (+)\nResta (-)\nMultiplicaci√≥n (*)\nPotencia (**)\nDivisi√≥n (/)\nDivisi√≥n entera (//)\nM√≥dulo (%)\n\n\nSuma (+)\n\n10 + 25\n\n35\n\n\n\n10.0 + 25.0\n\n35.0\n\n\n\n-8 + 12.1\n\n4.1\n\n\nEl operador suma tambi√©n puede ser usado con un solo argumento:\nEn este caso no modifica en nada al valor 8.\n\n\n\nResta (-)\n\n11 - 8\n\n3\n\n\n\n100 - 100.0\n\n0.0\n\n\n\n-35 - 28\n\n-63\n\n\nEl operador resta tambi√©n puede ser usado con un solo argumento:\n\n- 7\n\n-7\n\n\n\n\nMultiplicaci√≥n (*) y potencia (**)\n\n21 * 5\n\n105\n\n\n\n21 * 5.0\n\n105.0\n\n\n\n21.0 * 5.0\n\n105.0\n\n\n\n2 ** 3\n\n8\n\n\n\n2 ** 3.0\n\n8.0\n\n\n\n\n\n\n\n\nConclusiones\n\n\n\n\nSi utilizamos valores enteros, el resultado es un valor entero.\nSi al menos uno de los dos argumentos es de tipo flotante, el resultado es de tipo flotante.\n\n\n\n\n\nDivisi√≥n (/ y //)\nPython provee dos operadores distintos para calcular el cociente entre dos n√∫meros.\n\nEl operador / que calcula la divisi√≥n flotante.\nEl operador // que calcula la divisi√≥n entera.\n\nEl operador / es el que m√°s se utiliza y siempre devuelve un n√∫mero de tipo flotante.\n\n10 / 5\n\n2.0\n\n\n\n10 / 5.5\n\n1.8181818181818181\n\n\nLa divisi√≥n entera se suele utilizar cuando uno quiere el resultado entero de la divisi√≥n, sin importar si el resto es 0 o no.\n\n10 // 5\n\n2\n\n\n\n10 // 5.5\n\n1.0\n\n\nVeamos los siguientes ejemplos donde comparamos la divisi√≥n flotante con la divisi√≥n entera, utilizando los mismos argumentos.\n\n15 / 4\n\n3.75\n\n\n\n15.0 // 4.0\n\n3.0\n\n\n\n\nM√≥dulo (%)\nOtro operador relacionado a la divisi√≥n entera es el operador m√≥dulo o resto (%).\nEsta operaci√≥n nos devuelve el resto que se obtiene al realizar la divisi√≥n entera entre dos n√∫meros.\n\n17 % 3\n\n2\n\n\nDebajo se puede ver la relaci√≥n entre la divisi√≥n entera y el m√≥dulo:\n\n\n\n\n\nAunque ahora pueda parecer dif√≠cil encontrar una aplicaci√≥n pr√°ctica para los operadores de divisi√≥n entera // y resto %, m√°s adelante veremos ejemplos donde haremos un uso intensivo de ellos.\n\n\nPrioridad de los operadores\nHasta ahora vimos operaciones bastante sencillas.\nCuando presentamos la suma, realizamos simplemente una suma. Cuando presentamos la multiplicaci√≥n, hicimos solo una multiplicaci√≥n.\nPor supuesto, al momento de hacer c√°lculos podemos combinar los operadores que ya conocemos, de la misma forma en que lo hacemos al resolver cuentas a mano.\nUn punto importante a tener en cuenta es que, al igual que cuando hacemos cuentas a mano, algunas operaciones se resuelven antes que otras, sin importar el orden en que aparecen. Esto ocurre porque algunos operadores tienen mayor prioridad y, por lo tanto, se eval√∫an antes.\nEn el siguiente ejemplo, ¬øpor qu√© se obtienen resultados distintos?\n\n10 - 2 * 4\n\n2\n\n\n\n(10 - 2) * 4\n\n32\n\n\nIndependientemente de que el s√≠mbolo + aparezca antes que el s√≠mbolo * en una expresi√≥n, Python realiza primero la multiplicaci√≥n.\nAl igual que cuando hacemos cuentas a mano, la multiplicaci√≥n tiene mayor prioridad que la suma.\nSi queremos forzar a Python a realizar una operaci√≥n antes que otra, sin importar la prioridad de los operadores, debemos usar par√©ntesis.\nOtro ejemplo es el siguiente‚Ä¶\n\n7 + 8 / 2\n\n11.0\n\n\n\n(7 + 8) / 2\n\n7.5\n\n\nA continuaci√≥n se incluye una tabla con los operadores que vimos y la prioridad que tiene cada uno.\nLos operadores que aparecen m√°s arriba tienen mayor prioridad.\nLos operadores que aparecen en la misma fila tienen el mismo nivel de prioridad y se resuelven seg√∫n el orden en que aparecen en el c√≥digo (de izquierda a derecha).\n\n\n\n\n\n\n\nOperador\nSignificado\n\n\n\n\n()\nAgrupamiento\n\n\n**\nPotencia\n\n\n*, /, //, %\nMultiplicaci√≥n, Divisi√≥n, Divisi√≥n entera, M√≥dulo\n\n\n+, -\nSuma, Resta\n\n\n\nEsta lista es una versi√≥n m√°s sencilla y resumida de la tabla de prioridades de todos los operadores que hay en Python. Una versi√≥n m√°s completa se puede encontrar en Programiz.\n\n\n\nOperadores l√≥gicos\nLos operadores l√≥gicos se llaman as√≠ porque el resultado que devuelven es de tipo l√≥gico (bool).\nEn algunos casos se utilizan s√≠mbolos, en otros se utilizan palabras claves.\nA partir de ahora vamos a ver varias operaciones que puedan resultar familiares para quienes hicieron alguna materia relacionada a l√≥gica.\n\nNegaci√≥n (not)\nDevuelve el opuesto del valor que le pasamos.\n\nnot False\n\n\nnot True\n\n\n\nConjunci√≥n o intersecci√≥n (and)\nEsta operaci√≥n devuelve True solamente cuando los dos operadores que le pasamos son True.\n\nTrue and True\n\n\nFalse and True\n\n\n\nDisyunci√≥n o uni√≥n (or)\nEsta operaci√≥n devuelve True cuando cualquiera de sus argumentos es True.\n\nTrue or False\n\nSolo devuelve False cuando sus dos argumentos son False.\n\nFalse or False\n\n\n\nIdentidad (is)\nExisten dos operadores para evaluar la identidad de los objetos.\n\nOperador is: es True cuando ambos operandos son el mismo objeto\nOperador is not: es True cuando los operandos no son el mismo objeto.\n\n\nFalse is False\n\n\nFalse is True\n\n\nNone is None\n\n\n\nComparaci√≥n\nPython provee varios operadores para realizar comparaciones entre objetos.\nLos operadores que vemos a continuaci√≥n son los mismos que aprendimos en la secundaria.\n\n\n\n\n\n\n\nOperador\nDescripci√≥n\n\n\n\n\n==\nIgualdad: El resultado es True cuando los dos operandos son iguales.\n\n\n!=\nDesigualdad: El resultado es True si los operandos son distintos.\n\n\n&gt;\nMayor a: El resultado es True si el operando de la izquierda es mayor que el de la derecha.\n\n\n&gt;=\nMayor o igual a: El resultado es True si el operando de la izquierda es mayor o igual que el de la derecha.\n\n\n&lt;\nMenor a: El resultado es True si el operando de la izquierda es menor que el de la derecha.\n\n\n&lt;=\nMenor o igual a: El resultado es True si el operando de la izquierda es menor o igual que el de la derecha.\n\n\n\nAlgunos ejemplos‚Ä¶\n\n10 &gt; 5\n\n\n10 &gt; 5 + 3\n\n\n0 &lt; 0\n\n\n1 &gt;= 1\n\n\n10.0 != 10\n\n\n10.0 == 10\n\nA pesar de que 10.0 es de tipo flotante y 10 es de tipo entero, vemos que la comparaci√≥n de igualdad == dice que son iguales.\nNo siempre que comparemos objetos de distinto tipo va a suceder algo as√≠.\nLa comparaci√≥n de cadenas de texto distingue may√∫sculas de min√∫sculas\n\n\"UNR\" == \"unr\"\n\nFalse\n\n\nEs posible comparar objetos de distinto tipo, como lo vimos en el ejemplo anterior donde comparamos 10 y 10.0.\nSalvo casos particulares, como son los valores num√©ricos, estos objetos son considerados siempre distintos.\n\n\"10\" == 10\n\nFalse\n\n\n\n\"False\" == False\n\nFalse\n\n\nEs posible combinar mas de una comparaci√≥n en la misma l√≠nea.\n\n1 &lt; 2 and 2 &lt; 3\n\nTrue\n\n\nIncluso es posible omitir el operador and y tener una expresi√≥n m√°s clara\n\n1 &lt; 2 &lt; 3\n\nTrue\n\n\n\n-5 &lt; -4 &lt; -3\n\nTrue\n\n\nTambi√©n podemos mezclar not, and y or a gusto.\n\nFalse or not False\n\nY es v√°lido utilizar par√©ntesis para agrupar operaciones.\n\n(False or True) and (True or False)\n\nA continuaci√≥n se incluye una tabla con los operadores l√≥gicos y la prioridad que tiene cada uno.\nLos operadores que aparecen m√°s arriba tienen mayor prioridad.\nLos operadores que aparecen en la misma fila tienen el mismo nivel de prioridad y se resuelven seg√∫n el orden en que aparecen en el c√≥digo (de izquierda a derecha).\n\n\n\n\n\n\n\nOperadores\nSignificado\n\n\n\n\n==, !=, &gt;, &gt;=, &lt;, &lt;=, is, is not, in, not in\nComparaciones, identidad, pertenencia\n\n\nnot\nNegaci√≥n\n\n\nand\nConjunci√≥n o intersecci√≥n\n\n\nor\nDisyunci√≥n o uni√≥n\n\n\n\nTodos los operadores l√≥gicos tienen menor prioridad que los operadores aritm√©ticos que vimos arriba.\nEn otras palabras, si pegaramos ambas tablas, √©sta √∫ltima quedar√≠a por debajo.\nAnalicemos nuevamente uno de los ejemplos que ya vimos.\n\nnot True and not True\n\nEl operador not tiene mayor prioridad que el operador and porque aparece primero en la tabla.\nEn consecuencia, en el c√≥digo anterior primero se resuelven los not True y luego el and. Esto es lo mismo que hacer\n\nFalse and False",
    "crumbs": [
      "Teor√≠a",
      "U1 - Introducci√≥n a Python",
      "Clase 1"
    ]
  },
  {
    "objectID": "teoria/01_introduccion_a_python/clase_1.html#ap√©ndice",
    "href": "teoria/01_introduccion_a_python/clase_1.html#ap√©ndice",
    "title": "Clase 1",
    "section": "Ap√©ndice",
    "text": "Ap√©ndice\n\nPalabras claves y funciones predefinidas\nPython tiene un conjunto de palabras conocidas como keywords que sirven para realizar acciones especificas y que no podemos utilizar como nombres de variables.\nCuando intentemos utilizar una keyword como nombre de variable, obtendremos un error.\nPor otro lado, si intentamos utilizar el nombre de una funci√≥n (o clase) predefinida como nombre de una variable que nosotros creamos, no vamos a obtener un error pero no podremos usar la funci√≥n nuevamente porque la variable ahora representa otra cosa.\n\nPalabras claves\nFalse      await      else       import     pass\nNone       break      except     in         raise\nTrue       class      finally    is         return\nand        continue   for        lambda     try\nas         def        from       nonlocal   while\nassert     del        global     not        with\nasync      elif       if         or         yield\n\n\nFunciones y clases pre-definidas\nabs()          copyright()    getattr()      list()         range()        vars()\nall()          credits()      globals()      locals()       repr()         zip()\nany()          delattr()      hasattr()      map()          reversed()\nascii()        dict()         hash()         max()          round()\nbin()          dir()          help()         memoryview()   set()\nbool()         display()      hex()          min()          setattr()\nbreakpoint()   divmod()       id()           next()         slice()\nbytearray()    enumerate()    input()        object()       sorted()\nbytes()        eval()         int()          oct()          staticmethod()\ncallable()     exec()         isinstance()   open()         str()\nchr()          filter()       issubclass()   ord()          sum()\nclassmethod()  float()        iter()         pow()          super()\ncompile()      format()       len()          print()        tuple()\ncomplex()      frozenset()    license()      property()     type()\n\n\n\nAsignaciones m√∫ltiples\nYa vimos que para asignar, o crear, una variable necesitamos hacer variable = &lt;valor&gt;.\nSi queremos crear multiples variables, podemos escribir las asignaciones en m√∫ltiples l√≠neas.\nPor ejemplo\n\npi, e = 3.1416, 2.7182\nprint(pi)\nprint(e)\n\nUna caracter√≠stica conveniente de Python es que permite asignar m√∫ltiples variables en una misma l√≠nea.\nOtro ejemplo es el siguiente, donde se demuestra que los tipos de las variables no necesitan ser iguales.\n\na, b, c = 100 + 20, \"un mensaje cualquiera\", None\n\n\nprint(a)\nprint(b)\nprint(c)\n\nEsta caracter√≠stica es muy √∫til para escribir c√≥digo m√°s conciso, aunque tampoco debemos abusar de ella. En muchos casos puede resultar en c√≥digo poco legible.",
    "crumbs": [
      "Teor√≠a",
      "U1 - Introducci√≥n a Python",
      "Clase 1"
    ]
  }
]