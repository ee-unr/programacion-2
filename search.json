[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programación II",
    "section": "",
    "text": "Programación II\n\n\n   Ciclo de Formación Técnica - Estadística y Ciencia de Datos\n   Facultad de Ciencias Económicas y Estadística (UNR)\n   2° Cuatrimestre 2025"
  },
  {
    "objectID": "index.html#docentes",
    "href": "index.html#docentes",
    "title": "Programación II",
    "section": "Docentes",
    "text": "Docentes\n\n\nTomás Capretto\n\n   tomas.capretto@fcecon.unr.edu.ar \n\n\n\nLuciano Anselmino\n\n   luciano.anselmino@fcecon.unr.edu.ar \n\n\n\nJoaquín Bermejo\n\n   joaquin.bermejo@fcecon.unr.edu.ar \n\n\n\nDolores Sollberger\n\n   dolores.sollberger@fcecon.unr.edu.ar"
  },
  {
    "objectID": "teoria/03_oop/04_polimorfismo.html",
    "href": "teoria/03_oop/04_polimorfismo.html",
    "title": "4 - Polimorfismo",
    "section": "",
    "text": "El término polimorfismo tiene origen en las palabras poly (muchos) y morfo (formas). Aplicado a la programación hace referencia a que los objetos pueden tomra diferentes formas.\nPero, ¿qué significa que los objetos pueden tomar diferentes formas? En el contexto de programación orientada a objetos significa que los objetos pueden responder a una misma operación de distintas maneras.\nTomemos, por ejemplo, la suma de dos variables:\na + b\nSi a y b son de tipo int, la operación está definida y devuelve otro int. Si son de tipo list, la operación también está definida y devuelve un nuevo objeto list. Así, diferentes tipos de datos, responden al mismo mensaje (la suma) de maneras distintas.",
    "crumbs": [
      "Teoría",
      "U3 - Programación Orientada a Objetos",
      "4 - Polimorfismo"
    ]
  },
  {
    "objectID": "teoria/03_oop/04_polimorfismo.html#introducción",
    "href": "teoria/03_oop/04_polimorfismo.html#introducción",
    "title": "4 - Polimorfismo",
    "section": "",
    "text": "El término polimorfismo tiene origen en las palabras poly (muchos) y morfo (formas). Aplicado a la programación hace referencia a que los objetos pueden tomra diferentes formas.\nPero, ¿qué significa que los objetos pueden tomar diferentes formas? En el contexto de programación orientada a objetos significa que los objetos pueden responder a una misma operación de distintas maneras.\nTomemos, por ejemplo, la suma de dos variables:\na + b\nSi a y b son de tipo int, la operación está definida y devuelve otro int. Si son de tipo list, la operación también está definida y devuelve un nuevo objeto list. Así, diferentes tipos de datos, responden al mismo mensaje (la suma) de maneras distintas.",
    "crumbs": [
      "Teoría",
      "U3 - Programación Orientada a Objetos",
      "4 - Polimorfismo"
    ]
  },
  {
    "objectID": "teoria/03_oop/04_polimorfismo.html#ejemplos",
    "href": "teoria/03_oop/04_polimorfismo.html#ejemplos",
    "title": "4 - Polimorfismo",
    "section": "Ejemplos",
    "text": "Ejemplos\nA lo largo de esta sección vamos a introducirnos en el polimorfismo mediante diferentes ejemplos.\n\nAnimales que hablan\nEn programación orientada a objetos (POO), el polimorfismo se refiere a la capacidad que tiene el programa de invocar un mismo método en objetos distintos, y que cada objeto responda de la forma que le corresponde según su propia implementación.\nPor ejemplo, imaginemos que tenemos una colección de perros, gatos y pájaros, y que cada uno entiende algunos comandos básicos. Si les pedimos a estas mascotas que hablen (es decir, si les enviamos el mensaje “habla”), los perros van a ladrar, los gatos van a maullar y los pájaros van a piar.\n\nclass Animal:\n    def __init__(self, nombre):\n        self.nombre = nombre\n\nclass Perro(Animal):\n1    def hablar(self):\n        print(self.nombre, \"dice ¡guau!\")\n\nclass Gato(Animal):\n2    def hablar(self):\n        print(self.nombre, \"dice ¡miau!\")\n\nclass Pajaro(Animal):\n3    def hablar(self):\n        print(self.nombre, \"dice ¡pio pio!\")\n\n\n1\n\nLos perros dicen guau.\n\n2\n\nLos gatos dicen miau.\n\n3\n\nLos pájaros dicen pio pio.\n\n\n\n\nComo todos los animales tienen la capacidad de hablar, podemos recorrer una lista de animales y ejecutar el método hablar en cada uno de ellos, sin importar de qué tipo de animal se trate. Todos podrán responder a la llamada, cada uno a su manera.\n\nmascotas = [\n    Perro(\"Julio\"),\n    Gato(\"Micha\"),\n    Perro(\"Justo\"),\n    Pajaro(\"Pedrito\")\n]\n\nfor mascota in mascotas:\n    mascota.hablar()\n\nJulio dice ¡guau!\nMicha dice ¡miau!\nJusto dice ¡guau!\nPedrito dice ¡pio pio!\n\n\n\n\n\n\n\n\n¿Enviar un mensaje?\n\n\n\nEn el contexto de la programación orientada a objetos se suele usar la expresión “enviar un mensaje” cuando hablamos de que un programa (también llamado cliente) llama a un método de un objeto o invoca una operación sobre el mismo. Por ejemplo:\nobjeto.correr() # Se envía el mensaje correr\nobj + obj2      # Se envía el mensaje de suma (__add__)\nLo que el objeto haga al recibir ese mensaje depende exclusivamente de él. Con el polimorfismo, podemos enviar el mismo mensaje a varios objetos, y cada uno va a reaccionar de manera diferente según cómo fue diseñado y según los datos que tenga disponibles.\n\n\n\n\nLa forma es lo de menos\nPodemos retomar el ejemplo de los rectángulos y circulos del apunte anterior. Ambos tienen acceso al método area que devuelve el área de la figura.\n\nimport math\n\nclass Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    def area(self):\n        return self.base * self.altura\n\n    def resumen(self):\n        return f\"Rectangulo(base={self.base}, altura={self.altura})\"\n\n\nclass Circulo:\n    def __init__(self, radio):\n        self.radio = radio\n\n    def area(self):\n        return self.radio ** 2 * math.pi\n\n    def resumen(self):\n        return f\"Circulo(radio={self.radio})\"\n\nSi contamos con un listado de rectángulos y círculos, podemos usar la función sorted junto a una función anónima para ordenar los elementos según su área.\n\nformas = [\n    Circulo(2),\n    Rectangulo(3, 2),\n    Circulo(1.4),\n    Rectangulo(4, 3),\n    Rectangulo(6, 4),\n]\n\n# Ordenar\nformas_ordenadas = sorted(formas, key=lambda f: f.area())\n\n# Imprimir formas en orden\nfor forma in formas_ordenadas:\n    print(forma.resumen(), forma.area(), sep=\": \")\n\nRectangulo(base=3, altura=2): 6\nCirculo(radio=1.4): 6.157521601035993\nRectangulo(base=4, altura=3): 12\nCirculo(radio=2): 12.566370614359172\nRectangulo(base=6, altura=4): 24\n\n\nCuando la función anónima recibe una forma f, ejecuta su método area sin importar de qué tipo sea. Como tanto rectángulos como círculos saben cómo responder a esa llamada devolviendo un número, pueden ordenarse correctamente según ese valor.\nAunque ambos métodos devuelvan el mismo tipo de resultado (un número), la forma en que se calcula ese resultado es distinta y depende de cada figura geométrica. De eso se trata el polimorfismo.",
    "crumbs": [
      "Teoría",
      "U3 - Programación Orientada a Objetos",
      "4 - Polimorfismo"
    ]
  },
  {
    "objectID": "teoria/03_oop/04_polimorfismo.html#métodos-mágicos",
    "href": "teoria/03_oop/04_polimorfismo.html#métodos-mágicos",
    "title": "4 - Polimorfismo",
    "section": "Métodos mágicos",
    "text": "Métodos mágicos\nEl polimorfismo no solo se da con métodos regulares como hablar o area. Realmente, la magia del polimorfismo aparece cuando incorporamos los métodos mágicos de Python en nuestras clases.\nLos métodos mágicos —también llamados dunder methods (por “double underscore”)— son métodos especiales que permiten que nuestros objetos participen en operaciones estándar del lenguaje, como comparaciones, sumas, conversiones a cadenas o iteraciones.\nPor ejemplo, si intentamos comparar dos rectángulos creados con nuestra clase Rectangulo, incluso si tienen las mismas dimensiones, la comparación devolverá False.\n\nr1 = Rectangulo(3, 2)\nr2 = Rectangulo(3, 2)\n\nr1 == r2\n\nFalse\n\n\nConceptualmente, tiene sentido esperar que la comparación en valor de dos rectángulos de iguales dimensiones sea True. Pero obtenemos False.\nEsto no ocurre porque r1 y r2 representen objetos distintos, sino porque todavía no hemos implementado el método mágico que define como se deben comparar objetos de la clase Rectangulo por valor.\n\nComparaciones\nEn Python, el operador de comparación por valor == utiliza internamente el método mágico __eq__. Si queremos comparar rectángulos con ==, entonces debemos implementar __eq__.\n\nclass Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    @property\n    def area(self):\n        return self.base * self.altura\n\n1    def __eq__(self, other):\n2        if self.base == other.base and self.altura == other.altura:\n            return True\n3        return False\n\n\n1\n\nEl método __eq__ recibe siempre dos objetos a comparar, llamados por convención self y other.\n\n2\n\nSi las bases y las alturas de los objetos son iguales, devuelve True, ya que consideramos que los rectángulos son iguales.\n\n3\n\nEn caso contrario, devuelve False, indicando que los rectángulos no son iguales.\n\n\n\n\nSi probamos nuestro método de comparación recién implementado, vemos que funciona correctamente:\n\nr1 = Rectangulo(3, 2)\nr2 = Rectangulo(3, 2)\nr3 = Rectangulo(5, 3)\n\n\nr1 == r3\n\nFalse\n\n\n\nr2 == r3\n\nFalse\n\n\n\nr1 == r2\n\nTrue\n\n\nNo solo tenemos acceso al operador ==, ahora también podemos usar !=.\n\nr1 != r3\n\nTrue\n\n\nTodos los operadores de comparación se corresponden con un método especial determinado. La tabla a continuación incluye el nombre del método, el operador binario que utulizamos y una descripción de cómo funciona.\n\n\n\n\n\n\n\n\nMétodo\nOperador asociado\nDescripción\n\n\n\n\n__eq__(self, other)\n==\nTrue si self es igual a other.\n\n\n__ne__(self, other)\n!=\nTrue si self no es igual a other.\n\n\n__lt__(self, other)\n&lt;\nTrue si self es menor que other.\n\n\n__le__(self, other)\n&lt;=\nTrue si self es menor o igual que other.\n\n\n__gt__(self, other)\n&gt;\nTrue si self es mayor que other.\n\n\n__ge__(self, other)\n&gt;=\nTrue si self es mayor o igual que other.\n\n\n\nDebajo incorporamos todos estos métodos en nuestra clase Rectangulo. No existe un criterio universal para determinar si un rectángulo es menor o mayor a otro. En nuestro caso, con el objetivo de mostrar la implementación de estos métodos, podemos decir que un rectángulo es menor a otro si su área es menor.\n\nclass Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    @property\n    def area(self):\n        return self.base * self.altura\n\n    def __eq__(self, other):\n        return self.base == other.base and self.altura == other.altura\n\n    def __lt__(self, other):\n        return self.area &lt; other.area\n\n    def __le__(self, other):\n        return self.area &lt;= other.area\n\n    def __gt__(self, other):\n        return self.area &gt; other.area\n\n    def __ge__(self, other):\n        return self.area &gt;= other.area\n\n\nr1 = Rectangulo(3, 5) # Área: 15\nr2 = Rectangulo(3, 4) # Área: 12\nr3 = Rectangulo(5, 3) # Área: 15\n\n\nr1 &lt; r2\n\nFalse\n\n\n\nr1 &lt; r3\n\nFalse\n\n\n\nr1 &lt;= r3\n\nTrue\n\n\n\nr3 &gt; r2\n\nTrue\n\n\n\nr1 == r2\n\nFalse\n\n\n\nr1 == r3 # No son iguales porque sus dimensiones no lo son.\n\nFalse\n\n\n\n\nApariencias\nAdemás de los operadores de comparación, muchas funciones built-in de Python utilizan métodos mágicos internamente. Una de las más comunes es repr(), que se encarga de devolver una representación de un objeto cuando se lo muestra en pantalla. Para personalizar esa representación en nuestras clases, debemos implementar el método mágico __repr__.\n\nclass Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    def __repr__(self):\n        return f\"Rectangulo(base={self.base}, altura={self.altura})\"\n\n\nr1 = Rectangulo(5, 3.5)\nr1\n\nRectangulo(base=5, altura=3.5)\n\n\nTambién str utiliza internamente un método especial llamado __str__, que define cómo debe mostrarse un objeto cuando se convierte a texto de forma legible.\n\nclass Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    def __repr__(self):\n        return f\"Rectangulo(base={self.base}, altura={self.altura})\"\n\n    def __str__(self):\n        return f\"Rectángulo de base {self.base} y altura {self.altura}\"\n\n\nr1 = Rectangulo(5, 3.5)\nr1\n\nRectangulo(base=5, altura=3.5)\n\n\n\nprint(\"repr:\", repr(r1))\nprint(\"str:\", str(r1))\n\nrepr: Rectangulo(base=5, altura=3.5)\nstr: Rectángulo de base 5 y altura 3.5\n\n\n\n\n\n\n\n\nDiferencia entre __repr__ y __str__\n\n\n\nAunque ambos métodos devuelven una representación en texto de un objeto, tienen propósitos distintos:\n\n__repr__ busca ofrecer una representación precisa y detallada, útil para desarrolladores. Idealmente, debería ser lo más cercana posible al código necesario para reconstruir el objeto.\n__str__, en cambio, devuelve una representación más legible y amigable, pensada para usuarios finales o para mostrar el objeto en interfaces y mensajes.\n\nPor ejemplo:\nfrom datetime import datetime\n\nd = datetime(2025, 10, 7, 17, 30)\nprint(\"repr:\", repr(d))\nprint(\"str:\", str(d))\nrepr: datetime.datetime(2025, 10, 7, 17, 30)\nstr: 2025-10-07 17:30:00\n\n\n\n\nAritmética\nFinalmente, retomamos el ejemplo de la introducción del apunte, que tanto hemos mencionado a lo largo del curso: la suma de objetos.\nResulta que el operador de suma + utiliza internamente el método especial __add__. Gracias a esto, también podemos definir cómo deben sumarse dos objetos de una clase que nosotros creamos.\nPor ejemplo, supongamos una clase que representa vectores en dos dimensiones, inicializada con valores para x e y.\nLa suma de dos vectores está definida componente a componente:\n\\[\n\\vec{u} + \\vec{v} = (x_1 + x_2, y_1 + y_2)\n\\]\nY podemos implementar la clase de la siguiente manera:\n\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n\n    def __repr__(self):\n        return f\"Vector({self.x}, {self.y})\"\n\n\nv = Vector(2, 2)\nu = Vector(1, -0.5)\nprint(v)\nprint(u)\n\nVector(2, 2)\nVector(1, -0.5)\n\n\nGracias a la implementación de __add__, está definida la suma entre vectores:\n\nv + u\n\nVector(3, 1.5)\n\n\nY como también implementamos __repr__, obtenemos una representación textual legible.\nTodos los operadores aritméticos en Python utilizan internamente métodos especiales. A continuación se muestran algunos de los más comunes:\n\n\n\n\n\n\n\n\nMétodo\nOperador asociado\nDescripción\n\n\n\n\n__add__(self, other)\n+\nSuma: self + other\n\n\n__sub__(self, other)\n-\nResta: self - other\n\n\n__mul__(self, other)\n*\nMultiplicación: self * other\n\n\n__truediv__(self, other)\n/\nDivisión real: self / other\n\n\n__floordiv__(self, other)\n//\nDivisión entera: self // other\n\n\n__mod__(self, other)\n%\nMódulo: self % other\n\n\n__pow__(self, other)\n**\nPotencia: self ** other\n\n\n\nConsiderando los vectores \\(\\vec{u}\\), \\(\\vec{v}\\) y el escalar \\(c\\), podemos implementar las siguientes operaciones en nuestra clase Vector:\n\\[\n\\begin{aligned}\n\\vec{u} + \\vec{v} &= (x_1 + x_2, y_1 + y_2) \\\\\n\\vec{u} - \\vec{v} &= (x_1 - x_2, y_1 - y_2) \\\\\n\\vec{u} \\times c &= (x_1 \\times c, y_1 \\times c) \\\\\n\\frac{\\vec{u}}{c} &= \\left(\\frac{x_1}{c}, \\frac{y_1}{c}\\right) \\\\\n\\end{aligned}\n\\]\nEn Python:\n\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vector(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, scalar):\n        return Vector(self.x * scalar, self.y * scalar)\n\n    def __truediv__(self, scalar):\n        return Vector(self.x / scalar, self.y / scalar)\n\n    def __repr__(self):\n        return f\"Vector({self.x}, {self.y})\"\n\nVeamos algunos ejemplos:\n\nu = Vector(1, -0.5)\nv = Vector(2, 1)\n\n\nu + v\n\nVector(3, 0.5)\n\n\n\nu - v\n\nVector(-1, -1.5)\n\n\n\nv - u \n\nVector(1, 1.5)\n\n\n\nu * 2.5\n\nVector(2.5, -1.25)\n\n\n\nv / 4\n\nVector(0.5, 0.25)\n\n\nPara finalizar, podemos usar la función graficar_vectores, que recibe una lista de vectores y los representa gráficamente en el plano, mostrando de forma visual el resultado de las operaciones realizadas.\n\n\nCódigo\nimport matplotlib.pyplot as plt\n\ndef graficar_vectores(vectores):\n    x_range = [0, 0]\n    y_range = [0, 0]\n\n    fig, ax = plt.subplots(figsize=(6, 5))\n\n    for i, vector in enumerate(vectores):\n        ax.quiver(\n            0, 0, vector.x, vector.y,\n            angles='xy',\n            scale_units='xy',\n            scale=1,\n            color=f\"C{i}\",\n            label=str(vector)\n        )\n\n        x_range[0] = min(x_range[0], vector.x)\n        x_range[1] = max(x_range[1], vector.x)\n\n        y_range[0] = min(y_range[0], vector.y)\n        y_range[1] = max(y_range[1], vector.y)\n\n    x_range[0] = x_range[0] - 0.5\n    x_range[1] = x_range[1] + 0.5\n    y_range[0] = y_range[0] - 0.5\n    y_range[1] = y_range[1] + 0.5\n\n    ax.axhline(0, color='k', linewidth=0.5)\n    ax.axvline(0, color='k', linewidth=0.5)\n    ax.set(xlim=x_range, ylim=y_range, xlabel=\"x\", ylabel=\"y\")\n    ax.grid()\n    ax.set_axisbelow(True)\n    ax.legend(loc=\"upper left\")\n    plt.show()\n\n\nGrafiquemos tres vectores cualesquiera:\n\ngraficar_vectores(\n    [\n        Vector(1, 2),\n        Vector(0.5, 0.75),\n        Vector(-1, 0.5),\n    ]\n)\n\n\n\n\n\n\n\n\nEl vector \\(\\vec{v}\\) y su opuesto \\(-\\vec{v}\\):\n\nv = Vector(2.5, 3)\n\ngraficar_vectores([v, v * (-1)])\n\n\n\n\n\n\n\n\nEl vector \\(\\vec{v}\\) y \\(1.5 \\times \\vec{v}\\):\n\ngraficar_vectores([v, v * 1.5])\n\n\n\n\n\n\n\n\nEl vector \\(\\vec{v}\\) y \\(0.5 \\times \\vec{v}\\):\n\ngraficar_vectores([v, v * 0.5])\n\n\n\n\n\n\n\n\nLos vectores \\(\\vec{u}\\), \\(\\vec{v}\\) y su suma:\n\nu = Vector(0.5, 0.3)\nv = Vector(0.2, 0.7)\n\ngraficar_vectores([u, v, u + v])\n\n\n\n\n\n\n\n\nY ahora su resta:\n\ngraficar_vectores([u, v, u - v])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSobrecarga de operadores\n\n\n\nA la capacidad de redefinir el comportamiento de los operadores estándar (como +, -, ==, etc.) se la conoce como sobrecarga de operadores.\nGracias a ella, podemos escribir programas más expresivos, legibles e intuitivos, haciendo que nuestras clases se comporten como tipos nativos de Python.",
    "crumbs": [
      "Teoría",
      "U3 - Programación Orientada a Objetos",
      "4 - Polimorfismo"
    ]
  },
  {
    "objectID": "teoria/03_oop/04_polimorfismo.html#otros-métodos",
    "href": "teoria/03_oop/04_polimorfismo.html#otros-métodos",
    "title": "4 - Polimorfismo",
    "section": "Otros métodos",
    "text": "Otros métodos\nLos métodos mágicos que cubrimos en este apunte solo incluyen algúnos de los métodos disponibles.\nAlguno de ellos se muestran a continuación:\n\n\n\n\n\n\n\n\nMétodo\nCómo se usa\nDescripción\n\n\n\n\n__neg__(self)\n-obj\nDevuelve el valor negado del objeto.\n\n\n__pos__(self)\n+obj\nDevuelve el valor positivo del objeto.\n\n\n__abs__(self)\nabs(obj)\nDevuelve el valor absoluto del objeto.\n\n\n__len__(self)\nlen(obj)\nDevuelve la longitud del objeto.\n\n\n__iter__(self)\nfor x in obj\nDevuelve un iterador.\n\n\n__next__(self)\nnext(obj)\nDevuelve el siguiente elemento de un iterador.\n\n\n__contains__(self, item)\nitem in obj\nComprueba pertenencia.\n\n\n__call__(self, ...)\nobj()\nPermite llamar a un objeto como si fuera función.\n\n\n__bool__(self)\nbool(obj)\nDefine si el objeto se considera True o False.\n\n\n__hash__(self)\nhash(obj)\nPermite usar el objeto en conjuntos y como clave en diccionarios.\n\n\n\nUn recurso útil para explorar el funcionamiento de ellos es Python Magic Methods de Real Python. El listado exhaustivo se puede encontrar en la documentación oficial de Python.",
    "crumbs": [
      "Teoría",
      "U3 - Programación Orientada a Objetos",
      "4 - Polimorfismo"
    ]
  },
  {
    "objectID": "teoria/03_oop/01_fundamentos.html",
    "href": "teoria/03_oop/01_fundamentos.html",
    "title": "1 - Fundamentos",
    "section": "",
    "text": "Para hablar de programación orientada a objetos (OOP, por sus siglas en inglés), podemos empezar preguntándonos qué es un objeto. Aunque no solemos pensar en ello de forma consciente, porque todos podemos distinguir un objeto de lo que no lo es, vale la pena definirlo como algo tangible, que se puede percibir, tocar y manipular. ¡Nos pasamos toda la vida interactuando con objetos!\nEn el mundo real, los objetos tienen atributos o propiedades que los describen. Por ejemplo, un televisor tiene forma, tamaño, color, peso, entre otros. Además, los objetos también pueden realizar acciones. Siguiendo con el ejemplo del televisor, puede encenderse, apagarse, cambiar de canal, modificar la fuente de entrada para ver una serie en Netflix o simplemente reproducir música.\nEn programación, la definición de objeto no difiere mucho de la anterior. Aunque los objetos no sean elementos físicos, representan entidades que poseen atributos y pueden ejecutar acciones.\nLa programación orientada a objetos es un paradigma que organiza el código en torno a estos objetos, que combinan datos (atributos) y comportamientos o acciones (métodos) dentro de una misma entidad. Este enfoque permite no solo crear e interactuar con objetos, sino también definir nuestros propios tipos de objetos, adaptados a las necesidades del programa.",
    "crumbs": [
      "Teoría",
      "U3 - Programación Orientada a Objetos",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/03_oop/01_fundamentos.html#introducción",
    "href": "teoria/03_oop/01_fundamentos.html#introducción",
    "title": "1 - Fundamentos",
    "section": "",
    "text": "Para hablar de programación orientada a objetos (OOP, por sus siglas en inglés), podemos empezar preguntándonos qué es un objeto. Aunque no solemos pensar en ello de forma consciente, porque todos podemos distinguir un objeto de lo que no lo es, vale la pena definirlo como algo tangible, que se puede percibir, tocar y manipular. ¡Nos pasamos toda la vida interactuando con objetos!\nEn el mundo real, los objetos tienen atributos o propiedades que los describen. Por ejemplo, un televisor tiene forma, tamaño, color, peso, entre otros. Además, los objetos también pueden realizar acciones. Siguiendo con el ejemplo del televisor, puede encenderse, apagarse, cambiar de canal, modificar la fuente de entrada para ver una serie en Netflix o simplemente reproducir música.\nEn programación, la definición de objeto no difiere mucho de la anterior. Aunque los objetos no sean elementos físicos, representan entidades que poseen atributos y pueden ejecutar acciones.\nLa programación orientada a objetos es un paradigma que organiza el código en torno a estos objetos, que combinan datos (atributos) y comportamientos o acciones (métodos) dentro de una misma entidad. Este enfoque permite no solo crear e interactuar con objetos, sino también definir nuestros propios tipos de objetos, adaptados a las necesidades del programa.",
    "crumbs": [
      "Teoría",
      "U3 - Programación Orientada a Objetos",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/03_oop/01_fundamentos.html#objetos-familiares",
    "href": "teoria/03_oop/01_fundamentos.html#objetos-familiares",
    "title": "1 - Fundamentos",
    "section": "Objetos familiares",
    "text": "Objetos familiares\nAsí como interactuamos con objetos en la vida real desde nuestros primeros días, también lo hemos estado haciendo en Python desde el comienzo. Por ejemplo, cada vez que creamos una cadena de texto, en realidad estamos creando un objeto de la clase str.\n\nx = \"Hola, soy un objeto de tipo 'str'.\"\ny = \"¿Y yo? ¡Yo también soy un objeto de tipo 'str'!\"\nprint(f\"x = {x}\")\nprint(f\"y = {y}\")\n\nx = Hola, soy un objeto de tipo 'str'.\ny = ¿Y yo? ¡Yo también soy un objeto de tipo 'str'!\n\n\nTanto x como y son objetos del mismo tipo: cadenas de caracteres, que en Python corresponden al tipo str. Sin embargo, x e y no son el mismo objeto, sino dos objetos distintos. Esto puede comprobarse no solo por su contenido (uno de sus atributos), sino también comparando sus identificadores únicos (ID), que son diferentes.\n\nprint(id(x))\nprint(id(y))\n\n140223504929120\n140223504962192\n\n\nA su vez, los objetos de tipo str pueden realizar ciertas acciones. Por ejemplo, si queremos convertir todas las letras de una cadena a mayúsculas, podemos hacer lo siguiente:\n\nx.upper()\n\n\"HOLA, SOY UN OBJETO DE TIPO 'STR'.\"\n\n\nLas cadenas de caracteres son uno de los muchos tipos de objetos con los que ya hemos interactuado. Todas las estructuras de datos que hemos utilizado —desde las más simples, como los enteros, flotantes y booleanos, hasta las más complejas, como listas, tuplas y diccionarios— no son más que distintos tipos de objetos.\nEn Python, cada tipo de dato está implementado como una clase, y trabajar con estas clases no solo nos permite crear nuestros propios tipos de datos según nuestras necesidades, sino también interactuar con los objetos que generamos a partir de ellas.",
    "crumbs": [
      "Teoría",
      "U3 - Programación Orientada a Objetos",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/03_oop/01_fundamentos.html#clases-y-objetos",
    "href": "teoria/03_oop/01_fundamentos.html#clases-y-objetos",
    "title": "1 - Fundamentos",
    "section": "Clases y objetos",
    "text": "Clases y objetos\nEn el contexto de la programación orientada a objetos, se utilizan clases para definir nuevas clases o tipos de objetos, especificando qué atributos deben tener y qué acciones pueden realizar. De forma informal, una clase puede pensarse como una plantilla que determina cómo se ve y se comporta un objeto.\nPor ejemplo, imaginemos un molde para hacer paletas heladas. Este molde permite producir paletas, pero no es una paleta en sí. De hecho, se parece más a una fábrica de paletas.\nEl molde define aspectos estructurales como la forma y el tamaño de las paletas, pero no determina por completo cómo serán. Podemos llenarlo con diferentes líquidos, sabores, colores o aromas, y así obtener resultados variados a partir del mismo molde.\nEn programación orientada a objetos, una clase cumple un rol similar: define la estructura y el comportamiento general de los objetos que se crearán a partir de ella. Los objetos, en cambio, son las instancias concretas generadas a partir de esa clase, cada una con sus propias características particulares, como cada paleta helada que sale del molde.\n\n\n\n\n\n\n¿Clases o tipos?\n\n\n\nEn Python, los tipos de datos están implementados como clases. Por eso mismo, en todos los casos debajo, se puede ver que el tipo está precedido por class.\nprint(type(\"texto\"))\nprint(type([1, 2, 3]))\nprint(type({\"a\": 1, \"b\": 2}))\n&lt;class 'str'&gt;\n&lt;class 'list'&gt;\n&lt;class 'dict'&gt;\nAsí, en Python, es lo mismo hablar de clases o tipos de datos.\n\n\n\nEjemplo: la clase dict\nLos diccionarios de Python son instancias de la clase dict. Es esta clase la que define, entre otras cosas, que los diccionarios tienen claves y valores.\nEn el ejemplo debajo, tanto d1 como d2 son instancias u objetos de la clase dict (es decir, son objetos creados con el mismo molde). Sin embargo, d1 y d2 son objetos distintos, que además tienen diferentes valores para sus atributos (claves y valores).\n\nd1 = {\"a\": 100, \"b\": 250}\nd2 = {\"m\": 20, \"n\": False}\n\nprint(type(d1))\nprint(type(d2))\n\n&lt;class 'dict'&gt;\n&lt;class 'dict'&gt;\n\n\n\nprint(d1 is d2)\nprint(d1 == d2)\n\nFalse\nFalse\n\n\nSi consultamos la ayuda de dict mediante help(dict), podemos ver que Python dice que esto se refiere a una clase:\nhelp(dict)\n\nHelp on class dict in module builtins:\n\n\n\n\n\n\n\n¿Objetos o instancias?\n\n\n\nEn el contexto de programación orientada a objetos, los términos “objeto” e “instancia” suelen usarse de manera intercambiable: ambos hacen referencia a una entidad concreta creada a partir de una clase.\nEn el siguiente ejemplo, decimos que l es una instancia de la clase list:\nl = list(\"abcde\")",
    "crumbs": [
      "Teoría",
      "U3 - Programación Orientada a Objetos",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/03_oop/01_fundamentos.html#creando-nuestras-propias-clases",
    "href": "teoria/03_oop/01_fundamentos.html#creando-nuestras-propias-clases",
    "title": "1 - Fundamentos",
    "section": "Creando nuestras propias clases",
    "text": "Creando nuestras propias clases\nLa definición de una clase, que crea un nuevo tipo de dato, define los atributos de un objeto (datos que representan estado) y las cosas que este objeto puede hacer (funciones que representan comportamiento).\nPara definir una nueva clase en Python se usa la sentencia class seguida del nombre de la clase. Veamos el siguiente ejemplo comentado línea a línea.\n\n1class PaletaHelada:\n2    def __init__(self):\n3        print(\"Creando nueva paleta helada\")\n\n\n1\n\nLa sentencia class indica el inicio de la definición de una clase. A continuación se escribe el nombre de la clase y, al final, los dos puntos (:), que señalan el comienzo del bloque donde se definen sus atributos y funciones (llamados métodos).\n\n2\n\nPor lo general, lo primero que se define dentro de una clase es su método de inicialización, siempre llamado __init__.\n\n3\n\nEsta línea se ejecuta cada vez que se crea un nuevo objeto de la clase. En este caso, imprime un mensaje en pantalla como parte del proceso de inicialización.\n\n\n\n\nDefinir una clase no crea ningún objeto por sí misma; simplemente construye el molde o plantilla a partir del cual se podrán crear objetos más adelante.\nPara crear un objeto a partir de una clase, es necesario “llamar” a la clase, lo que genera una nueva instancia de esa clase.\n\npaleta1 = PaletaHelada()\n\nCreando nueva paleta helada\n\n\nLa variable paleta1 representa un objeto de la clase PaletaHelada. En otras palabras, hemos creado, al menos en código, una paleta helada.\nComo las clases son reutilizables, podemos crear tantas paletas heladas como queramos, simplemente creando nuevas instancias de la clase.\n\npaleta2 = PaletaHelada()\n\nCreando nueva paleta helada\n\n\nAl imprimir estos objetos, obtenemos una representación generada automáticamente por Python. En ella podemos ver que ambos son instancias de la clase PaletaHelada, aunque también queda claro que ocupan ubicaciones distintas en memoria. Esto confirma que se trata de objetos distintos, aunque provengan de la misma clase.\n\nprint(paleta1)\nprint(paleta2)\n\n&lt;__main__.PaletaHelada object at 0x7f8854339220&gt;\n&lt;__main__.PaletaHelada object at 0x7f8854338530&gt;\n\n\n\nParámetros de inicialización\nTambién es posible pasar argumentos al momento de inicializar un objeto. Previamente, tenemos que agregar los parámetros necesarios en el método de inicialización.\n\nclass PaletaHelada:\n1    def __init__(self, gusto):\n2        print(f\"Creando nueva paleta helada de gusto {gusto}\")\n\n\n1\n\nEl método __init__ ahora recibe dos parámetros:\n\n2\n\nEl valor de gusto se utiliza para mostrar un mensaje de inicialización personalizado, indicando el sabor de la paleta.\n\n\n\n\nGracias a esto, ahora podemos crear paletas heladas con distintos sabores, como frutilla, naranja, entre otros.\n\npaleta1 = PaletaHelada(\"frutilla\")\npaleta2 = PaletaHelada(\"naranja\")\n\nCreando nueva paleta helada de gusto frutilla\nCreando nueva paleta helada de gusto naranja\n\n\nSin embargo, podemos observar que ninguna de estas dos instancias recuerda algo relacionado al gusto con el que fue inicializado.\npaleta1.gusto\n\nAttributeError: 'PaletaHelada' object has no attribute 'gusto'\n\npaleta2.gusto\n\nAttributeError: 'PaletaHelada' object has no attribute 'gusto'\n\nSi queremos que nuestros objetos puedan recordar datos, necesitamos comprender cómo se utilizan los atributos.\n\n\n\n\n\n\nInstanciación de un nuevo objeto\n\n\n\nLa instanciación es el proceso mediante el cual se crea un objeto a partir de una clase. La sintaxis general es la siguiente:\n&lt;objeto&gt; = &lt;NombreClase&gt;(&lt;argumentos opcionales&gt;)\nAunque al principio pueda parecer poco familiar, en realidad hemos estado instanciando objetos desde los primeros pasos que dimos en Python. Por ejemplo, al escribir list(\"hola\"), estamos creando un objeto de la clase list a partir de la cadena \"hola\". Del mismo modo, con range(10) craemos un objeto de la clase range.",
    "crumbs": [
      "Teoría",
      "U3 - Programación Orientada a Objetos",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/03_oop/01_fundamentos.html#atributos",
    "href": "teoria/03_oop/01_fundamentos.html#atributos",
    "title": "1 - Fundamentos",
    "section": "Atributos",
    "text": "Atributos\nLos atributos son variables asociadas a un objeto que representan su estado.\nEn Python, los atributos no requieren ninguna sintaxis especial para ser declarados. Simplemente se crean dentro de un método (generalmente en __init__) usando la notación self.&lt;atributo&gt;.\nEn nuestro ejemplo de la clase PaletaHelada, podemos hacer:\n\nclass PaletaHelada:\n    def __init__(self, gusto):\n1        self.gusto = gusto\n\n\n1\n\nEl valor de gusto que se pasa al momento de crear la instancia se asigna al atributo gusto del objeto.\n\n\n\n\nAunque la representación automática del objeto no cambia, ahora el objeto tiene estado: puede “recordar” el gusto con el que fue inicializado.\n\npaleta1 = PaletaHelada(\"frutilla\")\npaleta1\n\n&lt;__main__.PaletaHelada at 0x7f8854339c70&gt;\n\n\n\npaleta1.gusto\n\n'frutilla'\n\n\nEn este caso, la variable gusto es una variable de instancia o atributo de instancia. Estas variables existen solo dentro del objeto que las contiene, y no afectan a otras instancias de la misma clase. Así, distintos objetos de una misma clase pueden tener valores diferentes en sus atributos.\n\npaleta2 = PaletaHelada(\"naranja\")\nprint(paleta2.gusto)\nprint(paleta1.gusto)\n\nnaranja\nfrutilla\n\n\nLos atributos también pueden definirse o modificarse fuera de los métodos de la clase.\nPor ejemplo, es posible cambiar el valor de un atributo simplemente asignándole un nuevo valor utilizando la instancia:\n\npaleta1.gusto = \"crema americana\"\n\n\npaleta1.gusto\n\n'crema americana'\n\n\nY también se puede asignarle un valor a un nuevo atributo:\n\npaleta1.cobertura = \"chocolate\"\n\nprint(paleta1.gusto, paleta1.cobertura, sep=\", \")\n\ncrema americana, chocolate\n\n\nEste nuevo atributo existe únicamente en la instancia a la que fue asignado (paleta1). Es decir, paleta2 no tiene un atributo llamado cobertura, ya que no fue definido durante su inicialización ni se le asignó más adelante.\npaleta2.cobertura\n\nAttributeError: 'PaletaHelada' object has no attribute 'cobertura'\n\nEn Python, los atributos de instancia son independientes entre objetos: si un atributo no se define explícitamente en una instancia, simplemente no existe en ella.\n\nAtributos opcionales\nAunque Python permite crear nuevos atributos fuera del proceso de inicialización de un objeto, eso no significa que sea una práctica recomendable en todos los casos.\nAsignar un atributo directamente a una instancia específica puede generar inconsistencias: terminamos con objetos de la misma clase que no comparten la misma estructura de atributos. Esto puede dificultar la lectura del código y producir errores si intentamos acceder a un atributo que no existe en todas las instancias.\nUna alternativa más clara y segura es definir atributos opcionales dentro del método __init__, asignándoles un valor por defecto como None. De esta forma, todas las instancias tendrán los mismos atributos, aunque algunos puedan no tener un valor definido inicialmente.\n\nclass PaletaHelada:\n    def __init__(self, gusto, cobertura=None):\n        self.gusto = gusto\n        self.cobertura = cobertura\n\npaleta1 = PaletaHelada(\"crema americana\", \"chocolate\")\npaleta2 = PaletaHelada(\"frutilla\")\n\n\nprint(paleta1.gusto, paleta1.cobertura, sep=\", \")\nprint(paleta2.gusto, paleta2.cobertura, sep=\", \")\n\ncrema americana, chocolate\nfrutilla, None\n\n\nCon este enfoque, ambos objetos tienen los mismos atributos (gusto y cobertura), lo que mantiene la consistencia entre instancias de la clase. En el caso de paleta2, como no se especificó ninguna cobertura al crear el objeto, el valor de cobertura es None, lo cual indica que esa paleta no tiene ninguna cobertura.",
    "crumbs": [
      "Teoría",
      "U3 - Programación Orientada a Objetos",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/03_oop/01_fundamentos.html#métodos",
    "href": "teoria/03_oop/01_fundamentos.html#métodos",
    "title": "1 - Fundamentos",
    "section": "Métodos",
    "text": "Métodos\nAhora que comprendemos cómo los datos definen el estado de un objeto, el último concepto que nos falta abordar son las acciones que un objeto puede realizar.\nPara llevar a cabo acciones, los objetos utilizan métodos.\nLos métodos son funciones asociadas a una clase determinada, y permiten que los objetos de la clase realicen operaciones o modifiquen su propio estado.\nPor ejemplo, el método upper es un método propio de los objetos de tipo str (cadenas de caracteres) y podemos invocarlo de la siguiente manera:\n\n\"Rosario\".upper()\n\n'ROSARIO'\n\n\nPero no podemos llamarlo sobre una lista:\n[\"Rosario\", \"Santa Fe\"].upper()\n\nAttributeError: 'list' object has no attribute 'upper'\n\nEn el caso de las clases creadas por nosotros, los métodos no son más que funciones definidas dentro de la clase.\nA diferencia de las funciones normales, todos los métodos deben tener al menos un parámetro especial, llamado self por convención, que representa a la instancia sobre la que se está llamando el método.\nGracias a self, los métodos pueden acceder y modificar los atributos del objeto:\n\nclass PaletaHelada:\n    def __init__(self, gusto, cobertura=None):\n        self.gusto = gusto\n        self.cobertura = cobertura\n\n    def mostrar_info(self):\n        print(\"PaletaHelada\")\n        print(f\" - Gusto: {self.gusto}\")\n        print(f\" - Cobertura: {self.cobertura}\")\n\n\npaleta = PaletaHelada(gusto=\"Dulce de leche\", cobertura=\"Chocolate amargo\")\npaleta\n\n&lt;__main__.PaletaHelada at 0x7f885433b440&gt;\n\n\nPara ejecutar el método, se lo llama de la misma forma que a cualquier otro método.\n\npaleta.mostrar_info()\n\nPaletaHelada\n - Gusto: Dulce de leche\n - Cobertura: Chocolate amargo\n\n\n\npaleta2 = PaletaHelada(gusto=\"Mentra granizada\", cobertura=\"Chocolate blanco\")\npaleta2.mostrar_info()\n\nPaletaHelada\n - Gusto: Mentra granizada\n - Cobertura: Chocolate blanco\n\n\n\nMétodos que modifican estado\nEl método mostrar_info no altera el estado del objeto: simplemente muestra un resumen de su estado actual.\nSin embargo, como los métodos acceden al objeto mediante self, también pueden modificar su estado.\nEn el siguiente ejemplo, el método quitar_cobertura elimina cualquier cobertura que pueda tener nuestro helado.\n\nclass PaletaHelada:\n    def __init__(self, gusto, cobertura=None):\n        self.gusto = gusto\n        self.cobertura = cobertura\n\n    def mostrar_info(self):\n        print(\"PaletaHelada\")\n        print(f\" - Gusto: {self.gusto}\")\n        print(f\" - Cobertura: {self.cobertura}\")\n\n    def quitar_cobertura(self):\n        self.cobertura = None\n\n\npaleta = PaletaHelada(\"Chocolate\", \"Chocolate\")\npaleta.mostrar_info()\nprint(\"\")\npaleta.quitar_cobertura()\npaleta.mostrar_info()\n\nPaletaHelada\n - Gusto: Chocolate\n - Cobertura: Chocolate\n\nPaletaHelada\n - Gusto: Chocolate\n - Cobertura: None\n\n\n\n\nMétodos que reciben argumentos\nLos métodos mostrar_info y quitar_cobertura no reciben argumentos, a lo sumo usan los datos ya almacenados en el objeto.\nTambién es posible definir métodos que acepten argumentos, lo que permite realizar distintas operaciones y, por ejemplo, modificar el estado interno del objeto.\nA continuación, incorporamos a la clase un nuevo método que permite actualizar la cobertura de la paleta helada.\n\nclass PaletaHelada:\n    def __init__(self, gusto, cobertura=None):\n        self.gusto = gusto\n        self.cobertura = cobertura\n\n    def mostrar_info(self):\n        print(\"PaletaHelada\")\n        print(f\" - Gusto: {self.gusto}\")\n        print(f\" - Cobertura: {self.cobertura}\")\n\n    def cambiar_cobertura(self, cobertura):\n        self.cobertura = cobertura\n\n\npaleta = PaletaHelada(\"Chocolate\", \"Chocolate\")\npaleta.mostrar_info()\n\nprint(\"\")\npaleta.cambiar_cobertura(\"Chocolate blanco\")\npaleta.mostrar_info()\n\nPaletaHelada\n - Gusto: Chocolate\n - Cobertura: Chocolate\n\nPaletaHelada\n - Gusto: Chocolate\n - Cobertura: Chocolate blanco\n\n\n\n\nMétodos que devuelven resultados\nComo los métodos son funciones de Python, también pueden devolver un resultado.\nPor ejemplo, el método tiene_cobertura retorna True cuando la paleta helada tiene asignada alguna cobertura, sin importar cuál sea.\n\nclass PaletaHelada:\n    def __init__(self, gusto, cobertura=None):\n        self.gusto = gusto\n        self.cobertura = cobertura\n\n    def mostrar_info(self):\n        print(\"PaletaHelada\")\n        print(f\" - Gusto: {self.gusto}\")\n        print(f\" - Cobertura: {self.cobertura}\")\n\n    def cambiar_cobertura(self, cobertura):\n        self.cobertura = cobertura\n\n    def tiene_cobertura(self):\n        return self.cobertura is not None\n\n\npaleta = PaletaHelada(\"Dulce de leche\", \"Chocolate blanco\")\npaleta2 = PaletaHelada(\"Dulce de leche\")\n\nprint(paleta.tiene_cobertura())\nprint(paleta2.tiene_cobertura())\n\nTrue\nFalse\n\n\n\n\nMétodos que devuelven al objeto\nFinalmente, como un método puede devolver cualquier tipo de objeto, también puede retornar la propia instancia sobre la que fue llamado (es decir, la que recibe en self).\nEste patrón se utiliza con frecuencia cuando se desea permitir el encadenamiento de métodos, ya que cada método devuelve el mismo objeto y permite seguir llamando otros métodos sobre él en una sola línea.\n\nclass PaletaHelada:\n    def __init__(self, gusto, cobertura=None):\n        self.gusto = gusto\n        self.cobertura = cobertura\n\n    def mostrar_info(self):\n        print(\"PaletaHelada\")\n        print(f\" - Gusto: {self.gusto}\")\n        print(f\" - Cobertura: {self.cobertura}\")\n\n    def cambiar_cobertura(self, cobertura):\n        self.cobertura = cobertura\n1        return self\n\nPaletaHelada(\"Frutilla\").cambiar_cobertura(\"Chocolate\").mostrar_info()\n\n\n1\n\nLuego de actualizar la cobertura, se devuelve a la instancia con la que se llamó al método.\n\n\n\n\nPaletaHelada\n - Gusto: Frutilla\n - Cobertura: Chocolate\n\n\nComo el método cambiar_cobertura devuelve la propia instancia, es posible encadenar su llamada con otros métodos de la clase, como por ejemplo .mostrar_info.",
    "crumbs": [
      "Teoría",
      "U3 - Programación Orientada a Objetos",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/03_oop/01_fundamentos.html#ejemplo-final-cuenta-bancaria",
    "href": "teoria/03_oop/01_fundamentos.html#ejemplo-final-cuenta-bancaria",
    "title": "1 - Fundamentos",
    "section": "Ejemplo final: Cuenta bancaria",
    "text": "Ejemplo final: Cuenta bancaria\nPara concluir este apunte, vamos a implementar una clase que represente de forma sencilla una cuenta bancaria.\nEn este modelo simplificado, cada cuenta tendrá tres atributos:\n\ntitular: el nombre de la persona dueña de la cuenta\nsaldo: el dinero disponible en la cuenta\nmoneda: el tipo de moneda en el que está expresado el saldo (por ejemplo, \"ARS\" o \"USD\")\n\nAdemás, la clase contará con métodos que permitan realizar operaciones básicas:\n\ndepositar: suma dinero al saldo actual\nretirar: descuenta dinero del saldo, si hay fondos suficientes\ntransferir: mueve dinero de una cuenta a otra\nresumen: muestra el estado actual de la cuenta de forma clara y legible\n\n\nclass CuentaBancaria:\n    def __init__(self, titular, saldo=0, moneda=\"ARS\"):\n        self.titular = titular\n        self.saldo = saldo\n        self.moneda = moneda\n\n    def depositar(self, monto):\n        self.saldo = self.saldo + monto\n\n    def retirar(self, monto):\n        if monto &lt;= self.saldo:\n            self.saldo = self.saldo - monto\n            return True\n\n        print(f\"El saldo es insuficiente ({self.saldo} {self.moneda})\")\n        return False\n\n    def transferir(self, other, monto): # 'other' es tambien una 'CuentaBancaria'\n        if self.moneda != other.moneda:\n            print(f\"Las cuentas usan monedas distintas ({self.moneda} vs {other.moneda})\")\n            return False\n\n        if self.retirar(monto):\n            other.depositar(monto)\n\n        return True\n\n    def resumen(self):\n        print(\"Cuenta bancaria\")\n        print(f\" - Titular: {self.titular}\")\n        print(f\" - Saldo: {self.saldo}\")\n        print(f\" - Moneda: {self.moneda}\")\n\n\ncuenta_A = CuentaBancaria(\"Guido Van Rossum\", saldo=20000, moneda=\"ARS\")\ncuenta_B = CuentaBancaria(\"Ross Ihaka\", saldo=8000, moneda=\"ARS\")\n\ncuenta_A.resumen()\nprint(\"\")\ncuenta_B.resumen()\n\nCuenta bancaria\n - Titular: Guido Van Rossum\n - Saldo: 20000\n - Moneda: ARS\n\nCuenta bancaria\n - Titular: Ross Ihaka\n - Saldo: 8000\n - Moneda: ARS\n\n\n\ncuenta_A.retirar(2500)\n\nTrue\n\n\n\ncuenta_A.resumen()\n\nCuenta bancaria\n - Titular: Guido Van Rossum\n - Saldo: 17500\n - Moneda: ARS\n\n\nEn el caso de las transferencias, no solo se modifica el estado de la cuenta desde la que se realiza la operación (cuenta_A), sino también el estado de la cuenta que recibe el dinero (cuenta_B).\n\ncuenta_A.transferir(cuenta_B, 10000)\n\nTrue\n\n\n\ncuenta_A.resumen()\n\nCuenta bancaria\n - Titular: Guido Van Rossum\n - Saldo: 7500\n - Moneda: ARS\n\n\n\ncuenta_B.resumen()\n\nCuenta bancaria\n - Titular: Ross Ihaka\n - Saldo: 18000\n - Moneda: ARS\n\n\n\ncuenta_B.retirar(20000)\n\nEl saldo es insuficiente (18000 ARS)\n\n\nFalse\n\n\n\n\n\n\n\n\n¿Sabías que …? Sobre __init__\n\n\n\n\n__init__ no lleva una sentencia return. Su propósito no es devolver datos, sino inicializar el objeto.\n__init__ no crea la instancia (eso lo hace Python antes); su función es inicializar el estado del objeto recién creado.\n__init__ no es obligatorio: una clase puede funcionar perfectamente sin definirlo, aunque en ese caso no se podrán establecer valores iniciales personalizados al instanciar.\n\n\n\n\n\n\n\n\n\nSobre self\n\n\n\nNunca se debe pasar explícitamente un valor para self, Python lo hace automáticamente.",
    "crumbs": [
      "Teoría",
      "U3 - Programación Orientada a Objetos",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html",
    "title": "4 - Colecciones de datos",
    "section": "",
    "text": "Además de los tipos de datos elementales que se presentaron en capítulos anteriores, Python proporciona estructuras de datos más complejas que permiten almacenar colecciones de objetos. Estas estructuras facilitan la organización de múltiples valores bajo un mismo nombre, posibilitando, entre otras tareas, su manipulación de manera conjunta.\nEn este capítulo exploraremos tres colecciones básicas de Python:\n\nListas (list)\nTuplas (tuple)\nDiccionarios (dict)\n\nEstas estructuras tienen en común que permiten agrupar varios objetos, aunque presentan diferencias importantes en cuanto a la sintaxis utilizada para definirlas, su mutabilidad (capacidad de modificarse tras su creación) y las operaciones disponibles para manipular sus elementos. En definitiva, cada estructura está especialmente diseñada para representar relaciones particulares entre los datos, adaptándose así a diversas situaciones y necesidades de programación.\nSupongamos que contamos con el nombre y la edad de 4 personas y queremos utilizar estos datos en nuestro programa. Si solamente tenemos acceso a los tipos de datos elementales de Python, una alternativa para almacenar esta información consiste en crear 4 variables para las edades y 4 variables para los nombres:\n\nnombre_1 = \"Juan\"\nnombre_2 = \"Carla\"\nnombre_3 = \"Evelina\"\nnombre_4 = \"Leandro\"\n\nedad_1 = 29\nedad_2 = 34\nedad_3 = 33\nedad_4 = 38\n\nEn este caso, el código es legible e incluso permite intuir la relación entre los nombres y las edades.\nSin embargo, vale preguntarse qué ocurriría si quisiéramos almacenar la información de muchas más personas. Python nos permitiría crear tantas variables como necesitemos, pero trabajar de esa manera no sería práctico ni sostenible.\nPor eso, el lenguaje ofrece estructuras de datos que facilitan el manejo de grandes cantidades de valores del mismo tipo, de forma más organizada y eficiente.",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#introducción",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#introducción",
    "title": "4 - Colecciones de datos",
    "section": "",
    "text": "Además de los tipos de datos elementales que se presentaron en capítulos anteriores, Python proporciona estructuras de datos más complejas que permiten almacenar colecciones de objetos. Estas estructuras facilitan la organización de múltiples valores bajo un mismo nombre, posibilitando, entre otras tareas, su manipulación de manera conjunta.\nEn este capítulo exploraremos tres colecciones básicas de Python:\n\nListas (list)\nTuplas (tuple)\nDiccionarios (dict)\n\nEstas estructuras tienen en común que permiten agrupar varios objetos, aunque presentan diferencias importantes en cuanto a la sintaxis utilizada para definirlas, su mutabilidad (capacidad de modificarse tras su creación) y las operaciones disponibles para manipular sus elementos. En definitiva, cada estructura está especialmente diseñada para representar relaciones particulares entre los datos, adaptándose así a diversas situaciones y necesidades de programación.\nSupongamos que contamos con el nombre y la edad de 4 personas y queremos utilizar estos datos en nuestro programa. Si solamente tenemos acceso a los tipos de datos elementales de Python, una alternativa para almacenar esta información consiste en crear 4 variables para las edades y 4 variables para los nombres:\n\nnombre_1 = \"Juan\"\nnombre_2 = \"Carla\"\nnombre_3 = \"Evelina\"\nnombre_4 = \"Leandro\"\n\nedad_1 = 29\nedad_2 = 34\nedad_3 = 33\nedad_4 = 38\n\nEn este caso, el código es legible e incluso permite intuir la relación entre los nombres y las edades.\nSin embargo, vale preguntarse qué ocurriría si quisiéramos almacenar la información de muchas más personas. Python nos permitiría crear tantas variables como necesitemos, pero trabajar de esa manera no sería práctico ni sostenible.\nPor eso, el lenguaje ofrece estructuras de datos que facilitan el manejo de grandes cantidades de valores del mismo tipo, de forma más organizada y eficiente.",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#listas",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#listas",
    "title": "4 - Colecciones de datos",
    "section": "Listas",
    "text": "Listas\n\nDefinición\nEl siguiente bloque de código genera una lista con los números 1, 2, 3, 4 y 5.\n\n[1, 2, 3, 4, 5]\n\n[1, 2, 3, 4, 5]\n\n\nUna lista de Python es una secuencia ordenada de objetos mutable. De manera menos técnica, podemos decir que una lista es un objeto que contiene otros objetos en un orden determinado y cuyo contenido puede modificarse.\nLas listas son una de las estructuras más utilizadas en Python. De hecho, programar en este lenguaje implica trabajar constantemente con listas: crearlas, modificarlas, recorrerlas y transformarlas.\nAsí que si queremos ser buenos Pythonistas, ¡a aprender de listas!\n\n\nCreación de listas\nLas listas en Python se crean escribiendo los elementos entre corchetes ([]), separándolos con comas.\nCreemos una lista que contenga los nombres de nuestras cafeterias de especialidad preferidas: Orlan, Infinita, Arto, Cristóbal, Ruffo y Heroica.\n\ncafeterias = [\"Orlan\", \"Infinita\", \"Arto\", \"Cristóbal\", \"Ruffo\", \"Heroica\"]\nprint(cafeterias)\n\n['Orlan', 'Infinita', 'Arto', 'Cristóbal', 'Ruffo', 'Heroica']\n\n\nCuando imprimimos una lista, Python muestra una representación muy parecida a la que usamos al definirla: con corchetes para encerrar los elementos y comas para separarlos.\nSi consultamos el tipo de una lista, no hay sorpresas: es del tipo list.\n\ntype(cafeterias)\n\nlist\n\n\n\n\nObjetos permitidos en una lista\nEn Python, una lista puede contener objetos de cualquier tipo. Incluso es posible mezclar distintos tipos en una misma lista.\nCon los tipos de datos que vimos hasta ahora, podríamos tener listas con números, cadenas de texto, valores booleanos e incluso el valor nulo.\nPor ejemplo, la siguiente lista contiene elementos de cuatro tipos distintos:\n\npopurri = [1, \"dos\", True, None, \"dos\"]\npopurri\n\n[1, 'dos', True, None, 'dos']\n\n\nSi bien las listas pueden mezclar objetos de distinto tipo, y algunas veces hacerlo tiene sentido, en general vamos a trabajar con listas donde todos sus objetos son del mismo tipo.\n\n\nQué significa que una lista sea ordenada\nConsideremos las listas [1, 2, 3] y [2, 1, 3]. Vale preguntarse si ambas listas son iguales o no. Veamos que dice Python:\n\n[1, 2, 3] == [2, 1, 3]\n\nFalse\n\n\nDado que una lista es una secuencia en la que el orden de los elementos es relevante, dos listas son iguales solo si contienen los mismos elementos y en el mismo orden. A continuación se muestra un ejemplo en el que ambas condiciones se cumplen.\n\n[1, 2, 3] == [1, 2, 3]\n\nTrue\n\n\nTambién vale la pena preguntarse si dos listas iguales son, en memoria, el mismo objeto. Debajo definimos dos listas x e y con los mismos elementos, en el mismo orden. Como es de esperarse, ambas listas son iguales en valor.\n\nx = [\"a\", \"b\", \"c\"]\ny = [\"a\", \"b\", \"c\"]\n\nprint(x == y)\nprint(x is y)\n\nTrue\nFalse\n\n\nSin embargo, estas listas no son iguales en memoria, es decir, no son el mismo objeto.\n\nprint(\"id(x):\", id(x))\nprint(\"id(y):\", id(y))\n\nid(x): 139718308051328\nid(y): 139718306480896\n\n\n\n\n\n\n\n\nConclusión 📝\n\n\n\nDos listas son iguales (en valor) si en cada posición contienen elementos que también son iguales en valor. Sin embargo, que dos listas sean iguales no implica que sean el mismo objeto en memoria.\n\n\n\n\n\n\n\n\nPara pensar 🧠\n\n\n\n¿Cuál es el resultado de la siguiente comparación?\n[1, 2, 3] == [1.0, 2, 3.0]\n\n\n\n\nAcceder a elementos\nDado que una lista es una secuencia ordenada, cada objeto tiene una posición determinada. Podemos acceder a cualquiera de los elementos de la lista indicando la posición del objeto que deseamos. Esta posición se conoce como índice (o index, en inglés).\nPara acceder a un elemento de una lista, escribimos el nombre de la lista seguido de la posición del objeto que queremos seleccionar, encerrada entre corchetes [].\nVeamos un ejemplo utilizando la lista cafeterias que creamos anteriormente.\n\ncafeterias = [\"Orlan\", \"Infinita\", \"Arto\", \"Cristóbal\", \"Ruffo\", \"Heroica\"]\ncafeterias\n\n['Orlan', 'Infinita', 'Arto', 'Cristóbal', 'Ruffo', 'Heroica']\n\n\nIntentemos seleccionar el primer objeto de la lista:\n\ncafeterias[1]\n\n'Infinita'\n\n\nCuando accedemos a un elemento individual de una lista, el resultado no es, en principio, otra lista, sino el objeto que se encuentra en esa posición. Ese objeto puede ser de cualquier tipo: un número, una cadena de texto, otra lista, etc.\nPor lo tanto, si el elemento obtenido es una cadena de caracteres, podemos aplicar directamente los métodos que corresponden a ese tipo de dato. Por ejemplo, podemos encadenar la selección del elemento en la posición 1 con una llamada al método .upper(), sabiendo que es válido porque ese elemento es de tipo str.\n\ncafeterias[1].upper()\n\n'INFINITA'\n\n\nComo es de esperarse, también podemos incluir una operación de indexación dentro de una f-string.\n\nf\"¡Qué rico que es el café de {cafeterias[1]}!\"\n\n'¡Qué rico que es el café de Infinita!'\n\n\n\n\n\n\n\n\nIndexación desde cero 0️⃣\n\n\n\nObservamos que cafeterias[1] devuelve \"Infinita\", que es el elemento de la segunda posición, y no \"Orlan\", que aparece primero. Este resultado no es un error, sino una consecuencia de que Python usa indexación desde cero (zero-based indexing, en inglés). Esto significa que, si una lista contiene 6 elementos, sus posiciones van desde el 0 al 5. En general:\n\nEl primer elemento está en la posición 0.\nEl último elemento está en la posición n - 1.\n\n\n\n\n\n\n\n\n\nMisma sintaxis, significados distintos 🎭\n\n\n\nEn Python, los corchetes no siempre significan lo mismo. Sus dos funciones principales son la creación de listas y la indexación de secuencias. Un ejemplo curioso que combina ambos usos es el siguiente:\n[0][0]\n0\n\n\nEn el siguiente diagrama se muestra que la variable cafeterias referencia a un objeto de tipo list, que a su vez contiene referencias a distintos objetos de tipo str. Cada uno de estos elementos está asociado a un índice, comenzando desde el 0.\n\n\n\nRepresentación gráfica de la lista cafeterias en Python.\n\n\n\nÍndices negativos\nPython también permite utilizar valores negativos como índices para seleccionar elementos.\n\nEl índice -1 indica el último elemento.\nEl índice -2 indica el penúltimo elemento.\nY así sucesivamente.\n\n\ncafeterias[-1]\n\n'Heroica'\n\n\n\ncafeterias[-2]\n\n'Ruffo'\n\n\n\n\n\nRepresentación gráfica de cafeterias utilizando índices negativos para cada elemento.\n\n\n\n\n\nAcceder a sub-listas\nHasta ahora vimos que, al usar corchetes con un número entero, podemos acceder a un único elemento de una lista. Si en cambio queremos obtener varios elementos a la vez, necesitamos usar una herramienta llamada slice (o rebanada) que permite seleccionar un subconjunto de elementos de una secuencia.\nLa sintaxis para usar slices es la siguiente:\nlista[inicio:fin]\nEsto crea una nueva lista con los elementos que van desde la posición inicio hasta la posición fin, sin incluir esta última.\nPor ejemplo:\n\ncafeterias[1:4]\n\n['Infinita', 'Arto', 'Cristóbal']\n\n\n\n\n\nSelección de sublista de cafeterias usando el slice 1:4.\n\n\nComo los slices incluyen el índice de inicio pero excluyen el de fin, el siguiente código funciona correctamente:\n\ncafeterias[4:6]\n\n['Ruffo', 'Heroica']\n\n\n\n\n\nSelección de sublista de cafeterias usando el slice 4:6.\n\n\nEn Python, la sintaxis de los slices permite omitir de forma implícita los valores de inicio o fin cuando se desea tomar una porción desde el principio o hasta el final de la lista. Por ejemplo:\n\n:n es equivalente a 0:n y selecciona los primeros n elementos.\nn: es equivalente a n:len(lista) y selecciona desde la posición n hasta el final.\n\nEstas formas abreviadas hacen el código más conciso sin perder claridad. Por ejemplo:\n\ncafeterias[:3]\n\n['Orlan', 'Infinita', 'Arto']\n\n\n\n\n\nSelección de sublista de cafeterias hasta el índice 3 usando el slice de inicio implícito :3.\n\n\n\ncafeterias[3:]\n\n['Cristóbal', 'Ruffo', 'Heroica']\n\n\n\n\n\nSelección de sublista de cafeterias desde el índice 3 usando el slice con fin implícito 3:.\n\n\n\n\nModificar, agregar y eliminar elementos\nEn general, nuestros programas utilizan las listas como objetos dinámicos, es decir, como estructuras cuyo contenido puede cambiar a lo largo del tiempo mediante la modificación, agregación o eliminación de sus elementos.\nPor ejemplo, supongamos que desarrollamos una página web que permite el registro de usuarios. En este caso, es natural usar una lista para almacenar los nombres de quienes se registran. A medida que pase el tiempo, se espera que se registren nuevos usuarios, otros se den de baja, o algunos incluso decidan cambiar su nombre. Esto implica realizar operaciones sobre la lista, como agregar, eliminar o modificar sus elementos.\n\nModificar elementos\nPara modificar un elemento se utiliza una sintaxis muy similar a la que utilizamos para acceder a un elemento.\nEscribimos el nombre de la lista seguido del índice del objeto que queremos modificar y el valor que queremos asignar.\nSupongamos que tenemos una lista con diferentes marcas de café: Puerto Blest, Martínez y Fuego Tostadores.\n\nmarcas = [\"Puerto Blest\", \"Martínez\", \"Fuego Tostadores\"]\nmarcas\n\n['Puerto Blest', 'Martínez', 'Fuego Tostadores']\n\n\n¿Cómo hacemos para cambiar el valor del primer elemento?\n\nmarcas[0] = \"Cabrales\"\nmarcas\n\n['Cabrales', 'Martínez', 'Fuego Tostadores']\n\n\n\n\n\n\n\n\nUna dosis de precisión 🎯\n\n\n\nEn esta sección, cuando hablamos de modificar un elemento, nos referimos a reemplazar el objeto que se encuentra en una posición determinada de la lista. Observemos el siguiente ejemplo:\ningredientes = [\"azucar\", \"flores\", \"colores\"]\nid_original = id(ingredientes[0])\n\n# \"Modifico\" el primer elemento\ningredientes[0] = \"pimienta\"\nid_nuevo = id(ingredientes[0])\n\nprint(\"ID original:\", id_original)\nprint(\"ID nuevo:\", id_nuevo)\nID original: 139872198862160\nID nuevo: 139872198582832\nEste ejemplo muestra que la operación no modificó el objeto que se encontraba originalmente en el índice 0, sino que lo reemplazó por uno nuevo.\n\n\n\n\n\n\n\n\n\n\n\n\n\n¡Atención! 🤓\n\n\n\nEl ejemplo del bloque anterior demuestra que la sintaxis lista[indice] = objeto reemplaza el objeto que se encuentra en una determinada posición, en vez de modificarlo. Sin embargo, vale la pena destacar que sí es posible modificar un elemento de una lista. Para ello, es necesario que el elemento sea un objeto mutable.\n\n\n\n\nAgregar elementos\nSupongamos que queremos construir una lista con los nombres de las ciudades que forman parte del Gran Rosario. Para ello, vamos a utilizar el siguiente mapa como referencia. A medida que identifiquemos las distintas localidades, las vamos a ir incorporando a una lista de Python.\nAgregar elementos a una lista es una tarea común en programación, y Python nos ofrece varias formas de hacerlo. En esta sección vamos a explorar algunos de estos métodos, entendiendo en qué se diferencian y cuándo conviene utilizar cada uno.\n\n\n\nMapa ilustrado del Gran Rosario.\n\n\nPrimero vamos a armar una lista que contenga los vecinos de Rosario, considerando solo aquellas localidades que limitan con la ciudad.\nSupongamos que empezamos con una lista que contiene únicamente a la localidad de Funes. A partir de ahí, iremos agregando otras localidades vecinas utilizando distintos métodos que ofrece Python.\n\nvecinos_de_rosario = [\"Funes\"]\nvecinos_de_rosario\n\n['Funes']\n\n\n\nAgregar elementos al final de la lista\nLa manera más sencilla de agregar un nuevo elemento a una lista es utilizando el método .append().\nEste método recibe un único elemento como argumento y lo agrega al final de la lista.\n\nvecinos_de_rosario.append(\"Soldini\")\n\nLa llamada a este método parece no devolver ningún resultado. Observemos la lista nuevamente:\n\nvecinos_de_rosario\n\n['Funes', 'Soldini']\n\n\nEl método .append() agregó \"Soldini\" al final de la lista sin retornar ningún valor. En lugar de crear una nueva lista, modificó directamente la que referencia nuestra variable vecinos_de_rosario. En otras palabras, el método .append() no crea una nueva lista, sino que modifica directamente la lista existente.\nVeamos el siguiente ejemplo:\n\nvecinos_de_rosario = []\nprint(\"ID:\", id(vecinos_de_rosario))\nprint(vecinos_de_rosario, \"\\n\")\n\nvecinos_de_rosario.append(\"Funes\")\nprint(\"ID:\", id(vecinos_de_rosario))\nprint(vecinos_de_rosario, \"\\n\")\n\nvecinos_de_rosario.append(\"Soldini\")\nprint(\"ID:\", id(vecinos_de_rosario))\nprint(vecinos_de_rosario)\n\nID: 139718307382528\n[] \n\nID: 139718307382528\n['Funes'] \n\nID: 139718307382528\n['Funes', 'Soldini']\n\n\nComo se puede observar, Python operó siempre sobre la misma lista. Esto se debe a que el método .append() modifica la lista existente, en lugar de crear una nueva en cada paso.\n\n\nInsertar elementos en cualquier posición de una lista\nPara insertar elementos en una lista también podemos utilizar el método .insert().\n¿Cuál es la diferencia entre .append() e .insert()?\n\n.append() agrega el nuevo elemento al final de la lista.\n.insert() permite insertar un elemento en cualquier posición, indicando el índice donde queremos ubicarlo.\n\nPor ejemplo, si queremos insertar \"Villa Gobernador Gálvez\" al principio de la lista, podemos hacerlo con .insert(0, \"Villa Gobernador Gálvez\").\n\nvecinos_de_rosario.insert(0, \"Villa Gobernador Gálvez\")\nvecinos_de_rosario\n\n['Villa Gobernador Gálvez', 'Funes', 'Soldini']\n\n\nEl método .insert() agregó a \"Villa Gobernador Gálvez\" en el inicio de la lista y corrió o trasladó al resto de los elementos hacia la derecha.\nY si ahora queremos agregar a \"Pérez\" en la tercera posición de la lista, simplemente:\n\nvecinos_de_rosario.insert(2, \"Pérez\")\nvecinos_de_rosario\n\n['Villa Gobernador Gálvez', 'Funes', 'Pérez', 'Soldini']\n\n\nAl igual que .append(), .insert() también modifica la lista existente en vez de devolver una lista nueva.\n\n\n\n\n\n\n¿Qué significa in-place? 🤔\n\n\n\nQue una operación sea in-place significa que la operación modifica directamente el objeto original, sin crear uno nuevo. Por ejemplo, objetos.append(e) agrega el elemento e a la lista existente objetos en lugar de crear y devolver una lista nueva.\n\n\n\n\n\nCombinar listas\nEn la sección anterior vimos cómo insertar elementos individuales en una lista. Ahora vamos a explorar otra operación muy común: combinar listas.\nSupongamos que ya tenemos una lista llamada vecinos_de_rosario, y otra llamada vecinos_al_norte. Queremos unir ambas listas para tener toda la información en una sola. Para lograrlo, una opción es usar el método .extend(), que nos permite agregar todos los elementos de una lista al final de otra, modificando directamente la lista original.\n\nprint(vecinos_de_rosario)\n\n['Villa Gobernador Gálvez', 'Funes', 'Pérez', 'Soldini']\n\n\n\nvecinos_al_norte = [\"Granadero Baigorria\", \"Ibarlucea\"]\n\nvecinos_de_rosario.extend(vecinos_al_norte)\nvecinos_de_rosario\n\n['Villa Gobernador Gálvez',\n 'Funes',\n 'Pérez',\n 'Soldini',\n 'Granadero Baigorria',\n 'Ibarlucea']\n\n\nDe la misma manera que .append() agrega un elemento al final de una lista, el método .extend() permite agregar todos los elementos de otra lista al final.\nOtra forma de combinar listas es utilizando el operador de suma +, que realiza una concatenación de listas. A diferencia de .extend(), este operador no modifica las listas originales, sino que devuelve una nueva lista con los elementos de las dos listas originales concatenados en una nueva.\nPara ver cómo funciona, primero vamos a construir una lista llamada otras_localidades, que contiene localidades del Gran Rosario que no están pegadas a Rosario. Luego, vamos a concatenar esa lista a la que ya tenemos.\n\notras_localidades = [\n    \"Puerto San Martín\",\n    \"San Lorenzo\",\n    \"Fray Luis Beltrán\",\n    \"Capitán Bermudez\",\n    \"Ricardone\",\n    \"Roldán\",\n    \"Alvear\",\n    \"Pueblo Esther\",\n    \"General Lagos\",\n    \"Arroyo Seco\"\n]\n\nPrimero, observemos los IDs de las listas que vamos a combinar:\n\nprint(id(vecinos_de_rosario))\nprint(id(otras_localidades))\n\n139718307382528\n139718306450176\n\n\nY concatenemos ambas listas utilizando el operador de suma:\n\nvecinos_de_rosario + otras_localidades\n\n['Villa Gobernador Gálvez',\n 'Funes',\n 'Pérez',\n 'Soldini',\n 'Granadero Baigorria',\n 'Ibarlucea',\n 'Puerto San Martín',\n 'San Lorenzo',\n 'Fray Luis Beltrán',\n 'Capitán Bermudez',\n 'Ricardone',\n 'Roldán',\n 'Alvear',\n 'Pueblo Esther',\n 'General Lagos',\n 'Arroyo Seco']\n\n\nPodemos notar que la operación sí retorna una lista como resultado, la cual podríamos guardar en una nueva variable.\n\ngran_rosario = vecinos_de_rosario + otras_localidades\ngran_rosario\n\n['Villa Gobernador Gálvez',\n 'Funes',\n 'Pérez',\n 'Soldini',\n 'Granadero Baigorria',\n 'Ibarlucea',\n 'Puerto San Martín',\n 'San Lorenzo',\n 'Fray Luis Beltrán',\n 'Capitán Bermudez',\n 'Ricardone',\n 'Roldán',\n 'Alvear',\n 'Pueblo Esther',\n 'General Lagos',\n 'Arroyo Seco']\n\n\nY finalmente, se puede ver que las listas originales no se han modificado y que gran_rosario referencia una lista nueva.\n\nprint(id(vecinos_de_rosario))\nprint(vecinos_de_rosario, \"\\n\")\n\nprint(id(otras_localidades))\nprint(otras_localidades, \"\\n\")\n\nprint(id(gran_rosario))\nprint(gran_rosario, \"\\n\")\n\n139718307382528\n['Villa Gobernador Gálvez', 'Funes', 'Pérez', 'Soldini', 'Granadero Baigorria', 'Ibarlucea'] \n\n139718306450176\n['Puerto San Martín', 'San Lorenzo', 'Fray Luis Beltrán', 'Capitán Bermudez', 'Ricardone', 'Roldán', 'Alvear', 'Pueblo Esther', 'General Lagos', 'Arroyo Seco'] \n\n139718306451456\n['Villa Gobernador Gálvez', 'Funes', 'Pérez', 'Soldini', 'Granadero Baigorria', 'Ibarlucea', 'Puerto San Martín', 'San Lorenzo', 'Fray Luis Beltrán', 'Capitán Bermudez', 'Ricardone', 'Roldán', 'Alvear', 'Pueblo Esther', 'General Lagos', 'Arroyo Seco'] \n\n\n\n\n\nEliminar elementos\nAsí como es común agregar elementos a una lista o combinar listas para crear nuevas, también lo es eliminar elementos.\nPor ejemplo, si en una página web guardamos los nombres de los usuarios en una lista, y uno de ellos se da de baja, necesitaremos eliminar su nombre de esa lista.\nPara ilustrarlo, vamos a crear una lista de usuarios ficticios:\n\nusuarios = [\"cyberwolf\", \"neo_404\", \"pixelbyte\", \"alphaX\", \"quantum.dev\"]\nusuarios\n\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX', 'quantum.dev']\n\n\n\nEliminar elementos utilizando del\nLa sentencia del, que ya usamos para eliminar variables, también puede usarse para eliminar elementos de una lista.\nPara hacerlo, necesitamos conocer la posición del elemento que queremos eliminar.\nPor ejemplo, si queremos eliminar a \"neo_404\", que está en la segunda posición, podemos hacerlo con:\n\nprint(usuarios)\n\ndel usuarios[1]\n\nprint(usuarios)\n\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX', 'quantum.dev']\n['cyberwolf', 'pixelbyte', 'alphaX', 'quantum.dev']\n\n\n\n\nEliminar elementos con .pop()\nSi bien la sentencia del permite eliminar elementos de una lista, no nos da acceso al elemento eliminado.\nSin embargo, en muchos casos queremos extraer un elemento de una lista para utilizarlo en otra parte de nuestro programa. Por ejemplo, si tenemos una lista de usuarios, tal vez nos interesa guardar el nombre del usuario que se elimina en otra lista que registre los usuarios dados de baja.\nPara eso podemos usar el método .pop(), que elimina un elemento de la lista y, al mismo tiempo, lo devuelve.\n\nusuarios = [\"cyberwolf\", \"neo_404\", \"pixelbyte\", \"alphaX\", \"quantum.dev\"]\nusuario_eliminado = usuarios.pop(2)\n\nprint(usuarios) # \"pixelbyte\" es 'extraido'\nprint(usuario_eliminado)\n\n['cyberwolf', 'neo_404', 'alphaX', 'quantum.dev']\npixelbyte\n\n\nEn resumen, usuarios.pop(2) busca el valor en la tercera posición, lo extrae de la lista y lo devuelve.\nTambién es posible usar .pop() sin indicar una posición. En ese caso, extrae el último elemento de la lista por defecto.\n\nusuarios = [\"cyberwolf\", \"neo_404\", \"pixelbyte\", \"alphaX\", \"quantum.dev\"]\nprint(usuarios, \"\\n\")\n\nusuario_eliminado = usuarios.pop()\nprint(usuario_eliminado)\nprint(usuarios, \"\\n\")\n\nusuario_eliminado = usuarios.pop()\nprint(usuario_eliminado)\nprint(usuarios)\n\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX', 'quantum.dev'] \n\nquantum.dev\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX'] \n\nalphaX\n['cyberwolf', 'neo_404', 'pixelbyte']\n\n\nY podríamos continuar así hasta vaciar la lista.\n\n\nEliminar elementos con .remove()\nEl método .remove() es útil para cuando queremos eliminar elementos de una lista a partir de su valor, en lugar de su posición. Por ejemplo:\n\nusuarios = [\"cyberwolf\", \"neo_404\", \"pixelbyte\", \"alphaX\", \"quantum.dev\"]\nprint(usuarios)\n\nusuarios.remove(\"cyberwolf\")\nprint(usuarios)\n\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX', 'quantum.dev']\n['neo_404', 'pixelbyte', 'alphaX', 'quantum.dev']\n\n\nAl igual que del, remove no devuelve el valor que se remueve.\n\n\n\n\n\n\nResumen 📌\n\n\n\n\n\n\n\n\n\n\n\n\nHerramienta\nQué hace\nCómo se usa\nDevuelve\n\n\n\n\ndel\nElimina un elemento por índice o un segmento por slicing\ndel lista[i]  del lista[i:j]\nNada\n\n\n.pop()\nElimina un elemento por índice (por defecto el último)\nlista.pop(i)  lista.pop()\nEl elemento eliminado\n\n\n.remove()\nElimina la primera ocurrencia de un valor dado\nlista.remove(valor)\nNada\n\n\n\n\n\n\n\n\n\nFunciones y métodos útiles\n\nOrdenamiento\nEs común que las listas se creen sin seguir un orden particular. Sin embargo, en algunas situaciones puede ser importante conservar el orden en que se agregaron los elementos, mientras que en otras puede resultar útil trabajar con los datos ordenados, por ejemplo, para facilitar su presentación.\nEn Python existen al menos dos formas de obtener listas ordenadas.\n\nEl método .sort()\nPara ordenar una lista de manera sencilla, podemos usar el método .sort(). Veamos un par de ejemplos para entender cómo funciona.\n\nproductos = [\"Fanta\", \"Coca Cola\", \"Sprite\"]\nproductos.sort()\nprint(productos)\n\n['Coca Cola', 'Fanta', 'Sprite']\n\n\n\nprecios = [100, 110, 80.0, 70]\nprecios.sort()\nprint(precios)\n\n[70, 80.0, 100, 110]\n\n\nPodemos concluir que el método .sort() realiza un ordenamiento permanente, ya que modifica directamente la lista sobre la que se aplica y no devuelve una nueva. Esto significa que, una vez ejecutado, no es posible recuperar la lista original a menos que la hayamos guardado previamente.\nPor defecto, el ordenamiento se hace de menor a mayor: en el caso de cadenas de texto, se compara caracter por caracter, y en el caso de números, se ordenan a partir de su valor.\n¿Cómo hacemos para ordenar de manera decreciente?\nEl método .sort() tiene un argumento llamado reverse. Si este valor es igual a True, se ordenan los elementos de mayor a menor.\n\nproductos = [\"Fanta\", \"Coca Cola\", \"Sprite\"]\nproductos.sort(reverse=True)\nprint(productos)\n\n['Sprite', 'Fanta', 'Coca Cola']\n\n\n\nprecios = [100, 110, 80, 70]\nprecios.sort(reverse=True)\nprint(precios)\n\n[110, 100, 80, 70]\n\n\n\n\nLa función sorted()\nAl igual que el método .sort(), la función sorted() permite ordenar una lista. La diferencia principal es que sorted() no modifica la lista original, sino que devuelve una nueva lista ordenada. Esto resulta útil cuando queremos conservar tanto el orden original como una versión ordenada de la misma lista.\nVeamos algunos ejemplos breves:\n\njuegos = [\"Counter Strike\", \"The Sims\", \"Age of Empires II\", \"League of Legends\", \"Among Us\"]\njuegos_ordenados = sorted(juegos)\n\nprint(\"Esta es la lista original:\")\nprint(juegos, \"\\n\")\n\nprint(\"Esta es la lista ordenada:\")\nprint(juegos_ordenados)\n\nEsta es la lista original:\n['Counter Strike', 'The Sims', 'Age of Empires II', 'League of Legends', 'Among Us'] \n\nEsta es la lista ordenada:\n['Age of Empires II', 'Among Us', 'Counter Strike', 'League of Legends', 'The Sims']\n\n\n\nprint(\"id(juegos):\".ljust(22), id(juegos))\nprint(\"id(juegos_ordenados):\".ljust(22), id(juegos_ordenados))\n\nid(juegos):            139718306677440\nid(juegos_ordenados):  139718306597952\n\n\nAl igual que .sort(), sorted() también tiene un argumento que determina el orden:\n\nsorted(juegos, reverse=True)\n\n['The Sims',\n 'League of Legends',\n 'Counter Strike',\n 'Among Us',\n 'Age of Empires II']\n\n\n\n\n\nInvertir el orden con .reverse()\nHasta ahora vimos cómo ordenar listas de menor a mayor y de mayor a menor.\nOtra operación común es invertir el orden de los elementos, y para eso podemos usar el método .reverse().\nAl igual que .sort(), esta operación modifica la lista original de forma permanente.\n\nproductos = [\"Fanta\", \"Coca Cola\", \"Sprite\"]\nproductos.reverse()\nprint(productos)\n\n['Sprite', 'Coca Cola', 'Fanta']\n\n\nSi nos arrepentimos de haber invertido el orden, podemos usar .reverse() nuevamente y recuperamos el orden original.\n\nproductos.reverse()\nprint(productos)\n\n['Fanta', 'Coca Cola', 'Sprite']\n\n\n\n\n\n\n\n\n¿Y la función reversed()? 🤔\n\n\n\nAsí como tenemos .sort() y sorted(), uno podría preguntarse si existe un reversed() que complemente .reverse().\nLa respuesta es sí, reversed() existe. Sin embargo, su resultado no es una lista, sino un tipo de objeto que aún no hemos explorado.\nSin embargo, lo vamos a ver más adelante 😊\n\n\n\n\nCantidad de elementos\nPara saber cuantos elementos hay en una lista utilizamos la función len().\nPor ejemplo, para obtener la cantidad de usuarios de manera programática:\n\nusuarios = [\"cyberwolf\", \"neo_404\", \"pixelbyte\", \"alphaX\", \"quantum.dev\"]\nprint(usuarios)\nlen(usuarios)\n\n['cyberwolf', 'neo_404', 'pixelbyte', 'alphaX', 'quantum.dev']\n\n\n5\n\n\nY para obtener la cantidad de ciudades del Gran Rosario (aunque falte una 😉):\n\nprint(gran_rosario)\nlen(gran_rosario)\n\n['Villa Gobernador Gálvez', 'Funes', 'Pérez', 'Soldini', 'Granadero Baigorria', 'Ibarlucea', 'Puerto San Martín', 'San Lorenzo', 'Fray Luis Beltrán', 'Capitán Bermudez', 'Ricardone', 'Roldán', 'Alvear', 'Pueblo Esther', 'General Lagos', 'Arroyo Seco']\n\n\n16\n\n\n\n\nExistencia de elemento\nPara evaluar si un determinado elemento se encuentra en una lista utilizamos el operador in.\n\nnuevo_usuario = \"pepito\"\nnuevo_usuario in usuarios\n\nFalse\n\n\nQue correctamente indica que \"pepito\" no está en nuestra base de usuarios. Por otro lado,\n\n\"cyberwolf\" in usuarios\n\nTrue\n\n\n¿Y cómo preguntar si algún elemento no está dentro de la lista? Para eso, utilizamos el operador not in.\n\n\"Colón\" not in gran_rosario\n\nTrue\n\n\nLa respuesta es True porque efectivamente \"Colón\" no pertenece al Gran Rosario.\nEste es uno de los tantos ejemplos donde Python se parece mucho mas al lenguaje humano que al lenguaje de las computadoras.\n\n\nPosición de un elemento\nSi queremos conocer la posición de un elemento en la lista podemos utilizar el método .index(). Por ejemplo:\n\nvocales = [\"a\", \"e\", \"i\", \"o\", \"u\"]\nvocales\n\n['a', 'e', 'i', 'o', 'u']\n\n\n\nvocales.index(\"i\")\n\n2\n\n\nAl igual que .remove(), el método .index() actúa sobre el primer elemento de la lista que coincide con el valor indicado. Es decir, si hay múltiples apariciones del mismo valor, solo se considera la primera.\n\n[\"a\", \"a\", \"a\"].index(\"a\")\n\n0\n\n\nEl resultado es 0 porque esa es la primera posición en la que aparece \"a\" en la lista. Sin embargo, esto no quiere decir que \"a\" aparezca una sola vez; simplemente indica la ubicación de su primera ocurrencia.\n\n\nFrecuencia de un elemento\nSi queremos saber cuántas veces aparece un elemento en una lista, podemos usar el método .count(). Este método devuelve la cantidad de ocurrencias del valor indicado dentro de la lista.\n\n[\"a\", \"a\", \"a\"].count(\"a\")\n\n3\n\n\n\n[\"a\", \"a\", \"a\"].count(\"b\")\n\n0\n\n\n\n\nEstadísticas básicas\nPython ofrece funciones que nos permiten calcular fácilmente algunas estadísticas básicas o medidas resumen, como el mínimo, el máximo y la suma de los elementos de una lista.\nSe destacan:\n\nmin(), que devuelve el valor mínimo\nmax(), que devuelve el valor máximo\nsum(), que devuelve la suma total\n\nVeamos algunos ejemplos:\n\nnumeros = [3, 7.5, 12, 1.2, 9, 4.8, 6, 15.3, 2.1, 8]\nnumeros\n\n[3, 7.5, 12, 1.2, 9, 4.8, 6, 15.3, 2.1, 8]\n\n\n\nprint(\"Valor mínimo:\", min(numeros))\nprint(\"Valor máximo:\", max(numeros))\nprint(\"Suma de valores:\", sum(numeros))\n\nValor mínimo: 1.2\nValor máximo: 15.3\nSuma de valores: 68.9\n\n\n\n\n\nResumen de métodos in-place\n\n\n\n\n\n\n\nMétodo\nDescripción\n\n\n\n\n.append(x)\nInserta el valor x al final de la lista\n\n\n.pop(i)\nRemueve y devuelve el elemento en la posición i\n\n\n.insert(i, x)\nInserta el valor x en la posición i\n\n\n.extend(iterable)\nInserta todos los valores de iterable al final de la lista\n\n\n.index(x)\nDevuelve el la posición donde x aparece por primera vez en la lista\n\n\n.count(x)\nDevuelve la cantidad de veces que aparece x en la lista\n\n\n.sort()\nOrdena los elementos de la lista, de menor a mayor\n\n\n.reverse()\nInvierte el orden de los elementos en la lista",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#tuplas",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#tuplas",
    "title": "4 - Colecciones de datos",
    "section": "Tuplas",
    "text": "Tuplas\n\nDefinición\nEl siguiente bloque de código genera una tupla con los números 1, 2, 3, 4 y 5.\n\n(1, 2, 3, 4, 5)\n\n(1, 2, 3, 4, 5)\n\n\nUna tupla es una secuencia ordenada de objetos inmutable. Al igual que las listas, permite almacenar múltiples elementos de cualquier tipo y acceder a ellos por posición. Muchas de las operaciones que usamos con listas también funcionan con tuplas. La diferencia clave es que las listas son mutables (se pueden modificar), mientras que las tuplas son inmutables (no se pueden cambiar una vez creadas).\nLas tuplas suelen utilizarse para representar registros o estructuras simples. En general, las tuplas se utilizan para representar:\n\nUna colección fija de valores posibles para un cierto atributo (e.g., Identificaciones válidas), o\nLos distintos atributos de un objeto. En este caso, cada tupla es como un registro de una base de datos (e.g., Baraja española).\n\n\n\nEjemplos\n\nIdentificaciones válidas\nSupongamos que trabajamos en un aeropuerto internacional y estamos implementando un programa de autenticación de personas. Para ello, necesitamos definir los tipos de identificación que se aceptan. Por ejemplo: LE, LC, DNI, CUIT, CUIL y Pasaporte.\nComo esperamos que estos tipos no vayan a cambiar con el tiempo (¡al menos mientras corre nuestro programa!), tiene sentido utilizar una tupla (inmutable) en vez de una lista (mutable).\n\ntipos_identificacion = (\"LE\", \"LC\", \"DNI\", \"CUIT\", \"CUIL\", \"Pasaporte\")\ntipos_identificacion\n\n('LE', 'LC', 'DNI', 'CUIT', 'CUIL', 'Pasaporte')\n\n\n\ntype(tipos_identificacion)\n\ntuple\n\n\nAl igual que con las listas, podemos utilizar los índices para acceder a los elementos de la tupla:\n\nprint(tipos_identificacion[0])\nprint(tipos_identificacion[-1])\n\nLE\nPasaporte\n\n\nAl contrario de lo que sucede con las listas, no es posible modificar ninguno de sus elementos existentes:\ntipos_identificacion[0] = \"NUEVO_TIPO\"\n\n    tipos_identificacion[0] = \"NUEVO_TIPO\"\n    ~~~~~~~~~~~~~~~~~~~~^^^\nTypeError: 'tuple' object does not support item assignment\n\nSin embargo, si necesitamos combinar una o más tuplas en otra tupla, sigue siendo posible utilizar el operador de suma (+) para concatenar tuplas y así crear una nueva, con sus elementos concatenados.\n\ntupla_nueva = tipos_identificacion + (\"NT1\", \"NT2\")\ntupla_nueva\n\n('LE', 'LC', 'DNI', 'CUIT', 'CUIL', 'Pasaporte', 'NT1', 'NT2')\n\n\n\nprint(\"id(tipos_identificacion):\", id(tipos_identificacion))\nprint(\"id(tupla_nueva):\".ljust(25), id(tupla_nueva))\n\nid(tipos_identificacion): 139718618931520\nid(tupla_nueva):          139718306406336\n\n\nAsí, se genera una nueva tupla mientras que la original se mantiene intacta.\n\n\nBaraja española\nSupongamos que queremos desarrollar un software para jugar al truco en línea con nuestros amigos. Tarde o temprano, vamos a necesitar una forma de representar las cartas de la baraja española.\nEsta baraja está compuesta por 40 cartas, divididas en 4 palos: oros, copas, espadas y bastos. Cada palo incluye las siguientes cartas: 1, 2, 3, 4, 5, 6, 7, 10, 11 y 12.\nUna forma simple y efectiva de representar esta baraja en Python es utilizando una lista de tuplas: la lista representa el mazo completo, y cada tupla representa una carta individual. Cada tupla tiene dos elementos: el palo y el valor. Es decir, cada carta se representa así:\n(palo, valor)\nPor ejemplo: (\"espadas\", 7) representa el 7 de espadas.\n\nbaraja = [\n    (\"oros\", 1), (\"oros\", 2), (\"oros\", 3), (\"oros\", 4), (\"oros\", 5),\n    (\"oros\", 6),  (\"oros\", 7), (\"oros\", 10), (\"oros\", 11), (\"oros\", 12),\n    (\"copas\", 1), (\"copas\", 2), (\"copas\", 3), (\"copas\", 4), (\"copas\", 5),\n    (\"copas\", 6), (\"copas\", 7), (\"copas\", 10), (\"copas\", 11), (\"copas\", 12),\n    (\"espadas\", 1), (\"espadas\", 2), (\"espadas\", 3), (\"espadas\", 4), (\"espadas\", 5),\n    (\"espadas\", 6), (\"espadas\", 7), (\"espadas\", 10), (\"espadas\", 11), (\"espadas\", 12),\n    (\"bastos\", 1), (\"bastos\", 2), (\"bastos\", 3), (\"bastos\", 4), (\"bastos\", 5),\n    (\"bastos\", 6), (\"bastos\", 7), (\"bastos\", 10), (\"bastos\", 11), (\"bastos\", 12)\n]\n\nDe este modo, cada tupla representa una carta y resalta su característica de inmutable.\n\n\n\nCuándo usar tuplas\nSi las tuplas se parecen tanto a las listas, ¿para qué existen?\nLas tuplas son apropiadas cuando se necesita una colección inmutable, es decir, una secuencia que no debe cambiar ni en contenido ni en tamaño. Esto evita modificaciones accidentales y, además, es más eficiente en memoria que una lista.\nAunque suelen usarse con datos heterogéneos, el criterio más importante es la inmutabilidad. Si la colección va a cambiar, no corresponde usar una tupla, independientemente del tipo de datos que esta contenga.\nFinalmente, aunque usar una lista en lugar de una tupla no afecte significativamente el rendimiento de un programa particular, elegir la estructura adecuada mejora la legibilidad: una tupla deja en claro que esa secuencia no se modifica en ningún momento.\n\n\nDiferencias entre listas y tuplas\nCómo las creamos:\n\nPara crear listas usamos [].\nPara crear tuplas usamos () (no es del todo cierto, ver Definición de tuplas 🔍).\n\nComportamiento “dinámico” vs “estático”:\n\nEl tamaño de las listas puede ser modificado luego de ser creado (dinámico).\nEl tamaño de las tuplas no puede ser modificado luego de ser creado (estático).\n\nObjetos “mutables” vs “inmutables”:\n\nLos elementos de la lista se pueden modificar luego de ser creada (mutable).\nLos elementos de una tupla no se pueden modificar (inmutable).\n\nMás allá de sus diferencias, las listas y las tuplas tienen muchas similitudes:\n\nSon secuencias ordenadas.\nPueden contener objetos de distintos tipos al mismo tiempo.\nPermiten acceder a los elementos mediante su índice.\nAdmiten operaciones de slicing para obtener subconjuntos.\n\n\n\n\n\n\n\nDefinición de tuplas 🔍\n\n\n\nHasta ahora dijimos que las tuplas se crean utilizando paréntesis y separando los elementos con comas. Pero eso no es del todo cierto.\nEn realidad, los paréntesis no son necesarios para definir una tupla. Lo que define a una tupla en Python es la coma, no los paréntesis. Por ejemplo:\nt = 10, 25.0, 50\nprint(t)\nprint(type(t))\n(10, 25.0, 50)\n&lt;class 'tuple'&gt;\nLos paréntesis en Python se usan principalmente para agrupar expresiones y modificar el orden de evaluación, pero no son lo que convierte una serie de valores en una tupla. Si pensáramos a los paréntesis como una función, simplemente devuelven el mismo objeto que encierran.\nDicho esto, el uso de paréntesis es una convención ampliamente aceptada a la hora de definir tuplas. De hecho, por más que los paréntesis no sean necesarios para su definición, Python siempre muestra a las tuplas entre paréntesis.",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#diccionarios",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#diccionarios",
    "title": "4 - Colecciones de datos",
    "section": "Diccionarios",
    "text": "Diccionarios\nEn el ejemplo al inicio de este apunte presentamos el siguiente bloque de código:\nnombre_1 = \"Juan\"\nnombre_2 = \"Carla\"\nnombre_3 = \"Evelina\"\nnombre_4 = \"Leandro\"\n\nedad_1 = 29\nedad_2 = 34\nedad_3 = 33\nedad_4 = 38\nA simple vista, se pudo concluir que existía una relación entre los nombres y las edades. Por ejemplo, pudimos deducir que la edad de Juan es de 29 años.\nCon las herramientas adquiridas en este apunte podríamos representar esta información de las siguientes dos maneras:\n\nnombres = [\"Juan\", \"Carla\", \"Evelina\", \"Leandro\"]\nedades = [29, 34, 33, 38]\n\nAsí, el elemento ubicado en la posición i-ésima de la lista nombres se corresponde con el elemento de la misma posición en la lista edades.\nEn principio, este enfoque resuelve el problema de tener que crear una variable distinta para cada valor. Sin embargo, mantener dos colecciones mutables e independientes en sincronía puede convertirse en un verdadero dolor de cabeza. De hecho, podemos estar casi seguros de que, tarde o temprano, esa sincronía se va a romper.\nOtra alternativa es la siguiente:\n\npersonas = [(\"Juan\", 29), (\"Carla\", 34), (\"Evelina\", 33), (\"Leandro\", 38)]\n\nAhora, contamos con un único objeto de Python que reúne toda la información de las personas. En esta lista de tuplas, cada tupla representa a una persona: el primer elemento es su nombre y el segundo, su edad. Una de las ventajas de este enfoque es que permite agregar o quitar registros sin preocuparse por mantener la sincronización entre distintas colecciones.\nSin embargo, existe otra estructura de datos que puede resultar aún más adecuada para este escenario: el diccionario.\nLos diccionarios son estructuras que establecen un mapeo (del inglés, mapping) o relación entre dos conjuntos de elementos: claves y valores (keys y values en Python). En nuestro caso, podemos crear un diccionario donde las claves sean los nombres y los valores, las edades.\nEn Python, los diccionarios se definen entre llaves ({}). Dentro de ellas, cada elemento se escribe como un par clave: valor, separado por comas para distinguirlo de los demás.\n\npersonas = {\"Juan\": 29, \"Carla\": 34, \"Evelina\": 33, \"Leandro\": 38}\npersonas\n\n{'Juan': 29, 'Carla': 34, 'Evelina': 33, 'Leandro': 38}\n\n\n\ntype(personas)\n\ndict\n\n\n\nlen(personas)\n\n4\n\n\nPodemos usar este ejemplo para destacar algunos puntos clave sobre los diccionarios:\n\nLa longitud de un diccionario corresponde a la cantidad de pares clave: valor que contiene, no a la suma de la cantidad de claves y valores.\nAunque es común usar cadenas de texto como claves, no es obligatorio: cualquier objeto que sea hashable puede ser una clave (lo veremos más adelante).\nLos valores pueden ser de cualquier tipo de objeto en Python.\nLas claves deben ser únicas, pero los valores pueden repetirse.\n\nPor último, veremos con un ejemplo que, aunque desde Python 3.7 los diccionarios mantienen un orden, este no es relevante al compararlos.\n\nd1 = {\"nombre\": \"Juan\", \"apellido\": \"Pérez\"}\nd2 = {\"apellido\": \"Pérez\", \"nombre\": \"Juan\"}\n\nprint(d1)\nprint(d2)\nprint(d1 == d2)\n\n{'nombre': 'Juan', 'apellido': 'Pérez'}\n{'apellido': 'Pérez', 'nombre': 'Juan'}\nTrue\n\n\nAunque d1 y d2 tengan las claves en distinto orden, para Python son diccionarios equivalentes; lo que importa no es el orden de los elementos en los diccionarios, sino los pares clave: valor que contienen.\n\n\n\n\n\n\n¿Por qué se llaman diccionarios? 🤔\n\n\n\nEl nombre proviene de la idea de que en un diccionario real, uno busca la definición de una palabra (su valor) a partir de la palabra misma (la clave).\n\n\n\nAcceder a los elementos\nA diferencia de las listas y las tuplas, que son objetos donde el orden importa y se puede acceder a sus elementos por posición, los diccionarios no utilizan posiciones: en ellos, el acceso a los elementos se realiza mediante sus claves. Por ejemplo, si queremos acceder a la edad de Juan utilizando el índice 0, vamos a obtener un error:\npersonas[0]\n\n    personas[0]\n    ~~~~~~~~^^^\nKeyError: 0\n\nEn cambio, si usamos la clave \"Juan\", que es lo que corresponde:\n\npersonas[\"Juan\"]\n\n29\n\n\n\n\nVerificar la existencia de un elemento\nLos operadores in y not in permiten determinar si un diccionario contiene a un elemento con una determinada clave.\n\nd = {\"color\": \"azul\", \"forma\": \"cuadrado\"}\n\n\"color\" in d\n\nTrue\n\n\n\n\"area\" in d\n\nFalse\n\n\n\n\"area\" not in d\n\nTrue\n\n\n\n\"azul\" in d\n\nFalse\n\n\nAunque \"azul\" aparece como valor de uno de los elementos del diccionario d, \"azul\" in d retorna False porque no hay ninguna clave que sea \"azul\".\n\n\nAcceder a claves y valores\nEs posible acceder solo a las claves:\n\nd = {\"color\": \"azul\", \"forma\": \"cuadrado\"}\nd.keys()\n\ndict_keys(['color', 'forma'])\n\n\nO a los valores:\n\nd.values()\n\ndict_values(['azul', 'cuadrado'])\n\n\nO a las claves y los valores:\n\nd.items()\n\ndict_items([('color', 'azul'), ('forma', 'cuadrado')])\n\n\nEn todos los casos se obtiene una estructura de datos especial: dict_keys, dict_values o dict_items. No profundizaremos en ellas, ya que rara vez es necesario interactuar directamente con estos objetos. En la práctica, lo relevante es que permiten iterar sobre sus elementos y convertirse fácilmente a tipos más comunes, como las listas.\n\n\nModificar, agregar y eliminar elementos\nLos diccionarios son objetos mutables, lo que significa que podemos modificar, agregar o eliminar elementos. Su funcionamiento es muy similar al de las listas. La diferencia más notable es que, en vez de usar índices, se usan claves.\n\nModificar elementos\nAl igual que en una lista, podemos modificar un elemento seleccionándolo y asignándole un nuevo valor.\n\npersonas\n\n{'Juan': 29, 'Carla': 34, 'Evelina': 33, 'Leandro': 38}\n\n\n\npersonas[\"Juan\"] = 54\n\n\npersonas\n\n{'Juan': 54, 'Carla': 34, 'Evelina': 33, 'Leandro': 38}\n\n\n\n\nAgregar elementos\nPara agregar un elemento, se utiliza la misma sintaxis que para modificar uno: se asigna un valor a una nueva clave en el diccionario.\n\npersonas[\"Marisa\"] = 29\n\nEn resumen, al asignar un valor a una clave, Python primero verifica si existe: si la encuentra, reemplaza su valor; si no, agrega un nuevo par clave-valor.\n\n\nEliminar elementos\nEn un diccionario, es posible eliminar elementos de distintas maneras. Las más comunes son:\n\nLa sentencia del.\nEl método .pop().\n\nLa sentencia del elimina un elemento asociado a una clave sin devolver su valor, por lo que no puede usarse posteriormente.\nPor ejemplo:\n\ndescuentos = {\n    \"Lunes\": 0,\n    \"Martes\": 20,\n    \"Miercoles\": 10,\n    \"Jueves\": 20,\n    \"Viernes\": 30,\n    \"Sábado\": 30,\n    \"Domingo\": 0\n}\ndescuentos\n\n{'Lunes': 0,\n 'Martes': 20,\n 'Miercoles': 10,\n 'Jueves': 20,\n 'Viernes': 30,\n 'Sábado': 30,\n 'Domingo': 0}\n\n\n\ndel descuentos[\"Domingo\"]\ndescuentos\n\n{'Lunes': 0,\n 'Martes': 20,\n 'Miercoles': 10,\n 'Jueves': 20,\n 'Viernes': 30,\n 'Sábado': 30}\n\n\nEs como si el elemento \"Domingo\": 0 se hubiera esfumado.\nEn cambio, el método .pop() extrae el valor del diccionario y lo devuelve, lo que permite almacenarlo o utilizarlo más adelante en el programa.\n\ndescuento_lunes = descuentos.pop(\"Lunes\")\nprint(descuento_lunes)\nprint(descuentos)\n\n0\n{'Martes': 20, 'Miercoles': 10, 'Jueves': 20, 'Viernes': 30, 'Sábado': 30}\n\n\n\n\nActualizar diccionarios\nLos diccionarios tienen acceso a un método .update() que permiten actualizar un diccionario a partir de otro diccionario. Supongamos que tenemos un diccionario con información relacionada a una persona y otro diccionario con información actualizada de esa persona.\n\ndatos = {\"nombre\": \"Guillermina\", \"ciudad\": \"Rosario\", \"estado civil\": \"soltera\"}\ndatos_nuevos = {\"ciudad\": \"Roldán\", \"estado civil\": \"casada\", \"hijos\": 2}\n\nSe puede actualizar el contenido del diccionario datos con el contenido del diccionario datos_nuevos de la sigiuente manera:\n\ndatos.update(datos_nuevos)\ndatos\n\n{'nombre': 'Guillermina',\n 'ciudad': 'Roldán',\n 'estado civil': 'casada',\n 'hijos': 2}\n\n\nEste método modifica el diccionario datos in-place.\nSi se quiere realizar la operación sin alterar el diccionario original, se puede usar el operador pipe (|), que devuelve un nuevo diccionario.\n\nd1 = {\"a\": 1, \"b\": 2}\nd2 = {\"b\": 10, \"c\": 25}\nd3 = d1 | d2\n\nprint(d1)\nprint(d2)\nprint(d3)\n\n{'a': 1, 'b': 2}\n{'b': 10, 'c': 25}\n{'a': 1, 'b': 10, 'c': 25}\n\n\nPor último, vale la pena notar que al actualizar un diccionario podemos modificar elementos existentes o agregar otros nuevos.\n\n\n\nEstructuras anidadas\nAnteriormente mencionamos que los diccionarios pueden contener cualquier tipo de objeto de Python. Por lo tanto, significa que puede contener números, cadenas, listas… ¡e incluso otros diccionarios!\nVeamos un ejemplo donde esta idea resulta útil. Supongamos que queremos representar la información de una persona llamada Julia, que tiene 33 años y realizó tres cursos de Python: Introducción a Python, Análisis de datos con Python y Python avanzado. El tipo de dato para el nombre y la edad es evidente: str e int, respectivamente. En cambio, para los cursos necesitamos una colección de valores, ya que no se trata de un único elemento. Así, podemos crear el siguiente diccionario:\n\npersona = {\n    \"nombre\": \"Julia\",\n    \"edad\": 33,\n    \"cursos\": [\"Introducción a Python\", \"Análisis de datos con Python\", \"Python avanzado\"]\n}\n\nprint(persona)\n\n{'nombre': 'Julia', 'edad': 33, 'cursos': ['Introducción a Python', 'Análisis de datos con Python', 'Python avanzado']}\n\n\n\nprint(f\"Nombre: {persona['nombre']}\")\nprint(f\"Edad: {persona['edad']}\")\nprint(f\"Cursos: {persona['cursos']}\")\n\nNombre: Julia\nEdad: 33\nCursos: ['Introducción a Python', 'Análisis de datos con Python', 'Python avanzado']\n\n\nTambién es posible representar estructuras de datos más complejas, como registros. En el siguiente ejemplo, el diccionario usuarios tiene como valores otros diccionarios. Las claves de usuarios corresponden a nombres de usuario (por ejemplo, \"aeinstein\"), mientras que los valores son diccionarios que almacenan atributos de ese usuario, como su nombre, apellido y ciudad de residencia.\n\nusuarios = {\n    \"aeinstein\": {\n        \"nombre\": \"albert\",\n        \"apellido\": \"einstein\",\n        \"ciudad\": \"princenton\"\n    },\n    \"mcurie\": {\n        \"nombre\": \"marie\",\n        \"apellido\": \"curie\",\n        \"ciudad\": \"paris\"\n    },\n    \"afleming\": {\n        \"nombre\": \"alexander\",\n        \"apellido\": \"fleming\",\n        \"ciudad\": \"londres\"\n    }\n}\n\nPara acceder a un elemento dentro de un diccionario anidado, se encadenan los accesos usando [] tantas veces como sea necesario: primero para obtener el diccionario interno y luego para acceder a la clave deseada dentro de él.\n\nprint(usuarios[\"aeinstein\"])\nprint(usuarios[\"aeinstein\"][\"ciudad\"])\n\n{'nombre': 'albert', 'apellido': 'einstein', 'ciudad': 'princenton'}\nprincenton\n\n\n\nusuario = \"aeinstein\"\ndatos = usuarios[usuario]\nf\"El usuario '{usuario}' se llama {datos['nombre'].capitalize()} {datos['apellido'].capitalize()}.\"\n\n\"El usuario 'aeinstein' se llama Albert Einstein.\"",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#secuencias",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#secuencias",
    "title": "4 - Colecciones de datos",
    "section": "Secuencias",
    "text": "Secuencias\nLos tres tipos de datos que presentamos en este apunte pertenecen a la categoría de las colecciones, ya que permiten almacenar una colección o conjunto de objetos.\nOtra categoría muy interesante de tipos de datos son las secuencias.\nUna secuencia es una estructura de datos que contiene elementos organizados en orden, y se puede acceder a cada elemento mediante un índice entero que representa su posición en la secuencia. Por lo tanto, las listas y las tuplas son ejemplos de secuencias; los diccionarios, en cambio, no lo son.\nAunque pueda parecer sorprendente al principio, las cadenas de texto también son secuencias.\nVale la pena destacar a las secuencias, ya que todos los tipos de datos que abarca comparten un conjunto común de operaciones, que se resumen en la siguiente tabla:\n\n\n\n\n\n\n\n\nOperación\nResultado\nComentarios\n\n\n\n\ne in s\nIndica si el valor e se encuentra en s\n \n\n\ne not in s\nIndica si el valor e no se encuentra en s\n \n\n\ns + t\nConcatena las secuencias s y t\n \n\n\ns * n\nConcatena n copias de s\n \n\n\ns[i]\nObtiene el elemento i de s\n \n\n\ns[i:j]\nPorción de la secuencia s desde i hasta j (no inclusive)\n \n\n\ns[i:j:k]\nPorción de la secuencia s desde i hasta j (no inclusive), con paso k\n \n\n\nlen(s)\nCantidad de elementos en la secuencia s\n \n\n\nmin(s)\nMínimo elemento en la secuencia s\nRequiere elementos comparables\n\n\nmax(s)\nMáximo elemento de la secuencia s\nRequiere elementos comparables\n\n\nsum(s)\nSuma de los elementos de la secuencia s\nNo aplica a str\n\n\nsorted(s)\nOrdena los elementos de la secuencia s y los devuelve en una lista\nRequiere elementos comparables\n\n\nenumerate(s)\nIterador sobre los elementos de s junto con sus posiciones\nPermite iterar con (índice, valor)\n\n\nreversed(s)\nIterador inverso sobre los elementos de s\n \n\n\nall(s)\nIndica si bool(e) es True para todos los elementos de s\n \n\n\nany(s)\nIndica si bool(e) es True para al menos un elemento de s\n \n\n\ns.index(e)\nPosición del elemento e en la secuencia s\n \n\n\ns.count(e)\nCantidad de veces que el elemento e aparece la secuencia s\n \n\n\n\nPor ejemplo:\n\ntexto = \"Esto es un texto cualquiera\"\notro = \"y esto es otro texto\"\nprint(\"texto[0]:\", texto[0])\n\ntexto[0]: E\n\n\n\nprint(\"texto[-1]:\", texto[-1])\n\ntexto[-1]: a\n\n\n\nprint(\"texto[0:3]:\", texto[0:3])\n\ntexto[0:3]: Est\n\n\n\nprint(\"texto[0:10:2]:\", texto[0:20:2])\n\ntexto[0:10:2]: Et su et u\n\n\n\nprint(\"texto + otro:\", texto + otro)\n\ntexto + otro: Esto es un texto cualquieray esto es otro texto\n\n\n\nprint(\"texto * 2:\", texto * 2)\n\ntexto * 2: Esto es un texto cualquieraEsto es un texto cualquiera\n\n\n\nprint(\"len(texto):\", len(texto))\n\nlen(texto): 27\n\n\n\nprint(\"sorted(texto):\", sorted(texto))\n\nsorted(texto): [' ', ' ', ' ', ' ', 'E', 'a', 'a', 'c', 'e', 'e', 'e', 'i', 'l', 'n', 'o', 'o', 'q', 'r', 's', 's', 't', 't', 't', 'u', 'u', 'u', 'x']\n\n\nAdemás, es posible crear una secuencia (o colección) a partir de otra secuencia (o colección) utilizando el tipo de dato como constructor. Por ejemplo:\n\nlist(\"texto\")\n\n['t', 'e', 'x', 't', 'o']\n\n\n\ntuple(\"texto\")\n\n('t', 'e', 'x', 't', 'o')\n\n\n\nlist((1, 2, 3, 4))\n\n[1, 2, 3, 4]\n\n\nSin embargo, el resultado puede no ser de lo más intuitivo incialmente:\n\nstr([\"1\", \"2\", \"3\"]) # ¡Notar que no concatena los elementos!\n\n\"['1', '2', '3']\"\n\n\n\nlist({\"a\": 1, \"b\": 2}) # Crea una lista a partir de las claves\n\n['a', 'b']\n\n\n\nlist({\"a\": 1, \"b\": 2}.values()) # Es posible crear una lista a partir de los valores\n\n[1, 2]\n\n\nSi intentamos crear un diccionario a partir de una lista (o tupla) “plana”, obtendremos un error, ya que no hay una forma clara de identificar las claves y los valores.\ndict([1, 2, 3])\n\n    dict([1, 2, 3])\n    ~~~~^^^^^^^^^^^\nTypeError: cannot convert dictionary update sequence element #0 to a sequence\n\nEn cambio, si usamos una lista (o tupla) compuesta por listas (o tuplas) de longitud 2, la conversión es posible:\n\ndict([[\"x\", 1], [\"y\", 2]])\n\n{'x': 1, 'y': 2}\n\n\n\ndict([(\"A\", \"aaa\"), (\"B\", \"bbb\")])\n\n{'A': 'aaa', 'B': 'bbb'}",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#resumen-1",
    "href": "teoria/01_programacion_en_python/04_colecciones_de_datos.html#resumen-1",
    "title": "4 - Colecciones de datos",
    "section": "Resumen",
    "text": "Resumen\n\nLista (list)\n\nSintaxis: [a, b, c]\nEs mutable\nTiene orden\nSe accede a los elementos por índice\nEs secuencia\nAdmite cualquier objeto\n\nTupla (tuple)\n\nSintaxis: (a, b, c) o a, b, c\nEs inmutable\nTiene orden\nSe accede a los elementos por índice\nEs secuencia\nAdmite cualquier objeto\n\nDiccionario (dict)\n\nSintaxis: {clave: valor, ...}\nEs mutable\nTiene orden, pero no importa para evaluar igualdad\nSe accede a los elementos por clave\nNo es secuencia\nLas claves admiten objetos hashable, los valores pueden ser cualquier objeto\n\nCadena (str)\n\nSintaxis: \"texto\" o 'texto'\nEs inmutable\nTiene orden\nSe accede a los elementos por índice\nEs secuencia\nSolo admite caracteres",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "4 - Colecciones de datos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html",
    "title": "3 - Ejecución condicional",
    "section": "",
    "text": "Las computadoras son muy buenas para muchísimas cosas. En particular:\n\nDeterminar automáticamente que secciones de un programa se debe ejecutar.\nRealizar tareas repetitivas.\n\nEl primer punto se refiere a la ejecución condicional de código y el segundo a la ejecución repetitiva de código.\nEstos dos puntos pueden ser vistos de manera general como control de flujo del código.\nEn este apunte hablamos de la ejecución condicional de código.",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "3 - Ejecución condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#introducción",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#introducción",
    "title": "3 - Ejecución condicional",
    "section": "",
    "text": "Las computadoras son muy buenas para muchísimas cosas. En particular:\n\nDeterminar automáticamente que secciones de un programa se debe ejecutar.\nRealizar tareas repetitivas.\n\nEl primer punto se refiere a la ejecución condicional de código y el segundo a la ejecución repetitiva de código.\nEstos dos puntos pueden ser vistos de manera general como control de flujo del código.\nEn este apunte hablamos de la ejecución condicional de código.",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "3 - Ejecución condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if",
    "title": "3 - Ejecución condicional",
    "section": "Bloques if",
    "text": "Bloques if\nLos bloques if utilizan la keyword if para evaluar una condición y ejecutar una sección de código en base al resultado de esta evaluación.\n\n\n\n\n\nVeamos un ejemplo.\n\ncondicion = True\nif condicion:\n    print(\"Se ejecuta el bloque if\")\n\nSe ejecuta el bloque if\n\n\n\ncondicion = False\nif condicion:\n    print(\"Se ejecuta el bloque if\")\n\nDe manera mas general, un bloque if es de la siguiente forma:\n\n\n\n\n\nTiene los siguientes componentes:\n\nLa palabra clave if.\nLa condición a evaluar, que tiene que ser True o False. Esta va seguida de los dos puntos : que indican el fin de la condición a evaluar y que lo siguiente es el bloque de código a ejecutar condicionalmente.\nEl bloque de código a evaluar si condición es verdadera.\n\nVeamos otro ejemplo.\n\ncondicion = True\nif condicion:\n    print(\"Se ejecuta el bloque if\")\n\nprint(\"Esto se imprime siempre\")\n\nSe ejecuta el bloque if\nEsto se imprime siempre\n\n\nEl segundo print() se imprime siempre porque está por fuera del bloque de ejecución condicional.\n¿Cómo nos damos cuenta que no está dentro del bloque condicional?\nSimplemente la indentación vuelve a ser normal. El fin de la indentación indica el fin del bloque de código.\n\nvalor = 12\nif valor &gt; 10:\n    print(\"Se ejecuta el bloque if\")\n\nSe ejecuta el bloque if",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "3 - Ejecución condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if---else",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if---else",
    "title": "3 - Ejecución condicional",
    "section": "Bloques if - else",
    "text": "Bloques if - else\nVimos que el bloque if nos permite ejecutar un bloque de código de manera condicional, y que luego el programa sigue su ejecución normal.\nTambién es posible que necesitemos ejecutar un bloque de código cuando las condiciones resulten en True y un bloque distinto en el caso contrario.\nPara eso, utilizamos el bloque if-else.\nUn bloque if-else es muy similar a un bloque if.\nLa diferencia es que nos permite definir otro bloque de código que se ejecuta cuando la prueba condicional es False.\n\n\n\n\n\n\nedad = 21\nif edad &gt;= 16:\n    print(\"Tenés la edad suficiente para votar\")\nelse:\n    print(\"Lo siento, aún sos demasiado jóven para votar\")\n\nTenés la edad suficiente para votar\n\n\n\n\n\n\n\nAl igual que con el bloque if, cualquier parte del código que se escriba luego del bloque if-else es ejecutada sin importar el valor de las condiciones.\nVeamos otro ejemplo donde evaluamos si un número es par o impar.\n\nvalor = 10\nprint(valor)\n\nif valor % 2 == 0:\n    mensaje = \"Es par\"\nelse:\n    mensaje = \"Es impar\"\n\nprint(mensaje)\n\n10\nEs par\n\n\nEn este caso, print(mensaje) se ejecuta siempre.\nLo que varía es el valor de la variable mensaje, que depende de si el número es par o impar.",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "3 - Ejecución condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if-elif-else",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#bloques-if-elif-else",
    "title": "3 - Ejecución condicional",
    "section": "Bloques if-elif-else",
    "text": "Bloques if-elif-else\nEs muy probable que tengamos situaciones donde necesitemos considerar más de dos escenarios posibles.\nPara esto, Python ofrece los bloques if-elif-else.\nEste tipo de programa considera varias condiciones y las evalúa de a una a la vez hasta que alguna es verdadera. Luego se ejecuta solamente el bloque de código que corresponde a la primer condición verdadera.\n\n\n\n\n\nSupongamos que viene un parque de diversiones a Rosario y tiene los siguientes precios para la entrada:\n\nMenores de 4 años, gratis.\nPersonas entre 4 y 18 años, $400.\nPersonas de 18 o mas años, $600.\n\n\nedad = 3\n\nif edad &lt; 4:\n    print(\"El costo de entrada para vos es de $0.\")\nelif edad &lt; 18:\n    print(\"El costo de entrada para vos es de $400.\")\nelse:\n    print(\"El costo de entrada para vos es de $600.\")\n\nEl costo de entrada para vos es de $0.",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "3 - Ejecución condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#múltiples-bloques-elif",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#múltiples-bloques-elif",
    "title": "3 - Ejecución condicional",
    "section": "Múltiples bloques elif",
    "text": "Múltiples bloques elif\nHasta ahora utilizamos un único bloque elif, pero podemos usar tantos como sea necesario.\nPor ejemplo, si el parque de diversiones decide realizar un descuento para adultos mayores, dejando el precio en $350, podriamos agregar otro bloque elif que represente la evaluación de esta condición.\n\nedad = 68\n\nif edad &lt; 4:\n    precio = 0\nelif edad &lt; 18:\n    precio = 400\nelif edad &lt; 65:\n    precio = 600\nelse:\n    precio = 350\n\nprint(f\"El precio de entrada para vos es de ${precio}.\")\n\nEl precio de entrada para vos es de $350.",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "3 - Ejecución condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#omitir-el-bloque-else",
    "href": "teoria/01_programacion_en_python/03_ejecucion_condicional.html#omitir-el-bloque-else",
    "title": "3 - Ejecución condicional",
    "section": "Omitir el bloque else",
    "text": "Omitir el bloque else\nNo hay ninguna regla que nos obligue a terminar un bloque de if-elif con un bloque else.\nUtilizar el bloque else a veces es lo correcto, pero otras veces puede ser mejor poner una condición explícita en un último elif que contemple solamente la condición que realmente nos interesa.\n\nedad = 10\n\nif edad &lt; 4:\n    precio = 0\nelif edad &lt; 18:\n    precio = 400\nelif edad &lt; 65:\n    precio = 600\nelif edad &gt;= 65:\n    precio = 350\n\nprint(f\"El precio de entrada para vos es de ${precio}.\")\n\nEl precio de entrada para vos es de $400.\n\n\nEl bloque elif que agregamos indica que el precio será de $350 cuando la edad de la persona sea mayor o igual a 65 años.\nEsta condición es más explícita y fácil de entender que el bloque else que usábamos antes.\nSin embargo, todavía hay un problema: el programa sigue funcionando incluso si se ingresan edades fuera de un rango razonable. A continuación se muestra una versión más completa:\n\nedad = 125\n\nif edad &lt; 0:\n    print(\"¡Error!\")\n    precio = None\nelif edad &lt; 4:\n    precio = 0\nelif edad &lt; 18:\n    precio = 400\nelif edad &lt; 65:\n    precio = 600\nelif edad &gt;= 65 and edad &lt;= 120:\n    precio = 350\nelse:\n    print(\"¡Error!\")\n    precio = None\n\nprint(f\"El precio de entrada para vos es ${precio}.\")\n\n¡Error!\nEl precio de entrada para vos es $None.\n\n\nEl diagrama y el código para el caso solo con elif se ven de la siguiente manera:",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "3 - Ejecución condicional"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html",
    "href": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html",
    "title": "6 - Uso de código externo",
    "section": "",
    "text": "En la mayoría de los proyectos de programación no alcanza con el código que escribimos nosotros mismos. Con frecuencia necesitamos utilizar código externo y/o de terceros, ya sea para resolver problemas comunes de manera más rápida o para aprovechar el trabajo de la comunidad.\nPython facilita este proceso a través de módulos y paquetes, que nos permiten organizar, compartir e integrar código de forma sencilla. Gracias a ellos podemos sumar nuevas funcionalidades sin tener que programar todo desde cero, mantener el código más ordenado y evitar errores innecesarios.",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "6 - Uso de código externo"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#introducción",
    "href": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#introducción",
    "title": "6 - Uso de código externo",
    "section": "",
    "text": "En la mayoría de los proyectos de programación no alcanza con el código que escribimos nosotros mismos. Con frecuencia necesitamos utilizar código externo y/o de terceros, ya sea para resolver problemas comunes de manera más rápida o para aprovechar el trabajo de la comunidad.\nPython facilita este proceso a través de módulos y paquetes, que nos permiten organizar, compartir e integrar código de forma sencilla. Gracias a ellos podemos sumar nuevas funcionalidades sin tener que programar todo desde cero, mantener el código más ordenado y evitar errores innecesarios.",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "6 - Uso de código externo"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#módulos-y-paquetes",
    "href": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#módulos-y-paquetes",
    "title": "6 - Uso de código externo",
    "section": "Módulos y paquetes",
    "text": "Módulos y paquetes\nUn módulo es un archivo de Python (por ejemplo, modulo.py) que contiene código que se puede reutilizar. En general, los módulos definen funciones, clases y objetos que representan datos de distinta complejidad. Estos pueden ir desde estructuras simples, como una constante numérica, hasta otras más elaboradas, como una tabla de datos con columnas de diferentes tipos.\nUn paquete, por otro lado, es una colección de módulos, generalmente interdependientes. En la práctica, un paquete es una carpeta que contiene varios módulos e, incluso, subpaquetes (carpetas con módulos). Por lo general, los paquetes ofrecen un conjunto de herramientas más amplio que un módulo individual. Además, suelen distribuirse de forma que puedan ser instalados y utilizados por otros usuarios.\n\nPor qué existen\nAsí como las funciones ayudan a reutilizar un programa sin repetir el código y los bucles permiten repetir la misma acción muchas veces, los módulos y paquetes también permiten la reutilización de código.\nDe este modo se evita, por ejemplo, tener que crear una función cada vez que la queremos usar. Simplemente la importamos o la “traemos” de un módulo o paquete. Se ahorra tiempo, se reduce la probabilidad de errores y se mejora la mantenibilidad del código.\nAdemás, los paquetes y módulos nos ayudan a mantener el código organizado y modular. Al dividir el código en “partes” más pequeñas y manejables, facilitamos su comprensión y mantenimiento.\nPor último pero no menos importante, los módulos paquetes nos permiten aprovechar el trabajo de otros. De esta manera, podemos hacer mucho más sin tener que programar todo desde cero.\n\n\n\n\n\n\nGlosario 🎯\n\n\n\nLa documentación de Python 3 provee un glosario con definiciones precisas para términos relevantes en el universo de Python. Entre ellas, podemos destacar las de módulo y paquete:\n\nMódulo: Un objeto que funciona como una unidad de organización de código de Python. Los módulos tienen un espacio de nombres (namespace) que contiene objetos de Python arbitrarios. Los módulos se cargan en Python a través del proceso de importación.\nPaquete: Un módulo de Python que puede contener submódulos o, de forma recursiva, subpaquetes. Técnicamente, un paquete es un módulo de Python con un atributo __path__.",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "6 - Uso de código externo"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#cómo-importar-código",
    "href": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#cómo-importar-código",
    "title": "6 - Uso de código externo",
    "section": "Cómo importar código",
    "text": "Cómo importar código\n\nLa sentencia import\nPara importar un módulo usamos la sentencia import seguida del nombre del módulo a importar.\nimport nombre\nDe esta manera, podemos importar el módulo math que pertenece a la librería estándar de Python.\n\nimport math\n\nLuego, podemos acceder a los objetos dentro del namespace math utilizando math.nombre_objeto. Por ejemplo, para usar la función sqrt(), que calcula la raíz cuadrada de un numero n, escribimos math.sqrt(n).\n\nmath.sqrt(16)\n\n4.0\n\n\nSi quisiéramos importar más de una módulo, solo tenemos que agregar una nueva línea con el import correspondiente. Así, podemos también importar el módulo random que provee herramientas para generar números aleatorios.\n\nimport math\nimport random\n\n\nrandom.random() # número aleatorio entre 0 y 1\n\n0.02007022378062895\n\n\n\n\n\n\n\n\nLibrería estándar de Python 📚\n\n\n\nLa librería estándar de Python es un conjunto de módulos y paquetes incluidos por defecto con cualquier instalación oficial de Python, listos para usar sin necesidad de hacer instalaciones adicionales.\n\n\n\n\n\n\n\n\nDiferencias con R 🎭\n\n\n\nA diferencia de la carga de paquetes en R, que pone a disposición objetos del paquete en el ambiente global, el comando import math en Python no carga los objetos del módulo math directamente en el ambiente donde se ejecuta; solo carga el módulo en sí.\nPara acceder a las funciones de math, es necesario hacerlo mediante el nombre del módulo. Por este motivo, el siguiente bloque de código produce un error:\nimport math\nsqrt(16)\n\nNameError: name 'sqrt' is not defined\n\n\n\n\n\nListar nombres disponibles\nPara obtener un listado con los nombres de los objetos disponibles dentro de un módulo, podemos usar la función dir().\ndir(math)\n['__doc__',\n '__file__',\n '__loader__',\n '__name__',\n '__package__',\n '__spec__',\n 'acos',\n 'acosh',\n 'asin',\n 'asinh',\n...\n 'tan',\n 'tanh',\n 'tau',\n 'trunc',\n 'ulp']\nSin embargo, en la práctica, esta función no suele usarse demasiado para explorar los nombres disponibles en un módulo.\nPor lo general, trabajamos en editores de código que muestran automáticamente la lista de variables disponibles en un módulo.\nEn Positron, si escribimos math seguido de un punto (math.), el editor desplegará un listado de los objetos disponibles en dicho módulo.\n\n\n\n\n\n\n\nImportar objetos de un módulo\nLa flexibilidad en la carga de módulos en Python permite importar uno o más objetos de un módulo (o submódulo) sin necesidad de importar el módulo completo.\nLa sintaxis para traer un objeto de un módulo llamado cosas es:\nfrom cosas import objeto\nDe este modo, podemos cargar la constante pi del módulo math.\n\nfrom math import pi\n\nLuego, es posible acceder a la variable pi sin tener que pasar por el nombre del módulo donde se define.\n\npi\n\n3.141592653589793\n\n\nEn nuestro caso, como anteriormente también importamos el módulo math, seguimos teniendo acceso a pi a través de math.\n\nprint(math.pi)\nprint(pi)\n\n3.141592653589793\n3.141592653589793\n\n\nPara importar varios objetos a la vez, se utiliza una sintaxis similar a la anterior, separando sus nombres con comas. A modo de ejemplo, importemos las funciones mean() y median() de otro módulo estándar llamado statistics.\n\nfrom statistics import mean, median\n\n\nnumeros = [4, 5, 9, 30, 3, 8, 6]\n\nprint(\"La media es:\", mean(numeros))\nprint(\"La mediana es:\", median(numeros))\n\nLa media es: 9.285714285714286\nLa mediana es: 6\n\n\n\n\nImportar con alias\nPython no solo permite decidir que objetos importar de un módulo, si no que también hace posible asignar un alias al objeto o módulo que se importa.\nPara un módulo:\nimport modulo as alias\nY para un objeto dentro de un módulo:\nfrom modulo import objeto as alias\nPodemos importar el módulo math usando el alias mates:\n\nimport math as mates\n\nprint(mates.cos(mates.pi)) # coseno(pi)\n\n-1.0\n\n\nO importar la funcion sqrt con el nombre raiz:\n\nfrom math import sqrt as raiz\n\nraiz(81)\n\n9.0\n\n\n\n\n\n\n\n\nEl problema de importar todo\n\n\n\nPython permite cargar todos los objetos definidos en un módulo o paquete directamente en el ambiente actual. La sintaxis es:\nfrom nombre import *\nEsta no es una práctica recomendable, ya que no sabemos cuántos elementos se importarán ni qué conflictos podrían surgir entre los nombres definidos en el módulo y los que ya tenemos en nuestro programa.\nEl uso de from nombre import * produce un efecto similar al de library(paquete) en R, pero en Python se desaconseja.",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "6 - Uso de código externo"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#módulos-propios",
    "href": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#módulos-propios",
    "title": "6 - Uso de código externo",
    "section": "Módulos propios",
    "text": "Módulos propios\nLa sintaxis para importar un módulo propio, u objetos definidos en él, es la misma que la que se utiliza para importar cualquier otro módulo.\nSupongamos que tenemos un archivo llamado funciones.py con el siguiente contenido:\n\n\nfunciones.py\n\ndef es_par(n):\n    if n % 2 == 0:\n        return True\n    return False\n\n\ndef es_primo(n):\n    if n &lt;= 1:\n        return False\n\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n\n    return True\n\ny queremos usar las funciones es_par y es_primo en nuestro programa principal.\nUn aspecto fundamental a tener en cuenta para poder importar el módulo funciones desde nuestro programa principal es su ubicación.\nSi el archivo funciones.py no se encuentra en alguno de los directorios que Python recorre al ejecutar la sentencia import, obtendremos un error.\nUno de los directorios en los que Python busca módulos al importar es el directorio actual, es decir, aquel desde donde se ejecuta nuestro programa principal.\nSupongamos una carpeta (es decir, un proyecto) con la siguiente estructura de archivos:\nproyecto/                  # Carpeta\n├── funciones.py           # Módulo\n└── programa.py            # Programa principal\nAquí, programa.py es nuestro programa principal y contiene el siguiente código:\nimport funciones\n\nprint(funciones.es_par(12))\nprint(funciones.es_par(15))\n\nprint(funciones.es_primo(1))\nprint(funciones.es_primo(11))\nprint(funciones.es_primo(15))\nAl ejecutarlo, obtendremos la siguiente salida:\nTrue\nFalse\nFalse\nTrue\nFalse\nUn programa equivalente es el siguiente:\nfrom funciones import es_par, es_primo\n\nprint(es_par(12))\nprint(es_par(15))\n\nprint(es_primo(1))\nprint(es_primo(11))\nprint(es_primo(15))\nLa salida de este programa será la misma que la del ejemplo anterior. La diferencia es que en este segundo programa se importan directamente las funciones es_par y es_primo desde el módulo funciones, en lugar de importar el módulo y luego acceder a las funciones a través de funciones.es_par y funciones.es_primo.",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "6 - Uso de código externo"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#paquetes-externos",
    "href": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#paquetes-externos",
    "title": "6 - Uso de código externo",
    "section": "Paquetes externos",
    "text": "Paquetes externos\nLa instalación de paquetes en Python se realiza mediante un sistema de gestión de paquetes que se encarga de instalar y administrar paquetes.\nEstos paquetes se encuentran alojados en repositorios públicos (o privados) a los que los gestores acceden para descargar y actualizar el software.\nEn el ecosistema de Python existe una gran variedad de sistemas de gestión de paquetes, cuya adopción depende de las necesidades de cada usuario o proyecto.\nEn cuanto a los repositorios, también hay varias alternativas. Sin embargo, a diferencia de los gestores, el Python Package Index (PyPI) es el más utilizado por la gran mayoría de la comunidad.\n\n\n\n\n\n\nNota 📝\n\n\n\nSe puede considerar al Python Package Index (PyPI) como el equivalente del Comprehensive R Archive Network (CRAN) en el ecosistema de R.\n\n\n\nInstalación de paquetes con pip\nLa instalación oficial de Python incluye un administrador de paquetes estándar llamado pip. Esta herramienta permite instalar y gestionar paquetes que no forman parte de la biblioteca estándar de Python.\nEs importante resaltar que pip se utiliza desde la terminal, no desde el intérprete de Python.\nEn Windows, es posible usar el comando where pip para localizar la ubicación del programa. Otra opción es ejecutar pip --version, que muestra la versión instalada de pip junto con la ruta de la instalación de Python a la que está vinculado.\nAntes de instalar paquetes con pip, es posible consultar qué paquetes ya se encuentran instalados mediante esta herramienta con el comando list:\npip list\nEste comando muestra un listado con los paquetes instalados y sus respectivas versiones.\nC:\\Users\\tutoriales&gt;pip list\nPackage Version\n------- -------\npip     25.1.1\nComo aún no hemos instalado ningún paquete adicional a los que vienen con Python, solo se muestra pip.\nLa instalación de paquetes se hace con el comando install. Luego, para instalar el paquete NumPy hacemos:\npip install numpy\nDebajo se incluye una captura de la terminal de Windows donde se muestra la ejecución de los comandos antes mencionados y sus respectivas salidas:\n\n\n\n\n\n\n\n\n\n\n\nEjecutar pip como módulo de Python\n\n\n\nLa herramienta pip es simplemente un módulo de Python. Si tenemos múltiples instalaciones de Python y/o pip, es posible que la versión de pip a la que se accede en nuestra terminal no sea la que está asociada a la versión de Python que queremos utilizar. Para evitar este tipo de problemas, se puede ejecutar el programa pip como un módulo de Python. De este modo, la instalación de NumPy se vería de la siguiente manera:\npython -m pip install numpy\nLa opción -m le indica a Python que ejecute un módulo como si fuera un programa dentro del intérprete de Python.\n\n\n\n\n\n\n\n\n¿En qué momento seleccionamos a PyPI? 🤔\n\n\n\nNo es necesario que manualmente selccionemos a PyPI como repositorio de código. Por defecto, pip ya instala los paquetes desde PyPI.\n\n\n\n\nCreación de ambientes con venv\nCuando instalamos paquetes con la versión de pip que se incluye por defecto en Python, estos se instalan de forma global. Esto no siempre representa un problema, pero suele complicarse cuando trabajamos en varios proyectos distintos.\nCada proyecto puede depender de diferentes paquetes, e incluso de diferentes versiones de Python. Si todos comparten una misma instalación global, es muy probable que aparezcan conflictos: algunos programas podrían dejar de funcionar o comportarse de manera incorrecta.\nUna solución sería reinstalar todas las dependencias desde cero cada vez, pero esto implica una pérdida de tiempo innecesaria y, además, no garantiza el correcto funcionamiento. La solución más aceptada por la comunidad es usar ambientes virtuales.\nUn ambiente virtual en Python permite aislar dependencias y paquetes para evitar conflictos entre proyectos.\nExisten distintas herramientas para crear y administrar ambientes virtuales; la que se incluye en la instalación oficial de Python es venv.\nPara crear un ambiente virtual con venv, primero debemos ubicarnos en la carpeta de nuestro proyecto y ejecutar en la terminal:\npython -m venv .venv\nEl nombre .venv es una convención adoptada por la comunidad, aunque puede usarse cualquier nombre válido de directorio.\nEste comando genera una carpeta con la siguiente estructura:\n.venv\n├── Include\n├── Lib\n│   └── site-packages\n│       ├── pip\n│       └── pip-25.1.1.dist-info\n├── Scripts\n│   ├── Activate.ps1\n│   ├── activate\n│   ├── activate.bat\n│   ├── activate.fish\n│   ├── deactivate.bat\n│   ├── pip.exe\n│   ├── pip3.13.exe\n│   ├── pip3.exe\n│   ├── python.exe\n│   └── pythonw.exe\n└── pyvenv.cfg\nDentro de .venv/Lib/site-packages se almacenan los paquetes instalados en el ambiente, y en .venv/Scripts se encuentra el ejecutable de Python (python.exe) junto con otros scripts de utilidad.\nPara usar el intérprete de Python del ambiente e instalar paquetes en él, es necesario activarlo con el comando:\n.venv\\Scripts\\activate\nAl hacerlo, se mostrará (.venv) al inicio de la línea de la terminal.\nFinalmente, para desactivar el ambiente, basta con ejecutar:\ndeactivate\n\n\nEjemplo: NumPy\nNumPy es una paquete de Python especializado en el cálculo numérico y el análisis de datos.\nProvee un nuevo tipo de objeto llamado array que permite representar colecciones de datos de un mismo tipo en varias dimensiones y funciones muy eficientes para su manipulación.\n\n\n\n\n\nPara crear un proyecto, un ambiente con venv e instalar NumPy, seguimos los siguientes pasos:\nmkdir proyecto          # Crear directorio\ncd proyecto             # Mover la terminal al directorio del proyecto\npython -m venv .venv    # Crear ambiente virtual llamado .venv\n.venv\\Scripts\\activate  # Activar ambiente\npip install numpy       # Instalar numpy en el ambiente del proyecto\npython                  # Iniciar el intérprete interactivo de Python\nEl siguiente video muestra los pasos realizados en la terminal de Windows:\n\n\n\n\n\nLos paquetes de Python suelen importarse utilizando un alias. En el caso de los más populares, como NumPy, la mayoría de la comunidad usa el alias np.\n\nimport numpy as np\n\narray = np.array([1, 2, 3, 4])\narray\n\narray([1, 2, 3, 4])\n\n\n\ntype(array)\n\nnumpy.ndarray\n\n\nLa propiedad .ndim nos devuelve el número de dimensiones del array.\n\narray.ndim\n\n1\n\n\nY .shape nos devuelve la “forma” del array. Es decir, la cantidad de elementos por cada dimensión. Se puede notar que el .shape de un array es una tupla.\n\narray.shape\n\n(4,)\n\n\nEn este caso creamos un array a partir de una lista, pero también es posible crear arrays a partir de otros objetos.\nSi continuamos utilizando listas, el número de dimensiones del array va a depender del anidamiento que tengamos en las listas que utilizamos.\nA modo de ejemplo, podemos crear un array de dos dimensiones de la siguiente manera:\n\narray_2d = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])\narray_2d\n\narray([[1, 2, 3, 4],\n       [5, 6, 7, 8]])\n\n\n\nprint(array_2d.ndim)\nprint(array_2d.shape)\n\nUna de las características más atractivas de NumPy es que las operaciones matemáticas con arrays están vectorizadas, es decir, se realizan al nivel del arreglo.\n\nprint(array * 10)\nprint(array - 5)\nprint(array / 10)\nprint(array ** 2.4)\n\n[10 20 30 40]\n[-4 -3 -2 -1]\n[0.1 0.2 0.3 0.4]\n[ 1.          5.27803164 13.96661017 27.85761803]\n\n\nNumPy también provee muchísimas funciones para hacer cálculos comúnmente realizados con los arrays.\n\nprint(np.mean(array))\nprint(np.median(array))\nprint(np.std(array))\nprint(np.exp(array))\n\n2.5\n2.5\n1.118033988749895\n[ 2.71828183  7.3890561  20.08553692 54.59815003]",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "6 - Uso de código externo"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#apéndice",
    "href": "teoria/01_programacion_en_python/06_uso_de_codigo_externo.html#apéndice",
    "title": "6 - Uso de código externo",
    "section": "Apéndice",
    "text": "Apéndice\n\nAlgunos comandos de pip\n\n\n\n\n\n\n\nComando\nDescripción\n\n\n\n\npip install pkg1 pkg2\nInstala uno o varios paquetes.\n\n\npip install pkg==1.2.3pip install pkg&gt;=1.0,&lt;=2.0\nInstala una versión específica o un rango de versiones de un paquete.\n\n\npip install pkg --upgrade\nActualiza un paquete a la última versión disponible.\n\n\npip freeze\nMuestra todos los paquetes instalados y sus versiones en formato compatible con requirements.txt.\n\n\npip uninstall pkg\nDesinstala un paquete instalado.\n\n\npip show pkg\nMuestra información detallada sobre un paquete (versión, ubicación, dependencias).\n\n\npip help\nMuestra la ayuda general de pip o de un subcomando específico.\n\n\npip install -r dependencias.txt\nInstala todas las dependencias listadas en un archivo.\n\n\n\n\nEjemplos\npip install requests flask        # Instala varios paquetes\npip install numpy==1.25.0         # Instala una versión exacta\npip install pandas&gt;=1.0,&lt;2.0      # Instala dentro de un rango de versiones\npip install requests --upgrade    # Actualiza un paquete\npip freeze                        # Lista paquetes instalados y versiones\npip uninstall flask               # Desinstala un paquete\npip show numpy                    # Muestra información de un paquete\npip help install                  # Muestra ayuda sobre 'install'\npip install -r requirements.txt   # Instala dependencias desde un archivo",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "6 - Uso de código externo"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html",
    "href": "teoria/01_programacion_en_python/02_funciones.html",
    "title": "2 - Funciones",
    "section": "",
    "text": "Una función puede pensarse como un “mini-programa” dentro de un programa más grande. Su propósito es cumplir una tarea u objetivo específico, de forma independiente del resto del código.\nEl uso de funciones tiene varias ventajas:\n\nReutilización de código: se define una sola vez y se ejecuta cuando sea necesario.\nMejor organización: dividen el programa en partes más fáciles de leer y mantener.\nModularidad: permiten construir programas como bloques independientes que pueden combinarse entre sí (¡funciones dentro de funciones!).\n\nConsideremos el siguiente caso donde se busca calcuar el precio final de un producto, considerando impuestos y descuentos.\n\nprecio_base = 800   # Precio del producto ($800)\nimpuesto = 0.21     # Impuesto (21%)\ndescuento = 0.10    # Descuento (10%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n871.2\n\n\n¿Qué pasa si queremos calcular el precio final para otros productos con diferentes precios, impuestos o descuentos?\nUna opción es repetir el código tantas veces como sea necesario…\n\nprecio_base = 500   # Precio del producto ($500)\nimpuesto = 0.105    # Impuesto (10.5%)\ndescuento = 0.0     # Descuento (0%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n552.5\n\n\n\nprecio_base = 2000  # Precio del producto ($2000)\nimpuesto = 0.21     # Impuesto (21%)\ndescuento = 0.20    # Descuento (20%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n1936.0\n\n\nOtra opción, mucho mas conveniente, es utilizar funciones.\n\ndef calcular_precio(precio_base, impuesto, descuento):\n    resultado = precio_base * (1 + impuesto) * (1 - descuento)\n    return resultado\n\nLuego, para utilizar la función simplemente la llamamos (o invocamos).\n\ncalcular_precio(800, 0.21, 0.10)\n\n871.2\n\n\nTambién es posible indicar los valores de los argumentos utilizando sus nombres.\n\ncalcular_precio(precio_base=2000, impuesto=0.21, descuento=0.20)\n\n1936.0",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#qué-es-una-función",
    "href": "teoria/01_programacion_en_python/02_funciones.html#qué-es-una-función",
    "title": "2 - Funciones",
    "section": "",
    "text": "Una función puede pensarse como un “mini-programa” dentro de un programa más grande. Su propósito es cumplir una tarea u objetivo específico, de forma independiente del resto del código.\nEl uso de funciones tiene varias ventajas:\n\nReutilización de código: se define una sola vez y se ejecuta cuando sea necesario.\nMejor organización: dividen el programa en partes más fáciles de leer y mantener.\nModularidad: permiten construir programas como bloques independientes que pueden combinarse entre sí (¡funciones dentro de funciones!).\n\nConsideremos el siguiente caso donde se busca calcuar el precio final de un producto, considerando impuestos y descuentos.\n\nprecio_base = 800   # Precio del producto ($800)\nimpuesto = 0.21     # Impuesto (21%)\ndescuento = 0.10    # Descuento (10%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n871.2\n\n\n¿Qué pasa si queremos calcular el precio final para otros productos con diferentes precios, impuestos o descuentos?\nUna opción es repetir el código tantas veces como sea necesario…\n\nprecio_base = 500   # Precio del producto ($500)\nimpuesto = 0.105    # Impuesto (10.5%)\ndescuento = 0.0     # Descuento (0%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n552.5\n\n\n\nprecio_base = 2000  # Precio del producto ($2000)\nimpuesto = 0.21     # Impuesto (21%)\ndescuento = 0.20    # Descuento (20%)\n\nprecio_final = precio_base * (1 + impuesto) * (1 - descuento)\nprecio_final\n\n1936.0\n\n\nOtra opción, mucho mas conveniente, es utilizar funciones.\n\ndef calcular_precio(precio_base, impuesto, descuento):\n    resultado = precio_base * (1 + impuesto) * (1 - descuento)\n    return resultado\n\nLuego, para utilizar la función simplemente la llamamos (o invocamos).\n\ncalcular_precio(800, 0.21, 0.10)\n\n871.2\n\n\nTambién es posible indicar los valores de los argumentos utilizando sus nombres.\n\ncalcular_precio(precio_base=2000, impuesto=0.21, descuento=0.20)\n\n1936.0",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#definición-de-funciones",
    "href": "teoria/01_programacion_en_python/02_funciones.html#definición-de-funciones",
    "title": "2 - Funciones",
    "section": "Definición de funciones",
    "text": "Definición de funciones\nAnalicemos las diferentes partes que forman la definición de una función en Python:\n\n\n\n\n\n\nLa palabra clave def:\n\nMarca el inicio de la definición de una función.\nEs una palabra reservada (keyword).\n\nEl nombre de la función:\n\nDebe seguir las mismas reglas que los nombres de las variables.\n\nLos argumentos de la función, dentro de paréntesis:\n\nSe separan por comas y pueden ser 0 o más.\n\nLos dos puntos (:):\n\nIndican el final de la línea de definición y el inicio del bloque de código.\n\nEl bloque de código, que es el cuerpo de la función:\n\nEs el código que se ejecuta cada vez que llamamos a la función.\n\nLa sentencia return que indica el resultado que devuelve la función.\n\nLuego del return viene el valor o nombre de la variable a devolver.\nEs opcional (ya vamos a ver ejemplos).\n\n\n\n\n\n\n\n\nObservación 👀\n\n\n\nEn R se tiene que asignar de manera explícita una función a una variable. Por ejemplo:\nsumar &lt;- function(x, y) {\n    return(x + y)\n}\nEn cambio, en Python, la sentencia def define la función y le asigna un nombre en un mismo paso.",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#ejemplos",
    "href": "teoria/01_programacion_en_python/02_funciones.html#ejemplos",
    "title": "2 - Funciones",
    "section": "Ejemplos",
    "text": "Ejemplos\n\n1. Suma de números\nComencemos con una función super sencilla. La misma se llama sumar, recibe dos argumentos x e y, y devuelve la suma de ambos.\n\ndef sumar(x, y):\n    return x + y\n\n\nsumar(15, 21.9)\n\n36.9\n\n\n\ntype(sumar(15, 21.9))\n\nfloat\n\n\nEl valor que devuelve puede ser tratado como cualquier valor en Python. Por ejemplo, se lo puede asignar a una variable.\n\nresultado = sumar(10, 11)\nresultado\n\n21\n\n\nY el valor de esa variable puede ser luego pasado a una nueva llamada a sumar() (o a cualquier otra función).\n\nsumar(resultado, 2.55)\n\n23.55\n\n\nIncluso es posible pasar expresiones y llamadas a funciones a la hora de pasar un argumento:\n\nsumar(sumar(1, 2), 3)\n\n6\n\n\nEn la línea sumar(sumar(1, 2), 3), Python comienza evaluando la función sumar(). Pero para poder hacerlo, primero necesita conocer los valores de los argumentos. Al revisar el primer argumento, detecta que no es un valor directamente, sino otra llamada a la función sumar(1, 2), por lo que la evalúa primero. El resultado de esa operación es 3, que se toma como valor del primer argumento de la llamada externa. El segundo argumento ya está dado: también es 3. Entonces, Python invoca la función sumar() con los argumentos 3 y 3, cuyo resultado es 6. Finalmente, ese valor se muestra en pantalla.\n\n\n2. Saludo personalizado\nOtro ejemplo sencillo consiste en una función que recibe un nombre e imprime un saludo en pantalla.\n\ndef saludar(nombre):\n    print(\"Hola\", nombre)\n\n\nsaludar(\"Pablo\")\n\nHola Pablo\n\n\nEsta función no devuelve un resultado, sino que utiliza el argumento recibido para mostrar un mensaje en pantalla.\n\nsaludar(\"Juan\" + \" Manuel\")\n\nHola Juan Manuel\n\n\n\n\n3. Sin parámetros\nY podemos tener funciones que no utilicen ningún argumento.\n\ndef decir_hola():\n    print(\"¡Hola!\")\n\n\ndecir_hola()\ndecir_hola()\ndecir_hola()\n\n¡Hola!\n¡Hola!\n¡Hola!\n\n\n\n\n4. Devolución de múltiples valores\nEn Python, las funciones pueden devolver múltiples valores separándolos por comas en la sentencia return. Por ejemplo:\n\ndef potencias(x):\n    cuadrado = x ** 2\n    cubo = x ** 3\n    return cuadrado, cubo\n\npotencias(2)\n\n(4, 8)\n\n\nEl resultado de este tipo de funciones puede ser asignado a múltiples variables. De esta forma, podemos obtener el cuadrado y el cubo de un número con una sola llamada a una función.\n\ncuadrado, cubo = potencias(8)\nprint(cuadrado)\nprint(cubo)\n\n64\n512\n\n\n\n\n\n\n\n\nObservación 👀\n\n\n\nAl igual que en la asignación múltiple de variables, lo que parece ser una función que devuelve múltiples objetos es en realidad una función que devuelve un único objeto llamado tupla (de tipo tuple) que permite la técnica de unpacking.\nNo te preocupes, más adelante vamos a ver bien cómo funciona.",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#diagrama-de-una-función",
    "href": "teoria/01_programacion_en_python/02_funciones.html#diagrama-de-una-función",
    "title": "2 - Funciones",
    "section": "Diagrama de una función",
    "text": "Diagrama de una función\n\n\n\n\n\nAlgunos efectos colaterales pueden ser:\n\nImprimir un texto o un gráfico.\nCambiar el valor de una variable global.\nCrear, eliminar o modificar un archivo de la computadora.\n\n\n\n\n\n\n\n¿Puedo devolver una salida y generar efectos colaterales a la vez? 🤔\n\n\n\nUna función en Python puede realizar múltiples tareas, como devolver un valor e imprimir un mensaje en pantalla.\nPor ejemplo:\ndef producto(x, y):\n    resultado = x * y\n    print(\"El producto es\", resultado)\n    return resultado\nLa función producto() no solo calcula y devuelve el resultado de multiplicar x por y, sino que además muestra un mensaje por pantalla.\nSin embargo, en general no es una buena práctica combinar tareas distintas dentro de una misma función, especialmente si son de distinta naturaleza (como devolver un valor y causar un efecto colateral). Esto puede dificultar la reutilización y el mantenimiento del código.",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#argumentos-nombrados-y-posicionales",
    "href": "teoria/01_programacion_en_python/02_funciones.html#argumentos-nombrados-y-posicionales",
    "title": "2 - Funciones",
    "section": "Argumentos nombrados y posicionales",
    "text": "Argumentos nombrados y posicionales\nAl definir una función, debemos darle un nombre a cada uno de los argumentos que va a recibir.\nAl llamar a la función, podemos pasar los valores de dos formas: por posición o por nombre.\nPor ejemplo, las siguientes llamadas a la función sumar() son equivalentes:\n\nsumar(x = 10, y = 15)\n\n25\n\n\n\nsumar(10, 15)\n\n25\n\n\nSi utilizamos los nombres para pasar los argumentos no hace falta que estén en el mismo orden que en la definición de la función.\n\nsumar(y = 15, x = 10)\n\n25\n\n\n¡Que sea posible no significa que sea una buena práctica!",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#ausencia-de-return",
    "href": "teoria/01_programacion_en_python/02_funciones.html#ausencia-de-return",
    "title": "2 - Funciones",
    "section": "Ausencia de return",
    "text": "Ausencia de return\nLa función sumar() termina con la siguiente línea:\n    return x + y\nEs decir, utiliza la sentencia return para devolver un valor.\nPor otro lado, la función saludar() termina con un print() y no tiene ningún return.\n    print(\"Hola\", nombre)\n\nresultado = sumar(1, 2)\nresultado\n\n3\n\n\n\nsaludo = saludar(\"Juan\")\n\nHola Juan\n\n\n\n¿Cuál es el valor de la variable saludo?\n¿Por qué?\n¿Tiene sentido?\n\n\nprint(saludo)\n\nNone\n\n\nEn Python no existe el concepto de return implícito.\nSi queremos que una función devuelva un valor, es necesario usar la instrucción return de forma explícita.\nEn caso de no hacerlo, la función devuelve automáticamente None.",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/02_funciones.html#argumentos-por-defecto",
    "href": "teoria/01_programacion_en_python/02_funciones.html#argumentos-por-defecto",
    "title": "2 - Funciones",
    "section": "Argumentos por defecto",
    "text": "Argumentos por defecto\nCuando definimos una función podemos determinar valores por defecto para uno o más parámetros.\nSi cuando llamamos a la función le pasamos un valor a ese parámetro, se utiliza el valor que pasamos. Sino, se usa el valor por defecto.\nEsta práctica es útil para simplificar las llamadas que realizamos a una función.\nSupongamos la siguiente función describir_mascota() que tiene los parámetros nombre y tipo\n\ndef describir_mascota(nombre, tipo):\n    print(\"Tengo un\", tipo)\n    print(\"Y su nombre es\", nombre)\n\ndescribir_mascota(\"Bruno\", \"perro\")\n\nTengo un perro\nY su nombre es Bruno\n\n\nAhora, hacemos que el parámetro tipo sea por defecto igual a \"perro\".\n\ndef describir_mascota(nombre, tipo=\"perro\"):\n    print(\"Tengo un\", tipo)\n    print(\"Y su nombre es\", nombre)\n\nDe este modo, es posible llamar a la función solamente pasando valores para aquellos parámetros sin valor por defecto:\n\ndescribir_mascota(\"Bruno\")\n\nTengo un perro\nY su nombre es Bruno\n\n\nComo es de esperar, también es posible pasar valores distintos a los establecidos por defecto:\n\ndescribir_mascota(\"Nemo\", \"pez\")\n\nTengo un pez\nY su nombre es Nemo",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "2 - Funciones"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/02_estructuras_lineales.html",
    "href": "teoria/04_estructuras_y_algoritmos/02_estructuras_lineales.html",
    "title": "2 - Estructuras lineales",
    "section": "",
    "text": "En el apunte anterior exploramos algunas estructuras de datos basadas en arreglos y analizamos su desempeño al realizar distintas operaciones.\nSin embargo, el desempeño no es el único factor a considerar al elegir una estructura de datos. En muchos casos, se eligen ciertas estructuras porque permiten escribir un código más simple y fácil de leer.\nEn este apunte nos enfocaremos en las siguientes estructuras:\n\nPilas\nColas\nListas enlazadas\nListas doblemente enlazadas\n\nEstas estructuras pertenecen a la categoría de estructuras lineales. Las estructuras de datos lineales son aquellas en las que los elementos están organizados uno detrás de otro, formando una secuencia. Cada elemento (excepto el primero y el último) tiene un predecesor y un sucesor.\nAdemás, aprenderemos a distinguir entre un tipo de dato abstracto y una estructura de datos concreta.",
    "crumbs": [
      "Teoría",
      "U4 - Estructuras de Datos y Algoritmos",
      "2 - Estructuras lineales"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/02_estructuras_lineales.html#introducción",
    "href": "teoria/04_estructuras_y_algoritmos/02_estructuras_lineales.html#introducción",
    "title": "2 - Estructuras lineales",
    "section": "",
    "text": "En el apunte anterior exploramos algunas estructuras de datos basadas en arreglos y analizamos su desempeño al realizar distintas operaciones.\nSin embargo, el desempeño no es el único factor a considerar al elegir una estructura de datos. En muchos casos, se eligen ciertas estructuras porque permiten escribir un código más simple y fácil de leer.\nEn este apunte nos enfocaremos en las siguientes estructuras:\n\nPilas\nColas\nListas enlazadas\nListas doblemente enlazadas\n\nEstas estructuras pertenecen a la categoría de estructuras lineales. Las estructuras de datos lineales son aquellas en las que los elementos están organizados uno detrás de otro, formando una secuencia. Cada elemento (excepto el primero y el último) tiene un predecesor y un sucesor.\nAdemás, aprenderemos a distinguir entre un tipo de dato abstracto y una estructura de datos concreta.",
    "crumbs": [
      "Teoría",
      "U4 - Estructuras de Datos y Algoritmos",
      "2 - Estructuras lineales"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/02_estructuras_lineales.html#pilas",
    "href": "teoria/04_estructuras_y_algoritmos/02_estructuras_lineales.html#pilas",
    "title": "2 - Estructuras lineales",
    "section": "Pilas",
    "text": "Pilas\nUna pila es una colección de objetos con ciertas restricciones para su inserción y eliminación. Para entender su funcionamiento, podemos imaginar una pila de cajas como la siguiente:\n\n\n\n\n\nLa primera caja que se colocó en la pila es la roja, luego la amarilla, la verde y finalmente la naranja. Si quisiéramos leer el contenido de una caja o extraer una de ellas, no podríamos elegir una cualquiera: habría que empezar desde la parte superior, con la que fue agregada más recientemente. Del mismo modo, si quisiéramos insertar una nueva caja, también deberíamos hacerlo en la cima de la pila.\nEn computación, se dice que la pila es una colección de objetos que se insertan y extraen siguiendo el principio last-in, first-out (LIFO), que significa que “el último en entrar es el primero en salir”.\nPodemos imaginar un brazo mecánico que permite leer, quitar o agregar cajas en la pila:\n\n\n\n\n\nEn la computadora, podríamos representar una pila de la siguiente manera:\n\n\n\n\n\ndonde cada caja representa un objeto en memoria. Como ninguna celda tiene propiedades especiales, utilizamos el mismo color para todas:\n\n\n\n\n\n\nLectura\nComo ya adelantamos, solo es posible interactuar con el objeto en la cima de la pila. Por lo tanto, solo es posible leer el valor al inicio de la pila, independientemente de que se extraiga o no. Si quisieramos leer un valor posterior, primero deberíamos extraer los valores que están por encima de el.\n\n\nInserción\nPara insertar un valor en la pila, también tenemos que respetar la restricción de que solo podemos modificarla desde la cima. Por lo tanto, si queremos agregar un elemento, tenemos que hacerlo encima de todos los otros elementos.\n\n\n\n\n\n\n\n\n\n\n\n\nEliminación\nLa eliminación de elementos de la pila también tiene que seguir su orden natural: solo podemos eliminar elementos en la cima.\nLa siguiente figura representa la eliminación de Objeto Y de la pila.\n\n\n\n\n\nY a continuación se representa la eliminación de múltiples elementos:\n\n\n\n\n\n\n\nImplementación\nEn la práctica, no existe una pila de celdas de memoria con la que trabajemos directamente. Formalmente, una pila es un tipo de dato abstracto que define un método para insertar objetos en la cima y otro para extraerlos desde la cima.\nPara utilizar una pila en un programa, necesitamos una implementación concreta de la misma, la cual se apoya en otras estructuras de datos.\nUna forma de implementar una pila es a partir de un arreglo al que se le imponen ciertas restricciones. Por ejemplo, podemos crear una clase Pila que, internamente, almacene los valores utilizando una lista de Python.\nPara entender la relación entre la pila y el arreglo subyacente, se puede imaginar que la pila se rota o se tumba horizontalmente. El elemento en la cima de la pila corresponderá al último elemento del arreglo, y la base de la pila al primer elemento del arreglo.\n\n\n\n\n\nQue solo interactuemos con la cima de pila implica que solo interactuamos con la cola del arreglo.\n\n\n\n\n\nCuando insertamos un elemento, lo hacemos al final del arreglo, extendiendo su longitud:\n\n\n\n\n\nY cuando se elimina un elemento, también lo hacemos al final del arreglo, lo que reduce su longitud:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFinalmente, tenemos nuestra implementación en Python:\n\nclass Pila:\n    def __init__(self):\n1        self._datos = []\n\n2    def insertar(self, element):\n        self._datos.append(element)\n\n3    def extraer(self):\n        if len(self._datos) &gt; 0:\n            return self._datos.pop()\n        return None\n\n4    def leer(self):\n        if len(self._datos) &gt; 0:\n            return self._datos[-1]\n        return None\n\n    @property\n    def vacia(self):\n        return len(self._datos) == 0\n\n\n1\n\nInternamente, las pilas utilizan un arreglo “protegido” para almacenar los datos.\n\n2\n\nPara insertar un elemento, solo se necesita el valor a agregar, no su posición, ya que siempre se incorpora en la cima de la pila (es decir, al final del arreglo interno).\n\n3\n\nAl extraer un elemento, tampoco se requiere indicar la posición, ya que siempre se remueve el último elemento ingresado, el que se encuentra en la cima de la pila.\n\n4\n\nEl método leer permite consultar el valor en la cima sin retirarlo.\n\n\n\n\n\n\nAplicaciones\n\nInvertir orden\nGracias al protocolo LIFO, una pila puede servir para invertir el orden de los datos.\nPor ejemplo, si apilamos los valores 1, 2 y 3 en ese orden, al desapilarlos los obtendremos en orden inverso: 3, 2 y 1.\nEsta idea se puede usar en muchos casos. Por ejemplo, podríamos querer imprimir las líneas de un archivo en orden inverso para mostrar un conjunto de datos en orden descendente en lugar de ascendente.\nPara hacerlo, basta con leer cada línea, apilarla en la pila y luego imprimirlas en el orden en que se van desapilando.\n\ndef invertir_archivo(origen, destino):\n    pila = Pila()\n\n    with open(origen) as archivo_origen:\n        for linea in archivo_origen:\n            pila.insertar(linea.rstrip(\"\\n\"))\n\n    with open(destino, \"w\") as archivo_destino:\n        while not pila.vacia:\n            archivo_destino.write(pila.extraer() + \"\\n\")\n\nSi tenemos el siguiente archivo con un extracto de la letra de Tu misterioso alguien de Miranda!:\n\n\noriginal.txt\n\n¿Quién es tu nuevo amor?\n¿Tu nueva ocupación?\n¿Tu misterioso alguien?\n\ny ejecutamos la función de esta manera:\ninvertir_archivo(\"original.txt\", \"invertido.txt\")\nLuego tenemos:\n\n\noriginal.txt\n\n¿Tu misterioso alguien?\n¿Tu nueva ocupación?\n¿Quién es tu nuevo amor?\n\n\n\nVerificar de paréntesis y corchetes\nOtra aplicación de las pilas está relacionada con la verificación de paréntesis y corchetes en expresiones matemáticas. Estos símbolos se utilizan para agrupar partes de una expresión y, por lo general, para modificar el orden en que se evalúan los operadores.\nPara que una expresión sea válida, cada paréntesis (o corchete) que abre un grupo ( debe tener su correspondiente cierre ). Sin embargo, un simple conteo de paréntesis no es suficiente: la siguiente expresión contiene la misma cantidad de paréntesis de apertura y de cierre, y aun así es incorrecta.\n1 +) (3 * 5()\nLa función verificar_agrupamientos se vale de una pila para verificar que los paréntesis y corchetes se utilizan correctamente.\n\ndef verificar_agrupamientos(expr):\n    apertura = \"([\"\n    cierre = \")]\"\n\n    pila = Pila()\n\n    for caracter in expr:\n        if caracter in apertura:\n            pila.insertar(caracter)\n        elif caracter in cierre:\n            if pila.vacia: # Nada con que emparejarlo\n                return False\n\n            if cierre.index(caracter) != apertura.index(pila.extraer()): # Mismatch\n                return False\n\n    return pila.vacia\n\nLa función recorre la secuencia original de izquierda a derecha utilizando una pila pila para facilitar la verificación de los símbolos de agrupación.\nCada vez que se encuentra un símbolo de apertura, lo apilamos en pila. Y cuando se encuentra un símbolo de cierre, desapilamos un elemento de pila (si no está vacía) y verificamos que ambos símbolos formen un par válido.\nSi al llegar al final de la expresión la pila está vacía, significa que la expresión está correctamente balanceada. De lo contrario, debe haber quedado en la pila un símbolo de apertura sin su correspondiente cierre.\n\nverificar_agrupamientos(\"(3 + (4 * 5))\")\n\nTrue\n\n\n\nverificar_agrupamientos(\"[3 + (4 * 5)]\")\n\nTrue\n\n\n\nverificar_agrupamientos(\"(3 + (4 * 5)\")\n\nFalse\n\n\n\nverificar_agrupamientos(\"(3 + [(4 * 5)\")\n\nFalse",
    "crumbs": [
      "Teoría",
      "U4 - Estructuras de Datos y Algoritmos",
      "2 - Estructuras lineales"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/02_estructuras_lineales.html#colas",
    "href": "teoria/04_estructuras_y_algoritmos/02_estructuras_lineales.html#colas",
    "title": "2 - Estructuras lineales",
    "section": "Colas",
    "text": "Colas\nLa cola es otra estructura de datos fundamental, un pariente cercano de la pila. Al igual que ella, la cola es una colección ordenada de objetos. Sin embargo, los objetos se insertan y se extraen siguiendo el principio first in, first out (FIFO), es decir, el primero en entrar es el primero en salir.\nPara familiarizarnos con esta estructura, podemos imaginar una fila de personas esperando para entrar a un banco, como se muestra en la imagen:\n\n\n\n\n\nLos primeros en haber llegado son los primeros en entrar al banco, mientras que quienes llegan después se ubican al final de la cola y deben esperar a que ingresen quienes estan delante suyo para ingresar.\nEsta estructura tiene numerosas aplicaciones prácticas. En la vida real, restaurantes, tiendas, plataformas de ventas de entradas y otros procesan solicitudes siguiendo el principio FIFO. En los sistemas informáticos, como impresoras en red o servidores web, las peticiones también se atienden en orden de llegada. En todos estos casos, utilizar una cola es una forma natural y lógica de organizar las solicitudes.\n\nImplementación\nLas colas son un tipo de dato abstracto, ya que definen cómo deben comportarse, pero no cómo se implementan. Para utilizarlas en un programa necesitamos una implementación concreta.\nUna forma de hacerlo es mediante un arreglo restringido, donde solo se puede extraer el elemento del frente (índice 0) y agregar nuevos elementos al final (índice n).\n\n\n\n\n\nCuando se desea insertar un nuevo elemento en la estructura de datos, siempre se hace al final.\n\n\n\n\n\nSi luego se desea agregar otro elemento, simplemente se repite el proceso.\n\n\n\n\n\nPor el contrario, a la hora de extraer un elemento, solo se puede realizar desde el frente de la cola:\n\n\n\n\n\n\n\n\n\n\nUna implementación en Python de la cola basada en arreglos es la siguiente:\n\nclass Cola:\n    def __init__(self):\n        self._datos = []\n\n    def insertar(self, element): # enqueue\n        self._datos.append(element)\n\n    def extraer(self): # dequeue\n        if len(self._datos) &gt; 0:\n            return self._datos.pop(0)\n        return None\n\n    def leer(self):\n        if len(self._datos) &gt; 0:\n            return self._datos[0]\n        return None\n\n    @property\n    def vacia(self):\n        return len(self._datos) == 0\n    \n    def __len__(self):\n        return len(self._datos)\n\nDel mismo modo que la clase Pila, la clase Cola utiliza un arreglo interno llamado _datos para almacenar los valores. También define métodos para insertar y extraer elementos, con la diferencia de que la extracción se realiza desde el frente y no desde la parte posterior, siguiendo el principio FIFO (first in, first out), es decir, el primero en entrar es el primero en salir.\n\n\nAplicaciones\n\n\n\n\nCola de impresión\n\ncola_impresion = Cola()\ncola_impresion.insertar(\"documento1.pdf\")\ncola_impresion.insertar(\"documento2.docx\")\ncola_impresion.insertar(\"documento3.xlsx\")\n\nwhile not cola_impresion.vacia:\n    print(f\"Imprimiendo {cola_impresion.extraer()}...\")\n\ncola_impresion.vacia\n\nImprimiendo documento1.pdf...\nImprimiendo documento2.docx...\nImprimiendo documento3.xlsx...\n\n\nTrue\n\n\n\n\nAtención de llamadas 🧩\nEl siguiente programa contiene un ejemplo más realista donde se usa una cola como estructura de datos para una gestionar llamadas en espera.\ndef simular_centro_de_llamadas(tiempo_total=15):\n    cola = Cola()\n    nombres = [\"Ana\", \"Bruno\", \"Carla\", \"Damián\", \"Eva\"]\n\n    tiempo_inicial = time.time()\n\n    while time.time() - tiempo_inicial &lt; tiempo_total:\n        accion = random.random()\n        ahora = datetime.now().strftime(\"%H:%M:%S\")\n\n        # Simula la llegada de una llamada, con 50% de probabilidad\n        if accion &lt; 0.5:\n            llamada = {\"cliente\": random.choice(nombres), \"hora\": ahora}\n            cola.insertar(llamada)\n            print(f\"[{ahora}] Nueva llamada de {llamada['cliente']}\")\n            print(f\"    → Llamadas en espera: {len(cola)}\")\n        # Simula la atención de una llamada, con 40% de probabilidad\n        elif accion &lt; 0.9 and not cola.vacia:\n            llamada = cola.extraer()\n            print(f\"[{ahora}]  Atendiendo a {llamada['cliente']} (recibida a las {llamada['hora']})\")\n            print(f\"    → Quedan {len(cola)} llamadas en espera\")\n        # Caso contrario, no se hace nada\n        else:\n            print(f\"[{ahora}] Sin actividad...\")\n        \n        # Controla la velocidad de la simulación\n        time.sleep(random.uniform(1, 2))\n\n    print(\"\\nFin de la simulación.\")\n\nif __name__ == \"__main__\":\n    simular_centro_de_llamadas()\n\n\n\n\n\n\n\n\nPor qué usar estructuras de datos restringidas\nSi para implementar una pila necesitamos restringir un arreglo, ¿por qué no usamos directamente un arreglo en vez de una pila?, ¿tiene alguna ventaja usar la pila?\nLas estructuras de datos restringidas, como la pila y la cola, son importantes por varias razones.\nEn primer lugar, usar estructuras de datos restringidas ayuda a evitar errores. Por ejemplo, el algoritmo de verificación de paréntesis y corchetes solo funciona si los elementos se eliminan desde la cima. Si utilizaramos una lista de Python, podríamos cometer variados errores. En cambio, al usar una pila, que restringe las operaciones que podemos realizar, automáticamente se previenen usos incorrectos.\nEn segundo lugar, estas estructuras restringidas proporcionan un modelo mental claro para resolver ciertos problemas. La pila introduce el principio last in, first out (LIFO), “el último en entrar es el primero en salir”, que puede aplicarse para resolver una amplia variedad de problemas, como el del verificador mencionado antes.\nFinalmente, la familiaridad con la naturaleza LIFO de las pilas hace que el código sea más legible y predecible para otros desarrolladores: cuando alguien ve una pila, sabe que el proceso sigue una lógica LIFO.",
    "crumbs": [
      "Teoría",
      "U4 - Estructuras de Datos y Algoritmos",
      "2 - Estructuras lineales"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/02_estructuras_lineales.html#listas-enlazadas",
    "href": "teoria/04_estructuras_y_algoritmos/02_estructuras_lineales.html#listas-enlazadas",
    "title": "2 - Estructuras lineales",
    "section": "Listas enlazadas",
    "text": "Listas enlazadas\nEn esta sección vamos a introducir una estructura de datos llamada lista enlazada (linked list), que constituye una alternativa a las secuencias basadas en arreglos, como la lista de Python. Tanto las listas enlazadas como los arreglos mantienen los elementos en un cierto orden, pero lo hacen siguiendo distintas estrategias.\nPor un lado, un arreglo almacena los datos en una región contigua de memoria, lo que permite acceder rápidamente a cualquier elemento mediante su índice y facilita operaciones matemáticas vectorizadas. Sin embargo, este diseño puede volver poco eficientes tareas como la inserción o la eliminación de elementos.\nPor el otro, una lista enlazada se apoya en una estructura llamada nodo, que le permite distribuir los distintos elementos de la secuencia en diferentes ubicaciones de la memoria y modificarlos o reorganizarlos con mayor flexibilidad.\n\nEl nodo\nEn una lista enlazada, cada nodo representa un elemento de la lista. Aunque los nodos no se almacenen en posiciones contiguas de memoria, la computadora puede reconstruir el orden de la secuencia porque cada nodo no solo guarda un valor, sino que también una referencia al siguiente. Estos enlaces entre nodos son los que dan nombre a esta estructura de datos: lista enlazada.\n\n\n\n\n\nPara representar estos nodos podemos crear una clase Nodo, que define objetos que contienen un atributo para el valor y otro para la referencia al siguiente nodo de la lista.\n\nclass Nodo:\n    def __init__(self, valor):\n        self.valor = valor\n        self.siguiente = None\n    \n    def __repr__(self):\n        return f\"Nodo({self.valor})\"\n\nNodo(75)\n\nNodo(75)\n\n\nPodemos instanciar múltiples nodos y enlazarlos entre sí, para luego recorrerlos de la forma en que lo haría una lista enlazada.\n\nnodo1 = Nodo(1)\nnodo2 = Nodo(2)\nnodo3 = Nodo(3)\nnodo4 = Nodo(4)\n\n# Enlazar nodos\nnodo1.siguiente = nodo2\nnodo2.siguiente = nodo3\nnodo3.siguiente = nodo4  \n\n# Recorrer e imprimir la lista enlazada\nactual = nodo1\nwhile actual:\n    print(actual, end=\" -&gt; \")\n    actual = actual.siguiente\nprint(\"None\")\n\nNodo(1) -&gt; Nodo(2) -&gt; Nodo(3) -&gt; Nodo(4) -&gt; None\n\n\nComo se puede observar, aunque los nodos sean independientes y puedan almacenarse en cualquier lugar de la memoria, los enlaces entre ellos permiten construir una secuencia ordenada.\n\n\nImplementación básica\nLo único que se necesita para implementar una lista enlazada a partir de un conjunto de nodos es la dirección de memoria donde comienza la lista enlazada, es decir, donde se ubica el primer nodo. Como cada nodo guarda un enlace al nodo siguiente, basta con seguir esos enlaces uno a uno para reconstruir toda la secuencia.\n\nclass ListaEnlazada:\n    def __init__(self, primer_nodo=None):\n        self.primer_nodo = primer_nodo\n\nlista = ListaEnlazada(nodo1)\n\nEl diagrama de abajo representa la lista enlazada que acabamos de crear. Cada nodo contiene un valor y una referencia al siguiente nodo en la secuencia. Estas referencias son los enlaces que conectan los nodos y dan forma a la estructura.\n\n\n\n\n\nEl segundo diagrama muestra cómo se vería esa misma lista en la memoria. Los valores resaltados en rojo representan los nodos, que, como puede observarse, se encuentran dispersos en distintas ubicaciones.\n\n\n\n\n\n\n\nLectura\nDada una dirección de memoria, la lectura es una operación de tiempo constante, \\(O(1)\\). No importa en qué lugar de la memoria se encuentre esa dirección, la lectura siempre tarda lo mismo.\nCuando trabajamos con un arreglo contiguo, vimos que podíamos determinar la dirección de cualquier elemento a partir de la dirección base y el índice solicitado. En cambio, en una lista enlazada, los nodos no están almacenados contiguamente en memoria, por lo que ya no podemos usar esa estrategia.\nSupongamos que queremos leer el valor en el índice 3 de una lista enlazada. Nuestro programa solo conoce la dirección del primer nodo de la secuencia. Para ubicar el nodo en el índice 3, debe recorrer la lista pasando por todos los nodos intermedios, saltando de uno a otro a través de sus enlaces, hasta llegar al nodo correspondiente y devolver su valor.\nGráficamente, el proceso se ve de la siguiente manera:\n\n\n\n\n\nSi tenemos una lista enlazada de \\(N\\) elementos y queremos leer el elemento en la última posición, la operación nos llevará \\(N\\) pasos. Por lo tanto, a diferencia de la lectura en un arreglo contiguo, que es de orden \\(O(1)\\), la lectura en una lista enlazada es de orden \\(O(N)\\).\nPero no nos desmotivemos, no son todas pálidas con esta estructura de datos. Así como presenta esta limitación, pronto descubriremos también sus puntos fuertes.\nMientras tanto, concluimos la sección con una implementación en Python del método de lectura.\n    def leer(self, indice):\n1        nodo_actual = self.primer_nodo\n        indice_actual = 0\n\n2        while indice_actual &lt; indice:\n3            nodo_actual = nodo_actual.siguiente\n            indice_actual += 1\n\n4            if nodo_actual is None:\n                return None\n\n5        return nodo_actual.valor\n\n1\n\nSe comienza a recorrer la lista desde el primer nodo, que se encuentra en el índice 0.\n\n2\n\nSe recorre la lista enlazada hasta llegar al índice deseado.\n\n3\n\nEn cada paso, se avanza nodo a nodo, accediendo al siguiente e incrementando el valor del índice.\n\n4\n\nSi en algún momento el nodo obtenido es None, significa que la lista no tiene tantos elementos como el índice solicitado. En ese caso se devuelve None, aunque también podría lanzarse un IndexError.\n\n5\n\nEn este punto se sabe que se ha llegado al nodo del índice solicitado, y se devuelve su valor.\n\n\n\n\nBúsqueda\nYa sabemos que la búsqueda es una operación estrechamente relacionada con la lectura: en lugar de tomar un índice y devolver un valor, toma un valor y devuelve su índice (si es que el valor se encuentra en la secuencia).\nSi trabajamos con un arreglo contiguo, la búsqueda lineal es de orden \\(O(N)\\). En una lista enlazada, la búsqueda también es de orden \\(O(N)\\), ya que el proceso es similar al de la lectura.\nLa búsqueda se comienza explorando el primer nodo, con un acumulador de índice inicializado en 0. En cada paso, se compara el valor del nodo con el valor buscado:\n\nSi son distintos, se avanza al siguiente nodo y se incrementa el acumulador.\nSi son iguales, se devuelve el valor del índice.\n\nSi no existe un siguiente nodo, es decir, si se llega al final de la lista, significa que el valor buscado no se encuentra en la secuencia.\nEl proceso se puede representar de la siguiente manera:\n\n\n\n\n\nUna implementación para el método de búsqueda en nuestra clase es la siguiente:\n    def buscar(self, valor):\n1        nodo_actual = self.primer_nodo\n        indice_actual = 0\n\n2        while True:\n3            if nodo_actual.valor == valor:\n                return indice_actual\n            nodo_actual = nodo_actual.siguiente\n\n4            if nodo_actual is None:\n                break\n            indice_actual += 1\n\n5        return None\n\n1\n\nSe inicia el recorrido desde el primer nodo de la lista, comenzando con el índice 0.\n\n2\n\nSe itera hasta que el bloque ejecute un return o un break\n\n3\n\nEn cada iteración, se compara el valor almacenado en el nodo actual con el valor buscado. Si el valor coincide, se devuelve el índice correspondiente y la búsqueda termina. Si no coincide, se avanza al siguiente nodo.\n\n4\n\nSi el siguiente nodo es None, significa que se llegó al final de la lista sin encontrar el valor, se termina el bucle. Caso contrario, se incrementa el índice en 1 y se ejecuta el bucle desde el iniciio.\n\n5\n\nEn este punto se sabe que el valor no se encuentra en la lista y se devuelve None. Podría lanzarse un ValueError.\n\n\n\n\nInserción\nHasta ahora, el desempeño de las listas enlazadas es igual o peor que el de un arreglo contiguo. Son menos eficientes para leer e igual de eficientes para buscar.\nSin embargo, cuando consideramos la inserción, nuestra percepción sobre esta estructura comienza a cambiar. En un arreglo contiguo, el peor escenario ocurre al insertar al principio, ya que es necesario desplazar todos los elementos una celda a la derecha. En cambio, en una lista enlazada, insertar un elemento al inicio requiere un solo paso, por lo que es una operación de orden \\(O(1)\\).\nPara insertar un elemento al inicio de una lista enlazada, solo es necesario crear un nuevo nodo y enlazarlo con el nodo que era el primero antes de la inserción. Además, debemos actualizar la referencia al primer nodo dentro del objeto de tipo ListaEnlazada para que apunte al nuevo nodo.\n\n\n\n\n\nSi se desea insertar un elemento en una posición interna de la lista, en teoría la operación de inserción en sí misma lleva solo un paso, ya que no es necesario mover elementos, solo se requiere actualizar los enlaces entre nodos.\nEl siguiente diagrama muestra la inserción del valor 2.5 entre el 2 y el 3 en nuestra lista enlazada. Se crea un nuevo nodo que apunta a la ubicación del tercer elemento y se modifica el enlace del segundo elemento para que apunte al nuevo nodo.\n\n\n\n\n\nSin embargo, antes de poder realizar este cambio de enlaces, es necesario encontrar los nodos involucrados, lo que requiere recorrer la lista desde el inicio. Si queremos insertar el valor 2.5 en el índice 2, es necesario realizar la búsqueda que describe el diagrama debajo.\n\n\n\n\n\nUna vez identificados los nodos involucrados, se actualizan sus enlaces. La inserción no requiere mover valores en memoria, pero sí es necesario recorrer la lista desde el principio para los nodos que deben ser actualizados.\nLuego de la inserción, los elementos de la lista quedan distribuidos en memoria como se muestra en el siguiente diagrama:\n\n\n\n\n\nFinalmente, el peor de los escenarios se da cuando se desea insertar un elemento al final de la lista. Para ello hay que atravesar \\(N\\) elementos hasta encontrar el último. Una vez allí, se actualiza su enlace para que apunte a la dirección del nodo creado para el nuevo valor.\n\n\n\n\n\nEl método de inserción para nuestra clase ListaEnlazada es el siguiente:\ndef insertar(self, indice, valor):\n1    nodo_nuevo = Nodo(valor)\n\n2    if indice == 0:\n        nodo_nuevo.siguiente = self.primer_nodo\n        self.primer_nodo = nodo_nuevo\n        return None\n\n3    nodo_actual = self.primer_nodo\n    indice_actual = 0\n\n4    while indice_actual &lt; (indice - 1):\n        nodo_actual = nodo_actual.siguiente\n        indice_actual += 1\n        nodo_nuevo.siguiente = nodo_actual.siguiente\n        nodo_actual.siguiente = nodo_nuevo\n\n1\n\nSe crea un nuevo nodo con el valor recibido.\n\n2\n\nSi el índice es 0, significa que el nuevo nodo debe insertarse al inicio de la lista. En ese caso, se enlaza el nuevo nodo al antiguo primer nodo y el nuevo nodo se convierte en el primer nodo de la lista\n\n3\n\nSi no se trata del primer nodo, se inicia un recorrido desde el comienzo de la lista, con el índice actual igual a 0.\n\n4\n\nSe avanza nodo a nodo hasta llegar al nodo anterior a la posición donde se desea insertar. Una vez allí, se ajustan las referencias: el nuevo nodo apunta al siguiente del nodo actual, y el nodo actual pasa a apuntar al nuevo nodo.\n\n\n\n\nEliminación\nEn una lista enlazada, la eliminación tiene mucho en común con la inserción. Primero, eliminar un elemento no requiere mover valores en memoria, sino simplemente actualizar los enlaces entre nodos. Segundo, la eliminación al inicio de la lista es muy eficiente; basta con hacer que primer_nodo apunte al segundo nodo. Por último, cuando la eliminación no ocurre al principio, es necesario recorrer la lista hasta encontrar los nodos cuyos enlaces deben modificarse.\nEl siguiente diagrama muestra la eliminación de un nodo intermedio en la secuencia. Para realizarla se cambia el enlace del nodo anterior para que apunte al nodo siguiente. Opcionalmente, puede eliminarse también el enlace del nodo que fue removido.\n\n\n\n\n\nEn Python, tenemos:\ndef eliminar(self, indice):\n1    if indice == 0:\n        self.primer_nodo = self.primer_nodo.siguiente\n        return None\n\n2    nodo_actual = self.primer_nodo\n    indice_actual = 0\n\n3    while indice_actual &lt; (indice - 1):\n        nodo_actual = nodo_actual.siguiente\n        indice_actual += 1\n\n4    nodo_siguiente_al_eliminado = nodo_actual.siguiente.siguiente\n    nodo_actual.siguiente = nodo_siguiente_al_eliminado\n\n1\n\nSi el índice es 0, significa que se debe eliminar el primer nodo de la lista. En ese caso, solo es necesario actualizar la referencia primer_nodo para que apunte al segundo nodo, descartando así el primero.\n\n2\n\nSi no se trata del primer nodo, se inicia el recorrido desde el comienzo de la lista, con el índice actual igual a 0.\n\n3\n\nSe avanza nodo a nodo hasta llegar al nodo anterior al que se desea eliminar.\n\n4\n\nUna vez allí, se actualizan las referencias para que el nodo actual apunte al nodo siguiente del que será eliminado, de modo que el nodo en la posición indicada quede desconectado de la lista.\n\n\n\n\nEnlazando las partes\nSi juntamos todos los métodos definidos, podemos reimplementar nuestra lista enlazada junto a todas las funcionalidades necesarias.\n\nclass ListaEnlazada:\n    def __init__(self, primer_nodo=None):\n        self.primer_nodo = primer_nodo\n\n    def leer(self, indice):\n        nodo_actual = self.primer_nodo\n        indice_actual = 0\n\n        while indice_actual &lt; indice:\n            nodo_actual = nodo_actual.siguiente\n            indice_actual += 1\n\n            if nodo_actual is None:\n                return None\n\n        return nodo_actual.valor\n\n    def buscar(self, valor):\n        nodo_actual = self.primer_nodo\n        indice_actual = 0\n\n        while True:\n            if nodo_actual.valor == valor:\n                return indice_actual\n\n            nodo_actual = nodo_actual.siguiente\n            if nodo_actual is None:\n                break\n            indice_actual += 1\n\n        return None\n\n    def insertar(self, indice, valor):\n        nodo_nuevo = Nodo(valor)\n\n        if indice == 0:\n            nodo_nuevo.siguiente = self.primer_nodo\n            self.primer_nodo = nodo_nuevo\n            return None\n\n        nodo_actual = self.primer_nodo\n        indice_actual = 0\n\n        while indice_actual &lt; (indice - 1):\n            nodo_actual = nodo_actual.siguiente\n            indice_actual += 1\n            nodo_nuevo.siguiente = nodo_actual.siguiente\n            nodo_actual.siguiente = nodo_nuevo\n\n    def eliminar(self, indice):\n        if indice == 0:\n            self.primer_nodo = self.primer_nodo.next_node\n            return None\n\n        nodo_actual = self.primer_nodo\n        indice_actual = 0\n\n        while indice_actual &lt; (indice - 1):\n            nodo_actual = nodo_actual.siguiente\n            indice_actual += 1\n\n        nodo_siguiente_al_eliminado = nodo_actual.siguiente.siguiente\n        nodo_actual.siguiente = nodo_siguiente_al_eliminado\n\n\n\nAnálisis de la eficiencia\nLa siguiente tabla resume la eficiencia de los arreglos y las listas enlazadas para realizar las operaciones analizadas:\n\n\n\n\n\n\n\n\nOperación\nArreglo\nLista enlazada\n\n\n\n\nLectura\n\\(O(1)\\)\n\\(O(N)\\)\n\n\nBúsqueda\n\\(O(N)\\)\n\\(O(N)\\)\n\n\nInserción\n\\(O(N)\\) (\\(O(1)\\) al final)\n\\(O(N)\\) (\\(O(1)\\) al inicio)\n\n\nEliminación\n\\(O(N)\\) (\\(O(1)\\) al final)\n\\(O(N)\\) (\\(O(1)\\) al inicio)\n\n\n\nA simple vista, las listas enlazadas no parecen ofrecer grandes ventajas en cuanto a complejidad temporal. Tienen un rendimiento similar al de los arreglos en búsqueda, inserción y eliminación, y son más lentas para la lectura. Entonces, ¿por qué las usariamos?\nLa clave está en que los pasos de inserción y eliminación en sí mismos son operaciones de orden \\(O(1)\\). Es cierto que esto solo ocurre cuando ya conocemos el nodo correcto, por ejemplo, al insertar o eliminar al comienzo, pero hay situaciones en las que ese nodo ya está accesible por otro motivo dentro del programa.\nPor ejemplo, si tenemos que eliminar elementos erróneos de una secuencia, tendremos que recorrerla completa tanto si usamos un arreglo como una lista enlazada. La diferencia está en el costo de cada eliminación. En una lista enlazada, basta con actualizar los enlaces, sin mover valores en memoria. En cambio, en un arreglo, cada vez que se elimina un elemento es necesario desplazar todos los elementos posteriores, lo que hace el proceso más costoso.",
    "crumbs": [
      "Teoría",
      "U4 - Estructuras de Datos y Algoritmos",
      "2 - Estructuras lineales"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/02_estructuras_lineales.html#listas-doblemente-enlazadas",
    "href": "teoria/04_estructuras_y_algoritmos/02_estructuras_lineales.html#listas-doblemente-enlazadas",
    "title": "2 - Estructuras lineales",
    "section": "Listas doblemente enlazadas",
    "text": "Listas doblemente enlazadas\nExisten varios tipos de listas enlazadas. La que vimos hasta ahora es la lista enlazada simple, o clásica, donde cada nodo tiene una referencia al nodo siguiente.\nOtra variante es la lista doblemente enlazada, en la que cada nodo mantiene dos referencias: una al nodo anterior y otra al siguiente. En este caso, el primer nodo tiene la referencia anterior vacía, y el último nodo tiene la referencia siguiente vacía. A su vez, la clase mantiene referencias al primer y al último nodo de la lista.\n\nclass Nodo:\n    def __init__(self, valor):\n        self.valor = valor\n        self.anterior = None\n        self.siguiente = None\n\n\nclass ListaDoblementeEnlazada:\n    def __init__(self, primer_nodo=None, ultimo_nodo=None):\n        self.primer_nodo = primer_nodo\n        self.ultimo_nodo = ultimo_nodo\n\nComo una lista doblemente enlazada siempre conoce la posición de su primer y último nodo, puede acceder a cualquiera de ellos en un solo paso. Además, así como en una lista enlazada simple podemos leer, insertar o eliminar al inicio en tiempo constante, en una lista doblemente enlazada podemos hacerlo también al final, con la misma eficiencia.\n\n\n\n\n\n\nAplicaciones\n\nPilas como una lista enlazada\nLas pilas también pueden implementarse de forma muy eficiente utilizando una lista enlazada. En este caso, basta con mantener una referencia al primer nodo de la lista, que representará la parte superior de la pila. Tanto la inserción de un nuevo elemento, como la eliminación del elemento superior, pueden realizarse en tiempo constante, \\(O(1)\\).\nEn principio, esta implementación no ofrece ventajas significativas respecto de la versión basada en un arreglo, que también permite inserción y eliminación al final en tiempo constante. Sin embargo, cuando el arreglo alcanza su capacidad máxima, es necesario reservar un nuevo bloque contiguo de memoria y copiar todos los elementos, lo que implica un costo adicional. En cambio, la versión basada en una lista enlazada no requiere realocación, por lo que resulta más eficiente en escenarios donde el tamaño de la pila puede crecer considerablemente.\n\n\nColas con una lista doblemente enlazada\nSi mantenemos referencias tanto al primer como al último nodo, una lista doblemente enlazada permite acceder de forma inmediata a ambos extremos de la secuencia. Además, insertar o eliminar elementos en cualquiera de ellos es una operación de orden \\(O(1)\\), lo que la hace una estructura muy adecuada para implementar una cola.\nEn comparación, cuando usamos un arreglo para almacenar los elementos, agregar un nuevo valor al final tiene un costo \\(O(1)\\), pero extraer desde el principio requiere mover los \\(N - 1\\) elementos restantes, lo que implica un costo \\(O(N)\\).\nPor otro lado, si modificamos nuestra implementación de la lista simplemente enlazada para que mantenga una referencia al último nodo, también podríamos implementar una cola con inserción y extracción en tiempo constante (\\(O(1)\\)).",
    "crumbs": [
      "Teoría",
      "U4 - Estructuras de Datos y Algoritmos",
      "2 - Estructuras lineales"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html",
    "href": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html",
    "title": "3 - Funciones de orden superior",
    "section": "",
    "text": "Las funciones de orden superior son una herramienta muy importante en la programación funcional. A lo largo de esta unidad, trabajaremos con las siguientes variedades de funciones de orden superior:\n\nFunciones que aceptan funciones como argumentos.\nFunciones que devuelven una función como resultado.\nFunciones que aceptan funciones como argumentos y devuelven una función como resultado.\n\nEn este capítulo comenzamos enfocándonos en las funciones de orden superior más elementales: map, filter y reduce; todas ellas reciben funciones como argumentos. Luego, aprenderemos sobre las comprehensions, que constituyen la alternativa moderna y Pythonica a las funciones mencionadas anteriormente. Finalmente, trabajaremos con funciones que devuelven funciones cuando exploremos evaluación parcial de funciones y el uso de decoradores.",
    "crumbs": [
      "Teoría",
      "U2 - Programación Funcional",
      "3 - Funciones de orden superior"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#introducción",
    "href": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#introducción",
    "title": "3 - Funciones de orden superior",
    "section": "",
    "text": "Las funciones de orden superior son una herramienta muy importante en la programación funcional. A lo largo de esta unidad, trabajaremos con las siguientes variedades de funciones de orden superior:\n\nFunciones que aceptan funciones como argumentos.\nFunciones que devuelven una función como resultado.\nFunciones que aceptan funciones como argumentos y devuelven una función como resultado.\n\nEn este capítulo comenzamos enfocándonos en las funciones de orden superior más elementales: map, filter y reduce; todas ellas reciben funciones como argumentos. Luego, aprenderemos sobre las comprehensions, que constituyen la alternativa moderna y Pythonica a las funciones mencionadas anteriormente. Finalmente, trabajaremos con funciones que devuelven funciones cuando exploremos evaluación parcial de funciones y el uso de decoradores.",
    "crumbs": [
      "Teoría",
      "U2 - Programación Funcional",
      "3 - Funciones de orden superior"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#pilares-fundamentales",
    "href": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#pilares-fundamentales",
    "title": "3 - Funciones de orden superior",
    "section": "Pilares fundamentales",
    "text": "Pilares fundamentales\nLas funciones map, filter y reduce son funciones de orden superior fundamentales en la programación funcional. Actúan como primitivas básicas para procesar y transformar secuencias, y muchas otras operaciones funcionales pueden construirse a partir de ellas o expresarse en términos de estas.\nLas primeras dos, map y filter, están disponibles por defecto en nuestra sesión de Python (ya que son funciones built-in), mientras que a reduce la tenemos que importar desde el módulo estándar functools.\n\nMap\nSupongamos que tenemos una secuencia de palabras y queremos invertir el orden de los caracteres de cada una. Para ello, vamos a rebanadar cada cadena desde el principio al final usando un paso de -1. Por ejemplo:\n\n\"cosa\"[::-1]\n\n'asoc'\n\n\nSi quisiéramos obtener una lista con las palabras invertidas, podríamos crear una nueva lista, recorrer la original con un bucle for, invertir cada palabra y guardarla en la lista nueva.\n\npalabras = [\"hola\", \"mate\", \"somos\",\" libro\", \"conocer\", \"anilina\", \"programa\"]\npalabras_invertidas = []\n\nfor palabra in palabras:\n    palabras_invertidas.append(palabra[::-1])\n\nprint(\"Palabras originales:\", palabras, \"\\n\", sep=\"\\n\")\nprint(\"Palabras invertidas:\", palabras_invertidas, sep=\"\\n\")\n\nPalabras originales:\n['hola', 'mate', 'somos', ' libro', 'conocer', 'anilina', 'programa']\n\n\nPalabras invertidas:\n['aloh', 'etam', 'somos', 'orbil ', 'reconoc', 'anilina', 'amargorp']\n\n\nLa alternativa funcional consiste en utilizar map para aplicar una función a cada palabra de la secuencia. En este caso, aplicamos la función invertir, que invierte los caracteres de una palabra, a cada elemento de la lista palabras.\n\ndef invertir(x):\n    return x[::-1]\n\nlist(map(invertir, palabras))\n\n['aloh', 'etam', 'somos', 'orbil ', 'reconoc', 'anilina', 'amargorp']\n\n\nAsí, se obtiene una nueva lista con las palabras invertidas, sin necesidad de iterar manualmente con un bucle for.\nSi quisiéramos que el programa fuese aún más conciso, podríamos usar una función anónima en vez de una función regular:\n\nlist(map(lambda x: x[::-1], palabras))\n\n['aloh', 'etam', 'somos', 'orbil ', 'reconoc', 'anilina', 'amargorp']\n\n\n\n\n\n\n\n\nEl objeto map 🔍\n\n\n\nEn el ejemplo anterior usamos list para convertir el resultado de map en una lista. Este paso, que puede parecer innecesario, es fundamental si queremos obtener una lista como resultado final. De lo contrario, la llamada a map devuelve un objeto de tipo map.\nmap(lambda x: x[::-1], palabras)\n&lt;map object at 0x7fd2fc1ad360&gt;\nEste objeto, perezoso e iterable, puede recorrerse o convertirse en otras colecciones como listas, tuplas o conjuntos:\nlist(map(lambda x: x[::-1], palabras))\n['aloh', 'etam', 'somos', 'orbil ', 'reconoc', 'anilina', 'amargorp']\n\n\n\nmap con datos complejos\nEn el ejemplo anterior se usó map sobre una secuencia simple de cadenas de texto. Sin embargo, eso no implica que su uso se limite a casos sencillos.\nSupongamos ahora que tenemos una lista anidada de números, es decir, una lista que contiene otras listas con valores numéricos:\n\nventas = [\n    [22.5, 9.3, 11.0],\n    [5.4, 22.5],\n    [3.0, 3.0, 12.9, 7.5],\n]\n\nSi queremos calcular el total de cada sublista, podemos combinar map con la función sum. Esto aplica sum a cada elemento de la lista ventas, generando como resultado una nueva lista con los totales de cada sublista.\n\nlist(map(sum, ventas))\n\n[42.8, 27.9, 26.4]\n\n\nDe manera similar, se puede obtener el mínimo, el máximo, la media u otra medida de interés aplicando la función correspondiente a cada sublista.\nUsando una combinación más compleja de maps y expresiones lambda, se puede determinar cuáles sublistas de ventas contienen al menos un valor mayor a 20.\n\nlist(\n    map(\n        lambda sublista: any(map(lambda x: x &gt; 20,  sublista)),\n        ventas\n    )\n)\n\n[True, True, False]\n\n\nComo puede observarse, un programa que utiliza map junto con expresiones lambda puede volverse difícil de leer y comprender rápidamente, especialmente a medida que la lógica se vuelve más compleja.\nPara finalizar este listado de ejemplos, observemos uno donde se crea un diccionario a partir del map, en vez de una lista.\nSe cuenta con una lista de diccionarios. Cada diccionario contiene el nombre y las calificaciones de una persona. Nuestro objetivo es obtener un nuevo diccionario que tenga por claves al nombre de la persona, y por valor a la nota promedio.\n\nnotas = [\n    {\n        \"nombre\": \"Mariano\",\n        \"notas\": [6, 9, 9, 8]\n    },\n    {\n        \"nombre\": \"Daniela\",\n        \"notas\": [6, 7, 7, 8]\n    },\n    {\n        \"nombre\": \"Sofía\",\n        \"notas\": [8, 6, 9, 8]\n    },\n]\n\nSin utilizar un enfoque funcional, una solución posible es la siguiente:\n\ndef media(x):\n    return sum(x) / len(x)\n\npromedios = {}\n\nfor datum in notas:\n    promedios[datum[\"nombre\"]] = media(datum[\"notas\"])\n\npromedios\n\n{'Mariano': 8.0, 'Daniela': 7.0, 'Sofía': 7.75}\n\n\nEn cambio, utilizando map:\n\ndict(map(lambda datum: (datum[\"nombre\"], media(datum[\"notas\"])), notas))\n\n{'Mariano': 8.0, 'Daniela': 7.0, 'Sofía': 7.75}\n\n\nLa clave está en notar que la expresión lambda devuelve una tupla de dos elementos, donde el primero es el nombre y el segundo, la nota promedio. A partir de estos pares (str, float), dict puede construir directamente un diccionario con los str en las claves y los float en los valores.\n\n\nmap con múltiples iterabes\nHasta ahora hemos utilizado map con funciones que se aplican sobre los elementos de un único iterable. Sin embargo, map también acepta múltiples iterables y los recorre en paralelo, lo que la convierte en una función variádica. De este modo, se puede usar map para aplicar funciones que toman más de un argumento.\nSupongamos que queremos redondear un listado de números utilizando diferentes niveles de precisión. Para redondear un único número podemos usar directamente round:\n\nround(29.12951138, 4)\n\n29.1295\n\n\nSi quisiéramos redonear múltiples números en una lista, usando el mismo nivel de precisión, podemos usar map y round:\n\nnumeros = [\n    30.60726375,\n    78.12297368,\n    61.94972186,\n    68.78842783,\n    55.60016942,\n    94.9760221,\n    90.41151716,\n    38.72727347,\n    21.30193307,\n    66.39407577\n]\nlist(map(lambda x: round(x, 3), numeros))\n\n[30.607, 78.123, 61.95, 68.788, 55.6, 94.976, 90.412, 38.727, 21.302, 66.394]\n\n\n¿Y si quisiéramos aplicar diferentes niveles de precisión a cada número? Para ello, también podemos usar map. Definimos una función que reciba dos argumentos y luego iteramos en paralelo sobre dos iterables: uno con los números y otro con las precisiones correspondientes.\n\nprecisiones = [2, 2, 3, 3, 4, 4, 5, 5, 2, 2]\nlist(map(lambda x, y: round(x, y), numeros, precisiones))\n\n[30.61, 78.12, 61.95, 68.788, 55.6002, 94.976, 90.41152, 38.72727, 21.3, 66.39]\n\n\n\n\n\n\n\n\n¿Qué pasa si un iterable es más corto que el otro? 🤔\n\n\n\nCuando se recorren múltiples iterables con map, la iteración se detiene tan pronto como se agota el iterable más corto. Por ejemplo, si tenemos 10 números pero solo 5 precisiones, map aplicará la función únicamente a los primeros 5 pares de elementos:\nprecisiones = [1, 2, 3, 4, 5]\nlist(map(lambda x, y: round(x, y), numeros, precisiones))\n[30.6, 78.12, 61.95, 68.7884, 55.60017]\n\n\n\n\n\nFilter\nfilter se utiliza para seleccionar —o, más precisamente, filtrar— elementos de un iterable según el resultado de aplicar una función. A diferencia de map, la función usada por filter se aplica sobre los elementos de un solo iterable y debe devolver un valor booleano. El resultado es un nuevo iterable que contiene únicamente los elementos para los que la función retorna True.\nComo ejemplo del uso de filter, vamos a seleccionar las notas menores a 6 a partir de una lista de calificaciones.\n\nnotas = [6, 9, 6, 5, 7, 4, 5, 8, 3, 10, 9, 4, 7, 8]\nlist(filter(lambda x: x &lt; 6, notas))\n\n[5, 4, 5, 3, 4]\n\n\nDe este modo, resulta sencillo calcular el promedio de las notas de aquellos que no aprobaron:\n\nmedia(list(filter(lambda x: x &lt; 6, notas)))\n\n4.2\n\n\nRetomando el ejemplo del listado de palabras que se querían invertir, se podría usar filter para seleccionar solo aquellas palabras que sean palíndromos, es decir, capicúa.\n\npalabras = [\"hola\", \"mate\", \"somos\",\" libro\", \"conocer\", \"anilina\", \"programa\"]\ncapicuas = list(filter(lambda p: p[::-1] == p, palabras))\ncapicuas\n\n['somos', 'anilina']\n\n\nNaturalmente, filter también puede utilizarse para filtrar objetos más complejos. Por ejemplo, si tenemos una lista de diccionarios con información de estudiantes (nombre, ciudad de origen, edad y fecha de inscripción), podemos usar filter para seleccionar aquellos que cumplan una o más condiciones. En ese caso, el valor booleano que devuelve la función se construye combinando condiciones mediante operadores lógicos como and.\n\ndatos = [\n    {\"nombre\": \"Agustina\", \"ciudad\": \"Casilda\", \"edad\": 18, \"inscripcion\": 2025},\n    {\"nombre\": \"Emiliano\", \"ciudad\": \"Rosario\", \"edad\": 21, \"inscripcion\": 2024},\n    {\"nombre\": \"David\", \"ciudad\": \"Pergamino\", \"edad\": 19, \"inscripcion\": 2024},\n    {\"nombre\": \"Julieta\", \"ciudad\": \"Rosario\", \"edad\": 19, \"inscripcion\": 2025},\n    {\"nombre\": \"Victoria\", \"ciudad\": \"Chañar Ladeado\", \"edad\": 18, \"inscripcion\": 2025},\n    {\"nombre\": \"Fernando\", \"ciudad\": \"Rosario\", \"edad\": 20, \"inscripcion\": 2024},\n    {\"nombre\": \"Mateo\", \"ciudad\": \"Pérez\", \"edad\": 23, \"inscripcion\": 2025},\n    {\"nombre\": \"Lucía\", \"ciudad\": \"Rosario\", \"edad\": 22, \"inscripcion\": 2022},\n    {\"nombre\": \"Joaquín\", \"ciudad\": \"Casilda\", \"edad\": 19, \"inscripcion\": 2025},\n    {\"nombre\": \"Micaela\", \"ciudad\": \"Rosario\", \"edad\": 18, \"inscripcion\": 2024},\n]\n\nlist(filter(lambda x: x[\"ciudad\"] == \"Rosario\" and x[\"inscripcion\"] == 2025, datos))\n\n[{'nombre': 'Julieta', 'ciudad': 'Rosario', 'edad': 19, 'inscripcion': 2025}]\n\n\n\n\nReduce\nLa función reduce permite reducir una secuencia a un único valor aplicando de forma sucesiva una función de dos argumentos sobre sus elementos.\nPara utilizarla, es necesario importarla desde el módulo estándar functools:\n\nfrom functools import reduce\n\nreduce aplica la función acumulando resultados de a pares, desde el primer elemento hasta el último. Por ejemplo:\nreduce(lambda x, y: x + y, [1, 2, 3, 4, 5])\nequivale a:\n((((1 + 2) + 3) + 4) + 5)\nEn este caso, es simplemente una forma más rebuscada de escribir sum([1, 2, 3, 4, 5]) en Python.\nPara entender cómo funciona el proceso de acumulación en reduce, podemos definir una función que imprima los valores de sus argumentos en cada paso:\n\ndef sumar(x, y):\n    print(f\"x={x}, y={y}\")\n    return x + y\n\nreduce(sumar, [1, 2, 3, 4, 5])\n\nx=1, y=2\nx=3, y=3\nx=6, y=4\nx=10, y=5\n\n\n15\n\n\nEn la primera llamada, x e y son los dos primeros elementos de la secuencia. En la segunda, x es el resultado de la llamada anterior, e y es el siguiente elemento de la secuencia. Este proceso continúa hasta que se recorre toda la lista. En resumen:\n\nx representa el valor acumulado hasta el momento, e\ny es el nuevo elemento a combinar.\n\nAsí, reduce va aplicando la función paso a paso, acumulando resultados hasta obtener un único valor final.\nMuchas operaciones comunes, como sumas, productos, mínimos o máximos, pueden expresarse mediante reducciones. Por ejemplo, es posible calcular el factorial de un número utilizando una reduce:\n\ndef factorial(n):\n    return reduce(lambda x, y: x * y, range(1, n + 1))\n\nfactorial(5)\n\n120\n\n\nLa reducción mediante la multiplicación de dos números, aplicada a la secuencia del 1 al n, da como resultado el factorial de n.\nFinalmente, podemos ver que combinando una función que devuelve el mayor de dos números y una reducción, es posible obtener el máximo de una secuencia.\n\ndef mayor(x, y):\n    if x &gt; y:\n        return x\n    return y\n\nreduce(mayor, [23, 49, 6, 32, 101, 9])\n\n101\n\n\nVale la pena mencionar que reduce acepta un tercer argumento opcional, que especifica el valor inicial de la reducción. Este valor se utiliza como punto de partida antes de procesar los elementos del iterable.\n\ndef sumar(x, y):\n    print(f\"x={x}, y={y}\")\n    return x + y\n\nreduce(sumar, [1, 2, 3, 4, 5], 20)\n\nx=20, y=1\nx=21, y=2\nx=23, y=3\nx=26, y=4\nx=30, y=5\n\n\n35\n\n\n\n\n\n\n\n\nExpresiones condicionales 🔀😱\n\n\n\nLa reducción anterior puede expresarse de forma más concisa utilizando expresiones condicionales:\nreduce(lambda x, y: x if x &gt; y else y, [23, 49, 6, 32, 101, 9])\nEstas expresiones permiten simplificar asignaciones condicionales. Por ejemplo, el siguiente bloque:\nif x &gt; y:\n    valor = x\nelse:\n    valor = y\npuede escribirse de manera más compacta así:\nvalor = x if x &gt; y else y\nEn términos generales, la sintaxis es:\n&lt;valor_si_verdadero&gt; if &lt;condición&gt; else &lt;valor_si_falso&gt;\n\n\n\n\nResumen\nEl siguiente bloque de código resume el funcionamiento de map, filter y reduce.\n\nnumeros = [1, 2, 3, 4, 5]\n\n# Map: Aplicar una función a cada elemento de un iterable\ncuadrados = list(map(lambda x: x**2, numeros))\nprint(\"Map [cuadrados]:\", cuadrados)\n\n# Filter: Devuelve el subconjunto de elementos para los que la función devuelve True\npares = list(filter(lambda x: x % 2 == 0, numeros))\nprint(\"Filter [pares]:\", pares)\n\n# Reduce: Aplica una función de dos argumentos de manera acumulativa a los elementos de una secuencia\nproducto = reduce(lambda x, y: x * y, numeros)\nprint(\"Reduce [producto]:\", producto)\n\nMap [cuadrados]: [1, 4, 9, 16, 25]\nFilter [pares]: [2, 4]\nReduce [producto]: 120\n\n\n\nMap y filter como casos particulares de reduce 😱\nPor otro lado, algo menos evidente es que tanto map como filter pueden verse como casos particulares de reduce.\nEsta aplicación de map:\n\nlist(map(lambda x: x * 2, range(10)))\n\n[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n\n\nPuede ser reproducida con el siguiente uso de reduce:\n\ndef dup(x):\n    return x * 2\n\nreduce(lambda seq, x: seq + [dup(x)], range(10), [])\n\n[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n\n\nY el siguiente uso de filter\n\nlist(filter(lambda x: x % 2 == 1, range(10)))\n\n[1, 3, 5, 7, 9]\n\n\nSe puede expresar también con reduce:\n\ndef es_impar(x):\n    return x % 2 == 1\n\nreduce(lambda seq, x: seq + [x] if es_impar(x) else seq, range(10), [])\n\n[1, 3, 5, 7, 9]\n\n\nEstas expresiones con reduce() son complejas, pero ilustran claramente el poder de la función: cualquier operación que pueda definirse a partir de una combinación sucesiva de elementos puede, al menos en principio, expresarse como una reducción, aunque no siempre sea la forma más clara o recomendada de hacerlo.",
    "crumbs": [
      "Teoría",
      "U2 - Programación Funcional",
      "3 - Funciones de orden superior"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#comprehensions",
    "href": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#comprehensions",
    "title": "3 - Funciones de orden superior",
    "section": "Comprehensions",
    "text": "Comprehensions\nCuando usamos map y filter obtenemos objetos especiales: map devuelve un objeto de tipo map, y filter devuelve un objeto de tipo filter. Estos objetos son iterables y perezosos, lo que significa que no realizan ninguna operación hasta que se los recorre o convierte en una colección, como una lista. Por eso, si queremos ver directamente el resultado de una transformación o filtrado, necesitamos envolverlos con list():\nnumeros = [1, 2, 3]\nlist(map(lambda x: x * 2, numeros))          # → [2, 4, 6]\nlist(filter(lambda x: x % 2 == 0, numeros))  # → [2]\nAunque map y filter siguen siendo completamente válidos y útiles, hoy en día se consideran formas anticuadas o menos idiomáticas de construir listas transformadas o filtradas en Python.\nLa alternativa moderna y, en general preferida, son las comprensiones de listas (del inglés, list comprehensions), que permiten expresar las mismas ideas de forma más clara y legible:\n\nnumeros = list(range(11))\n[x * 2 for x in numeros] # Reemplaza a list(map(...))\n\n[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n\n\n\n[x for x in numeros if x % 2 == 0] # Reemplaza a list(filter(...))\n\n[0, 2, 4, 6, 8, 10]\n\n\n\nComprehension como reemplazo de map\nSupongamos que tenemos una lista de números y queremos restarles su media.\nUna forma de hacerlo utilizando un bucle for es:\n\nvector = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]\n\nmedia = media(vector)\nvector_centrado = []\nfor x in vector:\n    vector_centrado.append(x - media)\n\nvector_centrado\n\n[-4.5, -3.5, -2.5, -1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5]\n\n\nSi, en cambio, decidimos usar map, podemos hacer:\n\nlist(map(lambda x: x - media, vector))\n\n[-4.5, -3.5, -2.5, -1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5]\n\n\nFinalmente, se puede obtener el mismo resultado usando una list comprehension:\n\n[x - media for x in vector]\n\n[-4.5, -3.5, -2.5, -1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5]\n\n\nLa sintaxis general de una list comprehension que aplica una transformación sobre los elementos de un iterable es:\n[&lt;expresión&gt; for elemento in iterable]\nComo se observa en el ejemplo anterior, lo que aparece en la parte izquierda como &lt;expresión&gt; no tiene por qué ser una llamada a una función; puede ser cualquier expresión válida que produzca un resultado. Es decir, una operación matemática, un formateo de texto, la construcción de una estructura de datos, una llamada a una función, etc.\n\n\nComprehension como reemplazo de filter\nAhora veamos con mayor detalle cómo funciona una list comprehension que reemplaza al uso de filter. Para eso, retomemos el ejemplo de las palabras capicúa.\n\npalabras = [\"hola\", \"mate\", \"somos\",\" libro\", \"conocer\", \"anilina\", \"programa\"]\n\nInicialmente, podemos construir un listado de palabras capicúa usando un bucle for.\n\ncapicuas = []\nfor palabra in palabras:\n    if palabra == palabra[::-1]:\n        capicuas.append(palabra)\ncapicuas\n\n['somos', 'anilina']\n\n\nLuego, podemos construir el listado de palabras capicúa usando la función de orden superior filter.\n\nlist(filter(lambda x: x == x[::-1], palabras))\n\n['somos', 'anilina']\n\n\nY finalmente, se puede obtener exactamente el mismo resultado mediante una list comprehension.\n\n[palabra for palabra in palabras if palabra == palabra[::-1]]\n\n['somos', 'anilina']\n\n\nLa sintaxis general de una list comprehension que filtra los elementos de un iterable es:\n[elemento for elemento in iterable if &lt;expresión_lógica&gt;]\nAl igual que en la list comprehension que aplica funciones a todos los ementos, &lt;expresión_lógica&gt; puede ser cualquier expresión de Python que devuelva un valor True o False, o que pueda interpretarse como tal.\nTambién podría usarse una list comprehension que transforme elementos filtrados de un iterable:\n[&lt;expresión&gt; for elemento in iterable if &lt;expresión_lógica&gt;]\nPor ejemplo:\n\n# Multiplica por 2 a los numeros impares de `range(5)`\n[x * 2 for x in range(5) if x % 2]\n\n[2, 6]\n\n\n\n\n\n\n\n\nComprehensions con expresiones condicionales 😱\n\n\n\nLa estructura general:\n[elemento for elemento in iterable if &lt;expresión_lógica&gt;]\npuede modificarse cuando se desea evaluar una expresión en caso de que se cumpla una condición y otra distinta si no se cumple. Para ello, se usa una expresión condicional directamente en la parte izquierda de la comprensión:\n[&lt;expresión_si_verdadero&gt; if &lt;condición&gt; else &lt;expresión_si_falso&gt; for elemento in iterable]\nPor ejemplo:\nnumeros = [1, 2, 3, 4, 5]\n[f\"{x} es par\" if x % 2 == 0 else f\"{x} es impar\" for x in numeros]\n['1 es impar', '2 es par', '3 es impar', '4 es par', '5 es impar']\n\n\n\n\n\n\n\n\nDictionary comprehensions 😱😱\n\n\n\nLas comprensiones en Python no están limitadas a listas. Este patrón también puede utilizarse para construir otras estructuras de datos como diccionarios, conjuntos e incluso generadores (estructura que veremos más adelante).\nPor ejemplo, una comprensión de diccionario permite crear un dict a partir de una secuencia de pares clave-valor:\ndef media(x):\n    return sum(x) / len(x)\n\ndatos = [\n    (\"Marcos\", (4, 8, 9, 9)),\n    (\"Joaquín\", (10, 8, 8, 7)),\n    (\"Luján\", (10, 9, 9, 10)),\n]\n\n{nombre: media(notas) for nombre, notas in datos}\n{'Marcos': 7.5, 'Joaquín': 8.25, 'Luján': 9.5}",
    "crumbs": [
      "Teoría",
      "U2 - Programación Funcional",
      "3 - Funciones de orden superior"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#evaluación-parcial-de-funciones",
    "href": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#evaluación-parcial-de-funciones",
    "title": "3 - Funciones de orden superior",
    "section": "Evaluación parcial de funciones",
    "text": "Evaluación parcial de funciones\nEn Fundamentos comenzamos a trabajar con function factories, es decir, con funciones que definen y devuelven funciones. El ejemplo que vimos consistía en la función crear_multiplicador que recibía un múltiplo y devolvía una función de un argumento que al llamarla realizaba la multiplcación. Así, era posible crear funciones para duplicar, triplicar, cuadruplicar, etc.\n\ndef crear_multiplicador(x):\n    def interna(y):\n        return y * x\n    return interna\n\nduplicar = crear_multiplicador(2)\ntriplicar = crear_multiplicador(3)\n\nprint(duplicar(10), triplicar(22))\n\n20 66\n\n\nAhora bien, esta no es la única forma de crear funciones que multipliquen dos numeros dejando uno de sus argumentos fijo.\nUna alternativa consiste en crear una función general de multiplicación y usar partial del módulo functools para obtener una versión de la misma con alguno de sus argumentos fijados.\n\ndef multiplicar(x, y):\n    return x * y\n\nmultiplicar(7, 8)\n\n56\n\n\n\nfrom functools import partial\n\ncuadruplicar = partial(multiplicar, 4)\ncuadruplicar(2)\n\n8\n\n\nEn esencia, partial toma una función y fija algunos de sus parámetros, devolviendo una nueva función con argumentos ya establecidos. Dicho de otro modo, partial produce una función parcialmente evaluada, de ahí su nombre.\nDe un modo similar, se podrían crear funciones de potencia a partir de una función genérica.\n\ndef potencia(x, n):\n    return x ** n\n\ncuadrado = partial(potencia, n=2)\ncubo = partial(potencia, n=3)\n\nprint(cuadrado(5), cubo(9))\n\n25 729\n\n\nMediante un ejemplo podemos ver que partial también permite fijar más de un parámetro. Supongamos que tenemos una lista de números que queremos estandarizar; es decir, restarles la media y dividir cada valor por el desvío.\n\nnums = [\n    4.74346239e-01, -2.90877176e-01, -1.44377789e+00, -4.48680759e+01,\n    -1.21249801e+00, -3.32729317e-01,  2.21676912e-01,  1.05599711e+00,\n    -3.62372053e+00, -2.96441579e-01, -4.28304222e+00,  1.55908820e+02,\n    9.00858234e-01, -1.09384173e+00, -1.51083571e+00, -5.38491167e-01,\n    -3.84153084e-02,  1.20393395e+00,  1.82651406e-01,  2.05179405e+00\n]\n\ndef media(x):\n    return sum(x) / len(x)\n\ndef varianza(x):\n    numerador = 0\n    x_media = media(x)\n    for x_i in x:\n        numerador += (x_i - x_media) ** 2\n    return numerador / len(x)\n\nestandarizar = partial(\n1    lambda x, media, desvio: (x - media) / desvio,\n2    media=media(nums),\n    desvio=varianza(nums) ** 0.5\n)\n\n\n1\n\nDefinimos una función lambda que implementa la estandarización. Esta función recibe el valor a estandarizar, la media y el desvío correspondientes.\n\n2\n\nCalculamos la media y el desvío de la lista, y luego los pasamos a partial como parámetros a fijar.\n\n\n\n\nDe esta manera, obtenemos la función estandarizar, que al recibir un número le resta la media y lo divide por el desvío calculado a partir de nums.\n\nestandarizar(nums[0])\n\n-0.12933243764138067\n\n\nY, si queremos estandarizar toda la secuencia, podemos usar una list comprehension.\n\n[estandarizar(num) for num in nums]\n\n[-0.12933243764138067,\n -0.1506204085674334,\n -0.18269328610772323,\n -1.390726359064761,\n -0.17625924440864513,\n -0.15178470535100874,\n -0.13636151853677025,\n -0.1131513242720763,\n -0.24333773925841856,\n -0.1507752062996549,\n -0.2616795995472022,\n 4.1947440261328905,\n -0.11746717741646615,\n -0.1729583111265218,\n -0.1845587869464874,\n -0.1575088536123251,\n -0.1435970990449382,\n -0.10903582664474336,\n -0.13744718034588063,\n -0.08544896194045284]\n\n\n\n\n\n\n\n\nArgumentos posicionales y nombrados 🔢🏷️\n\n\n\npartial puede utilizarse para fijar tanto argumentos posicionales como nombrados. Cuando recibe argumentos posicionales, estos se transmiten a la función original en el mismo orden; mientras que, si se le pasan argumentos nombrados, se reenvían como tales.\nPor ejemplo, las siguientes llamadas a partial generan funciones equivalentes:\ndef prod(x, y):\n    return x * y\n\npartial(prod, 5)     # 5 * y\npartial(prod, x=5)   # 5 * y\npartial(prod, y=5)   # x * 5",
    "crumbs": [
      "Teoría",
      "U2 - Programación Funcional",
      "3 - Funciones de orden superior"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#decoradores",
    "href": "teoria/02_programacion_funcional/03_funciones_de_orden_superior.html#decoradores",
    "title": "3 - Funciones de orden superior",
    "section": "Decoradores",
    "text": "Decoradores\nEn Ciudadanos de primera clase aprendimos que las funciones son un objeto como cualquier otro. Por eso, ya no nos sorprende que puedan pasarse como argumento a otra función o devolverse como resultado de otra función.\nAhora vamos a explorar un tipo de funciones que son muy útiles en Python: los decoradores.\nLos decoradores son funciones que “envuelven” o “encapsulan” funciones y modifican su comportamiento.\nEmpecemos con un ejemplo: la función decorador recibe una función fun, define una función envoltura que contiene una llamada a fun y la devuelve.\n\ndef decorador(fun):\n\n    def envoltura():\n        print(\"Antes de llamar a la función...\")\n        fun()\n        print(\"Listo, ya se llamó a la función.\")\n\n    return envoltura\n\nPara mostrar el funcionamiento del decorador, definamos una función muy sencilla, que simplemente imprime un saludo.\n\ndef decir_hola():\n    print(\"¡Hola hola!\")\n\ndecir_hola()\n\n¡Hola hola!\n\n\nAhora, invocamos a decorador pasandole la función decir_hola y obtenemos una nueva una función.\nPodemos ver que esta nueva función es la función envoltura definida dentro del decorador.\n\nnueva = decorador(decir_hola)\nnueva\n\n&lt;function __main__.decorador.&lt;locals&gt;.envoltura()&gt;\n\n\nAntes de ejecutar la función nueva, intentemos anticipar qué va a ocurrir cuando la llamemos.\nAl invocar nueva, se ejecutarán las siguientes tres líneas de código:\n1print(\"Antes de llamar a la función...\")\n2fun()\n3print(\"Listo, ya se llamó a la función.\")\n\n1\n\nLa primera línea contiene directamente un print, por lo que podemos anticipar que lo primero que vamos a ver es un mensaje que dice \"Antes de llamar a la función...\".\n\n2\n\nLa segunda línea contiene una llamada a la función fun. Esta es la función que le pasamos a decorador al momento de crear nueva, es decir, es la función decir_hola.\nPor lo tanto, habrá un segundo mensaje que dice \"¡Hola hola!\".\n\n3\n\nFinalmente, se ejecuta la tercera línea, y como vemos que es un print, sabemos que vamos a ver un mensaje que dice \"Listo, ya se llamó a la función.\".\n\n\n\nnueva()\n\nAntes de llamar a la función...\n¡Hola hola!\nListo, ya se llamó a la función.\n\n\nEn este ejemplo vemos que el decorador “envuelve” o “encapsula” a la función decir_hola. Gracias a esto, la función decorada ya no se ejecuta como antes, sino que ahora también imprime mensajes antes y después de realizar la tarea en su definición original.\n\nDecoradores que reciben argumentos\nSi intentamos pasarle argumentos a la función nueva, obtendremos un error. Este error no se debe a que la función decorada, decir_hola, no acepte parámetros, sino a que la función que devuelve el decorador, envoltura, no está preparada para recibirlos.\nAhora bien, si queremos que nuestra función de envoltura pueda transmitir argumentos a la función decorada, necesitamos un mecanismo flexible. No podemos conocer de antemano qué parámetros recibirá la función a decorar, justamente porque no sabemos cuál será esa función.\nLa solución es definir envoltura de manera que acepte una cantidad arbitraria de argumentos posicionales y nombrados. De esta forma, podemos propagar todos esos argumentos a la función decorada sin importar cuáles sean.\n\ndef decorador(fun):\n\n1    def envoltura(*args, **kwargs):\n        if args:\n            print(\"Argumentos posicionales:\", args)\n        if kwargs:\n            print(\"Argumentos nombrados:\", kwargs)\n2        fun(*args, **kwargs)\n\n    return envoltura\n\ndef potencia(x, n):\n    return x ** n\n\npotencia = decorador(potencia)\n\n\n1\n\nenvoltura recibe una cantidad arbitraria de argumentos posicionales y nombrados.\n\n2\n\nCuando se llama a fun, se le pasan todos los argumentos posicionales y nombrados recibidos.\n\n\n\n\n\npotencia(5, 3)\n\nArgumentos posicionales: (5, 3)\n\n\n\npotencia(5, n=3)\n\nArgumentos posicionales: (5,)\nArgumentos nombrados: {'n': 3}\n\n\n\npotencia(x=5, n=3)\n\nArgumentos nombrados: {'x': 5, 'n': 3}\n\n\nEl ejemplo muestra que el decorador imprime los argumentos de la función original, tanto posicionales como nombrados, siempre que se le haya pasado alguno.\n\n\nDecoradores que devuelven valores\nSi bien el decorador anterior funcionaba correctamente con funciones que reciben tanto argumentos posicionales como nombrados, no vemos que la función decorada devuelva la potencia calculada. Para que eso ocurra, la envoltura no solo tiene que llamar a fun, sino también retornar lo que esta retorne.\n\ndef decorador(fun):\n\n    def envoltura(*args, **kwargs):\n        if args:\n            print(\"Argumentos posicionales:\", args)\n        if kwargs:\n            print(\"Argumentos nombrados:\", kwargs)\n1        return fun(*args, **kwargs)\n\n    return envoltura\n\ndef potencia(x, n):\n    return x ** n\n\n\n1\n\nGracias a esta línea, la función envoltura retorna lo que sea que fun retorne.\n\n\n\n\n\npotencia = decorador(potencia)\npotencia(x=5, n=3)\n\nArgumentos nombrados: {'x': 5, 'n': 3}\n\n\n125\n\n\n\n\nAzúcar sintáctico\nDado que los decoradores cumplen un rol muy importante en la programación con Python, el lenguaje ofrece una sintaxis especial para aplicarlos directamente al momento de definir una función.\nPara ello, basta con escribir @&lt;nombre_decorador&gt; en la línea anterior a la definición de la función. Por ejemplo:\n\n@decorador\ndef producto(x, y):\n    return x * y\n\nproducto(3, 7)\n\nArgumentos posicionales: (3, 7)\n\n\n21\n\n\n\nproducto(x=3, y=7)\n\nArgumentos nombrados: {'x': 3, 'y': 7}\n\n\n21\n\n\nDe esta manera, no es necesario incluir líneas adicionales del estilo:\ndef funcion(...):\n    ...\n    return ...\n\nfuncion = decorador(funcion)\nA este tipo de atajos sintácticos que brinda el lenguaje se los conoce como azúcar sintáctico (del inglés, syntax sugar).\n\n\nEjemplo: medir tiempo de ejecución\nHasta ahora, los ejemplos que vimos fueron un tanto artificiales, pensados únicamente para mostrar qué son los decoradores y cómo se utilizan. A continuación, presentamos un ejemplo más cercano a un uso práctico.\nEl decorador timer imprime el tiempo de ejecución que le toma a una función. Luego, lo aplicamos para comparar los tiempos entre la función built-in max y otra implementación que obtiene el máximo mediante una reducción.\n\nimport time\n\ndef timer(fun):\n    def envoltura(*args, **kwargs):\n        inicio = time.time()\n        resultado = fun(*args, **kwargs)\n        fin = time.time()\n        print(f\"{fun.__name__} demoró {fin - inicio:6f} segundos\")\n        return resultado\n    return envoltura\n\n\ndef mayor(x, y):\n    if x &gt; y:\n        return x\n    return y\n\n@timer\ndef maximo_reduce(x):\n    return reduce(mayor, x)\n\n@timer\ndef maximo_builtin(x):\n    return max(x)\n\n\nlista = list(range(1_000_000))\n\nmaximo_reduce(lista)\n\nmaximo_reduce demoró 0.044118 segundos\n\n\n999999\n\n\n\nmaximo_builtin(lista)\n\nmaximo_builtin demoró 0.017050 segundos\n\n\n999999",
    "crumbs": [
      "Teoría",
      "U2 - Programación Funcional",
      "3 - Funciones de orden superior"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/01_fundamentos.html",
    "href": "teoria/02_programacion_funcional/01_fundamentos.html",
    "title": "1 - Fundamentos",
    "section": "",
    "text": "La programación funcional es un paradigma de programación que se centra en el uso de funciones puras y en concebir la computación como la evaluación de funciones. En lugar de dar instrucciones paso a paso que cambian variables o estados (como ocurre en la programación imperativa), la idea es construir programas a partir de funciones que transforman datos.\nExisten lenguajes diseñados específicamente para la programación funcional (como Haskell), pero Python no es uno de ellos. Python es un lenguaje multiparadigma, lo que significa que nos permite combinar diferentes estilos de programación. Por este motivo, la programación funcional en Python no suele ser el enfoque principal, pero puede ser muy útil para escribir código más claro, conciso y fácil de probar.",
    "crumbs": [
      "Teoría",
      "U2 - Programación Funcional",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/01_fundamentos.html#introducción",
    "href": "teoria/02_programacion_funcional/01_fundamentos.html#introducción",
    "title": "1 - Fundamentos",
    "section": "",
    "text": "La programación funcional es un paradigma de programación que se centra en el uso de funciones puras y en concebir la computación como la evaluación de funciones. En lugar de dar instrucciones paso a paso que cambian variables o estados (como ocurre en la programación imperativa), la idea es construir programas a partir de funciones que transforman datos.\nExisten lenguajes diseñados específicamente para la programación funcional (como Haskell), pero Python no es uno de ellos. Python es un lenguaje multiparadigma, lo que significa que nos permite combinar diferentes estilos de programación. Por este motivo, la programación funcional en Python no suele ser el enfoque principal, pero puede ser muy útil para escribir código más claro, conciso y fácil de probar.",
    "crumbs": [
      "Teoría",
      "U2 - Programación Funcional",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/01_fundamentos.html#funciones-puras",
    "href": "teoria/02_programacion_funcional/01_fundamentos.html#funciones-puras",
    "title": "1 - Fundamentos",
    "section": "Funciones puras",
    "text": "Funciones puras\nUna función es pura cuando su salida depende únicamente de los valores de entrada y no produce ningún efecto secundario o colateral (side effect, en inglés).\nLa función sumar, que calcula y devuelve la suma de dos números, es un ejemplo de función pura: su resultado depende solo de sus argumentos y no genera efectos colaterales.\n\ndef sumar(x, y):\n    return x + y\n\nsumar(3, 11)\n\n14\n\n\nEn cambio, la función agregar no es una función pura. Esto se debe a que modifica un objeto global, lo que se conoce como un efecto secundario. Además, el valor de su salida no depende únicamente de la entrada, sino también de un estado global: la cantidad de elementos en lista.\n\nlista = []\n\ndef agregar(x):\n    \"\"\"Agrega el elemento `x` al final de `lista` y devuelve la longitud de `lista`\"\"\"\n    lista.append(x)\n    return len(lista)\n\n\nagregar(\"azucar\")\n\n1\n\n\n\nagregar(\"flores\")\n\n2\n\n\n\nagregar(\"colores\")\n\n3\n\n\n\nlista\n\n['azucar', 'flores', 'colores']\n\n\n\nEfectos secundarios\nUn efecto secundario (side effect) es cualquier cambio de estado observable que ocurre fuera del ámbito local de una función. En otras palabras, se trata de una modificación del entorno externo de la función que va más allá de simplemente devolver un valor.\nAlgunos ejemplos de side effects son:\n\nModificar una variable global o un objeto mutable.\nImprimir en la consola.\nEscribir en un archivo.\nRealizar una llamada a una API o a una base de datos.\n\nLas funciones con efectos secundarios pueden ser problemáticas porque, al modificar elementos externos, hacen que el código sea impredecible y difícil de probar.\nEn el ejemplo de la función agregar que creamos anteriormente, no es posible predecir el valor de salida para un valor de entrada determinado.\nPor eso, la programación funcional promueve el uso de funciones puras, que no producen efectos secundarios. De esta manera, con las mismas entradas siempre se obtiene la misma salida, logrando un código más confiable, predecible y sencillo de mantener.",
    "crumbs": [
      "Teoría",
      "U2 - Programación Funcional",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/01_fundamentos.html#sec-ciudadanos",
    "href": "teoria/02_programacion_funcional/01_fundamentos.html#sec-ciudadanos",
    "title": "1 - Fundamentos",
    "section": "Ciudadanos de primera clase",
    "text": "Ciudadanos de primera clase\nDefinamos otra función muy sencilla, restar, que calcula y devuelve la diferencia entre dos objetos.\n\ndef restar(x, y):\n    return x - y\n\nrestar(10, 5)\n\n5\n\n\nPodemos observar que esta función es un objeto de tipo function.\nprint(type(restar))\nprint(restar)\nrestar\n&lt;class 'function'&gt;\n&lt;function restar at 0x7f71cee62020&gt;\n&lt;function __main__.restar(x, y)&gt;\nAl imprimir la función, Python nos muestra su nombre y la dirección de memoria donde está almacenada (en formato hexadecimal). En cambio, al mostrar su representación, obtenemos información adicional: el módulo en el que fue definida (en este caso __main__) y la lista de parámetros que recibe (x e y).\nDado que la función restar es un objeto de Python, podemos asignarla a una nueva variable y realizar una llamada utilizando esa nueva etiqueta en vez de la original.\n\nresta_especial = restar\nresta_especial(10, 5)\n\n5\n\n\nNotemos que resta_especial no es una nueva función; es solamente una nueva referencia a la función antes definida.\n\nresta_especial # muestra 'restar', no 'resta_especial'\n\n&lt;function __main__.restar(x, y)&gt;\n\n\n\nresta_especial is restar\n\nTrue\n\n\nEn Python, las funciones son ciudadanos de primera clase. Esto significa que son objetos, al igual que las cadenas o los números. Por lo tanto, todo lo que se puede hacer con una cadena o un número también puede hacerse con una función.\nPor ejemplo, se pueden almacenar dentro de una lista junto con otros objetos de distintos tipos:\npopurri = [128, restar, None]\nprint(popurri[0])\nprint(popurri[1])\nprint(popurri[2])\n128\n&lt;function restar at 0x7f71cee62020&gt;\nNone\nIncluso una función puede ser almacenada como valor en un diccionario:\n\nmapeo = {\n    \"sum\": sumar,\n    \"sub\": restar,\n}\n\nLuego, se las puede usar de la siguiente manera:\n\nmapeo[\"sum\"](25, 4)\n\n29\n\n\n\nmapeo[\"sub\"](25, 4)\n\n21\n\n\n\nFunciones de orden superior\nComo cualquier objeto de Python, una función puede ser pasada como argumento de otra función. Debajo definimos dos funciones muy simples. Una imprime un mensaje de bienvenida y la otra uno de despedida.\n\ndef bienvenida():\n    print(\"¡Hola!\")\n\ndef despedida():\n    print(\"¡Chau!\")\n\n\nbienvenida()\ndespedida()\n\n¡Hola!\n¡Chau!\n\n\nSe puede definir otra función, que llamaremos externa (del inglés outer function), que tiene un único parámetro interna. En su cuerpo, la función externa llama a la función interna y devuelve lo que sea que interna devuelva.\n\ndef externa(interna):\n    return interna()\n\nDe este modo, si llamamos a externa pasándole como argumento a bienvenida, se imprimirá ¡Hola!; y si lo hacemos con despedida, se imprimirá ¡Chau!.\n\nexterna(bienvenida)\n\n¡Hola!\n\n\n\nexterna(despedida)\n\n¡Chau!\n\n\nComo ni bienvenida ni despedida devuelven nada, lo mismo ocurre con externa en los dos ejemplos anteriores.\nA esta función podemos pasarle cualquier función que pueda ser llamada sin ningún argumento. Por ejemplo:\n\ndef crear_lista():\n    return []\n\nexterna(crear_lista)\n\n[]\n\n\nTambién es posible que una función devuelva como resultado otra función. La función fabricar construye y devuelve una función que computa la suma de dos objetos.\n\ndef fabricar():\n    def interna(x, y):\n        return x + y\n    return interna\n\n# La llamada a 'fabricar' genera y devuelve una función\nf = fabricar()\n\n# La función obtenida puede ser tratada como cualquier otra función\nf(10, 15)\n\n25\n\n\nUna función que fabrica otras funciones puede recibir parámetros que luego son utilizados dentro de la función interna. En el bloque siguiente, la función crear_multiplicador recibe un parámetro x, que define el valor por el cual se multiplicará el argumento de la función interna que se devuelve.\n\ndef crear_multiplicador(x):\n    def interna(y):\n        return y * x\n    return interna\n\nAsí, es posible crear funciones para duplicar, triplicar, etc.\n\nduplicar = crear_multiplicador(2)\ntriplicar = crear_multiplicador(3)\n\nprint(duplicar(5))\nprint(triplicar(5))\nprint(triplicar(18))\n\n10\n15\n54\n\n\n\n\n\n\n\n\nObservación 👀\n\n\n\nCada vez que se invoca la función fabricar, se crea y devuelve una nueva función. Por eso, el resultado de la comparación en el siguiente bloque es False.\nf1 = fabricar()\nf2 = fabricar()\nprint(f1 is f2)\nFalse\n\n\n\n\n\n\n\n\nFunction factory 🏭\n\n\n\nA las funciones que crean y devuelven funciones se las conoce como fábrica de funciones, del inglés function factory.\n\n\n\n\nAtributos de una función\nEn Python, las funciones también cuentan con atributos, del mismo modo que otros objetos. En el siguiente ejemplo definimos la función resolvente, que recibe las constantes a, b y c de un polinomio de segundo grado, calcula sus raíces usando la fórmula resolvente y las devuelve en una tupla.\n\ndef resolvente(a, b, c):\n    discriminante = b ** 2 - 4 * a * c\n    x0 = (-b + (discriminante) ** 0.5) / (2 * a)\n    x1 = (-b - (discriminante) ** 0.5) / (2 * a)\n\n    return x0, x1\n\nresolvente(2, 5, -3)\n\n(0.5, -3.0)\n\n\nA través del atributo especial __code__ es posible consultar ciertos atributos o detalles internos de una función:\n\nprint(resolvente.__code__.co_argcount) # Cantidad de argumentos\nprint(resolvente.__code__.co_name)     # Nombre de la función\nprint(resolvente.__code__.co_varnames) # Variables en el ámbito local\n\n3\nresolvente\n('a', 'b', 'c', 'discriminante', 'x0', 'x1')\n\n\nAcceder a la información de una función a través de __code__ puede resultar poco práctico, ya que los atributos disponibles son técnicos y no siempre coinciden directamente con lo que solemos necesitar (por ejemplo, obtener solo los nombres de los argumentos).\nPara facilitar esta tarea, la librería estándar de Python incluye el módulo inspect, que ofrece herramientas más claras e intuitivas para explorar los atributos y detalles de una función.\nA modo ilustrativo tomemos la función signature, que devuelve un objeto que representa la firma de la función resolvente.\n\nimport inspect\n\nfirma = inspect.signature(resolvente)\nfirma\n\n&lt;Signature (a, b, c)&gt;\n\n\nA partir de esta firma podemos consultar distintos aspectos de los parámetros, como sus valores por defecto:\n\nfirma.parameters[\"a\"].default # 'a' no tiene asignado un valor por defecto\n\ninspect._empty\n\n\nFinalmente, inspect también permite acceder al código fuente de la función en forma de cadena de texto:\n\nprint(inspect.getsource(resolvente))\n\ndef resolvente(a, b, c):\n    discriminante = b ** 2 - 4 * a * c\n    x0 = (-b + (discriminante) ** 0.5) / (2 * a)\n    x1 = (-b - (discriminante) ** 0.5) / (2 * a)\n\n    return x0, x1",
    "crumbs": [
      "Teoría",
      "U2 - Programación Funcional",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/01_fundamentos.html#funciones-anónimas",
    "href": "teoria/02_programacion_funcional/01_fundamentos.html#funciones-anónimas",
    "title": "1 - Fundamentos",
    "section": "Funciones anónimas",
    "text": "Funciones anónimas\nLa programación funcional se basa en llamar funciones y pasarlas, por lo que, naturalmente, puede implicar definir muchas funciones. En Python, además de usar def, podemos crear funciones anónimas de forma rápida con una expresión lambda.\nLa sintaxis es la siguiente:\nlambda &lt;argumentos&gt;: &lt;expresión&gt;\ny devuelve como resultado una función anónima. Un ejemplo es el siguiente:\n\nlambda x, y: x + y\n\n&lt;function __main__.&lt;lambda&gt;(x, y)&gt;\n\n\nComo la función anónima que acabamos de crear no fue asignada a ninguna variable, ya no podemos usarla.\nUna posibilidad es invocarla inmediatamente al momento de su creación:\n\n(lambda x, y: x + y)(7, 15)\n\n22\n\n\nOtra opción es asignarla a una variable para poder llamarla más adelante:\n\nsumar = lambda x, y: x + y\nsumar(7, 15)\n\n22\n\n\n\n\n\n\n\n\nAusencia de return\n\n\n\nA diferencia de las funciones definidas con def, las expresiones lambda no requieren la sentencia return. De forma implícita, siempre devuelven el resultado de la única expresión que contienen.\n\n\n\nUsos de funciones anónimas\nEn ninguno de los ejemplos anteriores parece que obtengamos alguna ventaja frente a usar def para definir una función. De hecho, da la impresión de que estamos complicando el código innecesariamente.\nLo cierto es que las funciones anónimas no están pensadas para emplearse de la manera expuesta en nuestros ejemplos. Su uso principal es en operaciones simples y puntuales, cuando no resulta práctico definir una función regular con def.\nUn caso de uso típico de la funciones anónimas es cuando se tiene que pasar una función como argumento de otra función.\nSupongamos que queremos ordenar la siguiente lista de refranes según diferentes criterios.\n\nrefranes = [\n    \"Al mal tiempo, buena cara\",\n    \"Perro que ladra no muerde\",\n    \"A caballo regalado no se le miran los dientes\",\n    \"Cada loco con su tema\",\n    \"El que mucho abarca, poco aprieta\",\n    \"Más vale pájaro en mano que cien volando\",\n]\n\nPor defecto, la función sorted ordena una lista de cadenas de manera alfabética.\n\nsorted(refranes)\n\n['A caballo regalado no se le miran los dientes',\n 'Al mal tiempo, buena cara',\n 'Cada loco con su tema',\n 'El que mucho abarca, poco aprieta',\n 'Más vale pájaro en mano que cien volando',\n 'Perro que ladra no muerde']\n\n\nSi quisiéramos ordenar los refranes por su longitud, podemos usar el argumento opcional key de sorted. Este argumento recibe una función que, aplicada a cada elemento, devuelve el valor a utilizar en el ordenamiento. En nuestro caso, basta con usar len, ya que solo nos interesa la cantidad de caracteres de cada cadena.\n\nsorted(refranes, key=len)\n\n['Cada loco con su tema',\n 'Al mal tiempo, buena cara',\n 'Perro que ladra no muerde',\n 'El que mucho abarca, poco aprieta',\n 'Más vale pájaro en mano que cien volando',\n 'A caballo regalado no se le miran los dientes']\n\n\nAsí, obtenemos una lista donde las frases se ordenan según la cantidad de caracteres.\n¿Y si quisiéramos ordenarlos según la cantidad de palabras? Para eso necesitamos una función que reciba una cadena, la divida en palabras y cuente cuántas tiene.\nSin funciones anónimas podríamos hacer lo siguiente:\n\ndef contar_palabras(x):\n    return len(x.split())\n\nsorted(refranes, key=contar_palabras)\n\n['Al mal tiempo, buena cara',\n 'Perro que ladra no muerde',\n 'Cada loco con su tema',\n 'El que mucho abarca, poco aprieta',\n 'Más vale pájaro en mano que cien volando',\n 'A caballo regalado no se le miran los dientes']\n\n\nEn cambio, con una función anónima podemos escribir todo el programa en una sola línea:\n\nsorted(refranes, key=lambda x: len(x.split()))\n\n['Al mal tiempo, buena cara',\n 'Perro que ladra no muerde',\n 'Cada loco con su tema',\n 'El que mucho abarca, poco aprieta',\n 'Más vale pájaro en mano que cien volando',\n 'A caballo regalado no se le miran los dientes']\n\n\nDe esta forma el código es más conciso y evitamos definir funciones “descartables” que no volverán a usarse.\n\n\n\n\n\n\nOrigen del nombre lambda λ✨\n\n\n\nEl término lambda proviene del cálculo lambda, un sistema formal de lógica matemática para expresar cálculos basados en la abstracción y aplicación de funciones.\nSe le dio ese nombre porque Alonzo Church, creador del cálculo lambda en la década de 1930, usó la letra griega λ para denotar la operación de abstracción de funciones.\n\n\n\n\n\n\n\n\nFunciones anónimas sin parámetros\n\n\n\nUna función lambda normalmente recibe uno o múltiples parámetros, pero no es obligatorio, por lo que es posibile escribir una función anónima sin parámetros:\ncrear_numero_magico = lambda: 128\ncrear_numero magico()\n128\nLa función anónima crear_numero_magico es equivalente a la siguiente función\ndef f():\n    return 128",
    "crumbs": [
      "Teoría",
      "U2 - Programación Funcional",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/01_fundamentos.html#funciones-variádicas",
    "href": "teoria/02_programacion_funcional/01_fundamentos.html#funciones-variádicas",
    "title": "1 - Fundamentos",
    "section": "Funciones variádicas",
    "text": "Funciones variádicas\nLas funciones variádicas son funciones que pueden recibir una cantidad variable de argumentos.\nA lo largo de estos apuntes hemos utilizado funciones variádicas en tantísimas oportunidades. Un ejemplo de función variádica es print, que acepta tantos argumentos posicionales como necesitemos.\n\nprint(\"Primero\")\n\nPrimero\n\n\n\nprint(\"Primero\", \"segundo\")\n\nPrimero segundo\n\n\n\nprint(\"Primero\", \"segundo\", \"tercero\")\n\nPrimero segundo tercero\n\n\nAfortunadamente, no solo las funciones built-in pueden ser variádicas, sino que también podemos implementarlas nosotros mismos.\n\nCantidad variable de argumentos posicionales *args\nSupongamos que queremos una función que recibe una cantidad arbitraria de gustos de helado e imprime un mensaje como si lo agregase a un pedido. Por ejemplo:\narmar_pedido(\"Dulce de leche\")\nAgregando 'Dulce de leche'\narmar_pedido(\"Dulce de leche\", \"Sambayón\", \"Frutos del bosque\")\nAgregando 'Dulce de leche'\nAgregando 'Sambayón'\nAgregando 'Frutos del bosque'\nUna posible implementación para tal función es:\ndef armar_pedido(gusto_1=None, gusto_2=None, gusto_3=None):\n    if gusto_1 is not None:\n        print(f\"Agregando '{gusto_1}'\")\n    if gusto_2 is not None:\n        print(f\"Agregando '{gusto_2}'\")\n    if gusto_3 is not None:\n        print(f\"Agregando '{gusto_3}'\")\nAunque funciona en los ejemplos anteriores, esta solución está lejos de ser ideal. Requiere definir un argumento separado para cada gusto, asignarle un valor por defecto y luego verificar si es distinto de None antes de agregarlo al pedido.\nAdemás, el código resulta repetitivo y restrictivo: solo permite un máximo de tres gustos.\nEn cambio, podemos crear una función que reciba una cantidad arbitraria de argumentos posicionales. Para ello se utiliza un argumento especial precedido por un asterisco (*), lo que le permite recibir una cantidad arbitraria de valores no nombrados.\n\ndef armar_pedido(*args):\n    for gusto in args:\n        print(f\"Agregando '{gusto}'\")\n\n\narmar_pedido(\"Dulce de leche\", \"Sambayón\", \"Frutos del bosque\", \"Menta granizada\")\n\nAgregando 'Dulce de leche'\nAgregando 'Sambayón'\nAgregando 'Frutos del bosque'\nAgregando 'Menta granizada'\n\n\n\narmar_pedido(\"gusto 1\", \"gusto 2\", \"gusto 3\", \"gusto 4\", \"gusto 5\", \"gusto 6\", \"gusto 7\")\n\nAgregando 'gusto 1'\nAgregando 'gusto 2'\nAgregando 'gusto 3'\nAgregando 'gusto 4'\nAgregando 'gusto 5'\nAgregando 'gusto 6'\nAgregando 'gusto 7'\n\n\nPor convención, este argumento suele escribirse como *args, aunque en realidad el nombre del argumento puede ser cualquiera que resulte apropiado. En nuestro caso, resulta más intuitivo usar *gustos, y la función quedaría así:\n\ndef armar_pedido(*gustos):\n    for gusto in gustos:\n        print(f\"Agregando '{gusto}'\")\n\n\narmar_pedido(\"gusto 1\", \"gusto 2\", \"gusto 3\", \"gusto 4\", \"gusto 5\", \"gusto 6\", \"gusto 7\")\n\nAgregando 'gusto 1'\nAgregando 'gusto 2'\nAgregando 'gusto 3'\nAgregando 'gusto 4'\nAgregando 'gusto 5'\nAgregando 'gusto 6'\nAgregando 'gusto 7'\n\n\n\n\n\n\n\n\nQué hay debajo de *args 🔍\n\n\n\nPython agrupa automáticamente en una tupla los valores pasados mediante el argumento especial *args. Esto permite acceder a todos los argumentos como miembros de una colección inmutable.\ndef fun(*args):\n    print(len(args))\n    print(args)\n    print(type(args))\n\nfun(\"que\", \"es\", \"esto\", True, None)\n5\n('que', 'es', 'esto', True, None)\n&lt;class 'tuple'&gt;\n\n\n\n\nCantidad variable de argumentos nombrados **kwargs\nAsí como recibimos una cantidad arbitraria de argumentos posicionales, también podemos recibir una cantidad arbitraria de argumentos nombrados.\nEn este caso, se utilizan dos asteríscos (**) en vez de uno (*) en la definición de los parámetros de la función.\nLa convención es usar el nombre **kwargs, pero también es válido usar cualquier otro nombre que sea adecuado en nuestro contexto.\nComencemos por un ejemplo elemental, que solo imprime el objeto kwargs y su tipo:\n\ndef ejemplo(**kwargs):\n    print(kwargs)\n    print(type(kwargs))\n\nejemplo(nombre=\"Mariano\", apellido=\"Pérez\")\n\n{'nombre': 'Mariano', 'apellido': 'Pérez'}\n&lt;class 'dict'&gt;\n\n\nCuando usamos una cantidad variable de argumentos nombrados, Python los agrupa en un diccionario, ya que esta estructura permite asociar cada nombre con su valor de forma natural.\nDentro de la función, se puede manipular al diccionario kwargs como a cualquier otro diccionario de Python.\nImaginemos, por ejemplo, una función que registra información de distintos departamentos. En este caso, no sabemos de antemano qué atributos se van a proporcionar, pero sí sabemos que ciertos atributos deben contar con un valor por defecto si no se especifican.\n\ndef registrar_propiedad(**kwargs):\n    print(\"Diccionario original:\")\n    print(kwargs)\n\n    # Si no se especifica la cantidad de cocheras, se pone 0 por defecto\n    if \"cochera\" not in kwargs:\n        kwargs[\"cochera\"] = 0\n\n    # Si no se especifica la ciudad, se pone 'Desconocido' por defecto\n    if \"ciudad\" not in kwargs:\n        kwargs[\"ciudad\"] = \"Desconocido\"\n\n    return kwargs\n\nCuando no se especifician la cantidad de cocheras, la función nos devuelve un diccionario donde la cantidad de cocheras es 0.\n\ndatos = registrar_propiedad(ambientes=2, ciudad=\"Rosario\")\n\nprint(\"\\nDiccionario sanitizado\")\nprint(datos)\n\nDiccionario original:\n{'ambientes': 2, 'ciudad': 'Rosario'}\n\nDiccionario sanitizado\n{'ambientes': 2, 'ciudad': 'Rosario', 'cochera': 0}\n\n\nSi los atributos requeridos son especificados, se devuelve el diccionario sin cambios.\n\ndatos = registrar_propiedad(ambientes=2, ciudad=\"Santa Fe\", cochera=2)\n\nprint(\"\\nDiccionario sanitizado\")\nprint(datos)\n\nDiccionario original:\n{'ambientes': 2, 'ciudad': 'Santa Fe', 'cochera': 2}\n\nDiccionario sanitizado\n{'ambientes': 2, 'ciudad': 'Santa Fe', 'cochera': 2}\n\n\nY si se pasan otros atributos, también se incluyen en la salida.\n\ndatos = registrar_propiedad(ambientes=4, dormitorios=2)\n\nprint(\"\\nDiccionario sanitizado\")\nprint(datos)\n\nDiccionario original:\n{'ambientes': 4, 'dormitorios': 2}\n\nDiccionario sanitizado\n{'ambientes': 4, 'dormitorios': 2, 'cochera': 0, 'ciudad': 'Desconocido'}\n\n\n\n\nCombinando *args y **kwargs\nLas funciones en Python pueden recibir simultáneamente una cantidad variable de argumentos posicionales y nombrados. Para lograrlo, se combinan *args y **kwargs. Es importante recordar que, al definir la función, *args debe colocarse antes que **kwargs, ya que los argumentos posicionales siempre se pasan antes que los nombrados.\n\ndef superfuncion(*args, **kwargs):\n    for arg in args:\n        print(f\"Me pasaron el argumento posicional '{arg}'\")\n\n    for key, value in kwargs.items():\n        print(f\"Me pasaron el argumento con nombre '{key}' y valor '{value}'\")\n\nsuperfuncion(True, 64, nombre=\"Elsa\", apellido=\"Pato\")\n\nMe pasaron el argumento posicional 'True'\nMe pasaron el argumento posicional '64'\nMe pasaron el argumento con nombre 'nombre' y valor 'Elsa'\nMe pasaron el argumento con nombre 'apellido' y valor 'Pato'\n\n\nSi se intenta pasar un argumento posicional (sin nombre) después de un argumento nombrado, obtendríamos un error:\nsuperfuncion(True, nombre=\"Elsa\", apellido=\"Pato\", 64)\n\n    superfuncion(True, nombre=\"Elsa\", apellido=\"Pato\", 64)\n                                                         ^\nSyntaxError: positional argument follows keyword argument\n\n\n\n\n\n\n\n¿Y para qué me sirven? 🤔\n\n\n\nA primera vista, los ejemplos de *args y **kwargs pueden dar la impresión de que estas herramientas solo complican la escritura del código. Sin embargo, su verdadero valor aparece al trabajar en programas más complejos, donde se vuelven fundamentales para simplificar la lógica y aportar flexibilidad en la resolución de una gran variedad de problemas.\nYa llegaremos…\n\n\n\n\n\n\n\n\nEs solo una convención 🤝\n\n\n\nPara reforzar que los nombres *args y **kwargs son solamente una convención, podríamos escribir la función superfuncion como:\ndef superfuncion(*posicionales, **nombrados):\n    for arg in posicionales:\n        print(f\"Me pasaron el argumento posicional '{arg}'\")\n\n    for key, value in nombrados.items():\n        print(f\"Me pasaron el argumento con nombre '{key}' y valor '{value}'\")\ny funcionaría de igual modo.",
    "crumbs": [
      "Teoría",
      "U2 - Programación Funcional",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/01_fundamentos.html#closures",
    "href": "teoria/02_programacion_funcional/01_fundamentos.html#closures",
    "title": "1 - Fundamentos",
    "section": "Closures",
    "text": "Closures\nEn la Sección 3.1 vimos el siguiente ejemplo:\ndef crear_multiplicador(x):\n    def interna(y):\n        return y * x\n    return interna\n\nduplicar = crear_multiplicador(2)\ntriplicar = crear_multiplicador(3)\n\nprint(duplicar(5))\nprint(triplicar(5))\n10\n15\nLa función crear_multiplicador es una fábrica de funciones que devuelve otra función que se encarga de realizar la multiplicación. Lo interesante de esta implementación es que la función interna solo recibe uno de los dos valores necesarios para la multiplicación; el otro queda que fijado cuando se ejecuta la función externa crear_multiplicador.\nPara que duplicar y triplicar funcionen correctamente, ambas funciones internas deben conservar acceso al entorno en el que está definido el valor de x. Ese mecanismo, que permite a una tener acceso a las variables de su contexto incluso después de que la ejecución de la función externa haya concluído, es precisamente lo que se conoce como un closure.\n\ndef crear_multiplicador(x):\n    def interna(y):\n        return y * x\n    return interna\n\nduplicar = crear_multiplicador(2)\ntriplicar = crear_multiplicador(3)\n\nprint(duplicar(5))\nprint(triplicar(5))\n\n10\n15\n\n\nEl siguiente ejemplo hace aún más evidente el funcionamiento de este mecanismo.\nDentro del cuerpo de la function factory externa, se define valor con el número 256. Luego, la función interna hace uso de esta variable valor dentro de print.\n\ndef externa():\n    valor = 256\n    def closure():\n        print(f\"¡El valor es: {valor}!\")\n    return closure\n\nrevelar_numero = externa()\nrevelar_numero()\n\n¡El valor es: 256!\n\n\nAunque desde fuera no podemos acceder directamente a valor:\nvalor\n\nNameError: name 'valor' is not defined\n\nla función interna sí puede hacerlo tantas veces como sea necesario:\n\nrevelar_numero()\nrevelar_numero()\nrevelar_numero()\n\n¡El valor es: 256!\n¡El valor es: 256!\n¡El valor es: 256!\n\n\nPara finalizar, veamos un ejemplo similar al anterior, pero donde el valor de la variable numero es desconocido para nosotros. Dicho valor se genera de manera aleatoria cuando se ejecuta la fábrica de funciones crear_funcion.\n\nimport random\n\ndef crear_funcion():\n    numero = random.randint(1, 1000)\n    def closure():\n        print(\"El valor es...\", numero)\n    return closure\n\nreveladora = crear_funcion()\n\nLuego, sin importar cuántas veces llamemos a reveladora, el mensaje será siempre el mismo, ya que el valor de numero se definió una sola vez en el momento en que se creó la función.\n\nreveladora()\n\nEl valor es... 393\n\n\n\nreveladora()\n\nEl valor es... 393\n\n\n\n\n\n\n\n\nUna dosis de precisión 🎯😱\n\n\n\nA menudo se dice que un closure es una función. Así, en el siguiente ejemplo, duplicar sería considerado un closure:\ndef crear_multiplicador(x):\n    def interna(y):\n        return y * x\n    return interna\n\nduplicar = crear_multiplicador(2)\nSin embargo, esa definición es un tanto imprecisa. Un closure no es simplemente una función, sino el mecanismo que permite a las funciones acceder a las variables del entorno en el que fueron definidas, incluso cuando ese entorno ya dejó de existir (por ejemplo, después de que termina la ejecución de la función externa que las creó).\nUf… ¡qué complicado!\n\n\n\n\n\n\n\n\nobject of type 'closure' is not subsettable 😵\n\n\n\nSi en R intentamos seleccionar filas o columnas de data sin haberle asignado un objeto previamente, obtendremos el siguiente error:\n\nError in data[1] : object of type 'closure' is not subsettable\n\nEsto ocurre porque data es en realidad una función en R. En este lenguaje, el tipo de los objetos función se denomina closure, haciendo referencia la capacidad que tienen las funciones de acceder a valores del ambiente donde fueron definidas.",
    "crumbs": [
      "Teoría",
      "U2 - Programación Funcional",
      "1 - Fundamentos"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/02_recursion.html",
    "href": "teoria/02_programacion_funcional/02_recursion.html",
    "title": "2 - Recursión",
    "section": "",
    "text": "En el apunte anterior vimos que en Python las funciones son ciudadanos de primera clase. Esto significa que una función es un objeto, al igual que un número, una cadena de texto o incluso un diccionario anidado con una estructura bastante enredada. Gracias a esto, no solo podemos inspeccionar sus atributos o hacer que una función llame a otras, sino que también es posible que una función cree y retorne nuevas funciones.\nAdemás de los casos ya mencionados, también es posible que una función se llame a sí misma. Es decir, que en el cuerpo de la definición de esa función se incluya una llamada a la función que se está definiendo (🤯). A este tipo de funciones se las llama recursivas, y la técnica en sí recibe el nombre de recursión.\nAunque pueda sonar extraño que una función se invoque a sí misma, en programación existen problemas para los que funciones recursivas resultan una solución natural y efectiva.",
    "crumbs": [
      "Teoría",
      "U2 - Programación Funcional",
      "2 - Recursión"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/02_recursion.html#introducción",
    "href": "teoria/02_programacion_funcional/02_recursion.html#introducción",
    "title": "2 - Recursión",
    "section": "",
    "text": "En el apunte anterior vimos que en Python las funciones son ciudadanos de primera clase. Esto significa que una función es un objeto, al igual que un número, una cadena de texto o incluso un diccionario anidado con una estructura bastante enredada. Gracias a esto, no solo podemos inspeccionar sus atributos o hacer que una función llame a otras, sino que también es posible que una función cree y retorne nuevas funciones.\nAdemás de los casos ya mencionados, también es posible que una función se llame a sí misma. Es decir, que en el cuerpo de la definición de esa función se incluya una llamada a la función que se está definiendo (🤯). A este tipo de funciones se las llama recursivas, y la técnica en sí recibe el nombre de recursión.\nAunque pueda sonar extraño que una función se invoque a sí misma, en programación existen problemas para los que funciones recursivas resultan una solución natural y efectiva.",
    "crumbs": [
      "Teoría",
      "U2 - Programación Funcional",
      "2 - Recursión"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/02_recursion.html#cuenta-regresiva",
    "href": "teoria/02_programacion_funcional/02_recursion.html#cuenta-regresiva",
    "title": "2 - Recursión",
    "section": "Cuenta regresiva",
    "text": "Cuenta regresiva\nSupongamos que queremos crear una función que imprima una cuenta regresiva desde un número entero dado hasta el 0. Es decir, la función se debería comportar de la siguiente manera:\nregresiva(3)\n3\n2\n1\n0\nregresiva(5)\n5\n4\n3\n2\n1\n0\nUna implementación no recursiva es la siguiente, basada en un bucle while:\ndef regresiva(n):\n    while n &gt; 0:\n        print(n)\n        n = n - 1\nOtra alternativa, que usa un bucle for y un range es:\ndef regresiva(n):\n    for i in range(n, -1, -1):\n        print(i)\nAmbas implementaciones resultan en funciones que se comportan correctamente y producen el resultado deseado.\nSin embargo, existe una alternativa recursiva para obtener la secuencia de números deseados.\n\ndef regresiva(i):\n    print(i)\n1    if i &gt; 0:\n        regresiva(i - 1)\n2    else:\n        return\n\n\n1\n\nEl caso recursivo: Es la condición donde la función se llama a sí misma. En este caso, regresiva vuelve a llamarse a sí misma solo cuando el número impreso sea mayor que 0. La llamada se hace pasando como argumento el valor i - 1, lo que nos acerca progresivamente al caso base.\n\n2\n\nEl caso base: Es la condición que detiene la recursión. Cuando se cumple, la función devuelve un valor sin volver a llamarse a sí misma, lo que evita que la ejecución continúe de manera infinita.\n\n\n\n\nAmbos casos trabajan en conjunto. Por un lado, el caso recursivo es la parte de la función que se llama a sí misma, pero con una entrada modificada que se acerca progresivamente al caso base. Por el otro, el caso base es la condición que detiene las llamadas recursivas, representando la versión más simple del problema que puede ser resuelta directamente.\n\nregresiva(3)\n\n3\n2\n1\n0\n\n\n\nregresiva(5)\n\n5\n4\n3\n2\n1\n0\n\n\n\n\n\n\n\n\nVersión con return implícito\n\n\n\nLa función recursiva regresiva usa return para terminar su ejecución devolviendo un None implícito en el caso base. Otra forma de implementar la misma función es omitiendo el return:\ndef regresiva(i):\n    print(i)\n    if i &gt; 0:\n1        regresiva(i - 1)\n2\n\n1\n\nEsta línea marca el caso recursivo y es idéntica a la anterior.\n\n2\n\nAcá no se usa return para devolver None, directamente no se escribe nada. El efecto es el mismo y constituye el caso base. En Python, si una función no incluye ningún return, se comporta como si al final hubiera un return o return None, es decir, la función termina y devuelve None.\n\n\n\n\n\nVersión comentada\nPara entender mejor el funcionamiento de la función recursiva progresiva, se pueden incorporar unos print en el cuerpo de la misma. En el ejemplo de abajo se muestra un print justo cuando la función es llamada, y otro cuando la función vuelve a invocarse a sí misma.\ndef regresiva(i):\n    print(f\"regresiva({i})\")\n    print(i)\n    if i &gt; 0:\n        print(f\"regresiva({i}) --&gt; regresiva({i -1})\")\n        regresiva(i - 1)\n\nregresiva(2)\n1regresiva(2)\n22\n3regresiva(2) --&gt; regresiva(1)\n4regresiva(1)\n51\n6regresiva(1) --&gt; regresiva(0)\n7regresiva(0)\n80\n\n1\n\nSe ejecuta regresiva con i = 2\n\n2\n\nregresiva(2) imprime 2\n\n3\n\nregresiva(2) llama a regresiva(1)\n\n4\n\nSe ejecuta regresiva con i = 1\n\n5\n\nregresiva(1) imprime 1\n\n6\n\nregresiva(1) llama a regresiva(0)\n\n7\n\nSe ejecuta regresiva con i = 0\n\n8\n\nregresiva(0) imprime 0\n\n\n\n\n¡Qué no falte el caso base!\nCuando escribimos una función recursiva es fundamental implementar el caso base, que determina la condición donde la función deja de llamarse a sí misma y comienza a devolver un valor.\nDebajo se muestra una implementación incorrecta de la función regresiva como función recursiva. La misma tiene el caso recursivo, donde la función se llama a sí misma, pero le falta el caso base, que es el que detiene esa cadena de llamadas. Como resultado, la función sigue contando números, incluso negativos, y Python termina frenando la ejecución con un RecursionError. Este error aperece cuando la profundidad de la pila de llamadas recursivas supera un límite predeterminado y, como regla general, indica que hay un problema en nuestra recursión.\ndef regresiva(i):\n    print(i)\n    regresiva(i - 1)\n\nregresiva(1)\n\n1\n0\n-1\n-2\n...\n-988\n-989\nTraceback (most recent call last):\n  File \"&lt;python-input-5&gt;\", line 1, in &lt;module&gt;\n    regresiva(1)\n    ~~~~~~~~~^^^\n  File \"&lt;python-input-2&gt;\", line 3, in regresiva\n    regresiva(i - 1)\n    ~~~~~~~~~^^^^^^^\n  File \"&lt;python-input-2&gt;\", line 3, in regresiva\n    regresiva(i - 1)\n    ~~~~~~~~~^^^^^^^\n  File \"&lt;python-input-2&gt;\", line 3, in regresiva\n    regresiva(i - 1)\n    ~~~~~~~~~^^^^^^^\n  [Previous line repeated 988 more times]\nRecursionError: maximum recursion depth exceeded",
    "crumbs": [
      "Teoría",
      "U2 - Programación Funcional",
      "2 - Recursión"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/02_recursion.html#factorial",
    "href": "teoria/02_programacion_funcional/02_recursion.html#factorial",
    "title": "2 - Recursión",
    "section": "Factorial",
    "text": "Factorial\nUn ejemplo clásico para estudiar cómo funciona la recursión en programación es el cálculo del factorial. El factorial de un número positivo \\(n\\) se define como:\n\\[\nn! = n \\times (n - 1) \\times (n - 2) \\times \\cdots \\times 2 \\times 1\n\\]\nEs decir, el factorial de un número es el producto de todos los enteros desde \\(1\\) hasta \\(n\\). Por convención, además, se establece que \\(0! = 1\\).\nUna forma de calcular el factorial de un número sin recurrir a la recursión es la siguiente:\n\ndef factorial(n):\n    resultado = 1\n    for i in range(2, n + 1):\n        resultado = resultado * i\n    return resultado\n\nfactorial(6)\n\n720\n\n\nSin embargo, y dado que el factorial admite la siguiente expresión como función recursiva,\n\\[\nn! = \\begin{cases}\n1 & \\text{para } n = 0 \\text{ o } n = 1 \\\\\nn \\times (n - 1)! & \\text {para } n \\ge 2\n\\end{cases}\n\\]\nse puede implementar en Python de la siguiente manera:\n\ndef factorial(n):\n    if n &lt;= 1:\n1        return 1\n    else:\n2        return n * factorial(n - 1)\n\n\n1\n\nCaso base.\n\n2\n\nCaso recursivo. La función hace uso del resultado que ella misma produce.\n\n\n\n\nPodemos ver algunos ejemplos:\n\nprint(\"factorial(1):\", factorial(1))\nprint(\"factorial(0):\", factorial(0))\nprint(\"factorial(6):\", factorial(6))\nprint(\"factorial(10):\", factorial(10))\n\nfactorial(1): 1\nfactorial(0): 1\nfactorial(6): 720\nfactorial(10): 3628800\n\n\n\nVersión comentada\nLa función regresiva nos sirvió como primera aproximación a la recursión. Sin embargo, en ella, no se hace uso del resultado que la misma función produce. En cambio, con factorial sí se utiliza el valor producido en el caso recursivo, lo que la vuelve más interesante para analizar cómo se van encadenando los distintos pasos.\n\ndef factorial(n):\n    print(f\"factorial({n})\")\n    if n &lt;= 1:\n        salida = 1\n    else:\n        print(f\"factorial({n}) -&gt; factorial({n - 1})\")\n        salida = n * factorial(n - 1)\n\n    print(f\"&gt; factorial({n}) devuelve {salida}\")\n    return salida\n\nfactorial(4)\n\nfactorial(4)\nfactorial(4) -&gt; factorial(3)\nfactorial(3)\nfactorial(3) -&gt; factorial(2)\nfactorial(2)\nfactorial(2) -&gt; factorial(1)\nfactorial(1)\n&gt; factorial(1) devuelve 1\n&gt; factorial(2) devuelve 2\n&gt; factorial(3) devuelve 6\n&gt; factorial(4) devuelve 24\n\n\n24\n\n\nEl proceso arranca con la llamada a factorial(4). Para calcular su resultado, la función necesita antes el valor de factorial(3). Esa, a su vez, depende de factorial(2), que depende de factorial(1). Finalmente, cuando llegamos a factorial(1), entramos en el caso base, que devuelve un resultado sin hacer más llamadas.\nPor eso primero vemos cómo se acumula la pila de llamadas, que crece paso a paso hasta llegar al caso base. Recién ahí comienza el camino de regreso: cada llamada se va resolviendo, utilizando el valor devuelto por la llamada anterior, hasta llegar de nuevo a factorial(4), donde se completa el cálculo y obtenemos el resultado final.",
    "crumbs": [
      "Teoría",
      "U2 - Programación Funcional",
      "2 - Recursión"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/02_recursion.html#letra-chica",
    "href": "teoria/02_programacion_funcional/02_recursion.html#letra-chica",
    "title": "2 - Recursión",
    "section": "Letra chica",
    "text": "Letra chica\nCada vez que una función se invoca a sí misma, crea un nuevo contexto de ejecución (con sus propias variables locales y el punto al que debe regresar) y lo apila sobre el anterior en una estructura que se llama pila de llamadas (del inglés, call stack). Por lo tanto, cuando llamamos a factorial(4), apilamos cuatro contextos de ejecución distintos, uno por cada llamada que va quedando pendiente, antes de empezar a devolver resultados.\nEste apilamiento no es gratis, consume memoria de nuestra computadora. Aunque para factorial(4) el consumo de memoria es insignificante, si intentáramos calcular un factorial muy grande, la pila podría crecer hasta agotar la cantidad de memoria disponible en nuestra computadora. Para evitar que las funciones recursivas causen una falla estrepitosa, Python establece un límite en la profundidad de la recursión. Al alcanzarlo, el intérprete se detiene con la excepción RecursionError que nos proteje de una ejecución recursiva infinita o excesivamente profunda.\nDado su potencial alto consumo de memoria y la sobrecarga que genera gestionar la pila de llamadas, una implementación recursiva no suele ser la más eficiente. De hecho, su equivalente iterativo suele ser más eficiente y además evita los riesgos asociados al desbordamiento de la pila. Sin embargo, el principal valor de la recursión reside en la claridad conceptual para modelar problemas de naturaleza inherentemente recursiva.",
    "crumbs": [
      "Teoría",
      "U2 - Programación Funcional",
      "2 - Recursión"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/problemas.html",
    "href": "practica/01_programacion_en_python/problemas.html",
    "title": "🧩 Problemas",
    "section": "",
    "text": "En criptografía, el cifrado César es una de las técnicas de cifrado más simples y más usadas.\nEs un tipo de cifrado en el que una letra en el texto original es reemplazada por otra letra que se encuentra un número fijo de posiciones más adelante en el alfabeto.\nPor ejemplo, con un desplazamiento de 3, la A sería sustituida por la D (situada 3 lugares a la derecha de la A), la B sería reemplazada por la E, etc.\n\n\n\n\n\nEscriba una función, y luego un script, que permita cifrar y descifrar cadenas usando el cifrado César con un número arbitrario de posiciones.\nDos funciones incluidas con Python que pueden ser útiles para esta tarea son ord(), que convierte caracteres numéricos a números, y chr(), que realiza la operación inversa.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara el cifrado de un único caracter:\n\nDefinir un desplazamiento, por ejemplo 3.\nConvertir el caracter a número usando ord().\nSumarle desplazamiento.\nFinalmente, convertirlo a caracter nuevamente utilizando chr().\n\nY para el descifrado:\n\nConvertir el caracter a número.\nRestarle desplazamiento.\nConvertirlo a caracter nuevamente utilizando chr().\n\nAsí, se debería recuperar el caracter definido al principio.",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🧩 Problemas"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/problemas.html#cifrado-césar",
    "href": "practica/01_programacion_en_python/problemas.html#cifrado-césar",
    "title": "🧩 Problemas",
    "section": "",
    "text": "En criptografía, el cifrado César es una de las técnicas de cifrado más simples y más usadas.\nEs un tipo de cifrado en el que una letra en el texto original es reemplazada por otra letra que se encuentra un número fijo de posiciones más adelante en el alfabeto.\nPor ejemplo, con un desplazamiento de 3, la A sería sustituida por la D (situada 3 lugares a la derecha de la A), la B sería reemplazada por la E, etc.\n\n\n\n\n\nEscriba una función, y luego un script, que permita cifrar y descifrar cadenas usando el cifrado César con un número arbitrario de posiciones.\nDos funciones incluidas con Python que pueden ser útiles para esta tarea son ord(), que convierte caracteres numéricos a números, y chr(), que realiza la operación inversa.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara el cifrado de un único caracter:\n\nDefinir un desplazamiento, por ejemplo 3.\nConvertir el caracter a número usando ord().\nSumarle desplazamiento.\nFinalmente, convertirlo a caracter nuevamente utilizando chr().\n\nY para el descifrado:\n\nConvertir el caracter a número.\nRestarle desplazamiento.\nConvertirlo a caracter nuevamente utilizando chr().\n\nAsí, se debería recuperar el caracter definido al principio.",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🧩 Problemas"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/problemas.html#números-aleatorios",
    "href": "practica/01_programacion_en_python/problemas.html#números-aleatorios",
    "title": "🧩 Problemas",
    "section": "2 Números aleatorios",
    "text": "2 Números aleatorios\nConstruya un programa en Python que genere una cantidad determinada de números aleatorios uniformes dentro de un rango definido por el usuario. El programa debe:\n\nSolicitar al usuario la cantidad de números a generar y los valores mínimo y máximo del rango.\nGenerar los números aleatorios\nGuardar los números en un archivo de texto, uno por línea.\nOfrecer la opción de mostrar un resumen estadístico con mínimo, máximo, media y desvío estándar, solo si el usuario lo solicita.\n\nPara resolver este problema utilice el módulo random y las funciones desarrolladas en el ejercicio Resúmenes estadísticos guardadas en un módulo llamado estadistica.py.",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🧩 Problemas"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/problemas.html#mensaje-al-descubierto",
    "href": "practica/01_programacion_en_python/problemas.html#mensaje-al-descubierto",
    "title": "🧩 Problemas",
    "section": "3 Mensaje al descubierto",
    "text": "3 Mensaje al descubierto\nResulta que Franco, un amigo que estudia Ciencias de la Computación en la FCEIA, te envía por WhatsApp un archivo de texto plano con mensajes “encriptados” usando caracteres sobrantes y símbolos extraños:\n    !!!,.,  aY??/u/DAM**e,, se =m!!e\n&&M&&e v!o!?LV...I.O /L/*oC/*o\n        __?e_?l//+ T++**e/*Cl!?aD==*O**\nTiene sentido pensar que está experimentando con nuevos algoritmos de cifrado y, de paso, te lanza el reto de descifrarlo.\nTu misión es escribir un programa que:\n\nLea un archivo de texto plano cualquiera.\nMuestre en pantalla su contenido original (tal cual llega).\nAplique un proceso de limpieza basado en las siguientes reglas:\n\nEliminar todos los caracteres +, *, -, /, =, !, ?, & y _.\nReemplazar cualquier secuencia de espacios múltiples por un solo espacio.\nHomogeinizar la capitalización de los caracteres.\nConservar los saltos de línea tal cual aparecen en el archivo original.\n\nMuestre en pantalla la versión desencriptada del texto.\nGuarde la versión limpia en un nuevo archivo de texto.\n\nEl usuario debe poder especificar el nombre del archivo de salida.\nSi no lo hace, se generará uno con el sufijo _limpio antes de la extensión original (por ejemplo, secreto.txt → secreto_limpio.txt).",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🧩 Problemas"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/problemas.html#código-morse",
    "href": "practica/01_programacion_en_python/problemas.html#código-morse",
    "title": "🧩 Problemas",
    "section": "4 Código Morse",
    "text": "4 Código Morse\nEl código Morse es un sistema utilizado para representar letras mediante combinaciones específicas de señales cortas y largas, denominadas puntos (.) y rayas (-). A continuación se muestra un diccionario con el mapeo de caracteres alfabéticos, dígitos del 0 al 9 y algunos símbolos de puntuación comunes:\nmapeo_morse = {\n    \"A\": \".-\",\n    \"B\": \"-...\",\n    \"C\": \"-.-.\",\n    \"D\": \"-..\",\n    \"E\": \".\",\n    \"F\": \"..-.\",\n    \"G\": \"--.\",\n    \"H\": \"....\",\n    \"I\": \"..\",\n    \"J\": \".---\",\n    \"K\": \"-.-\",\n    \"L\": \".-..\",\n    \"M\": \"--\",\n    \"N\": \"-.\",\n    \"O\": \"---\",\n    \"P\": \".--.\",\n    \"Q\": \"--.-\",\n    \"R\": \".-.\",\n    \"S\": \"...\",\n    \"T\": \"-\",\n    \"U\": \"..-\",\n    \"V\": \"...-\",\n    \"W\": \".--\",\n    \"X\": \"-..-\",\n    \"Y\": \"-.--\",\n    \"Z\": \"--..\",\n    \"1\": \".----\",\n    \"2\": \"..---\",\n    \"3\": \"...--\",\n    \"4\": \"....-\",\n    \"5\": \".....\",\n    \"6\": \"-....\",\n    \"7\": \"--...\",\n    \"8\": \"---..\",\n    \"9\": \"----.\",\n    \"0\": \"-----\",\n    \", \": \"--..--\",\n    \".\": \".-.-.-\",\n}\nEscriba una función en Python que permita convertir cualquier palabra a código Morse utilizando este diccionario. Luego, escriba otra función que haga exactamente lo contrario: dada una secuencia en código Morse, debe recuperar la palabra original. Finalmente, incorpore ambas funciones en un script principal que combine ambas funciones y permita encriptar o desencriptar texto desde un archivo de texto plano. El programa debe recibir:\n\nEl nombre del archivo de entrada.\nEl nombre del archivo de salida.\nLa operación a realizar (encriptar o desencriptar).\n\nAyuda: Para indicar espacios en código Morse utilice /.",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🧩 Problemas"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html",
    "href": "practica/01_programacion_en_python/ejercicios.html",
    "title": "🛠️ Ejercicios",
    "section": "",
    "text": "Escriba una función en Python que reciba el radio de un círculo y devuelva su área. Luego, escriba otra función que también reciba el radio de un círculo, pero devuelva su perímetro. Finalmente, escriba una tercera función que reciba el radio de un círculo y devuelva tanto el área como el perímetro.\nUna vez que haya implementado todas las funciones, analice la diferencia entre:\narea, perimetro = calcular_area_y_perimetro(radio=5)\ny\nresultados = calcular_area_y_perimetro(radio=5)\nConsidere el tipo de las variables area, perimetro y resultados.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\n\\[\n\\begin{aligned}\nA &= \\pi \\cdot r^2 \\\\\nP &= 2 \\cdot \\pi \\cdot r\n\\end{aligned}\n\\]",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#área-y-perímetro-de-un-círculo",
    "href": "practica/01_programacion_en_python/ejercicios.html#área-y-perímetro-de-un-círculo",
    "title": "🛠️ Ejercicios",
    "section": "",
    "text": "Escriba una función en Python que reciba el radio de un círculo y devuelva su área. Luego, escriba otra función que también reciba el radio de un círculo, pero devuelva su perímetro. Finalmente, escriba una tercera función que reciba el radio de un círculo y devuelva tanto el área como el perímetro.\nUna vez que haya implementado todas las funciones, analice la diferencia entre:\narea, perimetro = calcular_area_y_perimetro(radio=5)\ny\nresultados = calcular_area_y_perimetro(radio=5)\nConsidere el tipo de las variables area, perimetro y resultados.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\n\\[\n\\begin{aligned}\nA &= \\pi \\cdot r^2 \\\\\nP &= 2 \\cdot \\pi \\cdot r\n\\end{aligned}\n\\]",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#promociones",
    "href": "practica/01_programacion_en_python/ejercicios.html#promociones",
    "title": "🛠️ Ejercicios",
    "section": "2 Promociones",
    "text": "2 Promociones\nEscriba una función llamada calcular_precio que reciba dos argumentos: el monto total de una compra y el medio de pago utilizado.\nEl medio de pago puede ser \"efectivo\", \"débito\" o \"crédito\", y según el caso se aplicará una modificación sobre el monto:\n\nSi el medio de pago es \"efectivo\", el monto no se modifica.\nSi es \"débito\", se aplica un descuento del 10% sobre el monto.\nSi es \"crédito\", se aplica un recargo del 5% sobre el monto.\n\nLa función debe retornar el monto final a pagar, con el descuento o recargo aplicado según corresponda.\n\nPunto extra\nModifique la función de modo tal que no sea necesario especificar el medio de pago. En tal caso, el medio de pago se asume \"efectivo\". Ayuda: asigne un valor por defecto al argumento medio. Considere una implementación donde este sea \"efectivo\" y otra donde sea None.",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#etapas-de-la-vida",
    "href": "practica/01_programacion_en_python/ejercicios.html#etapas-de-la-vida",
    "title": "🛠️ Ejercicios",
    "section": "3 Etapas de la vida",
    "text": "3 Etapas de la vida\nImplemente una función que reciba una edad y devuelva un mensaje que indique la etapa de la vida correspondiente.\nUtilice una cadena de condicionales if-elif-else para clasificar la edad en alguno de los siguientes grupos:\n\nMenor a 2 años: bebé.\nEntre 2 (inclusive) y 4 años: infante.\nEntre 4 (inclusive) y 13 años: niño/a.\nEntre 13 (inclusive) y 20 años: adolescente.\nEntre 20 (inclusive) y 65 años: adulto/a.\n65 años o más: persona mayor.\n\nLa función debe imprimir un mensaje del tipo: \"La persona es un/a &lt;etapa&gt;\".",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres",
    "href": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres",
    "title": "🛠️ Ejercicios",
    "section": "4 Conteo de caracteres",
    "text": "4 Conteo de caracteres\nEscriba una función que reciba una cadena de texto y devuelva un diccionario que indique cuántas veces aparece cada caracter en la cadena. La función no debe diferenciar entre mayúsculas y minúsculas y debe ignorar espacios. Utilice el siguiente ejemplo como validación:\ncontar_caracteres(\"Ahora es mejor que nunca\")\n# {\"a\": 3, \"h\": 1, \"o\": 2, \"r\": 2, \"e\": 3, \"s\": 1, \"m\": 1, \"j\": 1, \"q\": 1, \"u\": 2, \"n\": 2, \"c\": 1}\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara saltear pasos de un bucle cuando se encuentra un espacio se puede utilizar la sentencia continue.\nfor i in ...:\n    # ... &lt;- Se ejecuta en todas las iteraciones\n    if condicion_de_salto:\n        continue\n    # ... &lt;- Se ejecuta en las iteraciones 'condicion_de_salto' es False",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#orden-de-mérito",
    "href": "practica/01_programacion_en_python/ejercicios.html#orden-de-mérito",
    "title": "🛠️ Ejercicios",
    "section": "5 Orden de mérito",
    "text": "5 Orden de mérito\nSe cuenta con una lista de tuplas que contienen las notas del examen final de Programación 2 para un conjunto de alumnos:\nnotas = [\n    (\"Escalada\", 9),\n    (\"Alonso\", 7),\n    (\"Pérez\", 8),\n    (\"Castro\", 8),\n    (\"Rossini\", 10),\n    (\"Martínez\", 9),\n    (\"Pérez\", 6),\n    (\"Riquelme\", 5),\n]\n\nEscriba un programa que a partir de notas genere un diccionario donde las claves se corresponden con los apellidos y los valores con las notas del examen final.\nEscriba un programa que a partir de notas genere un diccionario donde las claves son las notas y el valor asociado sea una lista con los apellidos de quienes tuvieron esa nota.",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#rendimento-académico",
    "href": "practica/01_programacion_en_python/ejercicios.html#rendimento-académico",
    "title": "🛠️ Ejercicios",
    "section": "6 Rendimento académico",
    "text": "6 Rendimento académico\nSe cuenta con el siguiente diccionario que asocia nombres de estudiantes con una lista de sus calificaciones:\nnotas = {\n    \"Ana\": [8, 9, 10],\n    \"Luis\": [6, 7, 8, 3, 9],\n    \"Carla\": [10, 9, 10],\n    \"Marcos\": [5, 6],\n    \"Sofía\": [7, 7, 8],\n    \"Pedro\": [6, 4, 5, 6, 3, 8],\n    \"Lucía\": [9, 8, 10, 9]\n}\nImplemente una función que resuma el rendimiento académico de los estudiantes. La función debe recibir el diccionario de notas y un argumento adicional llamado modo. Según el valor de modo, se debe devolver un nuevo diccionario con la siguiente información:\n\nSi modo es \"promedio\", se debe devolver el promedio de notas por estudiante.\nSi modo es \"proporcion\", se debe devolver la proporción de exámenes aprobados por estudiante (se considera aprobado todo valor mayor o igual a 6).",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#índice-de-precios",
    "href": "practica/01_programacion_en_python/ejercicios.html#índice-de-precios",
    "title": "🛠️ Ejercicios",
    "section": "7 Índice de precios",
    "text": "7 Índice de precios\nSe cuenta con la serie mensual del Índice de Precios al Consumidor (IPC) del año 2024:\nipc_2024 = [20.6, 13.2, 11.0, 8.8, 4.2, 4.6, 4.0, 4.2, 3.5, 2.7, 2.4, 2.7]\nRealice los siguientes cálculos y análisis:\n\nDetermine el menor y el mayor índice reportado durante el año.\nCalcule el IPC promedio mensual del 2024.\nEncuentre la diferencia entre el IPC mínimo y máximo del año.\n\n¿En qué mes se registró la inflación más alta?\n\nCalcule la inflación mediana del 2024.\n¿Cómo podría calcular el rango del IPC (diferencia entre el valor máximo y mínimo) sin usar las funciones min() ni max()?",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#resúmenes-estadísticos",
    "href": "practica/01_programacion_en_python/ejercicios.html#resúmenes-estadísticos",
    "title": "🛠️ Ejercicios",
    "section": "8 Resúmenes estadísticos",
    "text": "8 Resúmenes estadísticos\nCree funciones que, dada una lista de números, calculen los siguientes resúmenes estadísticos:\n\nLa media \\[\n\\text{media}(X) = \\frac{1}{n}\\sum_{i=1}^n{x_i}\n\\]\nEl rango \\[\n\\text{rango}(X) = \\text{max}(X) - \\text{min}(X)\n\\]\nLa varianza \\[\n\\text{var}(X) = \\frac{1}{n}\\sum_{i=1}^n{(x_i - \\bar{x})^2}\n\\]\nEl desvío estándar \\[\n\\text{sd}(X) = \\sqrt{\\text{var}(X)}\n\\]\nLa mediana \\[\n\\begin{array}{lr}\n\\text{mediana}(X) = x_{(\\frac{n + 1}{2})} & \\text{Si } n \\text{ es impar} \\\\\n\\text{mediana}(X) = \\frac{x_{(\\frac{n}{2})} + x_{(\\frac{n}{2}+1)}}{2} & \\text{Si } n \\text{ es par}\n\\end{array}\n\\]\ndonde los \\(x_{(i)}\\) están ordenados de manera ascendente.",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#validación-de-dni",
    "href": "practica/01_programacion_en_python/ejercicios.html#validación-de-dni",
    "title": "🛠️ Ejercicios",
    "section": "9 Validación de DNI",
    "text": "9 Validación de DNI\nCrear una función que dada una cadena de caracteres verifique si se corresponde con un DNI.\nSi es un DNI, devolver True. Caso contrario, devolver False.\nA tener en cuenta:\n\nAlgunos ejemplos de DNI válidos\n\n40.094.127\n19053512\n6.392.780\n\nDNI no válidos\n\n40,094,127\n19-053-512\n123456",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#la-física-del-rebote",
    "href": "practica/01_programacion_en_python/ejercicios.html#la-física-del-rebote",
    "title": "🛠️ Ejercicios",
    "section": "10 La física del rebote",
    "text": "10 La física del rebote\nUna pelota de goma es lanzada desde una altura inicial de 100 metros. Cada vez que toca el suelo, rebota alcanzando una altura equivalente a 3/5 de la altura desde la que cayó.\nEscriba un programa que imprima una tabla mostrando las alturas alcanzadas por la pelota en cada uno de sus primeros 10 rebotes.\nLuego, implemente este programa como una función que reciba dos parámetros:\n\nAltura inicial desde la que se lanza la pelota.\nCantidad de rebotes que se desea calcular.\n\nLa función debe devolver una lista con las alturas alcanzadas en cada rebote.\n\nPunto extra\nModifique la función para que considere un rebote como “significativo” solo si la altura alcanzada es mayor o igual a un valor mínimo especificado (por ejemplo, 1 centímetro).\nSi la pelota no alcanza esta altura mínima en algún rebote, se considera que ha completado su trayectoria y queda quieta. En este caso, la función debe devolver únicamente los valores correspondientes a los “rebotes significativos”.",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#un-montón-de-plata",
    "href": "practica/01_programacion_en_python/ejercicios.html#un-montón-de-plata",
    "title": "🛠️ Ejercicios",
    "section": "11 Un montón de plata",
    "text": "11 Un montón de plata\nUna mañana ponés un billete en la vereda al lado del Monumento a la Bandera. A partir de ahí, cada día vas y duplicás la cantidad de billetes, apilándolos prolijamente. ¿Cuánto tiempo pasa antes de que la pila de billetes sea más alta que la del Monumento?\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nAlgunas constantes útiles para resolver el problema:\nbillete_grosor = 0.11 * 0.001  # grosor de un billete en metros\naltura_monumento = 70          # altura en metros\nSugerencia: Usar un bucle while para realizar el cálculo.\n\n\n\n\nPunto extra\nEscribe una función que permita determinar la cantidad de días necesarios para superar cualquier altura arbitraria.",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#la-conjetura-de-collatz",
    "href": "practica/01_programacion_en_python/ejercicios.html#la-conjetura-de-collatz",
    "title": "🛠️ Ejercicios",
    "section": "12 La conjetura de Collatz",
    "text": "12 La conjetura de Collatz\nLa conjetura de Collatz dice:\n\nSi tomamos un número natural cualquiera, su secuencia de Collatz termina llegando siempre al número 1.\n\nSecuencia de Collatz:\n\nSi el número es par, se divide entre 2.\nSi el número es impar, se multiplica por 3 y se le suma 1.\n\n\\[\nf(n) =\n\\begin{cases}\n    \\displaystyle \\frac{n}{2} & \\text{si } n \\text{ es par,} \\\\ \\\\\n    3n + 1 & \\text{si } n \\text{ es impar.}\n\\end{cases}\n\\]\nEscribir una función que calcule la secuencia de Collatz para un número natural cualquiera.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\n\nUtilizar bucle while.\nEl bucle debe correr solo cuando el valor de la secuencia sigue siendo mayor a 1. Si es 1, hay que frenar.\nInsertar los elementos de la secuencia en una lista.",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#adivina-el-número",
    "href": "practica/01_programacion_en_python/ejercicios.html#adivina-el-número",
    "title": "🛠️ Ejercicios",
    "section": "13 Adivina el número",
    "text": "13 Adivina el número\nEscriba un programa que implemente el clásico juego “Adivina el número”. El programa debe:\n\nTener un número secreto (entero) que el usuario debe adivinar.\nSolicitar al usuario que ingrese un número.\nSi el número ingresado no coincide con el número secreto:\n\nInformar si el número ingresado es mayor o menor que el número secreto.\nPedir al usuario que intente nuevamente.\n\nSi el usuario adivina el número, el programa debe terminar mostrando un mensaje de felicitaciones.\n\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara generar números aleatorios enteros en un rango dado puede utilizar randint() del módulo random:\nimport random\nrandom.randint(-100, 100)     # Genera un número aleatorio entre -100 y 100\n\n\n\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nEl programa que resuelve este problema realiza una cantidad de iteraciones que se desconoce al momento de escribirlo. La solución típica a este tipo de problema involucra el uso de while True junto a la sentencia break.\nwhile True:\n    # realizar alguna accion\n    if condicion_de_salida:\n        break\n\n\n\n\nPunto extra\nImplemente una versión de este programa donde el usuario cuenta con 10 intentos.",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres-pythonico",
    "href": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres-pythonico",
    "title": "🛠️ Ejercicios",
    "section": "14 Conteo de caracteres Pythonico",
    "text": "14 Conteo de caracteres Pythonico\nLos diccionarios en Python cuentan con un método .get() que devuelve el valor asociado a una clave. Este método permite pasarle un segundo argumento con un valor que se devuelve cuando no se encuentra un elemento asociado a la clave que le pasamos. Por ejemplo:\nd = {\"a\": 1, \"b\": 20}\nd.get(\"b\", 0)\n20\nd.get(\"c\", 0)\n0\nModifique la función contar_caracteres del ejercicio Conteo de caracteres utilizando el metodo .get() para obtener una implementación más sencilla. Así, debería poder eliminar el bloque if.",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#validador-de-contraseñas",
    "href": "practica/01_programacion_en_python/ejercicios.html#validador-de-contraseñas",
    "title": "🛠️ Ejercicios",
    "section": "15 Validador de contraseñas 😱",
    "text": "15 Validador de contraseñas 😱\nEscriba un programa que solicite al usuario una contraseña y verifique que cumpla con las siguientes condiciones:\n\nDebe tener entre de 8 y 24 caracteres.\nDebe incluir letras, números y caracteres especiales (@#$%^&*()).\n\nSi la contraseña no es válida, el programa debe informar al usuario qué condición no se cumple y permitirle ingresar una nueva contraseña. El proceso se repite hasta que el usuario ingrese una contraseña válida o decida no continuar.",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres-ii",
    "href": "practica/01_programacion_en_python/ejercicios.html#conteo-de-caracteres-ii",
    "title": "🛠️ Ejercicios",
    "section": "16 Conteo de caracteres II 😱",
    "text": "16 Conteo de caracteres II 😱\nAgregue a la función contar_frecuencias del ejercicio Conteo de caracteres un argumento llamado orden que admita los valores \"aparicion\", \"alfabetico\" y \"frecuencia\".\nEste argumento debe permitir ordenar las claves del diccionario resultante según el siguiente criterio:\n\n\"aparicion\": mantiene el orden en que las palabras aparecen por primera vez en la lista original.\n\"alfabetico\": ordena las palabras alfabéticamente.\n\"frecuencia\": ordena las palabras por su frecuencia, de mayor a menor.",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/autoevaluacion.html",
    "href": "practica/04_estructuras_y_algoritmos/autoevaluacion.html",
    "title": "🪞 Autoevaluación",
    "section": "",
    "text": "Para un arreglo que contiene 100 elementos, indica la cantidad de pasos que llevarían las siguientes operaciones:\n\nLectura\nBúsqueda de un valor que no está contenido en el arreglo\nInserción al inicio del arreglo\nInserción al final del arreglo\nEliminación al inicio del arreglo\nEliminación al final del arreglo\n\nPara un conjunto basado en un arreglo que contiene 100 elementos, indica la cantidad de pasos que llevarían las siguientes operaciones:\n\nLectura\nBúsqueda de un valor que no está contenido en el conjunto\nInserción de un nuevo valor al inicio del conjunto\nInserción de un nuevo valor al final del conjunto\nEliminación al inicio del conjunto\nEliminación al final del conjunto\n\nEn general, la operación de búsqueda en un arreglo busca la primera instancia de un valor dado. Pero a veces queremos buscar todas las instancias de un valor determinado. Por ejemplo, supongamos que queremos contar cuántas veces aparece el valor \"manzana\" dentro de un arreglo. ¿Cuántos pasos tomaría encontrar todas las apariciones de \"manzana\"? Da tu respuesta en función de N.\nUse la notación Big O para describir la complejidad temporal de las siguientes funciones:\ndef es_bisiesto(valor):\n    if valor % 100 == 0:\n        if valor % 400 == 0:\n            return False\n        else:\n            return True\n    return valor % 4 == 0\ndef suma(arreglo):\n    total = 0\n    for numero in arreglo:\n        total += numero\n    return total\nLa siguiente función recibe un arreglo de cadenas y devuelve un nuevo arreglo que solo contiene las cadenas que comienzan con la letra \"a\". Use la notación Big O para describir la complejidad temporal de la función:\ndef seleccionar_cadenas_a(arreglo):\n    arreglo_nuevo = []\n    for cadena in arreglo:\n        if cadena[0] == \"a\":\n            arreglo_nuevo.append(cadena)\n    return arreglo_nuevo\nLa siguiente función calcula la mediana de un arreglo ordenado. Describa su complejidad temporal en términos de la notación Big O:\ndef mediana(arreglo):\n    if not arreglo:\n        return None\n\n    medio = len(arreglo) // 2\n\n    # Si el arreglo tiene una cantidad par de números:\n    if len(arreglo) % 2 == 0:\n        return (arreglo[medio - 1] + arreglo[medio]) / 2.0\n    else:  # Si el arreglo tiene una cantidad impar de números:\n        return arreglo[medio]\nReemplace los signos de interrogación en la siguiente tabla para describir cuántos pasos ocurren para una cantidad dada de elementos de datos, según distintos tipos de Big O:\n\n\n\nN elementos\nO(N)\nO(log N)\nO(N²)\n\n\n\n\n100\n100\n?\n?\n\n\n2000\n?\n?\n?\n\n\n\nLa siguiente función encuentra el producto más grande posible entre cualquier par de números dentro de un arreglo dado. Usá la notación Big O para describir la complejidad temporal de la siguiente función:\ndef greatest_product(arreglo):\n    if len(producto_mas_grande) &lt; 2:\n        return None\n\n    producto_mas_grande = arreglo[0] * arreglo[1]\n\n    for i, valor_i in enumerate(arreglo):\n        for j, valor_j in enumerate(arreglo):\n            if (i != j and valor_i * valor_j &gt; producto_mas_grande):\n                producto_mas_grande = valor_i * valor_j\n\n    return producto_mas_grande\nLa siguiente función verifica si un arreglo de números contiene un par de números cuya suma sea igual a 10:\ndef suma_de_pares(arreglo):\n    for i, valor_i in enumerate(arreglo):\n        for j, valor_j in enumerate(arreglo):\n            if (i != j) and (valor_i + valor_j == 10):\n                return True\n    return False\n\n¿Cuál es el mejor caso, el caso promedio y el peor caso?\nExprese el peor caso en términos de notación Big O.\n\nLa siguiente función encuentra el número más grande dentro de un arreglo, pero tiene una eficiencia de O(N²). Reescribí la función para que sea una versión más rápida, con eficiencia O(N):\ndef maximo(arreglo):\n    if not arreglo:\n        return None\n\n    for i in arreglo:\n        # Supongamos por ahora que i es el mayor\n        es_i_el_mas_grande = True\n\n        for j in arreglo:\n            # Si encontramos otro valor mayor que i, i no es el mayor\n            if j &gt; i:\n                es_i_el_mas_grande = False\n\n        # Si, al revisar todos los otros números, i sigue siendo el mayor,\n        # entonces i es el número más grande:\n        if es_i_el_mas_grande:\n            return i",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🪞 Autoevaluación"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/autoevaluacion.html#complejidad-computacional",
    "href": "practica/04_estructuras_y_algoritmos/autoevaluacion.html#complejidad-computacional",
    "title": "🪞 Autoevaluación",
    "section": "",
    "text": "Para un arreglo que contiene 100 elementos, indica la cantidad de pasos que llevarían las siguientes operaciones:\n\nLectura\nBúsqueda de un valor que no está contenido en el arreglo\nInserción al inicio del arreglo\nInserción al final del arreglo\nEliminación al inicio del arreglo\nEliminación al final del arreglo\n\nPara un conjunto basado en un arreglo que contiene 100 elementos, indica la cantidad de pasos que llevarían las siguientes operaciones:\n\nLectura\nBúsqueda de un valor que no está contenido en el conjunto\nInserción de un nuevo valor al inicio del conjunto\nInserción de un nuevo valor al final del conjunto\nEliminación al inicio del conjunto\nEliminación al final del conjunto\n\nEn general, la operación de búsqueda en un arreglo busca la primera instancia de un valor dado. Pero a veces queremos buscar todas las instancias de un valor determinado. Por ejemplo, supongamos que queremos contar cuántas veces aparece el valor \"manzana\" dentro de un arreglo. ¿Cuántos pasos tomaría encontrar todas las apariciones de \"manzana\"? Da tu respuesta en función de N.\nUse la notación Big O para describir la complejidad temporal de las siguientes funciones:\ndef es_bisiesto(valor):\n    if valor % 100 == 0:\n        if valor % 400 == 0:\n            return False\n        else:\n            return True\n    return valor % 4 == 0\ndef suma(arreglo):\n    total = 0\n    for numero in arreglo:\n        total += numero\n    return total\nLa siguiente función recibe un arreglo de cadenas y devuelve un nuevo arreglo que solo contiene las cadenas que comienzan con la letra \"a\". Use la notación Big O para describir la complejidad temporal de la función:\ndef seleccionar_cadenas_a(arreglo):\n    arreglo_nuevo = []\n    for cadena in arreglo:\n        if cadena[0] == \"a\":\n            arreglo_nuevo.append(cadena)\n    return arreglo_nuevo\nLa siguiente función calcula la mediana de un arreglo ordenado. Describa su complejidad temporal en términos de la notación Big O:\ndef mediana(arreglo):\n    if not arreglo:\n        return None\n\n    medio = len(arreglo) // 2\n\n    # Si el arreglo tiene una cantidad par de números:\n    if len(arreglo) % 2 == 0:\n        return (arreglo[medio - 1] + arreglo[medio]) / 2.0\n    else:  # Si el arreglo tiene una cantidad impar de números:\n        return arreglo[medio]\nReemplace los signos de interrogación en la siguiente tabla para describir cuántos pasos ocurren para una cantidad dada de elementos de datos, según distintos tipos de Big O:\n\n\n\nN elementos\nO(N)\nO(log N)\nO(N²)\n\n\n\n\n100\n100\n?\n?\n\n\n2000\n?\n?\n?\n\n\n\nLa siguiente función encuentra el producto más grande posible entre cualquier par de números dentro de un arreglo dado. Usá la notación Big O para describir la complejidad temporal de la siguiente función:\ndef greatest_product(arreglo):\n    if len(producto_mas_grande) &lt; 2:\n        return None\n\n    producto_mas_grande = arreglo[0] * arreglo[1]\n\n    for i, valor_i in enumerate(arreglo):\n        for j, valor_j in enumerate(arreglo):\n            if (i != j and valor_i * valor_j &gt; producto_mas_grande):\n                producto_mas_grande = valor_i * valor_j\n\n    return producto_mas_grande\nLa siguiente función verifica si un arreglo de números contiene un par de números cuya suma sea igual a 10:\ndef suma_de_pares(arreglo):\n    for i, valor_i in enumerate(arreglo):\n        for j, valor_j in enumerate(arreglo):\n            if (i != j) and (valor_i + valor_j == 10):\n                return True\n    return False\n\n¿Cuál es el mejor caso, el caso promedio y el peor caso?\nExprese el peor caso en términos de notación Big O.\n\nLa siguiente función encuentra el número más grande dentro de un arreglo, pero tiene una eficiencia de O(N²). Reescribí la función para que sea una versión más rápida, con eficiencia O(N):\ndef maximo(arreglo):\n    if not arreglo:\n        return None\n\n    for i in arreglo:\n        # Supongamos por ahora que i es el mayor\n        es_i_el_mas_grande = True\n\n        for j in arreglo:\n            # Si encontramos otro valor mayor que i, i no es el mayor\n            if j &gt; i:\n                es_i_el_mas_grande = False\n\n        # Si, al revisar todos los otros números, i sigue siendo el mayor,\n        # entonces i es el número más grande:\n        if es_i_el_mas_grande:\n            return i",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🪞 Autoevaluación"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/autoevaluacion.html#estructuras-de-datos-lineales",
    "href": "practica/04_estructuras_y_algoritmos/autoevaluacion.html#estructuras-de-datos-lineales",
    "title": "🪞 Autoevaluación",
    "section": "2 Estructuras de datos lineales",
    "text": "2 Estructuras de datos lineales\n\nSi estuvieras desarrollando un programa para un centro de llamadas que pone a los clientes en espera y luego los asigna al “próximo representante disponible”, ¿usarías una pila o una cola?\nSi se apilan números en una pila en el siguiente orden: 1, 2, 3, 4, 5, 6, y luego se desapilan dos elementos, ¿qué número quedaría visible en la parte superior de la pila?\nSi se insertan números en una cola en el siguiente orden: 1, 2, 3, 4, 5, 6, y luego se extraen dos elementos, ¿qué número sería el siguiente en salir de la cola?\nEscriba una función que use una pila para invertir una cadena de texto. (Por ejemplo, “abcde” debería convertirse en “edcba”)\n¿Qué valores se devuelven durante la siguiente serie de operaciones sobre una pila, si se ejecutan sobre una pila inicialmente vacía?\ninsertar(5)\ninsertar(3)\nextraer()\ninsertar(2)\ninsertar(8)\nextraer()\nextraer()\ninsertar(9)\ninsertar(1)\nextraer()\ninsertar(7)\ninsertar(6)\nextraer()\nextraer()\ninsertar(4)\nextraer()\nextraer()\n¿Qué valores se devuelven durante la siguiente secuencia de operaciones sobre una cola, si se ejecutan sobre una cola inicialmente vacía?\ninsertar(5)\ninsertar(3)\nextraer()\ninsertar(2)\ninsertar(8)\nextraer()\nextraer()\ninsertar(9)\ninsertar(1)\nextraer()\ninsertar(7)\ninsertar(6)\nextraer()\nextraer()\ninsertar(4)\nextraer()\nextraer()\nSuponga que se realiza una secuencia de operaciones de pila (insertar y extraer). Las operaciones de inserción colocan los enteros del 0 al 9, en orden, dentro de la pila; las operaciones extracción imprimen los valores que se extraen. ¿Cuál o cuáles de las siguientes secuencias no podrían ocurrir?\n\n4 3 2 1 0 9 8 7 6 5\n4 6 8 7 5 3 2 9 0 1\n2 5 6 7 4 8 9 3 1 0\n4 3 2 1 0 5 6 7 8 9\n1 2 3 4 5 6 9 8 7 0\n0 4 6 5 3 8 1 7 2 9\n1 4 7 9 8 6 5 3 0 2\n2 1 4 3 6 5 8 7 9 0\n\nSuponga que se realiza una secuencia de operaciones de cola (insertar y extraer). Las operaciones de inserción colocan los enteros del 0 al 9, en orden, dentro de la cola; las operaciones extracción imprimen los valores que se extraen. ¿Cuál o cuáles de las siguientes secuencias no podrían ocurrir?\n\n0 1 2 3 4 5 6 7 8 9\n4 6 8 7 5 3 2 9 0 1\n2 5 6 7 4 8 9 3 1 0\n4 3 2 1 0 5 6 7 8 9\n\nEscriba un algoritmo para encontrar el penúltimo nodo en una lista simplemente enlazada, en la cual el último nodo está indicado por una referencia siguiente igual a None.\nEscriba un buen algoritmo para concatenar dos listas enlazadas simples L y M, dadas únicamente las referencias al primer nodo de cada lista, en una sola lista L que contenga todos los nodos de L seguidos por todos los nodos de M.\nEscriba un algoritmo recursivo que cuente la cantidad de nodos en una lista simplemente enlazada.\nEscriba un algoritmo para dos nodos x e y (no solo sus contenidos) en una lista simplemente enlazada L, teniendo únicamente las referencias a x e y. Repita el ejercicio para el caso en que L sea una lista doblemente enlazada. ¿Cuál de los dos algoritmos requiere más tiempo?\nSuponga que x es un nodo de una lista enlazada y no es el último nodo de la lista. ¿Cuál es el efecto del siguiente fragmento de código?\nx.siguiente = x.siguiente.siguiente\nSuponga que x es un nodo de una lista enlazada e y es un nodo cualquiera. ¿Cuál es el efecto del siguiente fragmento de código?\ny.siguiente = x.siguiente\nx.siguiente = y\n¿Por qué el siguiente fragmento de código no hace la misma tarea que el fragmento del punto anterior?\nx.siguiente = y\ny.siguiente = x.siguiente",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🪞 Autoevaluación"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/problemas.html",
    "href": "practica/02_programacion_funcional/problemas.html",
    "title": "🧩 Problemas",
    "section": "",
    "text": "En programación, el logging es el proceso de registrar eventos durante la ejecución de un programa. Estos registros, llamados logs, permiten mantener un historial de lo que ocurrió, incluyendo estados del sistema, acciones realizadas y posibles errores o advertencias.\nEn este problema se propone implementar un decorador llamado log que registre, en un archivo, los valores de entrada y salida de cada llamada a las funciones decoradas. El decorador debe recibir como argumento la ruta del archivo donde se guardarán los mensajes.\nPor ejemplo, el siguiente código:\nimport time\n\n@log(\"registro.log\")\ndef f(x, y):\n    return x + y\n\n@log(\"registro.log\")\ndef g(a, b):\n    return a + b ** 2\n\nf(3, 9)\ntime.sleep(1)\nf(256, 256)\ntime.sleep(3)\ng(3, 2)\nf(7, 8)\nDebería generar un archivo registro.log con un contenido similar al siguiente:\n\n\nregistro.log\n\n2025-09-02 18:04:07 - | f(x=3, y=9) -&gt; 12\n2025-09-02 18:04:08 - | f(x=256, y=256) -&gt; 512\n2025-09-02 18:04:11 - | g(a=3, b=2) -&gt; 7\n2025-09-02 18:04:11 - | f(x=7, y=8) -&gt; 15\n\n\n\n\nSi el archivo no existe, debe crearse automáticamente.\nSi el archivo ya existe, los nuevos registros deben agregarse al final, sin sobrescribir los anteriores.\n\n\n\n\n\nPara obtener el momento exacto de la llamada, puede usar datetime.now() del módulo datetime.\nPara formatear ese valor como texto, utilice el método .strftime.\n\nPor ejemplo:\ndatetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n2025-09-02 18:30:39",
    "crumbs": [
      "Práctica",
      "U2 - Programación funcional",
      "🧩 Problemas"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/problemas.html#registro-de-llamadas",
    "href": "practica/02_programacion_funcional/problemas.html#registro-de-llamadas",
    "title": "🧩 Problemas",
    "section": "",
    "text": "En programación, el logging es el proceso de registrar eventos durante la ejecución de un programa. Estos registros, llamados logs, permiten mantener un historial de lo que ocurrió, incluyendo estados del sistema, acciones realizadas y posibles errores o advertencias.\nEn este problema se propone implementar un decorador llamado log que registre, en un archivo, los valores de entrada y salida de cada llamada a las funciones decoradas. El decorador debe recibir como argumento la ruta del archivo donde se guardarán los mensajes.\nPor ejemplo, el siguiente código:\nimport time\n\n@log(\"registro.log\")\ndef f(x, y):\n    return x + y\n\n@log(\"registro.log\")\ndef g(a, b):\n    return a + b ** 2\n\nf(3, 9)\ntime.sleep(1)\nf(256, 256)\ntime.sleep(3)\ng(3, 2)\nf(7, 8)\nDebería generar un archivo registro.log con un contenido similar al siguiente:\n\n\nregistro.log\n\n2025-09-02 18:04:07 - | f(x=3, y=9) -&gt; 12\n2025-09-02 18:04:08 - | f(x=256, y=256) -&gt; 512\n2025-09-02 18:04:11 - | g(a=3, b=2) -&gt; 7\n2025-09-02 18:04:11 - | f(x=7, y=8) -&gt; 15\n\n\n\n\nSi el archivo no existe, debe crearse automáticamente.\nSi el archivo ya existe, los nuevos registros deben agregarse al final, sin sobrescribir los anteriores.\n\n\n\n\n\nPara obtener el momento exacto de la llamada, puede usar datetime.now() del módulo datetime.\nPara formatear ese valor como texto, utilice el método .strftime.\n\nPor ejemplo:\ndatetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n2025-09-02 18:30:39",
    "crumbs": [
      "Práctica",
      "U2 - Programación funcional",
      "🧩 Problemas"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/problemas.html#fibonacci-el-memorioso",
    "href": "practica/02_programacion_funcional/problemas.html#fibonacci-el-memorioso",
    "title": "🧩 Problemas",
    "section": "2 Fibonacci el memorioso",
    "text": "2 Fibonacci el memorioso\nLa implementación recursiva más directa de la secuencia de Fibonacci es tan concisa como ineficiente.\ndef fibonacci(n):\n    if n &lt;= 1:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)\nAl invocar fibonacci(7), se realizan llamadas a fibonacci(6) y fibonacci(5). Luego, fibonacci(6) vuelve a llamar a fibonacci(5) y fibonacci(4), y así sucesivamente. Muchas de estas llamadas se repiten: por ejemplo, fibonacci(5) se calcula más de una vez.\nEste comportamiento muestra que los subproblemas se superponen: los mismos valores se recalculan de manera redundante.\nEl objetivo de este ejercicio es diseñar una función capaz de recordar resultados ya obtenidos, evitando recomputarlos cada vez que aparecen. Para lograrlo, podemos construir una función recursiva que memorice sus valores anteriores y, así, avance en la secuencia sin rehacer todos los cálculos previos.\n\nAyuda\nConsidere una function factory que devuelva la función recursiva. Dentro del ámbito de la function factory puede existir una estructura de datos mutable que almacene los resultados ya calculados.",
    "crumbs": [
      "Práctica",
      "U2 - Programación funcional",
      "🧩 Problemas"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html",
    "href": "practica/02_programacion_funcional/ejercicios.html",
    "title": "🛠️ Ejercicios",
    "section": "",
    "text": "Debajo se muestra un listado de funciones impuras. Analice por qué son impuras e implemente alternativas puras (manteniendo su lógica):\nFunción 1\ncontador = 0\ndef incrementar():\n1    global contador\n    contador += 1\n    return contador\n\n1\n\nLa palabra global es una keyword que indica que se pretende usar y modificar una variable definida fuera del ámbito de ejecución de la función.\n\n\nFunción 2\ndef obtener_hora_actual():\n    import datetime\n    return datetime.datetime.now().hour\nFunción 3\ndef add_time(time, hours, minutes, seconds):\n1    increment_time(time, hours, minutes, seconds)\n    return time\n\n1\n\nAsuma que esta función incrementa a time, que es un objeto datetime, en hours horas, minutes minutos y seconds segundos.\n\n\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nRepresente fechas y horas con el objeto objeto datetime del módulo estándar datetime. Además, considere el objeto timedelta del mismo módulo para luego calcular diferencias. Por ejemplo:\nimport datetime\n\nahora = datetime.datetime.now() # Devuelve un objeto con la fecha y la hora actual\nprint(ahora)\n\nuna_hora_mas_tarde = datetime.timedelta(hours=1, minutes=0, seconds=0)\nprint(ahora + una_hora_mas_tarde)\n2025-08-31 09:48:58.327461\n2025-08-31 10:48:58.327461\n\n\n\nFunción 4\nhistorial_de_nombres = []\ndef registrar_nombre(nombre):\n    historial_de_nombres.append(nombre)\n    return f\"'{nombre}' ha sido registrado en el historial.\"\nFunción 5\nLIMITE_MAXIMO = 100\ndef verificar_limite(valor):\n    if valor &gt; LIMITE_MAXIMO:\n        return \"Excede el límite\"\n    return \"Dentro del límite\"",
    "crumbs": [
      "Práctica",
      "U2 - Programación funcional",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#trasfromando-funciones",
    "href": "practica/02_programacion_funcional/ejercicios.html#trasfromando-funciones",
    "title": "🛠️ Ejercicios",
    "section": "",
    "text": "Debajo se muestra un listado de funciones impuras. Analice por qué son impuras e implemente alternativas puras (manteniendo su lógica):\nFunción 1\ncontador = 0\ndef incrementar():\n1    global contador\n    contador += 1\n    return contador\n\n1\n\nLa palabra global es una keyword que indica que se pretende usar y modificar una variable definida fuera del ámbito de ejecución de la función.\n\n\nFunción 2\ndef obtener_hora_actual():\n    import datetime\n    return datetime.datetime.now().hour\nFunción 3\ndef add_time(time, hours, minutes, seconds):\n1    increment_time(time, hours, minutes, seconds)\n    return time\n\n1\n\nAsuma que esta función incrementa a time, que es un objeto datetime, en hours horas, minutes minutos y seconds segundos.\n\n\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nRepresente fechas y horas con el objeto objeto datetime del módulo estándar datetime. Además, considere el objeto timedelta del mismo módulo para luego calcular diferencias. Por ejemplo:\nimport datetime\n\nahora = datetime.datetime.now() # Devuelve un objeto con la fecha y la hora actual\nprint(ahora)\n\nuna_hora_mas_tarde = datetime.timedelta(hours=1, minutes=0, seconds=0)\nprint(ahora + una_hora_mas_tarde)\n2025-08-31 09:48:58.327461\n2025-08-31 10:48:58.327461\n\n\n\nFunción 4\nhistorial_de_nombres = []\ndef registrar_nombre(nombre):\n    historial_de_nombres.append(nombre)\n    return f\"'{nombre}' ha sido registrado en el historial.\"\nFunción 5\nLIMITE_MAXIMO = 100\ndef verificar_limite(valor):\n    if valor &gt; LIMITE_MAXIMO:\n        return \"Excede el límite\"\n    return \"Dentro del límite\"",
    "crumbs": [
      "Práctica",
      "U2 - Programación funcional",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#fábrica-de-promociones",
    "href": "practica/02_programacion_funcional/ejercicios.html#fábrica-de-promociones",
    "title": "🛠️ Ejercicios",
    "section": "2 Fábrica de promociones",
    "text": "2 Fábrica de promociones\nConsidere el ejercicio Promociones de la Práctica 1. Utilizando el mismo sistema de descuentos cree la función crear_promocion que reciba como argumento el medio de pago y devuelva una función que al aplicarse sobre un número aplique el descuento (o recargo) que le corresponde a ese medio de pago. Por ejemplo:\npromo_debito = crear_promocion(\"débito\")\nprint(promo_debito(1000))\nprint(promo_debito(2700))\n900\n2430.0\nLuego, cree la función crear_promocion_personalizada que recibe el medio de pago y, de manera opcional, el porcentaje de descuento a aplicar. Como resultado devuelve una función que al aplicarse sobre un número impacta el descuento o recargo correspondiente. Además, considere que:\n\nSi no se pasa el porcentaje a aplicar, se deben usar los descuentos y recargos detallados en el enunciado del ejercicio en la Práctica 1.\nCaso contrario, la función devuelta debe aplicar ese porcentaje personalizado (e.g., crear_promocion_personalizada(\"débito\", 15) para 15% de descuento).\n\nEjemplo de uso:\npromo_debito = crear_promocion_personalizada(\"débito\", 15)\npromo_debito(1000)\n850",
    "crumbs": [
      "Práctica",
      "U2 - Programación funcional",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#bendita-media",
    "href": "practica/02_programacion_funcional/ejercicios.html#bendita-media",
    "title": "🛠️ Ejercicios",
    "section": "3 Bendita media",
    "text": "3 Bendita media\nEn Python no existe una función built-in que calcule la media de una secuencia de números. El objetivo de este ejercicio es implementar una función mean que funcione tanto cuando se le pasa un iterable, como cuando se le pasa una cantidad arbitraria de números.\nEl argumento es un iterable:\nmean([6.27, 8.11, 7.6, 5.2, 4.8])\nSe pasan una cantidad arbitraria de valores numéricos:\nmean(7.3, 8.2, 11.0, 12.5)",
    "crumbs": [
      "Práctica",
      "U2 - Programación funcional",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#sucesión-de-fibonacci",
    "href": "practica/02_programacion_funcional/ejercicios.html#sucesión-de-fibonacci",
    "title": "🛠️ Ejercicios",
    "section": "4 Sucesión de Fibonacci",
    "text": "4 Sucesión de Fibonacci\nConsidere la sucesión que comienza por los números 0 y 1. Los siguientes números se forman sumando los dos anteriores.\n\\[\n\\{\\;0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, \\cdots\\;\\}\n\\]\nEsta sucesión se conoce como sucesión de Fibonacci.\nImplemente una función recursiva que tome un número natural n como entrada y devuelva el n-ésimo número en la sucesión.",
    "crumbs": [
      "Práctica",
      "U2 - Programación funcional",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#palíndromos-recursivos",
    "href": "practica/02_programacion_funcional/ejercicios.html#palíndromos-recursivos",
    "title": "🛠️ Ejercicios",
    "section": "5 Palíndromos recursivos",
    "text": "5 Palíndromos recursivos\nUn palíndromo es una palabra, frase, número o secuencia que se lee igual de izquierda a derecha que de derecha a izquierda. En Argentina, a un número de este tipo le decimos le decimos capicúa.\nPara comprobar en Python si una cadena es palíndroma, puede compararse con su versión invertida, que se construye mediante un slice con paso -1:\nc = \"anilina\"\nc == c[::-1]\nTrue\nTambién podríaimos determinar si una cadena es un palíndromo de manera recursiva comparando el primer y el último carácter:\n\nSi la cadena tiene longitud 0 o 1, se devuelve True.\nSi el primer y el último carácter son iguales, se llama recursivamente a la función pasándole la cadena excluyendo al primer y último caracter ya comparados. Si son distintos, se devuelve False.\n\nEn otras palabras, la función recursiva devolverá True cuando todas las comparaciones por pares resulten verdaderas y se alcance el caso base: queda un único carácter (longitud impar) o ninguno (longitud par).\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara seleccionar todos los caracteres de una cadena, exceptuando al primero y el último, se puede usar\n\"radar\"[1:-1]\n\"ada\"\n\n\n\n\nPunto extra\nAdapte la función para que no considere espacios ni distinga mayúsculas de minúsculas. De este modo, debería detectar que la siguiente frase es palíndroma.\npalindromo(\"Anita lava la tina\") # True",
    "crumbs": [
      "Práctica",
      "U2 - Programación funcional",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#área-de-aprendizaje",
    "href": "practica/02_programacion_funcional/ejercicios.html#área-de-aprendizaje",
    "title": "🛠️ Ejercicios",
    "section": "6 Área de aprendizaje",
    "text": "6 Área de aprendizaje\nSe cuenta con una lista de tuplas de longitud 2, representando el ancho y alto de distintos rectángulos.\nrectangulos = [\n    (5, 8),\n    (2, 2),\n    (9, 2),\n    (3, 3),\n    (3, 7),\n    (6, 3)\n]\nCree una nueva lista que ordene dichos rectángulos en función de su área utilizando la función sorted.",
    "crumbs": [
      "Práctica",
      "U2 - Programación funcional",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#socios-ordenados",
    "href": "practica/02_programacion_funcional/ejercicios.html#socios-ordenados",
    "title": "🛠️ Ejercicios",
    "section": "7 Socios ordenados",
    "text": "7 Socios ordenados\nSe cuenta con la siguiente lista de diccionarios, la cual contiene datos personales sobre miembros de un club de atletismo:\ndatos_socios = [\n    {\"nombre\": \"Bautista Carrara\", \"edad\": 22, \"altura_cm\": 178, \"record_100m\": 13.4},\n    {\"nombre\": \"Valentina Lucci\",  \"edad\": 23, \"altura_cm\": 163, \"record_100m\": 14.2},\n    {\"nombre\": \"Gerónimo Cuesta\",  \"edad\": 26, \"altura_cm\": 170, \"record_100m\": 14.0},\n    {\"nombre\": \"Lucio Borga\",      \"edad\": 28, \"altura_cm\": 186, \"record_100m\": 13.8},\n    {\"nombre\": \"Julia Spoglia\",    \"edad\": 21, \"altura_cm\": 163, \"record_100m\": 11.9},\n    {\"nombre\": \"Soledad Colombo\",  \"edad\": 22, \"altura_cm\": 170, \"record_100m\": 13.5}\n]\nOrdene la lista en base a los récords en la carrera de 100 metros, en forma ascendente.\n\nPunto extra\nImplemente una función que tome como argumento una clave de diccionario y devuelva una lista ordenada por los valores de dicha clave. Si el argumento toma el valor \"nombre\", ordene los elementos alfabéticamente en base a los apellidos.",
    "crumbs": [
      "Práctica",
      "U2 - Programación funcional",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#listado-de-rimas",
    "href": "practica/02_programacion_funcional/ejercicios.html#listado-de-rimas",
    "title": "🛠️ Ejercicios",
    "section": "8 Listado de rimas",
    "text": "8 Listado de rimas\nSe tiene la siguiente lista de palabras, la cual se quiere utilizar para formar rimas:\npalabras_a_rimar = [\n    \"actividad\",\n    \"bendición\",\n    \"cartelera\",\n    \"ciudad\",\n    \"escalera\",\n    \"estación\",\n    \"felicidad\",\n    \"función\",\n    \"reposera\"\n]\nOrdene la lista en base al orden alfabético del reverso de cada palabra, de modo que las palabras que riman se encuentren juntas.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nSi la lista fuese [\"durazno\", \"kiwi\"], el resultado sería [\"kiwi\", \"durazno\"], porque \"iwik\" precede a \"onzarud\" en orden alfabético.",
    "crumbs": [
      "Práctica",
      "U2 - Programación funcional",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#analistas-de-temperaturas",
    "href": "practica/02_programacion_funcional/ejercicios.html#analistas-de-temperaturas",
    "title": "🛠️ Ejercicios",
    "section": "9 Analistas de temperaturas",
    "text": "9 Analistas de temperaturas\nConsidere una lista de temperaturas en grados Celsius sobre la cual se deben aplicar distintas operaciones.\ntemperaturas_celsius = [\n    25.5, 28.0, 19.3, 31.5, 22.8, 17.0, 30.2, 35.6, 14.2,\n    32.4, 22.7, 10.1, 29.5, 33.9, 22.1, 38.9, 18.4, 16.3\n]\n\nEnfoque funcional\n\nConvierta las temperaturas a grados Fahrenheit utilizando map y almacene el resultado en una lista llamada temperaturas_f. Use la fórmula de conversión: \\[\nF = C \\times \\frac{9}{5} + 32\n\\]\nUtilice filter para seleccionar de la lista anterior las temperaturas que sean mayores a 80°F. Guarde el resultado en una nueva lista. ¿Se le ocurre una alternativa que no utilice la lista creada en el primer punto?\n\n\n\nEnfoque idiomático\n\nUtilice una list comprehension para obtener una lista de temperaturas en grados Fahrenheit solo cuando para temperaturas mayores a 22 °C.",
    "crumbs": [
      "Práctica",
      "U2 - Programación funcional",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#el-tiempo-vuela",
    "href": "practica/02_programacion_funcional/ejercicios.html#el-tiempo-vuela",
    "title": "🛠️ Ejercicios",
    "section": "10 El tiempo vuela",
    "text": "10 El tiempo vuela\nSe quiere medir el tiempo que tarda la computadora en ejecutar distintos bloques de código. Para eso, implemente una función crear_cronometro que fabrique una función cronometro, la cual devuelve el tiempo transcurrido entre su creación y la llamada a la función. Luego, utilice dos cronómetros en paralelo para evaluar el siguiente código:\ncronometro1 = crear_cronometro()\n\nfor i in range(10**4):\n    i ** 2 # Calcula el cuadrado de un número pero no lo devuelve\n\nprint(f\"El bloque entero tardó {cronometro1()} segundos en ejecutarse.\")\n\ncronometro2 = crear_cronometro()\n\nfor j in range(10**6):\n    j // 2 # Calcula la división entera por 2 pero no la devuelve\n\nprint(f\"El segundo bucle tardó {cronometro2()} segundos en ejecutarse.\")\n\nPunto extra\nModifique el funcionamiento del cronómetro para que en cada llamada devuelva el tiempo transcurrido entre la llamada actual y la inmediata anterior (excepto en la primera llamada, que devuelve el tiempo transcurrido desde su creación).\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara medir el paso del tiempo en Python podemos usar la función time del módulo homónimo.\nfrom time import time, sleep\n\ninicio = time()\nsleep(2) # Detiene la ejecución por 2 segundos\nprint(time() - inicio) # ~ 2 (segundos)",
    "crumbs": [
      "Práctica",
      "U2 - Programación funcional",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#no-perdamos-el-centro",
    "href": "practica/02_programacion_funcional/ejercicios.html#no-perdamos-el-centro",
    "title": "🛠️ Ejercicios",
    "section": "11 No perdamos el centro",
    "text": "11 No perdamos el centro\nSuponga el siguiente listado de números, que contiene algunos None:\nnumeros = [\n    2.05, 1.09, None, 2.31, 2.28, 0.97, 2.59, 2.72, 0.76, None, 1.88, 2.04, 3.25, 1.88, None\n]\nCalcule la media de los numeros, sin considerar los nulos. Luego, utilizando una list comprehension, obtenga una nueva lista de los valores centrados, conservando los None en las posiciones originales.",
    "crumbs": [
      "Práctica",
      "U2 - Programación funcional",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#en-python-es-mejor",
    "href": "practica/02_programacion_funcional/ejercicios.html#en-python-es-mejor",
    "title": "🛠️ Ejercicios",
    "section": "12 En Python es mejor",
    "text": "12 En Python es mejor\nConsidere el siguiente programa, que selecciona valores atípicos de un listado:\nnumeros = [\n    4.74346239e-01, -2.90877176e-01, -1.44377789e+00, -4.48680759e+01,\n    -1.21249801e+00, -3.32729317e-01,  2.21676912e-01,  1.05599711e+00,\n    -3.62372053e+00, -2.96441579e-01, -4.28304222e+00,  1.55908820e+02,\n    9.00858234e-01, -1.09384173e+00, -1.51083571e+00, -5.38491167e-01,\n    -3.84153084e-02,  1.20393395e+00,  1.82651406e-01,  2.05179405e+00\n]\n\ndef media(x):\n    return sum(x) / len(x)\n\ndef varianza(x):\n    numerador = 0\n    x_media = media(x)\n    for x_i in x:\n        numerador += (x_i - x_media) ** 2\n    return numerador / len(x)\n\nx_media = media(numeros)\nx_desvio = varianza(numeros) ** 0.5\n\nmap_obj = map(lambda x: (x - x_media) / x_desvio, numeros)\nlist(filter(lambda x: abs(x) &gt; 3, map_obj))\nImplemente un programa equivalente haciendo uso de una list comprehension, en vez de map y filter.",
    "crumbs": [
      "Práctica",
      "U2 - Programación funcional",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#subiendo-de-rango",
    "href": "practica/02_programacion_funcional/ejercicios.html#subiendo-de-rango",
    "title": "🛠️ Ejercicios",
    "section": "13 Subiendo de rango",
    "text": "13 Subiendo de rango\nLa función range(start, stop, step) de Python devuelve un objeto que genera una secuencia de números desde start (inclusive) hasta stop (exclusive) en incrementos de step unidades. El argumento step, sin embargo, sólo puede ser un número entero (excepto cero). Implemente una función llamada frange que acepte los mismos argumentos, pudiendo step ser de tipo float. La función debe retornar un generador de la secuencia correspondiente.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nUtilice el siguiente ejemplo a modo de control:\nfor i in frange(3, 4, 0.2):\n    print(f\"{i:.2f}\")\n3.00\n3.20\n3.40\n3.60\n3.80\nTenga en cuenta que la precisión finita de las computadoras puede afectar el comportamiento de su generador.",
    "crumbs": [
      "Práctica",
      "U2 - Programación funcional",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#la-cajita-musical",
    "href": "practica/02_programacion_funcional/ejercicios.html#la-cajita-musical",
    "title": "🛠️ Ejercicios",
    "section": "14 La cajita musical",
    "text": "14 La cajita musical\nTenemos una caja musical que recita los siguientes versos:\nversos = [\n    \"Tengo que confesar que a veces no me gusta tu forma de ser\",\n    \"Luego te me desapareces y no entiendo muy bien por qué\",\n\n    \"No dices nada romántico cuando llega el atardecer\",\n    \"Te pones de un humor extraño con cada luna llena al mes\",\n\n    \"Pero a todo lo demás le gana lo bueno que me das\",\n    \"Sólo tenerte cerca, siento que vuelvo a empezar\"\n]\nImplemente una función para darle cuerda a la caja musical. En cada llamada debe devolver un verso distinto, hasta agotarlos todos.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nMediante el uso de yield se puede lograr que una función se detenga en un punto intermedio y retome desde ese punto en la siguiente llamada.\ndef mostrar_fase():\n    print(\"Inicio\")\n    yield\n    print(\"Medio\")\n    yield\n    print(\"Desenlace\")\n    yield",
    "crumbs": [
      "Práctica",
      "U2 - Programación funcional",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#el-mejor-precio",
    "href": "practica/02_programacion_funcional/ejercicios.html#el-mejor-precio",
    "title": "🛠️ Ejercicios",
    "section": "15 El mejor precio",
    "text": "15 El mejor precio\nUn supermercado ofrece múltiples promociones:\n\n15% de descuento los días lunes y miércoles.\n10% de descuento en compras con monto superior a $50.000.\n20% de descuento a clientes mayores de 65 años.\n\nPara determinar la promoción a aplicar, el supermercado utiliza un programa con la siguiente estructura:\ndef promo_dia_semana(compra):\n    \"\"\"Aplica un 15% de descuento si la compra se realiza un lunes o miércoles.\"\"\"\n    return None # hay que implementar esta función\n\ndef promo_monto_grande(compra):\n    \"\"\"Aplica un 10% de descuento si la compra tiene un monto superior a $50.000.\"\"\"\n    return None # hay que implementar esta función\n\ndef promo_edad(compra):\n    \"\"\"Aplica un 20% de descuento si el cliente tiene 65 años o más.\"\"\"\n    return None # hay que implementar esta función\n\npromos = [promo_dia_semana, promo_monto_grande, promo_edad]\n\ndef mejor_promo(compra):\n    \"\"\"Construye diccionario con el monto luego de aplicar la mejor promoción.\n\n    Esta función devuelve un diccionario con el monto original, el monto final, y el descuento\n    aplicado.\n    \"\"\"\n    # Obtener el multiplicador del mayor descuento\n    multiplicador = sorted([promo(compra) for promo in promos])[0]\n\n    return {\n        \"monto_original\": compra[\"monto\"],\n        \"monto_final\": compra[\"monto\"] * multiplicador,\n        \"descuento\": f\"{round((1 - multiplicador) * 100)}%\"\n    }\n\nejemplo_compra = {\"dia\": \"miércoles\", \"edad_cliente\": 42, \"monto\": 66420}\nmejor_promo(ejemplo_compra)\n# {'monto_original': 66420, 'monto_final': 56457.0, 'descuento': '15%'}\nEl problema con esta implementación es que, cada vez que se añade o elimina una promoción, el cambio debe llevarse a cabo tanto en la función de la promoción como en la lista de promociones. Para evitar el trabajo duplicado, implemente los siguientes cambios:\n\nDefina primero la lista promos, la cual comienza estando vacía.\nDefina un decorador promo que añade una función a la lista promos antes de ejecutarla.\nImplemente las tres funciones de promoción y decórelas con el decorador del paso anterior.",
    "crumbs": [
      "Práctica",
      "U2 - Programación funcional",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#bromas-pesadas",
    "href": "practica/02_programacion_funcional/ejercicios.html#bromas-pesadas",
    "title": "🛠️ Ejercicios",
    "section": "16 Bromas pesadas 😱",
    "text": "16 Bromas pesadas 😱\nNuestro amigo programador está armando una página web, con una función que saluda a los nuevos usuarios por su nombre cuando se registran. Nosotros queremos gastarle una broma a nuestro amigo, metiendo en su código un decorador que haga que su función corra normalmente excepto cada n-ésima corrida, fallando silenciosamente (no imprime nada). El valor n es un número entero de nuestra elección.\n@romper_cada(3)\ndef saludar(nombre):\n  print(f\"¡Hola, {nombre}!\")\n\nsaludar(\"Carlos\")     # \"¡Hola, Carlos!\"\nsaludar(\"María Luz\")  # \"¡Hola, María Luz!\"\nsaludar(\"Mirna\")      # Nada (la función devuelve None)\nsaludar(\"Diego\")      # \"¡Hola, Diego!\"\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara crear un decorador que reciba argumentos, podemos crear una fábrica de decoradores:\ndef mi_decorador(n):\n    def decorar(funcion):\n        print(f\"Ejecutando decorador con argumento {n}\")\n        return funcion\n    return decorar\n\n@mi_decorador(7)\ndef imprimir(mensaje):\n    print(mensaje)\n\nimprimir(\"Hola mundo\")\n# &gt; Ejecutando decorador con argumento 7\n# &gt; Hola mundo",
    "crumbs": [
      "Práctica",
      "U2 - Programación funcional",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#pipelines-de-procesamiento",
    "href": "practica/02_programacion_funcional/ejercicios.html#pipelines-de-procesamiento",
    "title": "🛠️ Ejercicios",
    "section": "17 Pipelines de procesamiento 😱",
    "text": "17 Pipelines de procesamiento 😱\nEste ejercicio tiene como objetivo implementar un sistema de preprocesamiento para una lista de diccionarios, donde cada diccionario representa una fila con sus columnas como pares clave–valor. Un conjunto de datos de ejemplo es el siguiente:\ndatos = [\n    {\"edad\": 20, \"ingresos\": 2000},\n    {\"edad\": 30, \"ingresos\": 3000},\n    {\"edad\": None, \"ingresos\": 2500},\n    {\"edad\": 40, \"ingresos\": None},\n    {\"edad\": 25, \"ingresos\": 4000},\n]\nEl primer paso consiste en definir tres funciones:\n\neliminar_nulos: elimina las filas con al menos un valor None.\ncalcular_log: que calcula el logaritmo en base 10 para los valores de la variable indicada.\nfiltrar: recibe el listado, el nombre de una columna y una función booleana que se aplica para determinar que registros se conservan.\n\nQue deben funcionar como se muestra en los ejemplos:\neliminar_nulos(datos)\n[\n    {\"edad\": 20, \"ingresos\": 2000},\n    {\"edad\": 30, \"ingresos\": 3000},\n    {\"edad\": 25, \"ingresos\": 4000},\n]\ncalcular_log(datos, \"ingresos\")\n[\n    {\"edad\": 20, \"ingresos\": 3.301},\n    {\"edad\": 30, \"ingresos\": 3.477},\n    {\"edad\": None, \"ingresos\": 3.397},\n    {\"edad\": 40, \"ingresos\": None},\n    {\"edad\": 25, \"ingresos\": 3.602},\n]\nfiltrar(datos, \"edad\", lambda e: e &gt; 25)\n[\n    {\"edad\": 30, \"ingresos\": 3000},\n    {\"edad\": 40, \"ingresos\": None},\n]\nEn el segundo paso, se debe implementar una función crear_pipeline, que recibe una cantidad arbitraria de funciones de procesamiento, junto a sus argumentos, y debe devolver una función que, al pasarle un listado de datos, los aplica de manera secuencial y devuelve un conjunto de datos procesado. Por ejemplo:\npipeline = crear_pipeline(\n    {\"fun\": eliminar_nulos, \"kwargs\": {}},\n    {\"fun\": calcular_log, \"kwargs\": {\"var_name\": \"ingresos\"}},\n    {\"fun\": filtrar, \"kwargs\": {\"var_name\": edad, \"key\": lambda e: e &gt; 25}}\n)\npipeline(datos)\n[{\"edad\": 30, \"ingresos\": 3.477}]",
    "crumbs": [
      "Práctica",
      "U2 - Programación funcional",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/ejercicios.html#espacio-o-tiempo",
    "href": "practica/02_programacion_funcional/ejercicios.html#espacio-o-tiempo",
    "title": "🛠️ Ejercicios",
    "section": "18 ¿Espacio o tiempo? ⏳",
    "text": "18 ¿Espacio o tiempo? ⏳\nSuponga que trabaja en el equipo de análisis de datos de un e-commerce y suponga que recibe un listado ventas del último mes. Deberá extraer información clave de esos datos utilizando dos maneras distintas de resolver cada tarea.\n1. Preparación de los datos\nPara empezar, use la siguiente función que genera datos de ejemplo de ventas de distinto tamaño:\nimport random\n\nCATEGORIAS = (\"electrónica\", \"hogar\", \"accesorios\", \"deportes\")\n\ndef generar_ventas(n=100_000, seed=None):\n    \"\"\"Generar datos de ventas.\n\n    Parameters\n    ----------\n    n : int\n        Cantidad de ventas a simular.\n    seed : int, optional\n        Semilla para el generador de números aleatorios. Por defecto, `None`.\n\n    Returns\n    -------\n    list[dict]\n        Listado de ventas.\n        Cada venta es un diccionario con claves `\"id\"`, `\"precio\"` y `\"categoria\"`.\n    \"\"\"\n    rng = random.Random(seed)\n    ventas = []\n    for i in range(1, n + 1):\n        ventas.append(\n            {\n                \"id\": f\"P{i+1:06d}\",\n                \"precio\": round(rng.uniform(5.0, 500.0), 2),\n                \"categoria\": CATEGORIAS[i % len(CATEGORIAS)],\n            }\n        )\n    return ventas\nGenere un conjunto de datos con 100,000 ventas:\nventas = generar_ventas(n=100_000, seed=1234)\n2. Implementación de operaciones\nRealice dos operaciones sobre este conjunto de datos, cada una en dos variantes.\n\nCalcular precios con IVA (21%):\n\nVersión A. Use una list comprehension para crear una nueva lista llamada precios_con_iva_1 que contenga todos los precios con el 21 % de IVA ya calculado.\nVersión B. Use una expresión generadora para crear un objeto precios_con_iva_2 que represente la operación, pero sin calcular ni almacenar los resultados todavía.\n\nFiltrar ventas de “electrónica”:\n\nVersión A. Use una list comprehension para crear una nueva lista llamada electronica_1 que contenga todas las ventas de la categoría “electrónica”.\nVersión B. Use una expresión generadora para crear un objeto electronica_2 que represente el filtro, sin materializar la lista.\n\n\n3. Análisis y comparación\n\nCalcule el total de las ventas de electrónica usando sum() en ambas variantes (electronica_1 y electronica_2).\nPara cada operación, antes y después de aplicar sum(), mida el tiempo de ejecución y el uso de memoria del objeto. Para el tiempo, podría usar time.time() del módulo time; para la memoria, sys.getsizeof() del módulo sys. Registre los resultados (si no observa diferencias claras, duplique n al generar el dataset).\n\n4. Reutilización del objeto\n\nIntente calcular el total de ventas de electrónica una segunda vez para ambos objetos (electronica_1 y electronica_2).\nObserve qué sucede en cada caso. ¿Qué objeto puede volver a usarse y cuál no?\n\n5. Preguntas para reflexión\n\n¿Qué diferencias fundamentales encontró entre las dos maneras de procesar los datos? Considere cuándo se realiza la operación, el uso de memoria y el tiempo de ejecución.\n¿Qué ocurrió cuando intentó recorrer o usar el mismo resultado dos veces?\n¿Se comportaron de la misma manera la lista generada y el objeto generador? ¿Por qué cree que sucede esto?\n¿En qué situaciones elegiría un enfoque u otro? Dé un ejemplo de un escenario donde la ejecución A sea mejor y otro donde la B resulte más eficiente.",
    "crumbs": [
      "Práctica",
      "U2 - Programación funcional",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "recursos/tutoriales/tutorial_04.html",
    "href": "recursos/tutoriales/tutorial_04.html",
    "title": "Contenedores",
    "section": "",
    "text": "El objetivo de este mini-tutorial es implementar un contenedor de datos en Python para mostrar como funcionan los métodos __getitem__, __setitem__ e __iter__.\nDado un objeto obj, estos métodos especiales se llaman al ejecutarse las siguientes operaciones:\nobj[2]             # obj.__getitem__(2)\nobj[1] = 'cosa'    # obj.__setitem__(1, 'cosa')\niter(obj)          # obj.__iter__(), devuelve un iterador\nEste último se llama de manera implícita cuando se recorre el contenedor con un bucle, po ejemplo:\nfor x in obj:\n    print(x)\nSupongamos que queremos implementar un contenedor que automáticamente convierte a todos sus elementos en cadenas de texto. Una implementación posible es la siguiente:\nclass ContenedorTexto:\n    def __init__(self, *valores):\n        self._datos = [str(x) for x in valores]\n\n    def __getitem__(self, indice):\n        return self._datos[indice]\n\n    def __setitem__(self, indice, valor):\n        self._datos[indice] = str(valor)\n\n    def __iter__(self):\n        return iter(self._datos)\nLuego, podemos utilizarla. Primero, creamos un objeto y accedemos al elemento 0:\ncontenedor = ContenedorTexto(22.1, 195, 13)\ncontenedor[0] # (por debajo, esto ejecuta `__getitem__(0)`)\n# '22.1'\nVemos que efectivamente es de tipo str, aunque hayamos pasado un float.\ntype(contenedor[0])\n# str\nComo el contenedor soparta el método __setitem__, podemos escribir valores en el contenedor:\ncontenedor[1] = 212 # (ejecuta `__setitem__(1, 212)`)\ncontenedor[1], type(contenedor[1])\n# ('212', str)\nFinalmente, podemos iterar a través de los elementos de nuestro contenedor:\nfor x in contenedor: # (necesita `__iter__()` para darle el iterador al 'for')\n    print(type(x), x)\n# &lt;class 'str'&gt; 22.1\n# &lt;class 'str'&gt; 212\n# &lt;class 'str'&gt; 13\nOtra opción para el método __iter__ es implementar un generador manualmente:\n    def __iter__(self):\n        for x in self._datos:\n            yield x\nEn este caso no es necesario porque la lista, que es el tipo de datos de self._datos, soporta la función iter para devolver un iterable.",
    "crumbs": [
      "Recursos",
      "Tutoriales",
      "Contenedores"
    ]
  },
  {
    "objectID": "recursos/tutoriales/tutorial_03.html",
    "href": "recursos/tutoriales/tutorial_03.html",
    "title": "Arreglos manuales",
    "section": "",
    "text": "En este mini-tutorial se muestra como implementar un arreglo como estructura de dato sin utilizar las listas de Python. De este modo, tendremos que implementar nuestros propios métodos para leer, insertar, buscar y eliminar valores. Además, también tendremos que crear y administrar el bloque de memoria donde se almacenan los valores de manera manual. Utilizaremos el modulo estándar ctypes para crear un bloque de memoria contigua que contiene objetos de Python.\nimport ctypes\n\nclass Array:\n    \"\"\"Implementación básica de un array con ctypes.\"\"\"\n    def __init__(self, *args):\n        n = len(args)\n        self._n = n\n        self._capacidad = n * 2\n        self._elementos = self._crear_bloque_memoria(self._capacidad)\n        # &lt;1&gt; Reservamos un bloque de memoria contigua para 'self._capacidad' elementos\n\n        # Guardar los valores pasados en el bloque de memoria `_elementos`\n        for i in range(n):\n            self._elementos[i] = args[i]\n\n\n    def _crear_bloque_memoria(self, capacidad):\n        \"\"\"Crear un nuevo bloque de memoria contigua para `capacidad` objetos.\"\"\"\n        return (capacidad * ctypes.py_object)()\n\n\n    def _cambiar_capacidad(self, nueva_capacidad):\n        \"\"\"Copiar los datos a un nuevo bloque de memoria con otra capacidad (mayor).\"\"\"\n        if nueva_capacidad &lt; self._capacidad:\n            raise ValueError(\n                \"La nueva capacidad no puede ser menor que la anterior \"\n                f\"({nueva_capacidad} &lt; {self._capacidad}).\"\n            )\n\n        # Crear nuevo bloque de memoria\n        nuevos_elementos = self._crear_bloque_memoria(nueva_capacidad)\n\n        # Copiar elementos del bloque de memoria actual al nuevo\n        for i in range(self._n):\n            nuevos_elementos[i] = self._elementos[i]\n\n        # Sobreescribir el bloque de memoria actual y actualizar la capacidad\n        self._elementos = nuevos_elementos\n        self._capacidad = nueva_capacidad\n\n    def __len__(self):\n        # Permite llamar len(objeto) para obtener su longitud\n        return self._n\n\n    # Escribir\n    def write(self, indice, valor):\n        \"\"\"Escribir un valor en una posición arbitraria\"\"\"\n        if not 0 &lt;= indice &lt;= self._n:\n            raise IndexError(\"Índice fuera de rango\")\n        self._elementos[indice] = valor\n\n    # Lectura\n    def get(self, indice):\n        \"\"\"Obtener elemento en una posición determinada del arreglo.\"\"\"\n        if not 0 &lt;= indice &lt;= self._n:\n            raise IndexError(\"Índice fuera de rango\")\n        return self._elementos[indice]\n\n    # Inserción\n    def insert(self, indice, valor):\n        \"\"\"Insertar elemento en una posición, desplazando los siguientes.\"\"\"\n        if not 0 &lt;= indice &lt;= self._n:\n            raise IndexError(\"Índice fuera de rango\")\n\n        # Si no hay espacio, se duplica la capacidad\n        if self._n == self._capacidad:\n            self._cambiar_capacidad(2 * self._capacidad)\n\n        # Desplazar elementos hacia la derecha\n        for i in range(self._n, indice, -1):\n            self._elementos[i] = self._elementos[i - 1]\n\n        # Insertar elemento en la posición deseada\n        self._elementos[indice] = valor\n\n        # Incrementar el conteo que mide la longitud del arreglo\n        self._n += 1\n\n    # Búsqueda\n    def index(self, valor):\n        \"\"\"Busca y devuelve la posición donde se encuentra un valor en el array.\"\"\"\n        # Inspeccionar elementos uno a uno, hasta que se encuentre un valor igual a `valor`.\n        for i in range(self._n):\n            if self._elementos[i] == valor:\n                return i\n        return None\n\n    # Eliminación\n    ## Por índice\n    def pop(self, indice=None):\n        \"\"\"Elimina y devuelve el elemento en `indice` (por defecto, el último).\"\"\"\n        if self._n == 0:\n            raise IndexError(\"No se puede usar .pop en un arreglo vacío\")\n\n        if indice is None:\n            indice = self._n - 1\n\n        if not 0 &lt;= indice &lt; self._n:\n            raise IndexError(\"Índice fuera de rango\")\n\n        valor = self._elementos[indice]\n\n        # Desplazar hacia la izquierda los elementos posteriores al eliminado\n        for i in range(indice, self._n - 1):\n            self._elementos[i] = self._elementos[i + 1]\n\n        # Borrar referencia al último elemento y decrementar conteo\n        self._elementos[self._n - 1] = None\n        self._n -= 1\n\n        return valor\n\n    ## Por valor\n    def remove(self, valor):\n        \"\"\"Elimina la primera ocurrencia de `valor` en el array.\"\"\"\n        indice = self.index(valor)\n        if indice is not None:\n            # Desplazar hacia la izquierda los elementos posteriores al eliminado\n            for i in range(indice, self._n - 1):\n                self._elementos[i] = self._elementos[i + 1]\n\n            # Borrar referencia al último elemento y decrementar conteo\n            self._elementos[self._n - 1] = None\n            self._n -= 1\n            return None\n\n        raise ValueError(f\"{valor} no está en el array\")\n\n    def __repr__(self):\n        elementos = [str(self._elementos[i]) for i in range(self._n)]\n        return f\"Array({', '.join(elementos)})\"\nPodemos crear un arreglo con 3 números\narray = Array(10, 20, 30)\nprint(len(array))\nprint(array)\n3\nArray(10, 20, 30)\nUsamos .get para obtener el valor en una posición:\narray.get(2)\n30\nSi queremos sobreescribir el valor en una posición, usamos .write:\narray.write(2, 150)\narray\nArray(10, 20, 150)\nSi usamos .get con un índice fuera del rango, obtenemos un error:\narray.get(5)\nIndexError: Índice fuera de rango\nSe pueden extraer elementos por posición con .pop, que por defecto elimina y devuelve el valor en la última posición:\narray.pop()\n150\nY vemos que ahora se tiene un arreglo de longitud 2\nprint(len(array))\narray\n2\nArray(10, 20)\nTambién es posible insertar elementos en una posición determinada, lo que expande el arreglo:\narray.insert(1, 128)\narray.insert(1, 128)\narray\nArray(10, 128, 128, 20)\nY, finalmente, también es posible eliminar elementos por valor:\narray.remove(10)\narray\nArray(128, 128, 20)\nSi inspeccionamos los detalles internos, como la capacidad del bloque de memoria reservado, tenemos:\narray._capacidad\n6\nAl insertar valores de forma tal que superamos la capacidad, vemos que esta se duplica:\narray.insert(0, 1)\narray.insert(0, 10)\narray.insert(0, 100)\narray.insert(0, 1000)\narray\nArray(1000, 100, 10, 1, 128, 128, 20)\narray._capacidad\n12",
    "crumbs": [
      "Recursos",
      "Tutoriales",
      "Arreglos manuales"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html",
    "title": "U2 - Programación funcional",
    "section": "",
    "text": "# 1\n# * Usa variable global\n# * Modifica variable global\n# * El resultado no depende de los valores de entrada\n\ndef incrementar(contador):\n    return contador + 1\n\n\n# 2\n# * El resultado no depende de la entrada, sino del momento de la llamada.\n# Se puede obtener una función similar, pero no exactamente igual.\nimport datetime\n\ndef hora(dt):\n    return dt.hour\n\nhora(datetime.datetime.now())\n\n# 3\n# Acá no estoy tan seguro, supongo que lo que es no puro no es `add_time``, sino que es\n# `increment_time`. Yo (tomi) propondría\n\ndef add_time(time, hours, minutes, seconds):\n    return time + datetime.timedelta(hours=hours, minutes=minutes, seconds=seconds)\n\nadd_time(datetime.datetime(2025, 8, 12), 2, 12, 44)\n\n# 4\n# Modifica objeto global\n# Salida sí depende de la entrada, eso está OK.\n# Una alternativa posible\ndef registar_nombre(listado, nombre):\n    return listado + [nombre]\n\nhistorial_de_nombres = []\nhistorial_de_nombres = registar_nombre(historial_de_nombres, \"Mateo\")\nhistorial_de_nombres = registar_nombre(historial_de_nombres, \"Camila\")\nhistorial_de_nombres = registar_nombre(historial_de_nombres, \"Victoria\")\nhistorial_de_nombres\n\n# 5\n# No es pura, no signific que sea mala per se.\n# El problema es que su salida no depende de sus valores\n# Si cambia una variable fuera de ella, cammbia el resultado.\n# Una alternativa\ndef verificar_limite(valor, limite):\n    if valor &gt; limite:\n        return \"Excede el límite\"\n    return \"Dentro del límite\"\n\nLIMITE_MAXIMO = 100\nverificar_limite(88, LIMITE_MAXIMO)",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programación funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#trasfromando-funciones",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#trasfromando-funciones",
    "title": "U2 - Programación funcional",
    "section": "",
    "text": "# 1\n# * Usa variable global\n# * Modifica variable global\n# * El resultado no depende de los valores de entrada\n\ndef incrementar(contador):\n    return contador + 1\n\n\n# 2\n# * El resultado no depende de la entrada, sino del momento de la llamada.\n# Se puede obtener una función similar, pero no exactamente igual.\nimport datetime\n\ndef hora(dt):\n    return dt.hour\n\nhora(datetime.datetime.now())\n\n# 3\n# Acá no estoy tan seguro, supongo que lo que es no puro no es `add_time``, sino que es\n# `increment_time`. Yo (tomi) propondría\n\ndef add_time(time, hours, minutes, seconds):\n    return time + datetime.timedelta(hours=hours, minutes=minutes, seconds=seconds)\n\nadd_time(datetime.datetime(2025, 8, 12), 2, 12, 44)\n\n# 4\n# Modifica objeto global\n# Salida sí depende de la entrada, eso está OK.\n# Una alternativa posible\ndef registar_nombre(listado, nombre):\n    return listado + [nombre]\n\nhistorial_de_nombres = []\nhistorial_de_nombres = registar_nombre(historial_de_nombres, \"Mateo\")\nhistorial_de_nombres = registar_nombre(historial_de_nombres, \"Camila\")\nhistorial_de_nombres = registar_nombre(historial_de_nombres, \"Victoria\")\nhistorial_de_nombres\n\n# 5\n# No es pura, no signific que sea mala per se.\n# El problema es que su salida no depende de sus valores\n# Si cambia una variable fuera de ella, cammbia el resultado.\n# Una alternativa\ndef verificar_limite(valor, limite):\n    if valor &gt; limite:\n        return \"Excede el límite\"\n    return \"Dentro del límite\"\n\nLIMITE_MAXIMO = 100\nverificar_limite(88, LIMITE_MAXIMO)",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programación funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#fábrica-de-promociones",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#fábrica-de-promociones",
    "title": "U2 - Programación funcional",
    "section": "2 Fábrica de promociones",
    "text": "2 Fábrica de promociones\n# Parte 1:\ndef crear_promocion(medio):\n    if medio == \"efectivo\":\n        multiplicador = 1\n    elif medio == \"débito\":\n        multiplicador = (1 - 0.1)\n    elif medio == \"crédito\":\n        multiplicador = (1 + 0.05)\n    else:\n        print(f\"El medio {medio} es desconocido.\")\n        multiplicador = 1\n\n    def f(x):\n        return x * multiplicador\n\n    return f\n\npromo_debito = crear_promocion(\"débito\")\nprint(promo_debito(1000))\nprint(promo_debito(2700))\n\n\n# Parte 2\ndef crear_promocion_personalizada(medio, descuento=None):\n    if descuento is None:\n        if medio == \"efectivo\":\n            multiplicador = 1\n        elif medio == \"débito\":\n            multiplicador = (1 - 0.1)\n        elif medio == \"crédito\":\n            multiplicador = (1 + 0.05)\n        else:\n            print(f\"El medio {medio} es desconocido.\")\n            multiplicador = 1\n    else:\n        multiplicador = 1 - descuento / 100\n\n    def f(x):\n        return x * multiplicador\n\n    return f\n\npromo_debito = crear_promocion_personalizada(\"débito\", 15)\npromo_debito(1000)\n\npromo_debito = crear_promocion_personalizada(\"débito\")\npromo_debito(1000)",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programación funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#bendita-media",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#bendita-media",
    "title": "U2 - Programación funcional",
    "section": "3 Bendita media",
    "text": "3 Bendita media\ndef mean(valores, *args):\n    # Asume que 'valores' es coleccion de numeros\n    if not args:\n        return sum(valores) / len(valores)\n\n    # Asume que 'valores' es un solo numero\n    x = [valores] + list(args)\n    return sum(x) / len(x)\n\n\nmean([6.27, 8.11, 7.6, 5.2, 4.8])\nmean(7.3, 8.2, 11.0, 12.5)",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programación funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#sucesión-de-fibonacci",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#sucesión-de-fibonacci",
    "title": "U2 - Programación funcional",
    "section": "4 Sucesión de Fibonacci",
    "text": "4 Sucesión de Fibonacci\ndef fibonacci(n):\n    if n &lt; 2:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)\n\nfor i in range(15):\n    print(fibonacci(i))",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programación funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#palíndromos-recursivos",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#palíndromos-recursivos",
    "title": "U2 - Programación funcional",
    "section": "5 Palíndromos recursivos",
    "text": "5 Palíndromos recursivos\n# Parte 2\ndef palindromo(x):\n    if len(x) &lt; 2:\n        return True\n\n    if x[0] == x[-1]:\n        return palindromo(x[1:-1])\n\n    return False\n\npalindromo(\"hola amigo\")\npalindromo(\"somos\")\npalindromo(\"anilina\")\npalindromo(\"menem\")\npalindromo(\"neuquen\")\n\n\n\n# Parte 2\ndef _palindromo(x):\n    # Identica a la anterior, pero ahora es una funcion interna\n    if len(x) &lt; 2:\n        return True\n\n    if x[0] == x[-1]:\n        return palindromo(x[1:-1])\n\n    return False\n\ndef palindromo(x):\n    return _palindromo(x.lower().replace(\" \", \"\"))\n\npalindromo(\"Anita lava la tina\")\npalindromo(\"Luz azul\")\npalindromo(\"Cualquier cosa\")",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programación funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#área-de-aprendizaje",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#área-de-aprendizaje",
    "title": "U2 - Programación funcional",
    "section": "6 Área de aprendizaje",
    "text": "6 Área de aprendizaje\nrectangulos = [\n    (5, 8),\n    (2, 2),\n    (9, 2),\n    (3, 3),\n    (3, 7),\n    (6, 3)\n]\n\nsorted(rectangulos, key=lambda r: r[0] *  r[1])\n\n# Cuidado que esto funciona, pero hace otra cosa\nsorted(rectangulos)",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programación funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#socios-ordenados",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#socios-ordenados",
    "title": "U2 - Programación funcional",
    "section": "7 Socios ordenados",
    "text": "7 Socios ordenados\ndatos_socios = [\n    {\"nombre\": \"Bautista Carrara\", \"edad\": 22, \"altura_cm\": 178, \"record_100m\": 13.4},\n    {\"nombre\": \"Valentina Lucci\",  \"edad\": 23, \"altura_cm\": 163, \"record_100m\": 14.2},\n    {\"nombre\": \"Gerónimo Cuesta\",  \"edad\": 26, \"altura_cm\": 170, \"record_100m\": 14.0},\n    {\"nombre\": \"Lucio Borga\",      \"edad\": 28, \"altura_cm\": 186, \"record_100m\": 13.8},\n    {\"nombre\": \"Julia Spoglia\",    \"edad\": 21, \"altura_cm\": 163, \"record_100m\": 11.9},\n    {\"nombre\": \"Soledad Colombo\",  \"edad\": 22, \"altura_cm\": 170, \"record_100m\": 13.5}\n]\n\nsorted(datos_socios, key=lambda datum: datum[\"record_100m\"])\n\n# Punto extra\ndef ordenar_diccionario(data, key):\n    if key == \"nombre\":\n        return sorted(data, key=lambda datum: datum[\"nombre\"].split(\" \")[1])\n    return sorted(data, key=lambda datum: datum[key])\n\nordenar_diccionario(datos_socios, \"record_100m\")\nordenar_diccionario(datos_socios, \"edad\")\nordenar_diccionario(datos_socios, \"altura_cm\")\nordenar_diccionario(datos_socios, \"nombre\")",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programación funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#listado-de-rimas",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#listado-de-rimas",
    "title": "U2 - Programación funcional",
    "section": "8 Listado de rimas",
    "text": "8 Listado de rimas\npalabras_a_rimar = [\n    \"actividad\",\n    \"bendición\",\n    \"cartelera\",\n    \"ciudad\",\n    \"escalera\",\n    \"estación\",\n    \"felicidad\",\n    \"función\",\n    \"reposera\"\n]\n\nsorted(palabras_a_rimar, key=lambda c: c[::-1])",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programación funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#analistas-de-temperaturas",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#analistas-de-temperaturas",
    "title": "U2 - Programación funcional",
    "section": "9 Analistas de temperaturas",
    "text": "9 Analistas de temperaturas\ntemperaturas_celsius = [\n    25.5, 28.0, 19.3, 31.5, 22.8, 17.0, 30.2, 35.6, 14.2,\n    32.4, 22.7, 10.1, 29.5, 33.9, 22.1, 38.9, 18.4, 16.3\n]\n\n# Enfoque funcional\n# 1\ntemperaturas_f = list(map(lambda c: c * 9 / 5 + 32, temperaturas_celsius))\n\n# 2\n# Opcion A:\nlist(filter(lambda f: f &gt; 80, temperaturas_f))\n\n# Opcion B --&gt; las devuelve en grados celsius\nlist(filter(lambda c: (c * 9 / 5 + 32) &gt; 80, temperaturas_celsius))\n\n# Enfoque idiomático\n[\n    c * 9 / 5 + 32 for c in temperaturas_celsius if c &gt; 22\n]",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programación funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#el-tiempo-vuela",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#el-tiempo-vuela",
    "title": "U2 - Programación funcional",
    "section": "10 El tiempo vuela",
    "text": "10 El tiempo vuela\nimport time\n\ndef crear_cronometro():\n    t_creacion = time.time()\n    def fun():\n        t_ejecucion = time.time()\n        return t_ejecucion - t_creacion\n    return fun\n\ncronometro1 = crear_cronometro()\n\nfor i in range(10**4):\n    i ** 2 # Calcula el cuadrado de un número pero no lo devuelve\n\nprint(f\"El bloque entero tardó {cronometro1()} segundos en ejecutarse.\")\n\n\ncronometro2 = crear_cronometro()\n\nfor j in range(10**6):\n    j // 2 # Calcula la división entera por 2 pero no la devuelve\n\nprint(f\"El segundo bucle tardó {cronometro2()} segundos en ejecutarse.\")\n\n# Punto extra: ¿cache?\ndef crear_cronometro():\n    t_creacion = time.time()\n    tiempos = [t_creacion]\n    def fun():\n        t_ejecucion = time.time()\n        t_anterior = tiempos[-1]\n        tiempos.append(t_ejecucion)\n        return t_ejecucion - t_anterior\n    return fun\n\ng = crear_cronometro()\n\ng()\ng()\ng()",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programación funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#no-perdamos-el-centro",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#no-perdamos-el-centro",
    "title": "U2 - Programación funcional",
    "section": "11 No perdamos el centro",
    "text": "11 No perdamos el centro\nnumeros = [\n    2.05, 1.09, None, 2.31, 2.28, 0.97, 2.59, 2.72, 0.76, None, 1.88, 2.04, 3.25, 1.88, None\n]\n\nnumeros_no_nulos = [n for n in numeros if n is not None]\nmedia = sum(numeros_no_nulos) / len(numeros_no_nulos)\n\n[n - media for n in numeros if n is not None]",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programación funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#en-python-es-mejor",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#en-python-es-mejor",
    "title": "U2 - Programación funcional",
    "section": "12 En Python es mejor",
    "text": "12 En Python es mejor\nnumeros = [\n    4.74346239e-01, -2.90877176e-01, -1.44377789e+00, -4.48680759e+01,\n    -1.21249801e+00, -3.32729317e-01,  2.21676912e-01,  1.05599711e+00,\n    -3.62372053e+00, -2.96441579e-01, -4.28304222e+00,  1.55908820e+02,\n    9.00858234e-01, -1.09384173e+00, -1.51083571e+00, -5.38491167e-01,\n    -3.84153084e-02,  1.20393395e+00,  1.82651406e-01,  2.05179405e+00\n]\n\ndef media(x):\n    return sum(x) / len(x)\n\ndef varianza(x):\n    numerador = 0\n    x_media = media(x)\n    for x_i in x:\n        numerador += (x_i - x_media) ** 2\n    return numerador / len(x)\n\nx_media = media(numeros)\nx_desvio = varianza(numeros) ** 0.5\n\nmap_obj = map(lambda x: (x - x_media) / x_desvio, numeros)\nlist(filter(lambda x: abs(x) &gt; 3, map_obj))\n\n# Respuesta 1: si queremos el numero transformado\n[(x - x_media) / x_desvio for x in numeros if abs((x - x_media) / x_desvio) &gt; 3]\n\n# Respuesta 2: si queremos el numero original\n[x for x in numeros if abs((x - x_media) / x_desvio) &gt; 3]",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programación funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#subiendo-de-rango",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#subiendo-de-rango",
    "title": "U2 - Programación funcional",
    "section": "13 Subiendo de rango",
    "text": "13 Subiendo de rango\ndef frange(start, stop, step):\n    while start &lt; stop:\n        yield start\n        start += step\n\nfor i in frange(3, 4, 0.2):\n    print(f\"{i:.2f}\")\n\nfor i in frange(3, 4, 0.15):\n    print(f\"{i:.2f}\")",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programación funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#la-cajita-musical",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#la-cajita-musical",
    "title": "U2 - Programación funcional",
    "section": "14 La cajita musical",
    "text": "14 La cajita musical\nimport random\n\ndef cajita_musical(versos):\n    versos = versos[:] # Para hacer una copia\n\n    while versos: # Mientras la lista no esté vacía\n        # Generar un índice al azar\n        i = random.randint(0, len(versos) - 1)\n\n        # Sacar y devolver el valor del índice al azar\n        yield versos.pop(i)\n\n\nversos = [\n    \"Tengo que confesar que a veces no me gusta tu forma de ser\",\n    \"Luego te me desapareces y no entiendo muy bien por qué\",\n\n    \"No dices nada romántico cuando llega el atardecer\",\n    \"Te pones de un humor extraño con cada luna llena al mes\",\n\n    \"Pero a todo lo demás le gana lo bueno que me das\",\n    \"Sólo tenerte cerca, siento que vuelvo a empezar\"\n]\n\nfor verso in cajita_musical(versos):\n    print(verso)",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programación funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#el-mejor-precio",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#el-mejor-precio",
    "title": "U2 - Programación funcional",
    "section": "15 El mejor precio",
    "text": "15 El mejor precio\ndef promo_dia_semana(compra):\n  \"\"\"Aplica un 15% de descuento si la compra se realiza un lunes o miércoles.\"\"\"\n  if compra[\"dia\"] in (\"lunes\", \"miércoles\"):\n    return 0.85\n  return 1\n\ndef promo_monto_grande(compra):\n  \"\"\"Aplica un 10% de descuento si la compra tiene un monto superior a $50.000.\"\"\"\n  if compra[\"monto\"] &gt; 50_000:\n    return 0.9\n  return 1\n\ndef promo_edad(compra):\n  \"\"\"Aplica un 20% de descuento si el cliente tiene 65 años o más.\"\"\"\n  if compra[\"edad_cliente\"] &gt;= 65:\n    return 0.8\n  return 1\n\npromos = [promo_dia_semana, promo_monto_grande, promo_edad]\n\ndef mejor_promo(compra):\n  \"\"\"Ordena los descuentos de mayor a menor y aplica el mejor disponible.\"\"\"\n  multiplicador = sorted([promo(compra) for promo in promos])[0]\n\n  return {\n    \"monto_original\": compra[\"monto\"],\n    \"monto_final\": compra[\"monto\"] * multiplicador,\n    \"descuento\": f\"{round((1 - multiplicador) * 100)}%\"\n  }\n\nejemplo_compra = {\"dia\": \"miércoles\", \"edad_cliente\": 42, \"monto\": 66420}\nmejor_promo(ejemplo_compra)\n\n# Solucion (no se si esto es lo que Joaco tenia en mente)\nPROMOS = [] # mayusculas para indicar que es global, una convencion\ndef promo(fun):\n    def envoltura(*args, **kwargs):\n        return fun(*args, **kwargs)\n    PROMOS.append(envoltura)\n    return envoltura\n\n@promo\ndef promo_dia_semana(compra):\n    if compra[\"dia\"] in (\"lunes\", \"miércoles\"):\n        return 0.85\n    return 1\n\n@promo\ndef promo_monto_grande(compra):\n    if compra[\"monto\"] &gt; 50_000:\n        return 0.9\n    return 1\n\n@promo\ndef promo_edad(compra):\n    if compra[\"edad_cliente\"] &gt;= 65:\n        return 0.8\n    return 1\n\nPROMOS # ahora contiene a las funciones\n\ndef mejor_promo(compra):\n    multiplicador = sorted([promo(compra) for promo in PROMOS])[0]\n    return {\n        \"monto_original\": compra[\"monto\"],\n        \"monto_final\": compra[\"monto\"] * multiplicador,\n        \"descuento\": f\"{round((1 - multiplicador) * 100)}%\"\n    }\n\nejemplo_compra = {\"dia\": \"miércoles\", \"edad_cliente\": 42, \"monto\": 66420}\nmejor_promo(ejemplo_compra)\n\nejemplo_compra = {\"dia\": \"jueves\", \"edad_cliente\": 42, \"monto\": 28000}\nmejor_promo(ejemplo_compra)\n\nejemplo_compra = {\"dia\": \"jueves\", \"edad_cliente\": 67, \"monto\": 28000}\nmejor_promo(ejemplo_compra)",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programación funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#bromas-pesadas",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#bromas-pesadas",
    "title": "U2 - Programación funcional",
    "section": "16 Bromas pesadas 😱",
    "text": "16 Bromas pesadas 😱\ndef romper_cada(n):\n    def decorador(func):\n\n        if type(n) is not int or n &lt; 1: # Chequea que \"n\" sea un argumento válido\n            return func\n\n        contador = 0  # Cuántas veces se llamó a la función\n\n        def envoltura(*args, **kwargs):\n            nonlocal contador\n            contador += 1\n\n            if contador % n == 0: # Cada n veces...\n                return None       # ...se rompe\n\n            return func(*args, **kwargs)\n\n        return envoltura\n    return decorador\n\n# Ejemplo de uso\n@romper_cada(3)\ndef saludar(nombre):\n    print(f\"¡Hola, {nombre}!\")\n\nsaludar(\"Carlos\")     # \"¡Hola, Carlos!\"\nsaludar(\"María Luz\")  # \"¡Hola, María Luz!\"\nsaludar(\"Mirna\")      # Nada (la función devuelve None)\nsaludar(\"Diego\")      # \"¡Hola, Diego!\"",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programación funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#pipelines-de-procesamiento",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#pipelines-de-procesamiento",
    "title": "U2 - Programación funcional",
    "section": "17 Pipelines de procesamiento 😱",
    "text": "17 Pipelines de procesamiento 😱\nfrom math import log10\n\n# Sin usar filter\n\ndef eliminar_nulos(datos):\n    datos_sin_nulos = []\n    for fila in datos:\n        if None not in fila.values():\n            datos_sin_nulos.append(fila.copy())\n    return datos_sin_nulos\n\ndef calcular_log(datos, variable):\n    datos_log = []\n    for fila in datos:\n        copia_fila = fila.copy()\n        valor = copia_fila[variable]\n        copia_fila[variable] = round(log10(valor), 3) if (valor is not None) else None\n        datos_log.append(copia_fila)\n    return datos_log\n\ndef filtrar(datos, variable, funcion):\n    datos_filtrados = []\n    for fila in datos:\n        if fila[variable] is not None and funcion(fila[variable]):\n            datos_filtrados.append(fila.copy())\n    return datos_filtrados\n\n\n# Usando filter\n\ndef eliminar_nulos(datos):\n    return list(filter(lambda fila: None not in fila.values(), datos))\n\ndef filtrar(datos, variable, funcion):\n    return list(filter(lambda fila: fila[variable] is not None and funcion(fila[variable]), datos))",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programación funcional"
    ]
  },
  {
    "objectID": "recursos/ejercicios/02_programacion_funcional/index.html#espacio-o-tiempo",
    "href": "recursos/ejercicios/02_programacion_funcional/index.html#espacio-o-tiempo",
    "title": "U2 - Programación funcional",
    "section": "18 ¿Espacio o tiempo? ⏳",
    "text": "18 ¿Espacio o tiempo? ⏳\n# 1 - PREPARACION DE DATOS\n\nimport random\n\nCATEGORIAS = (\"electrónica\", \"hogar\", \"accesorios\", \"deportes\")\n\ndef generar_ventas(n=100_000, seed=None):\n    rng = random.Random(seed)\n    return [\n        {\n            \"id\": f\"P{i+1:06d}\",\n            \"precio\": round(rng.uniform(5.0, 500.0), 2),\n            \"categoria\": CATEGORIAS[i % len(CATEGORIAS)],\n        }\n        for i in range(1, n + 1)\n    ]\n\nventas = generar_ventas(n=100_000, seed=1234)\n\n# 2- Precios con IVA (21%)\n\n# Versión A - List comprehension (ejecuta y guarda todo):\nprecios_con_iva_1 = [venta[\"precio\"] * 1.21 for venta in ventas]\n# Versión B - Generador (define la operación pero no la ejecuta):\nprecios_con_iva_2 = (venta[\"precio\"] * 1.21 for venta in ventas)\n\n# 3 - Filtrar ventas de electrónica\n\n# Versión A - List comprehension:\nelectronica_1 = [venta for venta in ventas if venta[\"categoria\"] == \"electrónica\"]\n#Versión B - Generador:\nelectronica_2 = (venta for venta in ventas if venta[\"categoria\"] == \"electrónica\")\n\n# 4 - Análisis y comparación (tiempo y memoria)\n\nimport time\nimport sys\n\n# A - Lista materializada\nt1 = time.time()\ntotal_1 = sum(venta[\"precio\"] for venta in electronica_1)\nt2 = time.time()\nmem_1 = sys.getsizeof(electronica_1)\nprint(f\"electronica_1 → total: {total_1:.2f}, tiempo: {t2 - t1:.4f}s, memoria: {mem_1} bytes\")\n\n# B - Generador (se consume al usar sum)\nt3 = time.time()\ntotal_2 = sum(venta[\"precio\"] for venta in electronica_2)\nt4 = time.time()\nmem_2 = sys.getsizeof(electronica_2)\nprint(f\"electronica_2 → total: {total_2:.2f}, tiempo: {t4 - t3:.4f}s, memoria: {mem_2} bytes\")\n\n\n# 5- Reutilización del objeto\n\n# Lista: se puede usar de nuevo\nprint(sum(venta[\"precio\"] for venta in electronica_1))  # OK\n\n# Generador: ya fue consumido, no devuelve nada\nprint(sum(venta[\"precio\"] for venta in electronica_2))  # 0.0\n\n# 6 - Reflexión final (resumen corto)\n\n# List comprehension (Versión A): usa más memoria, pero permite reutilizar los datos.\n# Ideal si vas a recorrer los resultados varias veces.\n\n# Generadores (Versión B): consumen poca memoria, pero solo pueden recorrerse una vez.\n# Son más eficientes si solo necesitás un recorrido rápido.\n\n# En problemas donde el dataset es enorme o se usa solo una vez → mejor un generador.\n# Si necesitás acceder varias veces al resultado o compartirlo entre funciones → mejor una lista.",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U2 - Programación funcional"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html",
    "href": "trabajos_practicos/trabajo_grupal.html",
    "title": "Trabajo práctico grupal",
    "section": "",
    "text": "El objetivo de este trabajo práctico es implementar un decorador en Python que permita monitorear la ejecución de funciones y luego utilizarlo en un programa que realiza operaciones de ordenamiento\nMonitorear la ejecución del código es una tarea fundamental en el desarrollo de software: permite detectar cuellos de botella de rendimiento, identificar funciones costosas y generar registros útiles para el debugging o auditoría.\nIncorporar herramientas de monitoreo desde etapas tempranas del desarrollo favorece la escritura de código más eficiente, mantenible y confiable.",
    "crumbs": [
      "Trabajos Prácticos",
      "Trabajo práctico grupal"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html#objetivo",
    "href": "trabajos_practicos/trabajo_grupal.html#objetivo",
    "title": "Trabajo práctico grupal",
    "section": "",
    "text": "El objetivo de este trabajo práctico es implementar un decorador en Python que permita monitorear la ejecución de funciones y luego utilizarlo en un programa que realiza operaciones de ordenamiento\nMonitorear la ejecución del código es una tarea fundamental en el desarrollo de software: permite detectar cuellos de botella de rendimiento, identificar funciones costosas y generar registros útiles para el debugging o auditoría.\nIncorporar herramientas de monitoreo desde etapas tempranas del desarrollo favorece la escritura de código más eficiente, mantenible y confiable.",
    "crumbs": [
      "Trabajos Prácticos",
      "Trabajo práctico grupal"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html#decorador-monitor",
    "href": "trabajos_practicos/trabajo_grupal.html#decorador-monitor",
    "title": "Trabajo práctico grupal",
    "section": "2 Decorador monitor",
    "text": "2 Decorador monitor\nEl decorador a implementar se llamará monitor y deberá ser capaz de registrar información sobre cada ejecución de la función decorada. Su interfaz contará con los siguientes argumentos:\n\nfuncion: la función decorada o None. Por defecto, será None. Su valor será distinto None solo cuando se use el decorador sin argumentos.\nconsola (bool): indica si los mensajes se muestran por consola. Por defecto es True.\narchivo (str o None): nombre del archivo donde se escribirán los mensajes de monitoreo. Por defecto es None. En ese caso, no se guarda ningún archivo.\nformato (str): cadena de formato que determina cómo se construye el mensaje de monitoreo.\n\n\n2.1 Componentes del formato\nLa cadena de formato puede incluir los siguientes componentes:\n\n{tiempo}: fecha y hora de la llamada en formato YYYY-MM-DD HH:mm:ss.mss, donde mss son tres dígitos para los milisegundos.\n{funcion}: nombre de la función.\n{modulo}: nombre del módulo donde se define la función.\n{duracion}: duración total de la ejecución en milisegundos.\n\nEl formato por defecto es:\nformato = \"({tiempo}) {funcion} demoró {duracion} milisegundos.\"\n\n\n2.2 Ejemplos de formato\nformato = \"({tiempo}) {funcion} demoró {duracion} milisegundos.\"\n# (2025-10-08 11:54:12.123) fun demoró 735 milisegundos.\n\nformato = \"({tiempo}) {modulo}::{funcion} demoró {duracion} milisegundos.\"\n# (2025-10-08 11:54:12.123) __main__::fun demoró 735 milisegundos.\n\n\n2.3 Ejemplos de @monitor\n# Ejemplo 1: comportamiento por defecto\n@monitor\ndef fun(x, y):\n    return x + y\n\n# Ejemplo 2: uso de archivo de registros\n@monitor(archivo=\"registros.log\")\ndef fun(x, y, z):\n    return x ** y * z\n\n# Ejemplo 3: uso de formato alternativo\nformato = \"({tiempo}) {modulo}::{funcion} demoró {duracion} milisegundos.\"\n@monitor(archivo=\"registros.log\", formato=formato)\ndef fun(a, b):\n    return list(range(a, b))",
    "crumbs": [
      "Trabajos Prácticos",
      "Trabajo práctico grupal"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html#aplicación-monitoreo-de-algoritmos-de-ordenamiento",
    "href": "trabajos_practicos/trabajo_grupal.html#aplicación-monitoreo-de-algoritmos-de-ordenamiento",
    "title": "Trabajo práctico grupal",
    "section": "3 Aplicación: monitoreo de algoritmos de ordenamiento",
    "text": "3 Aplicación: monitoreo de algoritmos de ordenamiento\nPara comprobar el correcto funcionamiento del decorador, se deben decorar las funciones merge_sort y bubble_sort, ambas encargadas de ordenar listas de números de menor a mayor.\n\n3.1 Implementación de los algoritmos\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if arr[j] &gt; arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n    return arr\n\ndef _merge_sort(arr):\n    if len(arr) &lt;= 1:\n        return arr\n\n    mitad = len(arr) // 2\n    izquierda = _merge_sort(arr[:mitad])\n    derecha = _merge_sort(arr[mitad:])\n\n    return merge(izquierda, derecha)\n\ndef merge(izquierda, derecha):\n    resultado = []\n    i = 0\n    j = 0\n\n    while i &lt; len(izquierda) and j &lt; len(derecha):\n        if izquierda[i] &lt; derecha[j]:\n            resultado.append(izquierda[i])\n            i += 1\n        else:\n            resultado.append(derecha[j])\n            j += 1\n\n    resultado.extend(izquierda[i:])\n    resultado.extend(derecha[j:])\n\n    return resultado\n\ndef merge_sort(arr):\n    return _merge_sort(arr)\n\n\n3.2 Generación de datos de prueba\nPara generar secuencias de números aleatorios se utilizará la función crear_numeros:\nimport random\n\ndef crear_numeros(n):\n    return [random.random() for _ in range(n)]",
    "crumbs": [
      "Trabajos Prácticos",
      "Trabajo práctico grupal"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html#ejecución-del-programa",
    "href": "trabajos_practicos/trabajo_grupal.html#ejecución-del-programa",
    "title": "Trabajo práctico grupal",
    "section": "4 Ejecución del programa",
    "text": "4 Ejecución del programa\nFinalmente, se debe implementar un script llamado programa.py que se ejecute desde la terminal. Este programa generará secuencias aleatorias de diferentes tamaños, las ordenará utilizando ambos algoritmos y registrará el monitoreo correspondiente.\nEjemplo de ejecución:\npython programa.py -n 100 1000 5000 10000 -s monitoreo.log -v\n\nCon -n se especifica una lista de tamaños de secuencias a generar.\nCon -s se indica el nombre del archivo donde se deben guardar los mensajes de monitoreo.\n\nSi no se especifica, no se guardan los mensajes en ningún archivo.\n\nCon -v se indica que se muestren los mensajes de monitoreo en la consola.",
    "crumbs": [
      "Trabajos Prácticos",
      "Trabajo práctico grupal"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html#entregable",
    "href": "trabajos_practicos/trabajo_grupal.html#entregable",
    "title": "Trabajo práctico grupal",
    "section": "5 Entregable",
    "text": "5 Entregable\nLa entrega de este trabajo práctico debe consistir exclusivamente en un archivo .zip que contiene los siguientes archivos, con estos nombres y contenidos exactos:\n\nmonitor.py: contiene la implementación del decorador monitor y las funciones auxiliares necesarias para su funcionamiento.\nprograma.py: contiene las funciones de ordenamiento (merge_sort y bubble_sort) y la implementación de la interfaz de línea de comandos (CLI) que admite los argumentos -n, -s y -v.\nsalida.log: archivo generado al ejecutar el programa con el siguiente comando:\npython programa.py -n 100 1000 5000 10000 -s salida.log -v\n\nNo se deben incluir archivos adicionales ni con nombres distintos a los especificados.\nEl nombre del archivo .zip debe seguir el formato G{n}_{Apellido1}_{Apellido2}_{Apellido3}.zip, donde:\n\n{n} es el número de grupo asignado.\n{Apellido1}, {Apellido2}, {Apellido3} son los apellidos de los integrantes del grupo.\n\nPor ejemplo, G1_Demicco_Gonzalez_Messi.zip.",
    "crumbs": [
      "Trabajos Prácticos",
      "Trabajo práctico grupal"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html#evaluación",
    "href": "trabajos_practicos/trabajo_grupal.html#evaluación",
    "title": "Trabajo práctico grupal",
    "section": "6 Evaluación",
    "text": "6 Evaluación\nLa evaluación contempla no solo la correcta ejecución del programa, sino también la calidad del código desarrollado, considerando aspectos como la organización, claridad, robustez y el uso de estructuras de datos y algoritmos apropiados\nAdemás, el programa será ejecutado desde la línea de comandos con otros valores de entrada para verificar su correcto funcionamiento en diferentes situaciones.",
    "crumbs": [
      "Trabajos Prácticos",
      "Trabajo práctico grupal"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_grupal.html#ayuda",
    "href": "trabajos_practicos/trabajo_grupal.html#ayuda",
    "title": "Trabajo práctico grupal",
    "section": "7 Ayuda",
    "text": "7 Ayuda\n\nDado que el decorador tiene que poder usarse de las siguientes dos maneras:\n@monitor\ndef f(...):\n    ...\n\n@monitor(archivo=\"registros.log\")\ndef f(...):\n    ...\nserá necesario inspeccionar si el argumento funcion de monitor es una función o no. Para ello, puede usar:\nif callable(funcion):\n    # accion\nConsidere el método .format de las cadenas de caracteres para usar el formato pasado al decorador.\nPuede ser útil tener presente que la decoración @monitor no es la única forma de obtener una función a partir de otra función.\nAlgunos enlaces útiles:\n\nUso de código externo\nScripting\nLectura y escritura de archivos\nDecoradores\nFábrica de decoradores",
    "crumbs": [
      "Trabajos Prácticos",
      "Trabajo práctico grupal"
    ]
  },
  {
    "objectID": "informacion/aprobacion.html",
    "href": "informacion/aprobacion.html",
    "title": "Condiciones de aprobación",
    "section": "",
    "text": "📝 Examen parcial: individual y escrito. Hay un recuperatorio, de similares características, que reemplaza la nota del parcial.\n🤝 Trabajo práctico grupal: se hace fuera de clase, en grupos de entre dos y tres integrantes.\n🧑‍💻 Trabajo práctico individual: opcional para promoción, con presentación y defensa oral.\nTodas las instancias se califican en una escala de 0 a 10 y se aprueban con 6.",
    "crumbs": [
      "Información",
      "Condiciones de aprobación"
    ]
  },
  {
    "objectID": "informacion/aprobacion.html#instancias-de-evaluación",
    "href": "informacion/aprobacion.html#instancias-de-evaluación",
    "title": "Condiciones de aprobación",
    "section": "",
    "text": "📝 Examen parcial: individual y escrito. Hay un recuperatorio, de similares características, que reemplaza la nota del parcial.\n🤝 Trabajo práctico grupal: se hace fuera de clase, en grupos de entre dos y tres integrantes.\n🧑‍💻 Trabajo práctico individual: opcional para promoción, con presentación y defensa oral.\nTodas las instancias se califican en una escala de 0 a 10 y se aprueban con 6.",
    "crumbs": [
      "Información",
      "Condiciones de aprobación"
    ]
  },
  {
    "objectID": "informacion/aprobacion.html#condiciones-de-aprobación",
    "href": "informacion/aprobacion.html#condiciones-de-aprobación",
    "title": "Condiciones de aprobación",
    "section": "Condiciones de aprobación",
    "text": "Condiciones de aprobación\n\nPromoción\n\nQuienes aprueben el parcial individual (con nota \\(\\text{P}\\)), el trabajo práctico grupal (con nota \\(\\text{T}\\)) y el trabajo práctico individual con defensa oral (con nota \\(\\text{O}\\)), adquieren la condición de estudiante promovido y su nota final se calcula como \\(0.5 \\times \\text{P} + 0.2 \\times \\text{T} + 0.3 \\times \\text{O}\\).\n\nRegularidad\n\nQuienes aprueben el parcial individual (o su recuperatorio) y el trabajo práctico grupal, pero no accedan o no aprueben el trabajo práctico individual, adquieren la condición de estudiante regular.\n\nLibres\n\nQuienes no aprueben el parcial individual (ni su recuperatorio) o el trabajo práctico grupal, adquieren la condición de estudiante libre.",
    "crumbs": [
      "Información",
      "Condiciones de aprobación"
    ]
  },
  {
    "objectID": "informacion/bibliografia.html",
    "href": "informacion/bibliografia.html",
    "title": "Bibliografía",
    "section": "",
    "text": "Principal\n\nCormen et al. (2022) Downey (2024) Kalb (2022) Kubica (2022) Lott y Phillips (2021) Lott (2022) Mertz (2015) Miller, Ranum, y Yasinovskyy (2023) Sedgewick y Wayne (2011) Sedgewick, Wayne, y Dondero (2015) Sweigart (2020) Tuckfield (2021)\n\n\n\nCormen, Thomas H., Charles E. Leiserson, Ronald L. Rivest, y Clifford Stein. 2022. Introduction to Algorithms. 4th ed. MIT.\n\n\nDowney, Allen B. 2024. Think Python. 3.ª ed. O’Reilly Media. https://allendowney.github.io/ThinkPython/.\n\n\nKalb, Irv. 2022. Object-Oriented Python. No Starch Press.\n\n\nKubica, Jacek. 2022. Data Structures the Fun Way. 1st ed. No Starch Press.\n\n\nLott, Steven F. 2022. Functional Python Programming. 3rd ed. Packt Publishing.\n\n\nLott, Steven F., y Dusty Phillips. 2021. Python Object-Oriented Programming. 4th ed. Packt Publishing.\n\n\nMertz, David. 2015. Functional Programming in Python. O’Reilly Media.\n\n\nMiller, Bradley, David Ranum, y Jan Yasinovskyy. 2023. Problem Solving with Algorithms and Data Structures Using Python. 3rd ed. Franklin, Beedle & Associates.\n\n\nSedgewick, Robert, y Kevin Wayne. 2011. Algorithms. 4th ed. Addison-Wesley Professional.\n\n\nSedgewick, Robert, Kevin Wayne, y Robert Dondero. 2015. Introduction to Programming in Python. Addison-Wesley Professional.\n\n\nSweigart, Al. 2020. Beyond the Basic Stuff with Python. No Starch Press. https://inventwithpython.com/beyond/.\n\n\nTuckfield, Bradford. 2021. Dive Into Algorithms. No Starch Press.\n\n\n\n\nComplementaria\n\nHetland (2014) Mailund (2023) Sweigart (2021) Vaughan (2019) Wickham (2019)\n\n\n\n\n\nHetland, Magnus Lie. 2014. Python Algorithms. 2.ª ed. Apress.\n\n\nMailund, Thomas. 2023. Functional Programming in R 4. 2.ª ed. Apress.\n\n\nSweigart, Al. 2021. The Big Book of Small Python Projects. No Starch Press. https://inventwithpython.com/bigbookpython/.\n\n\nVaughan, Lee. 2019. Impractical Python Projects. No Starch Press.\n\n\nWickham, Hadley. 2019. Advanced R. 2.ª ed. Chapman & Hall/CRC. https://adv-r.hadley.nz/.",
    "crumbs": [
      "Información",
      "Bibliografía"
    ]
  },
  {
    "objectID": "informacion/programa.html",
    "href": "informacion/programa.html",
    "title": "Programa",
    "section": "",
    "text": "Los profesionales en Estadística y Ciencia de Datos necesitan contar con habilidades avanzadas de programación, que les permitan abordar problemas complejos y desarrollar soluciones eficientes y robustas.\nLa asignatura Programación 2 introduce a los estudiantes a conceptos y prácticas avanzadas de la programación, incorporando herramientas y paradigmas que resultan fundamentales para el desarrollo profesional en Estadística y Ciencia de Datos.\nLa asignatura profundiza en enfoques como la programación funcional y la programación orientada a objetos, promoviendo el desarrollo de soluciones estructuradas, reutilizables, robustas y escalables. Además, se abordan conceptos fundamentales de estructuras de datos y algoritmos, relevantes para el diseño y análisis de programas eficientes, así como para la comprensión de la complejidad computacional. Se focaliza en el lenguaje Python, ampliamente utilizado en la industria y la academia por su versatilidad, su ecosistema de librerías y su capacidad para integrarse con diversas tecnologías.\nDictada en el segundo cuatrimestre del primer año, Programación 2 completa los contenidos del área de Fundamentos Computacionales en el Ciclo de Formación Técnica en Estadística y Ciencia de Datos, iniciada en el primer cuatrimestre con Programación 1. De este modo, consolida las competencias informáticas de los estudiantes y los prepara para afrontar asignaturas más avanzadas y desafíos profesionales que requieren un dominio sólido de la programación. Asimismo, fomenta buenas prácticas de desarrollo de código, el uso eficiente de los recursos computacionales y el pensamiento crítico en la resolución de problemas.",
    "crumbs": [
      "Información",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/programa.html#fundamentación",
    "href": "informacion/programa.html#fundamentación",
    "title": "Programa",
    "section": "",
    "text": "Los profesionales en Estadística y Ciencia de Datos necesitan contar con habilidades avanzadas de programación, que les permitan abordar problemas complejos y desarrollar soluciones eficientes y robustas.\nLa asignatura Programación 2 introduce a los estudiantes a conceptos y prácticas avanzadas de la programación, incorporando herramientas y paradigmas que resultan fundamentales para el desarrollo profesional en Estadística y Ciencia de Datos.\nLa asignatura profundiza en enfoques como la programación funcional y la programación orientada a objetos, promoviendo el desarrollo de soluciones estructuradas, reutilizables, robustas y escalables. Además, se abordan conceptos fundamentales de estructuras de datos y algoritmos, relevantes para el diseño y análisis de programas eficientes, así como para la comprensión de la complejidad computacional. Se focaliza en el lenguaje Python, ampliamente utilizado en la industria y la academia por su versatilidad, su ecosistema de librerías y su capacidad para integrarse con diversas tecnologías.\nDictada en el segundo cuatrimestre del primer año, Programación 2 completa los contenidos del área de Fundamentos Computacionales en el Ciclo de Formación Técnica en Estadística y Ciencia de Datos, iniciada en el primer cuatrimestre con Programación 1. De este modo, consolida las competencias informáticas de los estudiantes y los prepara para afrontar asignaturas más avanzadas y desafíos profesionales que requieren un dominio sólido de la programación. Asimismo, fomenta buenas prácticas de desarrollo de código, el uso eficiente de los recursos computacionales y el pensamiento crítico en la resolución de problemas.",
    "crumbs": [
      "Información",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/programa.html#objetivos",
    "href": "informacion/programa.html#objetivos",
    "title": "Programa",
    "section": "Objetivos",
    "text": "Objetivos\nQue los estudiantes logren:\n\nanalizar problemas computacionales y formular soluciones algorítmicas adecuadas;\nimplementar esas soluciones mediante el desarrollo de programas en Python, seleccionando estructuras de datos apropiadas y evaluando la eficiencia de los algoritmos involucrados;\nidentificar y aplicar los paradigmas funcional y orientado a objetos cuando resulte pertinente, desarrollando programas que integren estos enfoques; y\nutilizar e integrar módulos y librerías que permitan extender, organizar y mejorar las funcionalidades de sus programas.",
    "crumbs": [
      "Información",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/programa.html#contenidos",
    "href": "informacion/programa.html#contenidos",
    "title": "Programa",
    "section": "Contenidos",
    "text": "Contenidos\n\nUnidad 1: Introducción a Python\n\nLenguaje Python y su ecosistema. Uso de la interfaz Positron. Sintaxis de Python. Expresiones. Variables y asignaciones. Tipos de datos elementales. Operadores numéricos, de comparación y lógicos. Funciones. Ejecución condicional de código. Bucles definidos y no definidos. Listas, tuplas y diccionarios. Uso de código externo. Módulos y librerías. Librería estándar de Python. Instalación y gestión de librerías. Scripting. Lectura y escritura de archivos de texto plano. Modularización de programas.\n\nUnidad 2: Programación funcional\n\nPrincipios fundamentales. Funciones como ciudadanos de primera clase. Funciones puras. Funciones anónimas. Closures. Recursión. Funciones de orden superior: map, filter, reduce. Evaluación estricta y no estricta. Evaluación perezosa (lazy) e inmediata (eager). Generadores. Aplicación parcial de funciones. Decoradores.\n\nUnidad 3: Programación orientada a objetos\n\nPrincipios fundamentales. Objetos, clases e instancias. Atributos y métodos. Propiedades públicas y privadas. Métodos de clase y métodos de instancia. Encapsulamiento. Herencia simple y múltiple. Polimorfismo. Métodos especiales (dunder methods). Decoradores aplicados a métodos. Sobrecarga de operadores.\n\nUnidad 4: Estructuras de datos\n\nConcepto y clasificación. Estructuras lineales: listas, listas enlazadas, pilas y colas. Operaciones básicas: agregar, quitar y recorrer. Estructuras no lineales: árboles y grafos. Recorridos de árboles y grafos. Uso de colecciones de Python (list, deque, dict, set). Arreglos multidimensionales de NumPy.\n\nUnidad 5: Algoritmos de búsqueda y ordenamiento\n\nConcepto de algoritmo y complejidad. Notación Big O. Búsqueda lineal y binaria. Algoritmos de ordenamiento: bubble sort, insertion sort, selection sort, quick sort y merge sort. Comparación de eficiencia. Funciones de búsqueda y ordenamiento en Python (sorted, sort, heapq).",
    "crumbs": [
      "Información",
      "Programa"
    ]
  },
  {
    "objectID": "informacion/calendario.html",
    "href": "informacion/calendario.html",
    "title": "Calendario",
    "section": "",
    "text": "Semana\nFecha\nTemas\nOtras actividades\n\n\n\n\n1\n4 de agosto\n• Lenguaje Python y su ecosistema.• Uso de Python en la terminal.• Uso de Positron.• Python en Positron.• Python: expresiones; variables y asignaciones; tipos de datos elementales; operadores numéricos, de comparación y lógicos.• Jupyter Notebooks.• Definición de funciones.• Ejecución condicional de código.\n\n\n\n2\n11 de agosto\n• Colecciones de datos en Python: list, tuple, dict y set.• Secuencias.• Las secuencias str y range.• Bucles definidos (for) y no definidos (while).• Sentencias break y continue.\n\n\n\n3\n17 de agosto\n• Uso de código externo (propio y de terceros).• Módulos y librerías.• Librería estándar de Python.• Instalación y gestión de librerías.• Scripting.• Modularización de programas.• Lectura y escritura de archivos de texto plano.\n\n\n\n4\n25 de agosto\n• Funciones como ciudadanos de primera clase.• Funciones puras.• Funciones anónimas.• Closures.• Recursión.\n\n\n\n5\n1 de septiembre\n• Funciones de orden superior: map, filter, reduce.• Evaluación estricta y no estricta.• Evaluación perezosa (lazy) e inmediata (eager).• Generadores.• Aplicación parcial de funciones.• Decoradores.\n\n\n\n6\n15 de septiembre\n• Objetos, clases e instancias.• Atributos y métodos.• Propiedades públicas y privadas.• Métodos de clase y métodos de instancia.\n\n\n\n7\n22 de septiembre\n• Encapsulamiento.• Herencia simple y múltiple.• Polimorfismo.• Abstracción.\n\n\n\n8\n29 de septiembre\n• Métodos especiales (dunder methods).• Decoradores aplicados a métodos.• Sobrecarga de operadores.\nParcial\n\n\n9\n6 de octubre\n• Concepto y clasificación.• Estructuras lineales y no lineales.• Listas y listas enlazadas.• Operaciones básicas: agregar, quitar y recorrer.\nPresentación TP Grupal\n\n\n10\n13 de octubre\n• Hashing.• Diccionarios y conjuntos como estructuras asociativas.• Árboles y grafos.\nRecuperatorio\n\n\n11\n20 de octubre\n• Arreglos multidimensionales de NumPy.\n\n\n\n12\n27 de octubre\n• Concepto de algoritmo y complejidad.• Algoritmos de búsqueda.• Búsqueda lineal y binaria.• Notación Big O.\n\n\n\n13\n3 de noviembre\n• Algoritmos de ordenamiento.• bubble sort, insert sort, select sort, quick sort y merge sort.• Comparación de algoritmos de ordenamiento.\nEntrega TP GrupalPresentación TP Individual\n\n\n14\n10 de noviembre\n• Funciones de búsqueda y ordenamiento en Python.\n\n\n\n15\n17 de noviembre\n\n\n\n\n16\n24 de noviembre\n\nEntrega y defensa TP Individual",
    "crumbs": [
      "Información",
      "Calendario"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_individual.html",
    "href": "trabajos_practicos/trabajo_individual.html",
    "title": "Trabajo práctico final",
    "section": "",
    "text": "En el lenguaje R, los data frames son una de las estructuras de datos más utilizadas. Permiten almacenar y manipular información tabular de forma sencilla, donde cada columna representa una variable y cada fila una observación.\nEn Python no existe una estructura built-in equivalente al data frame. En la práctica, se utilizan librerías como pandas o polars, que implementan estructuras de datos diseñadas específicamente para este propósito. Ambas librerías se apoyan en dos estructuras fundamentales: Series, que representa una columna, y DataFrame, que representa una tabla completa compuesta por varias series.\nEl objetivo de este trabajo es implementar de forma básica las clases Series y DataFrame, con el fin de profundizar en la programación orientada a objetos y en el uso de Python como lenguaje de desarrollo. Además, busca comprender el funcionamiento interno de las estructuras de datos tabulares y los principios de diseño que las hacen posibles.",
    "crumbs": [
      "Trabajos Prácticos",
      "Trabajo práctico final"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_individual.html#introducción",
    "href": "trabajos_practicos/trabajo_individual.html#introducción",
    "title": "Trabajo práctico final",
    "section": "",
    "text": "En el lenguaje R, los data frames son una de las estructuras de datos más utilizadas. Permiten almacenar y manipular información tabular de forma sencilla, donde cada columna representa una variable y cada fila una observación.\nEn Python no existe una estructura built-in equivalente al data frame. En la práctica, se utilizan librerías como pandas o polars, que implementan estructuras de datos diseñadas específicamente para este propósito. Ambas librerías se apoyan en dos estructuras fundamentales: Series, que representa una columna, y DataFrame, que representa una tabla completa compuesta por varias series.\nEl objetivo de este trabajo es implementar de forma básica las clases Series y DataFrame, con el fin de profundizar en la programación orientada a objetos y en el uso de Python como lenguaje de desarrollo. Además, busca comprender el funcionamiento interno de las estructuras de datos tabulares y los principios de diseño que las hacen posibles.",
    "crumbs": [
      "Trabajos Prácticos",
      "Trabajo práctico final"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_individual.html#clase-series",
    "href": "trabajos_practicos/trabajo_individual.html#clase-series",
    "title": "Trabajo práctico final",
    "section": "2 Clase Series",
    "text": "2 Clase Series\nUna Series representa una estructura unidimensional de datos, similar a un vector o una columna. En nuestro caso, soportan cuatro tipos de datos: numéricos enteros (int), numéricos flotantes (float), texto (str) y booleanos (bool). Las series pueden también incluir valores nulos, representados por None.\n\n2.1 Inicialización\nPara inicializar una Series se necesita una secuencia de valores del mismo tipo. Opcionalmente, se pasan valores para los argumentos name y dtype. El primero le asigna un nombre a la serie y el segundo un tipo de dato. El nombre de la serie es una cadena de texto y el tipo puede ser \"int\", \"float\", \"str\" o \"bool\".\n\nEjemplos\nSe muestran algunos bloques de código donde se inicializan objetos de la clase Series.\nEjemplo mínimo, donde se pasa una secuencia de enteros.\n# Ejemplo 1\nserie = Series([1, 2, 3, 4])\nserie\n# Series: ''\n# len: 4\n# dtype: int\n# [\n#     1\n#     2\n#     3\n#     4\n# ]\nSerie nombrada:\nserie = Series([1.0, 2.0, 3.0], name=\"x\")\nserie\n# Series: 'x'\n# len: 3\n# dtype: float\n# [\n#     1.0\n#     2.0\n#     3.0\n# ]\nSerie con nombre y tipo explícito:\nserie = Series([1, 2, 3], name=\"cantidad\", dtype=\"float\")\nserie\n# Series: 'cantidad'\n# len: 3\n# dtype: float\n# [\n#     1.0\n#     2.0\n#     3.0\n# ]\nNotar que al utilizar dtype=\"float\" los valores enteros son convertidos a flotantes.\n\n\n\n2.2 Atributos\nLos objetos de la clase Series tienen los siguientes atributos públicos:\n\n\n\n\n\n\n\nMétodo\nDescripción\n\n\n\n\ndtype\nTipo de dato (\"int\", \"float\", \"str\", \"bool\")\n\n\nname\nEl nombre de la serie\n\n\nlen\nLa longitud de la serie\n\n\n\n\n\n2.3 Métodos para manipular de datos\nLa clase Series disponibiliza los siguientes métodos para la manipulación de datos:\n\n\n\n\n\n\n\nMétodo\nDescripción\n\n\n\n\nclone(self)\nDevuelve una nueva serie, idéntica a la original.\n\n\nhead(self, n=5)\nDevuelve una nueva serie con los primeros n valores.\n\n\ntail(self, n=5)\nDevuelve una nueva serie con los últimos n valores.\n\n\nappend(self, x)\nAgrega el elemento x al final de la serie.\n\n\nextend(self, s)\nExtiende la serie con los elementos de la serie s.\n\n\nfilter(self, f)\nDevuelve una nueva serie con los elementos de la serie que al ser pasados a f devuelven un valor verdadero. Por ejemplo, serie.filter(lambda x: x &gt; 5) devuelve una serie con los valores que son mayores a 5.\n\n\nwhere(self, f)\nDevuelve una nueva lista con los índices de los elementos que al ser pasados a f devuelven True\n\n\nis_null(self)\nDevuelve una serie de valores booleanos. Cada elemento será True si el elemento original es nulo.\n\n\nis_not_null(self)\nDevuelve una serie de valores booleanos. Cada elemento será True si el original es no nulo.\n\n\nfill_null(self, x)\nReemplaza los valores nulos por x.\n\n\nrename(self, name)\nCambia el nombre de la serie por name.\n\n\nsort(self, ...)\nOrdena la serie. El parámetro descending determina si se ordena de forma ascendente (por defecto) o descendente. y el parámetro in_place determina si se modifica la serie in-place o si se devuelve una nueva (por defecto).\n\n\nargsort(self, ...)\nDevuelve una lista con los índices que ordenan a la serie. El parámetro descending determina si se ordena de forma ascendente (por defecto) o descendente.\n\n\n\n\nEjemplos\nserie = Series([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\nserie.head()\n# Series: ''\n# len: 5\n# dtype: int\n# [\n#     1\n#     2\n#     3\n#     4\n#     5\n# ]\nserie = Series([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\nserie.tail(3)\n# Series: ''\n# len: 3\n# dtype: int\n# [\n#     8\n#     9\n#     10\n# ]\nserie = Series(list(\"ABCD\"))\nserie.clone()\n# Series: ''\n# len: 4\n# dtype: str\n# [\n#     A\n#     B\n#     C\n#     D\n# ]\ns1 = Series([True, True, False])\ns1.append(False)\ns1\n# Series: ''\n# len: 4\n# dtype: bool\n# [\n#     True\n#     True\n#     False\n#     False\n# ]\ns1 = Series([1, 2, 3])\ns2 = Series([4, 5, 6])\ns1.extend(s2)\ns1\n# Series: ''\n# len: 6\n# dtype: int\n# [\n#     1\n#     2\n#     3\n#     4\n#     5\n#     6\n# ]\ns = Series([1, 20, 50, 2, 100, 3])\ns.filter(lambda x: x &lt; 20)\n# Series: ''\n# len: 3\n# dtype: int\n# [\n#     1\n#     2\n#     3\n# ]\ns = Series([1, 20, 50, 2, 100, 3])\nindices = s.where(lambda x: x &lt; 20)\n\nindices\n# [0, 3, 5]\n\n[s[i] for indices in indices]\n# [1, 2, 3]\ns = Series([1, 20, 50, 2, 100, 3])\ns.is_null()\n# Series: ''\n# len: 6\n# dtype: bool\n# [\n#     False\n#     False\n#     False\n#     False\n#     False\n#     False\n# ]\ns = Series([5, None, None, 10])\ns.is_not_null()\n# Series: ''\n# len: 4\n# dtype: bool\n# [\n#     True\n#     False\n#     False\n#     True\n# ]\ns = Series([5, None, None, 10])\ns.fill_null(-1)\n# Series: ''\n# len: 4\n# dtype: int\n# [\n#     5\n#     -1\n#     -1\n#     10\n# ]\ns = Series(list(\"xyz\"))\ns.rename(\"letras\")\ns\n# Series: 'letras'\n# len: 3\n# dtype: str\n# [\n#     x\n#     y\n#     z\n# ]\ns = Series([128, 256.0, 42.5, 35])\ns.sort()\n# Series: ''\n# len: 4\n# dtype: float\n# [\n#     35.0\n#     42.5\n#     128.0\n#     256.0\n# ]\ns = Series([128, 256.0, 42.5, 35])\ns.sort(descending=True)\n# Series: ''\n# len: 4\n# dtype: float\n# [\n#     256.0\n#     128.0\n#     42.5\n#     35.0\n# ]\ns = Series([128, 256.0, 42.5, 35])\nindices = s.argsort()\nindices\n# [3, 2, 0, 1]\n\n[s[i] for i in indices] # Se utilizan los indices\n# [35.0, 42.5, 128.0, 256.0]\n\n\n\n\n\n\nSobre los tipos de datos\n\n\n\nTodas las operaciones que modifican una serie solo deben soportar valores del mismo tipo que el de la serie. Por ejemplo, debe ser posible usar append(125.5) en una serie de tipo flotante, pero no en una serie de tipo texto.\n\n\n\n\n\n2.4 Métodos para calcular agregaciones\nLos siguientes métodos obtienen un valor a partir de todos los valores de la serie. En todos los casos se ignoran los valores nulos. Solo se pueden aplicar a series numéricas.\n\n\n\n\n\n\n\nMétodo\nDescripción\n\n\n\n\nmin(self)\nEl valor más pequeño.\n\n\nmax(self)\nEl valor más grande.\n\n\nsum(self)\nLa suma de los elementos.\n\n\nmean(self)\nEl promedio de los elementos.\n\n\nproduct(self)\nEl producto de los elementos.\n\n\nstd(self)\nEl desvío estándar.\n\n\nvar(self)\nLa varianza.\n\n\n\n\nEjemplos\ns1 = Series([1, 4, 5, 2, 10, 6, 3, 7, 8, 9])\ns2 = Series([True, True, False, True])\n\ns1.min()     # 1\ns1.max()     # 9\ns1.sum()     # 55\ns1.mean()    # 5.5\ns1.product() # 3628800\ns1.std()     # 2.87228\ns1.var()     # 8.25\n\n\n\n2.5 Métodos especiales\n\nAritméticos\nEstos operadores solo se pueden utilizar con series de tipo numérico. Si other es un número, se recicla para todos los elementos de la serie. Por ejemplo:\ns = Series([5, 6, 7])\ns * 3.0\n# Series: ''\n# len: 3\n# dtype: float\n# [\n#     15.0\n#     18.0\n#     21.0\n# ]\nSi other es otra Series, deben tener la misma longitud y la operación se hace elemento a elemento. Por ejemplo:\ns1 = Series([10, 20, 30])\ns2 = Series([5, 25, 28])\ns1 &gt; s2\n# Series: ''\n# len: 3\n# dtype: bool\n# [\n#     True\n#     False\n#     True\n# ]\nLos métodos a implementar se resumen en la siguiente tabla:\n\n\n\n\n\n\n\nMétodo\nDescripción\n\n\n\n\n__eq__(self, other)\nIgual a\n\n\n__gt__(self, other)\nMayor que\n\n\n__ge__(self, other)\nMayor o igual que\n\n\n__lt__(self, other)\nMenor que\n\n\n__le__(self, other)\nMenor o igual que\n\n\n__add__(self, other)\nSuma\n\n\n__sub__(self, other)\nResta\n\n\n__mul__(self, other)\nMultiplicación\n\n\n__truediv__(self, other)\nDivisión flotante\n\n\n__pow__(self, other)\nPotencia\n\n\n\n\n\nAcceso e iteración\nEstos métodos permiten interactuar con la serie de forma natural.\n\n\n\n\n\n\n\nMétodo\nDescripción\n\n\n\n\n__repr__(self)\nRepresentación textual\n\n\n__len__(self)\nLongitud de la serie\n\n\n__contains__(self, item)\nDetermina si item se encuentra en la serie\n\n\n__getitem__(self, index)\nObtiene el elemento en la posición index\n\n\n__iter__(self)\nPermite iterar sobre los elementos de la serie\n\n\n\n\nEjemplos\nEl método de representación es el que determina que la serie se vea de la siguiente manera al mostrarla en la terminal:\n# Series: ''\n# len: 3\n# dtype: float\n# [\n#     15.0\n#     18.0\n#     21.0\n# ]\nLa cantidad máxima de elementos que se muestra es 10. Una serie con los números del 1 al 10 se ve de la siguiente manera:\n# Series: ''\n# len: 10\n# dtype: float\n# [\n#     1\n#     2\n#     3\n#     4\n#     5\n#     6\n#     7\n#     8\n#     9\n#     10\n# ]\nY si la serie tiene más elementos, se muestran los primeros cinco, luego tres puntos suspensivos, y finalmente los últimos cinco. Por ejemplo, una serie con los números del 1 al 100.\n# Series: ''\n# len: 100\n# dtype: float\n# [\n#     1\n#     2\n#     3\n#     4\n#     5\n#     ...\n#     96\n#     97\n#     98\n#     99\n#     100\n# ]\nEl método especial __len__ permite obtener la cantidad de elementos de la serie con len():\nlen(s)\n# 100\nPor su parte, __contains__(self, item) se ejecuta cuando utilizamos el operador in, de esta manera:\n20 in s\n# True\n\n200 in s\n# False\nEl método __getitem__(self, index) nos permite indexar la serie, tratandola como una secuencia (¡qué es lo que es!):\ns = Series([-10, 10, -20, 20, -30, 30])\ns[0] # -10\ns[1] # 10\nFinalmente, el método __iter__(self) nos permite iterar a través de la secuencia.\ns = Series([-10, 10, -20, 20, -30, 30])\nfor s_i in s:\n    if s_i &gt; 0:\n        print(s_i)\n# 10\n# 20\n# 30",
    "crumbs": [
      "Trabajos Prácticos",
      "Trabajo práctico final"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_individual.html#clase-dataframe",
    "href": "trabajos_practicos/trabajo_individual.html#clase-dataframe",
    "title": "Trabajo práctico final",
    "section": "3 Clase DataFrame",
    "text": "3 Clase DataFrame\nUn DataFrame representa una estructura bidimensional de datos, organizada en filas y columnas, donde cada columna está asociada a una instancia de Series. Se trata de una tabla en la que cada columna tiene un nombre único y un tipo de dato consistente a lo largo de toda la columna.\nEn este trabajo, la clase DataFrame se construye a partir de un conjunto de objetos Series, todas con la misma longitud, o a partir de un diccionario que mapea nombres de columnas a secuencias de valores compatibles.\n\n3.1 Inicialización\nPara crear un DataFrame, se puede pasar:\n\nUn diccionario donde las claves son los nombres de las columnas y los valores son listas o instancias de Series.\nUna lista de Series, donde cada una tiene asignado un nombre (name) distinto.\n\nEl inicializador debe validar que todas las columnas tengan la misma cantidad de filas. Si alguna columna contiene valores nulos, estos se preservan.\n\nEjemplos\nA partir de listas:\ndf = DataFrame({\n    \"x\": [1, 2, 3, 4],\n    \"y\": [10, 20, 30, 40]\n})\ndf\n# shape: (4, 2)\n# ┌───┬────┐\n# │ x │ y  │\n# ├───┼────┤\n# │ 1 │ 10 │\n# │ 2 │ 20 │\n# │ 3 │ 30 │\n# │ 4 │ 40 │\n# └───┴────┘\nA partir de Series:\ns1 = Series([1, 2, 3], name=\"x\")\ns2 = Series([True, False, True], name=\"condicion\")\n\ndf = DataFrame([s1, s2])\ndf\n# shape: (3, 2)\n# ┌───┬───────────┐\n# │ x │ condicion │\n# ├───┼───────────┤\n# │ 1 │ True      │\n# │ 2 │ False     │\n# │ 3 │ True      │\n# └───┴───────────┘\n\n\n\n3.2 Atributos\nLos objetos DataFrame exponen los siguientes atributos públicos:\n\n\n\n\n\n\n\nAtributo\nDescripción\n\n\n\n\ncolumns\nLista con los nombres de las columnas, en orden\n\n\ndtypes\nLista con los tipos de datos de las columnas, en orden\n\n\nshape\nDimensión de la tabla (filas, columnas)\n\n\nschema\nDiccionario que mapea las columnas a sus tipos\n\n\nheight\nCantidad de filas\n\n\nwidth\nCantidad de columnas\n\n\n\n\nEjemplos\ndf = DataFrame({\n    \"nombre\": [\"Ana\", \"Juan\", \"María\", \"Luna\"],\n    \"edad\": [25, 32, 29, 18],\n    \"activo\": [True, False, True, True]\n})\n\ndf.columns   # [\"nombre\", \"edad\", \"activo\"]\ndf.dtypes    # [\"str\", \"int\", \"bool\"]\ndf.shape     # (4, 3)\ndf.schema    # {\"nombre\": \"str\", \"edad\": \"int\", \"activo\": \"bool\"}\ndf.height    # 4\ndf.width     # 3\n\n\n\n3.3 Métodos\nLos DataFrame cuentan con un conjunto de métodos que permiten manipular y transformar los datos de manera sencilla.\n\n\n\n\n\n\n\nMétodo\nDescripción\n\n\n\n\nhead(self, n=5)\nDevuelve un nuevo DataFrame con las primeras n filas.\n\n\ntail(self, n=5)\nDevuelve un nuevo DataFrame con las últimas n filas.\n\n\nselect(self, *columns)\nDevuelve un nuevo DataFrame con solo las columnas indicadas.\n\n\nfilter(self, *predicates)\nDevuelve un DataFrame con las filas que cumplen todas las condiciones.\n\n\ndrop_nulls(self)\nElimina todas las filas que contengan valores nulos.\n\n\nsort(self, name, descending)\nDevuelve un nuevo DataFrame con las filas ordenadas según la columna name. Por defecto, descending es False.\n\n\n\n\nEjemplos\ndf = DataFrame({\n    \"x\": [1, 2, 3, 4, 5, 6],\n    \"y\": [10, 20, 30, 40, 50, 60],\n    \"z\": [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]\n})\n\ndf.head(3)\n# shape: (3, 3)\n# ┌────┬────┬────┐\n# │ x  │ y  │ z  │\n# ├────┼────┼────┤\n# │ 1  │ 10 │ a  │\n# │ 2  │ 20 │ b  │\n# │ 3  │ 30 │ c  │\n# └────┴────┴────┘\n\n```python\ndf.tail(1)\n# shape: (1, 3)\n# ┌────┬────┬────┐\n# │ x  │ y  │ z  │\n# ├────┼────┼────┤\n# │ 6  │ 60 │ f  │\n# └────┴────┴────┘\ndf.select(\"x\", \"z\")\n# shape: (6, 2)\n# ┌────┬────┐\n# │ x  │ z  │\n# ├────┼────┤\n# │ 1  │ a  │\n# │ 2  │ b  │\n# │ 3  │ c  │\n# │ 4  │ d  │\n# │ 5  │ e  │\n# │ 6  │ f  │\n# └────┴────┘\nPara filtrar, se pasan tuplas de longitud dos. El primer valor es el nombre de la columna, y el segundo es una función que se aplica a cada elemento de esa columna y devuelve un valor booleano. Por ejemplo, se seleccionan las filas donde \"x\" es impar e \"y\" es mayor a 30.\ndf.filter((\"x\", lambda x: x % 2 != 0), (\"y\", lambda x: x &gt; 30))\n# shape: (1, 2)\n# ┌────┬────┬────┐\n# │ x  │ y  │ z  │\n# ├────┼────┼────┤\n# │ 5  │ 50 │ e  │\n# └────┴────┴────┘\ndf = DataFrame({\n    \"a\": [1, None, 3],\n    \"b\": [\"x\", \"y\", None]\n})\ndf.drop_nulls()\n# shape: (1, 2)\n# ┌────┬────┐\n# │ a  │ b  │\n# ├────┼────┤\n# │ 1  │ x  │\n# └────┴────┘\ndf = DataFrame({\n    \"x\": [3, 1, 2],\n    \"y\": [5, 15, 20]\n})\ndf.sort(\"x\")\n# shape: (3, 2)\n# ┌────┬────┐\n# │ x  │ y  │\n# ├────┼────┤\n# │ 1  │ 15 │\n# │ 2  │ 20 │\n# │ 3  │ 5  │\n# └────┴────┘\n\n\n\n3.4 Métodos especiales\nEstos métodos permiten interactuar con el DataFrame de manera natural y en sintonía con el comportamiento esperado de una colección de datos tabulares.\n\n\n\n\n\n\n\nMétodo\nDescripción\n\n\n\n\n__len__(self)\nDevuelve la cantidad de filas del DataFrame.\n\n\n__repr__(self)\nRepresentación textual del DataFrame.\n\n\n__getitem__(self, name)\nDevuelve la Series asociada a la columna name.\n\n\n__setitem__(self, name, value)\nAgrega o sobreescribe la columna name con la Series value.\n\n\n\n\nEjemplos\nEl método especial __len__ permite obtener la cantidad de filas del DataFrame mediante la función built-in len():\ndf = DataFrame({\n    \"nombre\": [\"Ana\", \"Juan\", \"María\"],\n    \"edad\": [25, 32, 29]\n})\n\nlen(df)\n# 3\nEl método __repr__ define la representación textual del DataFrame, es decir, cómo se muestra al imprimirlo en la terminal o al evaluarlo en una celda interactiva.\ndf\n# shape: (3, 2)\n# ┌────────┬──────┐\n# │ nombre │ edad │\n# ├────────┼──────┤\n# │ Ana    │ 25   │\n# │ Juan   │ 32   │\n# │ María  │ 29   │\n# └────────┴──────┘\nCuando el DataFrame contiene más de diez filas, se muestran las primeras cinco y las últimas cinco, separadas por puntos suspensivos (...). Esto permite obtener una vista general del contenido sin saturar la salida.\n# shape: (20, 2)\n# ┌────────┬──────┐\n# │ nombre │ edad │\n# ├────────┼──────┤\n# │ Ana    │ 25   │\n# │ Juan   │ 32   │\n# │ María  │ 29   │\n# │ David  │ 24   │\n# │ Pipo   │ 12   │\n# │ ...    │ ...  │\n# │ Laura  │ 45   │\n# │ Marcos │ 17   │\n# │ Lucas  │ 41   │\n# │ Nora   │ 37   │\n# │ Zoe    │ 23   │\n# └────────┴──────┘\nPor su parte, __getitem__ permite acceder al objeto Series de una columna por su nombre:\ndf[\"nombre\"]\n# Series: 'nombre'\n# len: 3\n# dtype: str\n# [\n#     Ana\n#     Juan\n#     María\n# ]\nEn conjunto con __setitem__, permiten crear o modificar columnas en la tabla:\ndf[\"edad_meses\"] = df[\"edad\"] * 12\ndf\n# shape: (3, 3)\n# ┌────────┬──────┐────────────┐\n# │ nombre │ edad │ edad_meses │\n# ├────────┼──────┤────────────┤\n# │ Ana    │ 25   │ 300        │\n# │ Juan   │ 32   │ 384        │\n# │ María  │ 29   │ 248        │\n# └────────┴──────┘────────────┘",
    "crumbs": [
      "Trabajos Prácticos",
      "Trabajo práctico final"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_individual.html#pruebas",
    "href": "trabajos_practicos/trabajo_individual.html#pruebas",
    "title": "Trabajo práctico final",
    "section": "4 Pruebas",
    "text": "4 Pruebas\n\n4.1 Pruebas para Series\nCrear una serie y verificar operaciones básicas de acceso y longitud:\ns = Series([10, 20, 30, 40, 50], name=\"valores\")\ns.head(3)\ns.tail(2)\nlen(s)\nAgregar y extender una serie, manteniendo el tipo de datos:\ns1 = Series([1, 2, 3])\ns2 = Series([4, 5])\ns1.append(6)\ns1.extend(s2)\ns1\nFiltrar valores según una condición y obtener sus índices:\ns = Series([10, 25, 50, 75, 90, 100])\ns.filter(lambda x: x &lt; 60) # Una Series\ns.where(lambda x: x % 25 == 0) # Una lista de enteros\nDetectar y reemplazar valores nulos:\ns = Series([5, None, 15, None])\ns.is_null() # Una Series de booleanos\ns.is_not_null() # Otra Series de booleanos\ns.fill_null(0) # Una series de enteros\nOrdenar y obtener índices de ordenamiento:\ns = Series([42, 7, 100, 3])\ns.sort() # Una serie de enteros\ns.argsort() # Una lista de indices enteros\nCombinar filtrado y agregaciones:\ns = Series([5, 10, 15, 20, 25, 30])\ns.filter(lambda x: x &gt; 10).mean() # Promedio de los valores mayores a 10\ns.filter(lambda x: x &gt; 10).sum() # Suma de los valores mayores a 10\nIterar a través de la serie:\nfor x in Series(list(\"xyz\")):\n    print(x)\nDeterminar si la serie contiene un valor:\ns = Series([\"a\", \"a\", \"a\", None, \"z\"])\n\"a\" in s\n\n\n4.2 Pruebas para DataFrame\nEste conjunto de datos de ejemplo permite probar los distintos métodos implementados en las clases Series y DataFrame.\ndf = DataFrame({\n    \"id\": list(range(1, 31)),\n    \"nombre\": [f\"persona_{i}\" for i in range(1, 31)],\n    \"edad\": [20 + (i % 15) for i in range(30)],\n    \"activo\": [i % 2 == 0 for i in range(30)],\n    \"puntaje\": [\n        round(50 + (i * 1.5) % 25, 1) if i not in (4, 11, 19, 25) else None\n        for i in range(30)\n    ]\n})\nVerificar atributos:\ndf.height\ndf.width\ndf.shape\ndf.columns\ndf.schema\nSeleccionar columnas y filas:\ndf.get_column(\"edad\") # Devuelve una Series\ndf[5] # Devuelve un diccionario\nAplicar filtros sobre una o múltiples columnas:\ndf.filter((\"edad\", lambda e: e &gt; 30))\ndf.filter((\"activo\", lambda a: a), (\"puntaje\", lambda p: p &gt; 60))\nSeleccionar subconjunto de columnas:\ndf.select(\"nombre\", \"puntaje\")\nOrdenar filas según una columna:\ndf.sort(\"edad\")\ndf.sort(\"puntaje\", descending=True)\nCombinar varios métodos: filtrar, seleccionar una columna y calcular una agregación:\ndf.filter((\"activo\", lambda a: a)).get_column(\"puntaje\").mean()\nEstandarizar el puntaje de las personas:\ndf[\"puntaje_z\"] = (df[\"puntaje\"] - df[\"puntaje\"].mean()) / df[\"puntaje\"].std()",
    "crumbs": [
      "Trabajos Prácticos",
      "Trabajo práctico final"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_individual.html#entregable",
    "href": "trabajos_practicos/trabajo_individual.html#entregable",
    "title": "Trabajo práctico final",
    "section": "5 Entregable",
    "text": "5 Entregable\nLa entrega de este trabajo práctico debe consistir exclusivamente en un archivo comprimido (.zip) que contenga los siguientes archivos, con los nombres y contenidos indicados:\n\nseries.py: implementación de la clase Series. Puede incluir un bloque de código de prueba, siempre que no se ejecute automáticamente al importar la clase desde otro módulo.\ndataframe.py: implementación de la clase DataFrame. También puede contener pruebas, que no deben ejecutarse al importar el módulo.\ntest_series.py: incluye los ejemplos y pruebas correspondientes a la clase Series presentados en este trabajo práctico.\ntest_dataframe.py: incluye los ejemplos y pruebas correspondientes a la clase DataFrame. Si se prueban Series obtenidas desde un DataFrame, también deben incluirse en este archivo.\n\nNo se deben agregar otros archivos ni utilizar nombres diferentes a los especificados.\nEl nombre del archivo comprimido debe seguir el formato: {Apellido}_{Nombre}.zip. Por ejemplo: Alvarez_Julian.zip.",
    "crumbs": [
      "Trabajos Prácticos",
      "Trabajo práctico final"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_individual.html#evaluación",
    "href": "trabajos_practicos/trabajo_individual.html#evaluación",
    "title": "Trabajo práctico final",
    "section": "6 Evaluación",
    "text": "6 Evaluación\nLa evaluación consta de dos partes:\n\nEjecución y revisión del código: Se verificará que los archivos test_series.py y test_dataframe.py se ejecuten correctamente. Se valorará la presencia de comentarios que faciliten la comprensión de las pruebas, así como la correcta implementación de las clases Series y DataFrame en series.py y dataframe.py. También se considerarán la organización del código, su claridad, robustez y la reutilización de los métodos desarrollados. Esta instancia se califica de 0 a 10 y se aprueba con una nota mínima de 6. Quienes la aprueben pasarán a la etapa de presentación individual. Quienes la desaprueben podrán acceder al examen final en condición regular.\nPresentación individual: Cada estudiante deberá realizar una breve exposición (hasta 10 minutos) en la que describa cómo implementó las estructuras de datos y muestre la ejecución correcta de las pruebas. Luego, el docente realizará preguntas sobre el código desarrollado, que el estudiante deberá responder (hasta 10 minutos).\n\n\n\n\n\n\n\nNota importante\n\n\n\nLos archivos test_series.py y test_dataframe.py deberían incluir todos los ejemplos y pruebas mencionados en este trabajo. Dado que la complejidad y extensión del trabajo puede dificultar este objetivo, se considerarán válidas las entregas que incluyan al menos el 80 % de las pruebas y que todas se ejecuten correctamente.",
    "crumbs": [
      "Trabajos Prácticos",
      "Trabajo práctico final"
    ]
  },
  {
    "objectID": "trabajos_practicos/trabajo_individual.html#ayuda",
    "href": "trabajos_practicos/trabajo_individual.html#ayuda",
    "title": "Trabajo práctico final",
    "section": "7 Ayuda",
    "text": "7 Ayuda\n\nLa Series necesita una estructura de datos subyacente donde almacenar valores, se recomienda usar una lista.\nEl DataFrame también necesita una estructura de datos subyacente, se recomienda un diccionario, donde las claves sean los nombres de las columnas y los valores las Series.\nEl método __repr__ de las Series y DataFrame requiere que nos amiguemos con los métodos de las cadenas de caracteres. Tengan presentes: .ljust(), .rjust() y .center().\nLos métodos __getitem__, __setitem__ e __iter__ no han sido explorados a lo largo del curso. Pueden consultar el recurso Contenedores.\nLos métodos where y argsort de Series pueden parecer confusos e inútiles, pero serán de gran ayuda a la hora de implementar filter y sort en DataFrame.\nEste trabajo práctico describe la interface pública de las clases a implementar, no los detalles internos. Se recomienda que reutilicen, en la medida de lo posible, métodos y propiedades para reducir el trabajo y evitar errores. Por ejemplo, el método drop_nulls de DataFrame puede ser visto como un caso particular de filter.",
    "crumbs": [
      "Trabajos Prácticos",
      "Trabajo práctico final"
    ]
  },
  {
    "objectID": "recursos/ejemplos/01_funciones_y_bucles.html",
    "href": "recursos/ejemplos/01_funciones_y_bucles.html",
    "title": "Funciones y bucles: Python vs R",
    "section": "",
    "text": "El siguiente bloque de código define una función en R:\n\n\nfuncion.R\n\nsumar &lt;- function(a, b) {\n  resultado &lt;- a + b\n  return(resultado)\n}\n\ny el siguiente define una función análoga en Python:\n\n\nfuncion.py\n\ndef sumar(a, b):\n    resultado = a + b\n    return resultado",
    "crumbs": [
      "Recursos",
      "Ejemplos"
    ]
  },
  {
    "objectID": "recursos/ejemplos/01_funciones_y_bucles.html#funciones",
    "href": "recursos/ejemplos/01_funciones_y_bucles.html#funciones",
    "title": "Funciones y bucles: Python vs R",
    "section": "",
    "text": "El siguiente bloque de código define una función en R:\n\n\nfuncion.R\n\nsumar &lt;- function(a, b) {\n  resultado &lt;- a + b\n  return(resultado)\n}\n\ny el siguiente define una función análoga en Python:\n\n\nfuncion.py\n\ndef sumar(a, b):\n    resultado = a + b\n    return resultado",
    "crumbs": [
      "Recursos",
      "Ejemplos"
    ]
  },
  {
    "objectID": "recursos/ejemplos/01_funciones_y_bucles.html#ejecución-condicional",
    "href": "recursos/ejemplos/01_funciones_y_bucles.html#ejecución-condicional",
    "title": "Funciones y bucles: Python vs R",
    "section": "Ejecución condicional",
    "text": "Ejecución condicional\nPor otro lado, el siguiente bloque muestra el uso de ejecución condicional en R:\n\n\ncondicional.R\n\nx &lt;- 5\n\nif (x &gt; 0) {\n  mensaje &lt;- \"El número es positivo\"\n} else {\n  mensaje &lt;- \"El número no es positivo\"\n}\n\nprint(mensaje)\n\nY debajo se muestra la versión análoga en Python:\n\n\ncondicional.py\n\nx = 5\n\nif x &gt; 0:\n    mensaje = \"El número es positivo\"\nelse:\n    mensaje = \"El número no es positivo\"\n\nprint(mensaje)",
    "crumbs": [
      "Recursos",
      "Ejemplos"
    ]
  },
  {
    "objectID": "recursos/ejemplos/01_funciones_y_bucles.html#resumen-de-diferencias",
    "href": "recursos/ejemplos/01_funciones_y_bucles.html#resumen-de-diferencias",
    "title": "Funciones y bucles: Python vs R",
    "section": "Resumen de diferencias",
    "text": "Resumen de diferencias\n\nComunes\n\nUso de bloques:\n\nEn R los bloques de código siempre se delimitan con llaves {}.\nEn Python los bloques se definen exclusivamente mediante indentación (sin llaves).\n\nIndentación:\n\nEn Python la indentación es obligatoria y tiene significado sintáctico.\nEn R la indentación es opcional; sirve únicamente para mejorar la legibilidad.\n\nUso de los dos puntos (:):\n\nEn Python las definiciones de funciones y condiciones terminan con :.\nEn R no se utilizan los dos puntos al final de estas estructuras.\n\n\n\n\nFunciones\n\nForma de definir la función:\n\nEn R: sumar &lt;- function(a, b). Se crea la función y se asigna a una variable.\nEn Python: def sumar(a, b):. La creación de la función ya crea la variable.\n\nRetorno de valores:\n\nEn R, aunque es común usar return(), el resultado de la última expresión se devuelve automáticamente (puede omitirse return).\nEn Python es obligatorio usar return si se desea devolver un valor.\n\n\n\n\nEjecución condicional\n\nUso de paréntesis en condiciones:\n\nEn R es obligatorio usar paréntesis alrededor de la condición (if (x &gt; 0)).\nEn Python no se usan paréntesis (if x &gt; 0:).",
    "crumbs": [
      "Recursos",
      "Ejemplos"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html",
    "title": "U1 - Programación en Python",
    "section": "",
    "text": "# Área y perímetro de un círculo\ndef calcular_area(radio):\n    pi = 3.14159\n    area = pi * radio ** 2\n    return area\n\ndef calcular_perimetro(radio):\n    pi = 3.14159\n    perimetro = 2 * pi * radio\n    return perimetro\n\ndef calcular_area_y_perimetro(radio):\n    area = calcular_area(radio)\n    perimetro = calcular_perimetro(radio)\n    return area, perimetro\n\ncalcular_area(radio=2.5)\ncalcular_perimetro(radio=2.5)\n\narea, perimetro = calcular_area_y_perimetro(radio=2.5)\nresultados = calcular_area_y_perimetro(radio=2.5)\n\nprint(type(area))\nprint(type(perimetro))\nprint(type(resultados))\nprint(type(resultados[0]))\nprint(type(resultados[1]))",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programación en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#área-y-perímetro-de-un-círculo",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#área-y-perímetro-de-un-círculo",
    "title": "U1 - Programación en Python",
    "section": "",
    "text": "# Área y perímetro de un círculo\ndef calcular_area(radio):\n    pi = 3.14159\n    area = pi * radio ** 2\n    return area\n\ndef calcular_perimetro(radio):\n    pi = 3.14159\n    perimetro = 2 * pi * radio\n    return perimetro\n\ndef calcular_area_y_perimetro(radio):\n    area = calcular_area(radio)\n    perimetro = calcular_perimetro(radio)\n    return area, perimetro\n\ncalcular_area(radio=2.5)\ncalcular_perimetro(radio=2.5)\n\narea, perimetro = calcular_area_y_perimetro(radio=2.5)\nresultados = calcular_area_y_perimetro(radio=2.5)\n\nprint(type(area))\nprint(type(perimetro))\nprint(type(resultados))\nprint(type(resultados[0]))\nprint(type(resultados[1]))",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programación en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#promociones",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#promociones",
    "title": "U1 - Programación en Python",
    "section": "2 Promociones",
    "text": "2 Promociones\n# Promociones\ndef calcular_precio(monto, medio):\n    if medio == \"efectivo\":\n        monto_final = monto\n    elif medio == \"débito\":\n        monto_final = monto * (1 - 0.1)\n    elif medio == \"crédito\":\n        monto_final = monto * (1 + 0.05)\n    else:\n        print(f\"El medio {medio} es desconocido.\")\n        monto_final = monto\n\n    return monto_final\n\ncalcular_precio(80, \"efectivo\")\ncalcular_precio(80, \"débito\")\ncalcular_precio(80, \"crédito\")\n\n# Extra:\n# Usando valor por defecto 'efectivo'\ndef calcular_precio(monto, medio=\"efectivo\"):\n    if medio == \"efectivo\":\n        monto_final = monto\n    elif medio == \"débito\":\n        monto_final = monto * (1 - 0.1)\n    elif medio == \"crédito\":\n        monto_final = monto * (1 + 0.05)\n    else:\n        print(f\"El medio {medio} es desconocido.\")\n        monto_final = monto\n\n    return monto_final\n\n# Usando valor por defecto None\ndef calcular_precio(monto, medio=None):\n    if medio is None:\n        medio = \"efectivo\"\n\n    if medio == \"efectivo\":\n        monto_final = monto\n    elif medio == \"débito\":\n        monto_final = monto * (1 - 0.1)\n    elif medio == \"crédito\":\n        monto_final = monto * (1 + 0.05)\n    else:\n        print(f\"El medio {medio} es desconocido.\")\n        monto_final = monto\n\n    return monto_final",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programación en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#etapas-de-la-vida",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#etapas-de-la-vida",
    "title": "U1 - Programación en Python",
    "section": "3 Etapas de la vida",
    "text": "3 Etapas de la vida\n# Etapas de la vida\ndef obtener_etapa(edad):\n    if edad &lt; 2:\n        etapa = \"bebé\"\n    elif edad &lt; 4:\n        etapa = \"infante\"\n    elif edad &lt; 13:\n        etapa = \"niño/a\"\n    elif edad &lt; 20:\n        etapa = \"adolescente\"\n    elif edad &lt; 65:\n        etapa = \"adulto/a\"\n    else:\n        etapa = \"persona mayor\"\n\n    mensaje = f\"La persona es un/a {etapa}\"\n    print(mensaje)\n\n    return None\n\nobtener_etapa(67)\n\n# Comentarios:\n# 1. Un posible problema con esta implementación es que asume que la edad es positiva.\n#    También admite edades irrealmente altas.",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programación en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#conteo-de-caracteres",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#conteo-de-caracteres",
    "title": "U1 - Programación en Python",
    "section": "4 Conteo de caracteres",
    "text": "4 Conteo de caracteres\n# Conteo de caracteres\ndef contar_caracteres(texto):\n    caracteres = {}\n    for caracter  in texto:\n        # No considerar espacios\n        if caracter == \" \":\n            continue\n\n        # Pasar el caracter a minuscula\n        caracter_minuscula = caracter.lower()\n        if caracter_minuscula not in caracteres:\n            caracteres[caracter_minuscula] = 1\n        else:\n            caracteres[caracter_minuscula] += 1\n\n    return caracteres\n\ncontar_caracteres(\"Ahora es mejor que nunca\")\n\n# Comentarios:\n# 1. Implementacion usando 'in' vs 'not in'\n# 2. ¿Podrían meter el .lower en otro lado? Si, se podría pasar el texto a minúsculas antes de empezar a iterar.\n# 3. ¿En cuál implementación se realizaría menos trabajo?\n# 4. ¿Podriamos eliminar el `continue`?\n\n# Moraleja: no hay una única implementación correcta.",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programación en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#orden-de-mérito",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#orden-de-mérito",
    "title": "U1 - Programación en Python",
    "section": "5 Orden de mérito",
    "text": "5 Orden de mérito\n# Orden de mérito\nnotas = [\n    (\"Escalada\", 9),\n    (\"Alonso\", 7),\n    (\"Pérez\", 8),\n    (\"Castro\", 8),\n    (\"Rossini\", 10),\n    (\"Martínez\", 9),\n    (\"Pérez\", 6),\n    (\"Riquelme\", 5),\n]\n\n# Parte 1\nnotas_dict = {}\nfor registro in notas:\n    # Opcion 1:\n     notas_dict[registro[0]] = registro[1]\n\n    # Opcion 2:\n    # apellido = registro[0]\n    # nota = registro[1]\n    # notas_dict[apellido] = nota\n\n    # apellido, nota = registro\n    # notas_dict[apellido] = nota\n\n# Pregunta: ¿Que pasa si hay dos personas con el mismo apellido?\n\n# Parte 2\nnotas_dict = {}\nfor registro in notas:\n    apellido = registro[0]\n    nota = registro[1]\n    if nota not in notas_dict:\n        notas_dict[nota] = [apellido]\n    else:\n        notas_dict[nota].append(apellido)\n        # Otras opciones:\n        # notas_dict[nota] = notas_dict[nota] + [apellido]\n        # notas_dict[nota] = notas_dict[nota].extend([apellido])",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programación en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#rendimento-académico",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#rendimento-académico",
    "title": "U1 - Programación en Python",
    "section": "6 Rendimento académico",
    "text": "6 Rendimento académico\n# Rendimento académico\nnotas = {\n    \"Ana\": [8, 9, 10],\n    \"Luis\": [6, 7, 8, 3, 9],\n    \"Carla\": [10, 9, 10],\n    \"Marcos\": [5, 6],\n    \"Sofía\": [7, 7, 8],\n    \"Pedro\": [6, 4, 5, 6, 3, 8],\n    \"Lucía\": [9, 8, 10, 9]\n}\n\ndef resumir_notas(datos, modo):\n    resultado = {}\n\n    if modo == \"promedio\":\n        for nombre, notas in datos.items():\n            resultado[nombre] = sum(notas) / len(notas)\n    elif modo == \"proporcion\":\n        # NOTE: Esto tal vez sea un poco complicado\n        for nombre, notas in datos.items():\n            n_aprobado = 0\n            for nota in notas:\n                if nota &gt;= 6:\n                    n_aprobado += 1\n            resultado[nombre] = n_aprobado / len(notas)\n\n    else:\n        print(f\"El modo {modo} es desconocido\")\n        return None\n\n    return resultado\n\nresumir_notas(notas, \"promedio\")\nresumir_notas(notas, \"proporcion\")\n\n# ¿Cómo sería la implementación sin .items()?\n# ¿Podría escribir un único for loop? ¿Qué cambiaría? ¿Pros y contras?\n# ¿Hay algún conflicto entre la variable 'notas' del ambiente global y la del ambiente local de\n# la función?\n# El cálculo de la proporción se podría abstraer en una función.\n\n# Podría usarse un \"list comprehension\"\n# len([nota for nota in notas if nota &gt;= 6])\n\n# Podría usarse un generador:\n# sum(nota &gt;= 6 for nota in notas)",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programación en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#índice-de-precios",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#índice-de-precios",
    "title": "U1 - Programación en Python",
    "section": "7 Índice de precios",
    "text": "7 Índice de precios\nipc_2024 = [20.6, 13.2, 11.0, 8.8, 4.2, 4.6, 4.0, 4.2, 3.5, 2.7, 2.4, 2.7]\n\n# Menor y mayor valor\nmin(ipc_2024)\nmax(ipc_2024)\n\n# IPC promedio mensual\nsum(ipc_2024) / len(ipc_2024)\n\n# Mes de mayor inflación\nipc_2024.index(max(ipc_2024)) # 0 + 1 -&gt; enero\n\n# Inflación mediana\nipc_ordenado = sorted(ipc_2024)\n\n# Opcion 1:\n(ipc_ordenado[5] + ipc_ordenado[6]) * 0.5\n\n# Opcion 2:\nsum(ipc_ordenado[5:7]) * 0.5\n\n# Opcion 3:\nn_inicio = (len(ipc_ordenado) // 2) - 1 # Resto 1 porque Python indexa desde 0\nn_fin = (len(ipc_ordenado) // 2 + 1) -1   # Resto 1 porque Python indexa desde 0\n\n# Sumo 1 porque el slicing no es inclusivo por derecha\nsum(ipc_ordenado[n_inicio:(n_fin + 1)]) * 0.5\n\n# Rango de IPC sin min y max\nipc_ordenado[-1] - ipc_ordenado[0]",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programación en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#resúmenes-estadísticos",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#resúmenes-estadísticos",
    "title": "U1 - Programación en Python",
    "section": "8 Resúmenes estadísticos",
    "text": "8 Resúmenes estadísticos\ndef media(x):\n    return sum(x) / len(x)\n\n\ndef rango(x):\n    return max(x) - min(x)\n\n\n# Opcion 1.\ndef varianza(x):\n    x_media = media(x)\n    suma = 0\n    for x_i in x:\n        suma += (x_i - x_media) ** 2\n    return suma / len(x)\n\n\n# Opcion 2. Se podría usar un list-comprehension también.\ndef varianza2(x):\n    x_media = media(x)\n    distancias = []\n    for x_i in x:\n        distancias.append((x_i - x_media) ** 2)\n    return media(distancias)\n\ndef desvio_estandar(x):\n    return varianza(x) ** 0.5\n\n\ndef mediana(x):\n    x_ordenado = sorted(x)\n    n = len(x)\n    mitad = n // 2\n\n    if n % 2 == 1:\n        # Cantidad impar: se toma el elemento del medio\n        mediana = x_ordenado[mitad]\n    else:\n        # Cantidad par: se promedian los dos del medio\n        mediana = (x_ordenado[   - 1] + x_ordenado[mitad]) * 0.5\n\n    return mediana",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programación en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#validación-de-dni",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#validación-de-dni",
    "title": "U1 - Programación en Python",
    "section": "9 Validación de DNI",
    "text": "9 Validación de DNI\ndef validar_dni(dni):\n    # Si no 'dni' tiene puntos, es DNI válido cuando:\n    # - todos los caracteres sean todos dígitos\n    # - la longitud esté entre 7 y 8\n    if dni.count(\".\") == 0:\n        return dni.isdigit() and 7 &lt;= len(dni) &lt;= 8\n\n    # Si 'dni' tiene puntos, debe tener exactamente 2 puntos.\n    partes = dni.split(\".\")\n    if len(partes) != 3:\n        return False\n\n    # Si alguna de las partes no contiene todos dígitos, no es un DNI válido.\n    # Opcion 1\n    for parte in partes:\n        if not parte.isdigit():\n            return False\n    # Opcion 2\n    # if not all(parte.isdigit() for parte in partes):\n    #     return False\n\n    longitudes_validas = (\n        len(partes[0]) in (1, 2) and\n        len(partes[1]) == 3 and\n        len(partes[2]) == 3\n    )\n\n    return longitudes_validas\n\n\nvalidar_dni(\"40.094.127\")\nvalidar_dni(\"19053512\")\nvalidar_dni(\"6.392.780\")\n\nvalidar_dni(\"40,094,127\")\nvalidar_dni(\"19-053-512\")\nvalidar_dni(\"123456\")\nvalidar_dni(\"40..094127\")\nvalidar_dni(\"40.09412.7\")",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programación en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#la-física-del-rebote",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#la-física-del-rebote",
    "title": "U1 - Programación en Python",
    "section": "10 La física del rebote",
    "text": "10 La física del rebote\naltura_inicial = 100 # metros\nrebote = 3 / 5\n\n# Parte 1 (no es necesario el uso de una variable adicional)\naltura_actual = altura_inicial\nfor i in range(10):\n    altura_actual = altura_actual * rebote\n    print(\"Rebote\", i + 1, \"| Altura:\", round(altura_actual, 4))\n\n# Parte 2\ndef calcular_rebotes(altura_inicial, rebotes_n):\n    alturas = []\n    altura_actual = altura_inicial\n    for _ in range(rebotes_n): # '_' es una convencion cuando la variable de iteración no se usa\n        altura_actual = altura_actual * rebote\n        alturas.append(altura_actual)\n\n    return alturas\n\ncalcular_rebotes(100, 10)\n\n\n# Parte 3\ndef calcular_rebotes(altura_inicial, rebotes_n):\n    alturas = []\n    altura_actual = altura_inicial\n    for _ in range(rebotes_n): # '_' es una convencion cuando la variable de iteración no se usa\n        altura_actual = altura_actual * rebote\n        alturas.append(altura_actual)\n\n        if altura_actual &lt; 0.01:\n            break\n\n    return alturas\n\ncalcular_rebotes(100, 50)\nlen(calcular_rebotes(100, 50)) # Solo devuelve 19 rebotes\n\n# Se podria conversar si es necesario crear 'altura_actual'\n# Para el caso de las listas una opción, un poco más rebuscada, es:\n\ndef calcular_rebotes(altura_inicial, rebotes_n):\n    alturas = [altura_inicial * rebote]\n    for i in range(rebotes_n):\n        alturas.append(alturas[i] * rebote)\n\n        if alturas[-1] &lt; 0.01:\n            break\n\n    return alturas\n\ncalcular_rebotes(100, 50)\nlen(calcular_rebotes(100, 50)) # Solo devuelve 19 rebotes",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programación en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#un-montón-de-plata",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#un-montón-de-plata",
    "title": "U1 - Programación en Python",
    "section": "11 Un montón de plata",
    "text": "11 Un montón de plata\nbillete_grosor = 0.11 * 0.001  # grosor de un billete en metros\naltura_monumento = 70          # altura en metros\n\ndias = 1\nbilletes_n = 1\nwhile billetes_n * billete_grosor &lt;= altura_monumento:\n    billetes_n = billetes_n * 2\n    dias = dias + 1\n\nprint(\"Se necesitan\", dias, \"dias.\")\nprint(\"La altura de la pila es\", billetes_n * billete_grosor, \"metros.\")\nprint(\"Se colocaron\", billetes_n, \"billetes.\")\n\n\n# Punto extra\ndef calcular_dias(altura_objetivo):\n    billete_grosor = 0.11 * 0.001\n    dias = 1\n    billetes_n = 1\n    while billetes_n * billete_grosor &lt;= altura_objetivo:\n        billetes_n = billetes_n * 2\n        dias = dias + 1\n    return dias\n\ncalcular_dias(0.1)",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programación en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#la-conjetura-de-collatz",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#la-conjetura-de-collatz",
    "title": "U1 - Programación en Python",
    "section": "12 La conjetura de Collatz",
    "text": "12 La conjetura de Collatz\ndef collatz(n):\n    # Inicializar lista con solo el valor 'n'\n    secuencia = [n]\n    while n != 1:\n        # Numero par\n        if n % 2 == 0:\n            n = n // 2 # Notar uso de división entera\n        # Numero impar\n        else:\n            # ¿Puede el resultado ser flotante?\n            n = 3 * n + 1\n        secuencia.append(n)\n    return secuencia\n\n\ncollatz(5)\ncollatz(20)\ncollatz(16)\ncollatz(37)\n\n# Para discutir: ¿Podría implementarse con un 'while True'? ¿Cómo?",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programación en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#adivina-el-número",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#adivina-el-número",
    "title": "U1 - Programación en Python",
    "section": "13 Adivina el número",
    "text": "13 Adivina el número\n# Correr de la terminal con 'python {nombre_de_programa}.py'\nimport random\n\nprint(\" ======================== Adivina el número! ======================== \")\n\nnumero_secreto = random.randint(0, 100)\n\nmensaje = \"Ingresa un numero entero: \"\nconteo = 0\ntope_intentos = 5\nwhile True:\n    numero = int(input(mensaje))\n    conteo += 1\n    if numero &lt; numero_secreto:\n        mensaje = f\"¡Ups! El numero secreto es mayor a {numero}. Prueba de nuevo: \"\n    elif numero &gt; numero_secreto:\n        mensaje = f\"¡Ups! El numero secreto es menor a {numero}. Prueba de nuevo: \"\n    else:\n        print(f\"Has ganado, felicitaciones! Te llevó tan solo {conteo} intentos.\")\n        break\n\n    if conteo == (tope_intentos - 1):\n        print(\"¡Cuidado! Te queda solo un intento.\")\n\n    if conteo &gt;= tope_intentos:\n        print(f\"Has perdido :(. El numero secreto era {numero_secreto}.\")\n        break",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programación en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#conteo-de-caracteres-pythonico",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#conteo-de-caracteres-pythonico",
    "title": "U1 - Programación en Python",
    "section": "14 Conteo de caracteres Pythonico",
    "text": "14 Conteo de caracteres Pythonico\ndef contar_caracteres(texto):\n    texto = texto.lower() # Pasa a minuscula al principio\n    caracteres = {}\n    for caracter  in texto:\n        # Solo considerar letras del alfabeto\n        if not caracter.isalpha():\n            continue\n\n        # Si el caracter no esta en el diccionario, devuelve 0\n        # Si está, devuelve su conteo.\n        # En ambos casos, le suma 1.\n        caracteres[caracter] = caracteres.get(caracter, 0) + 1\n\n    return caracteres\n\ncontar_caracteres(\"Ahora es mejor que nunca\")\ncontar_caracteres(\"Ahora es mejor que nunca!!   +_\")\ncontar_caracteres(\"Ahora es mejor que nunca!!   +_\") == contar_caracteres(\"Ahora es mejor que nunca\")",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programación en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#validador-de-contraseñas",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#validador-de-contraseñas",
    "title": "U1 - Programación en Python",
    "section": "15 Validador de contraseñas 😱",
    "text": "15 Validador de contraseñas 😱\nCARACTERES_ESPECIALES = \"@#$%^&*()\"\n\ndef contiene_letra(texto):\n    # True si al menos un caracter es una letra\n    for caracter in texto:\n        if caracter.isalpha():\n            return True\n    return False\n\n\ndef contiene_numero(texto):\n    # True si al menos un caracter es un numero (del sistema decimal)\n    for caracter in texto:\n        if caracter.isdecimal():\n            return True\n    return False\n\n\ndef contiene_especial(texto):\n    # True si al menos un caracter es un numero\n    for caracter in texto:\n        if caracter in CARACTERES_ESPECIALES:\n            return True\n    return False\n\ndef validar_pwd(pwd):\n    errores = []\n\n    if not (8 &lt;= len(pwd) &lt;= 24):\n        errores.append(\"Debe tener entre 8 y 24 caracteres.\")\n\n    if not contiene_letra(pwd):\n        errores.append(\"Debe contener al menos una letra.\")\n    if not contiene_numero(pwd):\n        errores.append(\"Debe contener al menos un número.\")\n    if not contiene_especial(pwd):\n        errores.append(\"Debe contener al menos un carácter especial '@#$%^&*()'.\")\n\n    caracteres_desconocidos = []\n    for caracter in pwd:\n        # Hablar sobre si es posible simplificar esto\n        if (not caracter.isdecimal()) and (not caracter.isalpha()) and (caracter not in CARACTERES_ESPECIALES):\n            caracteres_desconocidos.append(caracter)\n\n    # Equivale a len(caracteres_desconocidos) &gt; 0\n    if caracteres_desconocidos:\n        errores.append(\n            f\"La contraseña contiene los siguientes caracteres desconocidos {caracteres_desconocidos}\"\n        )\n\n    if errores == []:\n        return True\n\n    return errores\n\n\nwhile True:\n    password = input(\"Ingrese una contraseña (o ENTER para salir): \")\n    if password == \"\":\n        print(\"Operación cancelada.\")\n        break\n\n    resultado = validar_pwd(password)\n\n    # Acá NO se puede usar 'if es_valida'.\n    if resultado is True:\n        print(\"Contraseña válida.\")\n        break\n\n    print(\"La contraseña no es válida:\")\n    for error in resultado:\n        print(\"-\", error)",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programación en Python"
    ]
  },
  {
    "objectID": "recursos/ejercicios/01_programacion_en_python/index.html#conteo-de-caracteres-ii",
    "href": "recursos/ejercicios/01_programacion_en_python/index.html#conteo-de-caracteres-ii",
    "title": "U1 - Programación en Python",
    "section": "16 Conteo de caracteres II 😱",
    "text": "16 Conteo de caracteres II 😱\ndef contar_caracteres(texto, orden=\"aparicion\"):\n    texto = texto.lower() # Pasa a minuscula al principio\n    caracteres = {}\n    for caracter  in texto:\n        # Solo considerar letras del alfabeto\n        if not caracter.isalpha():\n            continue\n\n        # Si el caracter no esta en el diccionario, devuelve 0\n        # Si está, devuelve su conteo.\n        # En ambos casos, le suma 1.\n        caracteres[caracter] = caracteres.get(caracter, 0) + 1\n\n    if orden == \"aparicion\":\n        salida = caracteres\n    elif orden == \"alfabetico\":\n        salida = {}\n        claves = sorted(caracteres.keys()) # No hace falta el .keys() en realidad\n        for clave in claves:\n            salida[clave] = caracteres[clave]\n    elif orden == \"frecuencia\":\n        salida = {}\n        claves = list(caracteres.keys()) # No hace falta el .keys() en realidad\n        claves_ordenadas = sorted(claves, key=lambda k: caracteres[k], reverse=True)\n        for clave in claves_ordenadas:\n            salida[clave] = caracteres[clave]\n\n    return salida\n\ncontar_caracteres(\"Ahora es mejor que nunca\", \"aparicion\")\ncontar_caracteres(\"Ahora es mejor que nunca\", \"alfabetico\")\ncontar_caracteres(\"Ahora es mejor que nunca\", \"frecuencia\")",
    "crumbs": [
      "Recursos",
      "Ejercicios",
      "U1 - Programación en Python"
    ]
  },
  {
    "objectID": "recursos/tutoriales/tutorial_02.html",
    "href": "recursos/tutoriales/tutorial_02.html",
    "title": "Fábrica de decoradores",
    "section": "",
    "text": "La función fabrica_decoradores se usa como decorador, pero es en realidad una fábrica de decoradores. Si el argumento fun es una función, tal como suecede cuando se usa @fabrica_decoradores, se devuelve fun ya decorada.\nEn cambio, si fun no es una función, como cuando se usa @fabrica_decoradores(mensaje='Procesando datos con'), se devuelve el decorador.\nimport time\n\ndef fabrica_decoradores(fun=None, mensaje=\"Ejecutando función\"):\n    def decorador(fun):\n        def wrapper(*args, **kwargs):\n            print(f\"{mensaje}: {fun.__name__}\")\n            inicio = time.perf_counter()\n            resultado = fun(*args, **kwargs)\n            fin = time.perf_counter()\n            print(f\"{fun.__name__} terminó en {fin - inicio:.3f} s\")\n            return resultado\n        return wrapper\n\n    # Si fun es callable (i.e., algo que se puede llamar, una funcion), el decorador\n    # se llamó sin argumentos. Por lo tanto, aplicamos el decorador manualmente.\n    if callable(fun):\n        return decorador(fun)\n\n    # Caso contrario, se usó con paréntesis y solo se devuelve el decorador.\n    # Python luego lo aplica automáticamente.\n    return decorador\nEjemplos\n# Ejemplo de uso SIN argumentos\n@fabrica_decoradores\ndef tarea_simple():\n    time.sleep(0.2)\n    print(\"Hecho.\")\n\ntarea_simple()\nEjecutando función: tarea_simple\nHecho.\ntarea_simple terminó en 0.210 s\n# Ejemplo de uso CON argumentos\n@fabrica_decoradores(mensaje=\"Procesando datos con\")\ndef tarea_compleja():\n    time.sleep(2.2)\n    print(\"Listo.\")\n\ntarea_compleja()\nProcesando datos con: tarea_compleja\nListo.\ntarea_compleja terminó en 2.216 s",
    "crumbs": [
      "Recursos",
      "Tutoriales",
      "Fábrica de decoradores"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/autoevaluacion.html",
    "href": "practica/02_programacion_funcional/autoevaluacion.html",
    "title": "🪞 Autoevaluación",
    "section": "",
    "text": "¿Por qué decimos que fun es una función con efectos secundarios?\ndef fun():\n    global x\n    x = 10\n    return x\n¿Cuál es el problema con la siguiente función? Explore el resultado de las llamadas que se incluyen luego de la definición.\ndef agregar_usuario(usuario, listado=[]):\n    listado.append(usuario)\n    return listado\n\nbase1 = agregar_usuario(\"Adrián\")\nbase2 = agregar_usuario(\"Daniela\")\nExplore el contenido y la identidad de base1 y base2. Si es necesario, utilice algún agente de IA para explorar en qué parte de la definición de la función se esconde una trampa.\n\n\n\n\n\n¿Por qué la siguiente definición devuelve un error?\nlambda x: return x + 1\n¿Qué hacen los siguientes bloques de código?\n(lambda x, y: x + y)(1, 5)\n(lambda f, x: f(x + 10))(lambda y: y * 5, 2)\n¿Qué devuelve la siguiente llamada? ¿Por qué?\n(lambda x: print(x))(1)\nAyuda: asigne el resultado a una variable y explore el valor de esa variable.\n\n\n\n\n\n¿Cuál es el valor de args en la siguiente llamada? ¿Por qué?\n def fun(x, *args):\n     return x + 10\n\n fun(128)\n¿Y el valor de kwargs debajo?\ndef fun(x, **kwargs):\n    return x + 11\n\nfun(128)\nLos siguientes intentos por definir una función arrojan un error. Investigue por qué y reflexione sobre el sentido de los errores.\ndef fun(**kwargs, x, y):\n    return x + y\ndef fun(**kwargs, *args):\n    return sum(args)\nCualquier llamada a la siguiente función que solo pase argumentos posicionales va a resultar en un error. ¿Por qué? ¿Cómo habría que llamarla para que no resulte en un error?\ndef fun(*args, x, y):\n    return sum(args), x + y\n\n\n\n\n\nEjecute el siguiente bloque de código e inspeccione el objeto que devuelven las sucesivas llamadas realizadas. Analice por qué ocurre este comportamiento y piense qué tipo de funcionalidades podrían aprovechar un mecanismo similar.\ndef fabrica():\n    cosas = []\n    def fun(elemento):\n        cosas.append(elemento)\n        return cosas\n    return fun\n\nf = fabrica()\nf(128)\nf(256)\nf(1024)\nAyuda: Compare el ID de los objetos devueltos en cada llamada. ¿Podría observar el mismo comportamiento si en vez de usar una lista para cosas se usara una tupla?",
    "crumbs": [
      "Práctica",
      "U2 - Programación funcional",
      "🪞 Autoevaluación"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/autoevaluacion.html#funciones",
    "href": "practica/02_programacion_funcional/autoevaluacion.html#funciones",
    "title": "🪞 Autoevaluación",
    "section": "",
    "text": "¿Por qué decimos que fun es una función con efectos secundarios?\ndef fun():\n    global x\n    x = 10\n    return x\n¿Cuál es el problema con la siguiente función? Explore el resultado de las llamadas que se incluyen luego de la definición.\ndef agregar_usuario(usuario, listado=[]):\n    listado.append(usuario)\n    return listado\n\nbase1 = agregar_usuario(\"Adrián\")\nbase2 = agregar_usuario(\"Daniela\")\nExplore el contenido y la identidad de base1 y base2. Si es necesario, utilice algún agente de IA para explorar en qué parte de la definición de la función se esconde una trampa.\n\n\n\n\n\n¿Por qué la siguiente definición devuelve un error?\nlambda x: return x + 1\n¿Qué hacen los siguientes bloques de código?\n(lambda x, y: x + y)(1, 5)\n(lambda f, x: f(x + 10))(lambda y: y * 5, 2)\n¿Qué devuelve la siguiente llamada? ¿Por qué?\n(lambda x: print(x))(1)\nAyuda: asigne el resultado a una variable y explore el valor de esa variable.\n\n\n\n\n\n¿Cuál es el valor de args en la siguiente llamada? ¿Por qué?\n def fun(x, *args):\n     return x + 10\n\n fun(128)\n¿Y el valor de kwargs debajo?\ndef fun(x, **kwargs):\n    return x + 11\n\nfun(128)\nLos siguientes intentos por definir una función arrojan un error. Investigue por qué y reflexione sobre el sentido de los errores.\ndef fun(**kwargs, x, y):\n    return x + y\ndef fun(**kwargs, *args):\n    return sum(args)\nCualquier llamada a la siguiente función que solo pase argumentos posicionales va a resultar en un error. ¿Por qué? ¿Cómo habría que llamarla para que no resulte en un error?\ndef fun(*args, x, y):\n    return sum(args), x + y\n\n\n\n\n\nEjecute el siguiente bloque de código e inspeccione el objeto que devuelven las sucesivas llamadas realizadas. Analice por qué ocurre este comportamiento y piense qué tipo de funcionalidades podrían aprovechar un mecanismo similar.\ndef fabrica():\n    cosas = []\n    def fun(elemento):\n        cosas.append(elemento)\n        return cosas\n    return fun\n\nf = fabrica()\nf(128)\nf(256)\nf(1024)\nAyuda: Compare el ID de los objetos devueltos en cada llamada. ¿Podría observar el mismo comportamiento si en vez de usar una lista para cosas se usara una tupla?",
    "crumbs": [
      "Práctica",
      "U2 - Programación funcional",
      "🪞 Autoevaluación"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/autoevaluacion.html#recursión",
    "href": "practica/02_programacion_funcional/autoevaluacion.html#recursión",
    "title": "🪞 Autoevaluación",
    "section": "2 Recursión",
    "text": "2 Recursión\n\n¿Cuál de las siguientes funciones es recursiva?\ndef f(x):\n    return x + 1\n\ndef g(x):\n    return f(x)\n\ndef h(x):\n    return h(x - 1)\n¿Qué son el caso base y el caso recursivo?\n¿Por qué toda recursión necesita un caso base?\n¿Qué pasa si una función recursiva nunca llega al caso base?\nReflexione sobre ventajas y desventajas de la recursión.",
    "crumbs": [
      "Práctica",
      "U2 - Programación funcional",
      "🪞 Autoevaluación"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/autoevaluacion.html#funciones-de-orden-superior",
    "href": "practica/02_programacion_funcional/autoevaluacion.html#funciones-de-orden-superior",
    "title": "🪞 Autoevaluación",
    "section": "3 Funciones de orden superior",
    "text": "3 Funciones de orden superior\n\nExplique por qué el primer print muestra 10 y el segundo falla:\nfrom functools import partial\n\ndef suma(x, y):\n    return x + y\n\nsuma2 = partial(suma, 10, 0)\nprint(suma2())\nprint(suma2(10))\n¿Cuál de las siguientes funciones es de orden superior?\ndef f(x):\n    return x + 1\n\ndef g(fn, x):\n    return fn(x)\n\ndef h():\n    return f\n¿Cuál de las siguientes funciones de Python es de orden superior?\n\nsum\nmax\nmin\nsorted\nprint\nfunctools.partial\n\n¿Qué hace la función fun? ¿Qué condicion debe cumplir f respecto de sus valores de entrada y salida?\ndef fun(f, x):\n    return f(f(x))\n¿Para qué sirve la función definida debajo?\ndef fun(f, g):\n    return lambda x: f(g(x))\n¿Qué tipo de función se necesita pasar a filter?\n¿Cuál es el resultado de la última línea de código? ¿Por qué?\nfilter_obj = filter(lambda x: x &gt; 2, range(5))\nlist(filter_obj) # Primera conversión a lista\nlist(filter_obj) # Segunda conversión a lista\nAyuda: Para comprender lo que sucede en este ejercicio es necesario estar familiarizados con los generadores.\n¿Cuál implementación es más eficiente desde el punto de vista del consumo de memoria? ¿Por qué?\nimpares = list(filter(lambda x: x % 2, range(1_000)))\nimpares_al_cubo = list(map(lambda x: x ** 3, impares))\nimpares_al_cubo = list(map(lambda x: x ** 3, filter(lambda x: x % 2, range(1_000))))\nAyuda: Nuevamente, es necesario estar familiarizados con los generadores para responder a esta pregunta.\n¿Cuál es el resultado de la reducción debajo? ¿Por qué?\nfrom functools import reduce\nreduce(lambda x, y: x + [y], range(3), [])\nAyuda: reduce ejecuta la función que se le pasa solamente 3 veces. Podría resultar de ayuda enumerar cada una de las llamadas manualmente.",
    "crumbs": [
      "Práctica",
      "U2 - Programación funcional",
      "🪞 Autoevaluación"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/autoevaluacion.html#comprehensions",
    "href": "practica/02_programacion_funcional/autoevaluacion.html#comprehensions",
    "title": "🪞 Autoevaluación",
    "section": "4 Comprehensions",
    "text": "4 Comprehensions\n\n¿Qué diferencia hay entre las siguientes dos líneas de código? Asuma que f es una función y xs es una secuencia.\nmap(f, xs)\n[f(x) for x in xs]\n¿Cuál es el resultado de esta expresión?\n[x for x in \"hola\" if x != \"o\"]\nEscriba una list comprehension para obtener una lista con la primera letra de cada palabra.\npalabras = [\"hola\", \"mundo\", \"python\"]\nEscriba una list comprehension que reemplace los None por un -1.\ndatos = [1, None, 3, None, 5]\nConvierta este bucle en una list comprehension.\nresultado = []\nfor x in range(5):\n    if x % 2 != 0:\n        resultado.append(x)\n¿Es posible que una list comprehension devuelva una lista vacía? ¿Cuándo?\nConstruya una única list comprehension que realice lo mismo que el siguiente bloque:\ndef f(x):\n    return 10 / x\n\ndef g(x):\n    return x != 0\n\nnumeros = [1, 0, -1, 0, 2, 0, -2, 0, 3, 0, -3]\nlist(map(f, filter(g, numeros)))",
    "crumbs": [
      "Práctica",
      "U2 - Programación funcional",
      "🪞 Autoevaluación"
    ]
  },
  {
    "objectID": "practica/02_programacion_funcional/autoevaluacion.html#generadores",
    "href": "practica/02_programacion_funcional/autoevaluacion.html#generadores",
    "title": "🪞 Autoevaluación",
    "section": "5 Generadores",
    "text": "5 Generadores\n\n¿Qué diferencia a una función regular de una función generadora?\n¿En qué momento se ejecuta el cuerpo de una función generadora? ¿Siempre se ejecuta todo?\n¿Cómo se puede obtener una lista a partir de un generador? ¿Cuántas veces se puede realizar esa operación sobre el mismo generador?\n¿Qué ventaja tiene un generador frente a una lista?\n¿Qué significa que un generador sea perezoso?\n¿Qué pasa si se llama a next sobre un generador más veces que la cantidad de yield en él?\n¿Qué se obtiene en el siguiente bloque de código?\ndef f():\n    yield 1\n    yield 2\n\ngen = f()\nprint(list(gen))\n¿Qué pasa si se corre next(gen) a continuación?\n¿Qué se imprime en pantalla?\nprint((x * 2 for x in [1, 2, 3]))\n¿Por qué es posible implementar un bucle infinito dentro de un generador?\n¿Cuántas veces es posible llamar a next sobre el generador g?\ndef fun():\n    yield 1\n    return 2\n    yield 3\n\ng = fun()",
    "crumbs": [
      "Práctica",
      "U2 - Programación funcional",
      "🪞 Autoevaluación"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html",
    "title": "🛠️ Ejercicios",
    "section": "",
    "text": "Imaginá un estante de farmacia con \\(N\\) posiciones perfectamente contiguas (sin huecos), numeradas desde 0 hasta \\(N-1\\). Cada posición guarda exactamente una caja de un medicamento.\nPara este ejercicio, asumiremos que N = 100.\n\n\n\nPara medir el costo de cada operación, definimos un paso como la unidad de tiempo más pequeña:\n\nObservar (Leer): Mirar qué medicamento hay en una posición específica. (1 paso)\nMover: Deslizar una caja una posición a la izquierda o derecha. (1 paso por cada caja movida)\nColocar (Escribir): Poner una caja nueva en una posición vacía. (1 paso)\n\n\n\n\n\nInserción: Para hacer un hueco en medio del estante, hay que mover todas las cajas desde esa posición en adelante hacia la derecha.\nEliminación: Para cerrar un hueco en medio del estante, hay que mover todas las cajas desde la posición eliminada en adelante hacia la izquierda.\nEl estante debe permanecer siempre contiguo (sin huecos).\n\n\n\n\nPara cada escenario, calcule el costo en pasos y deduzca su complejidad asintótica (Big O), basándote en la analogía física.\n\n\n\n\n\n\n\n\n\n\nOperación\nDescripción del escenario\nPasos (Con N=100)\nExpresión con N (Big O implícito)\nJustificación (¿Por qué?)\n\n\n\n\na) Lectura por Posición\nDecime qué medicamento hay en la posición 37.\n\n\n\n\n\nb) Búsqueda (peor caso)\n¿Está el medicamento X en el estante? (Asumí que NO está y debes revisar todo el estante).\n\n\n\n\n\nc) Inserción al Inicio\nPoné un nuevo medicamento en la posición 0 y corré todo lo demás.\n\n\n\n\n\nd) Inserción al Final\nAgregá un nuevo medicamento en la posición N (al final del estante).\n\n\n\n\n\ne) Eliminación al Inicio\nSacá la caja de la posición 0 y corré el resto para cerrar el hueco.\n\n\n\n\n\nf) Eliminación al Final\nSacá la última caja del estante (posición N−1).",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#el-estante-de-la-farmacia",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#el-estante-de-la-farmacia",
    "title": "🛠️ Ejercicios",
    "section": "",
    "text": "Imaginá un estante de farmacia con \\(N\\) posiciones perfectamente contiguas (sin huecos), numeradas desde 0 hasta \\(N-1\\). Cada posición guarda exactamente una caja de un medicamento.\nPara este ejercicio, asumiremos que N = 100.\n\n\n\nPara medir el costo de cada operación, definimos un paso como la unidad de tiempo más pequeña:\n\nObservar (Leer): Mirar qué medicamento hay en una posición específica. (1 paso)\nMover: Deslizar una caja una posición a la izquierda o derecha. (1 paso por cada caja movida)\nColocar (Escribir): Poner una caja nueva en una posición vacía. (1 paso)\n\n\n\n\n\nInserción: Para hacer un hueco en medio del estante, hay que mover todas las cajas desde esa posición en adelante hacia la derecha.\nEliminación: Para cerrar un hueco en medio del estante, hay que mover todas las cajas desde la posición eliminada en adelante hacia la izquierda.\nEl estante debe permanecer siempre contiguo (sin huecos).\n\n\n\n\nPara cada escenario, calcule el costo en pasos y deduzca su complejidad asintótica (Big O), basándote en la analogía física.\n\n\n\n\n\n\n\n\n\n\nOperación\nDescripción del escenario\nPasos (Con N=100)\nExpresión con N (Big O implícito)\nJustificación (¿Por qué?)\n\n\n\n\na) Lectura por Posición\nDecime qué medicamento hay en la posición 37.\n\n\n\n\n\nb) Búsqueda (peor caso)\n¿Está el medicamento X en el estante? (Asumí que NO está y debes revisar todo el estante).\n\n\n\n\n\nc) Inserción al Inicio\nPoné un nuevo medicamento en la posición 0 y corré todo lo demás.\n\n\n\n\n\nd) Inserción al Final\nAgregá un nuevo medicamento en la posición N (al final del estante).\n\n\n\n\n\ne) Eliminación al Inicio\nSacá la caja de la posición 0 y corré el resto para cerrar el hueco.\n\n\n\n\n\nf) Eliminación al Final\nSacá la última caja del estante (posición N−1).",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#cita-con-el-dentista",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#cita-con-el-dentista",
    "title": "🛠️ Ejercicios",
    "section": "2 Cita con el dentista",
    "text": "2 Cita con el dentista\n\nContexto\nUna clínica odontológica necesita un sistema sencillo para gestionar su agenda de turnos. Los turnos se agregan a la lista en orden de llegada, sin preocuparse inicialmente por el orden cronológico.\n\n\nDatos iniciales\nLa agenda se mantiene en un arreglo (lista) de diccionarios.\nagenda = [\n    {\"paciente\": \"Juana Pérez\", \"hora\": \"08:30\"},\n    {\"paciente\": \"Mario Gómez\", \"hora\": \"09:00\"},\n    {\"paciente\": \"Sofía López\", \"hora\": \"09:30\"},\n    {\"paciente\": \"Ana Fernández\", \"hora\": \"10:15\"},\n]\n\n\nFunciones a implementar\nUsando operaciones básicas sobre el arreglo (sin usar .remove ni .pop directamente):\n\nleer_pos(i): Devuelve el turno en la posición i. Si i no existe, devuelve None.\ninsertar(turno): Agrega un nuevo diccionario {\"paciente\": ..., \"hora\": \"HH:MM\"} al final de la lista (simulando la llegada de un nuevo paciente). Devuelve True.\neliminar(hora): Busca el primer turno con esa hora y lo elimina. Devuelve True si lo eliminó, False si el horario no estaba en la lista.\nbuscar(hora): Recorre la lista desde el principio hasta el final. Devuelve la posición (índice) donde está ese horario, o -1 si no existe.\nlistar(): Devuelve una lista de strings con el formato: [\"0) 08:30 - Juana Pérez\", \"1) 09:00 - Mario Gómez\", ...]\n\n\n\nEjemplo de uso\nprint(leer_pos(1))\n# {'paciente': 'Mario Gómez', 'hora': '09:00'}\n\nnuevo = {\"paciente\": \"Diego Romero\", \"hora\": \"09:45\"}\ninsertar(nuevo)  # Se agrega al final\n\nprint(buscar(\"09:45\"))\n# 4  (Si era el quinto elemento, ya que la lista creció)\n\nprint(eliminar(\"09:00\"))\n# True\n\nprint(listar())\n# ['0) 08:30 - Juana Pérez',\n#  '1) 09:30 - Sofía López',\n#  '2) 10:15 - Ana Fernández',\n#  '3) 09:45 - Diego Romero']\n\n\nCasos a probar\n\nInsertar \"08:15\" (debe ir al inicio).\nInsertar \"12:00\" (debe ir al final).\nInsertar repetido \"09:30\" (debe rechazarse).\nBuscar un horario inexistente (debe devolver -1).\nEliminar uno inexistente (debe devolver False).\n\n\n\nMini-consigna teórica\nResponda:\n\n¿Qué ocurre con los índices cuando eliminás o insertás un turno en el medio de la lista? (Pista: ¿qué pasa con los elementos que estaban después?)\n¿Por qué acceder a agenda[i] es una operación \\(O(1)\\) pero buscar un turno por hora es \\(O(N)\\)?\n¿Qué estructura te parecería más conveniente si hubiera miles de turnos? Explicá brevemente por qué.",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#la-lista-de-reproducción-del-dj",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#la-lista-de-reproducción-del-dj",
    "title": "🛠️ Ejercicios",
    "section": "3 La lista de reproducción del DJ️",
    "text": "3 La lista de reproducción del DJ️\n\nContexto\nUn DJ está gestionando su lista principal de canciones, almacenada en una secuencia ordenada de reproducción. Se necesita desarrollar las herramientas para manipular esta lista de forma eficiente y precisa antes del show.\n\n\nRequerimientos de manipulación\nEl sistema debe soportar las siguientes acciones, considerando que la lista es una secuencia lineal donde el orden es fundamental:\n\nConsulta por ubicación: El DJ debe poder pedir la canción que está en una posición exacta de la secuencia (ej. “Dime qué canción está en el tercer lugar”).\nAdición controlada: Se debe poder insertar una nueva canción exactamente en una posición específica de la secuencia (ej. “Pon ‘Nueva Canción’ justo antes de la canción que actualmente está en la posición 5”). Esto implica que las canciones que estaban en esa posición y después deben moverse para hacer espacio.\nRemoción dirigida: El DJ debe poder quitar una canción conociendo su nombre de la lista. Una vez retirada, las canciones que estaban después deben moverse para cerrar el hueco y mantener la secuencia contigua.\nIdentificación por nombre: Se requiere una función para localizar una canción por su nombre y devolver su ubicación actual en la secuencia.\n\n\n\nDatos iniciales\ncanciones = [\"Thunderstruck\", \"Billie Jean\", \"Smells Like Teen Spirit\"]\n\n\nEjemplos de uso\n# Ejemplo de requerimiento: Inserción\n# Intentamos poner \"One\" en la posición 2 (el tercer espacio)\ninsertar_cancion(2, \"One\")\n# La lista debe ajustarse automáticamente: [\"Thunderstruck\", \"Billie Jean\", \"One\", \"Smells Like Teen Spirit\"]\n\n# Ejemplo de requerimiento: Eliminación\neliminar_cancion(\"Billie Jean\")\n# La lista debe reajustarse: [\"Thunderstruck\", \"One\", \"Smells Like Teen Spirit\"]\n\n\nPunto extra: Visualización del Índice\nMuestre al DJ la lista completa, indicando claramente la posición inicial de cada pista en la secuencia.",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#scanner-pro-3000",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#scanner-pro-3000",
    "title": "🛠️ Ejercicios",
    "section": "4 Scanner Pro 3000",
    "text": "4 Scanner Pro 3000\n\nContexto\nEn un recital, cada entrada tiene un código. Al ingresar, el lector va guardando los códigos en una lista en el orden en que se escanean. La producción te pide detectar si hubo códigos repetidos (fraude o doble escaneo).\nTe entregan una lista escaneos con miles de códigos (que son strings de Python).\nescaneos = [\n    \"A1F3\", \"B9K2\", \"X7Z1\", \"A1F3\", \"L0P9\", \"M2Q5\", \"B9K2\", ...\n]\n\nEscriba una función que encuentre si hay algún código repetido comparando cada elemento con todos los que le siguen (utilice un doble bucle for).\n\n¿Cuántas comparaciones hace en el peor caso con N elementos?\n¿Qué pasa cuando N crece x10?\n\nImplemente una versión lineal usando un set para registrar códigos ya vistos.\n\n¿Por qué ahora es \\(O(N)\\)?\n¿Qué operación te permite “saltar” comparaciones?\n\nUse esta funcion que crea codigos aleatorios para generar listas de codigos de tamaños crecientes y mida el tiempo de ejecucion de cada funcion anterior: ```python import random, string, time\ndef generar_codigos(n, dup_ratio=0.0, seed=0): rng = random.Random(seed) base = set() # crear códigos únicos while len(base) &lt; int(n * (1 - dup_ratio)): base.add(’’.join(rng.choices(string.ascii_uppercase + string.digits, k=6))) lista = list(base) # inyectar duplicados while len(lista) &lt; n: lista.append(rng.choice(list(base))) rng.shuffle(lista) return lista ```",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#el-club-secreto-de-los-hackers",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#el-club-secreto-de-los-hackers",
    "title": "🛠️ Ejercicios",
    "section": "5 El club secreto de los hackers",
    "text": "5 El club secreto de los hackers\n\nContexto\nUn grupo de hackers tiene un club secreto con reglas muy estrictas sobre quién puede entrar y salir. Los miembros se ordenan según su entrada: desde el fundador hasta el último ingresante. En caso de ser necesaria una reducción de miembros, los primeros en irse deben ser los que menos experiencia tienen (el último en entrar al club debe ser el primero en salir).\nSi un hacker que no es el último en entrar sale del grupo fuera de orden, se considera una violación de seguridad y se registra la acción en el sistema.\n\n\nDatos iniciales\nclub = [\n    {\"nombre\": \"Anonymous\"},\n    {\"nombre\": \"Mitnick\"},\n    {\"nombre\": \"Soupnazi\"},\n    {\"nombre\": \"D-Dante\"}\n]\nTeniendo en cuenta el contexto implementa las siguientes funciones para regular la entrada y salida de los miembros del club:\n\nentrar(nombre)\n\nAgrega un hacker a la pila del club\nCada entrada debe registrarse como un diccionario: {\"nombre\": \"Neo\"}\nSi hay más de 10 hacker, imprimir: “El Club esta lleno, capacidad máxima alcanzada”\n\nsalir()\n\nSaca al último hacker que entró\nRetorna el nombre del hacker que salió\nSi la pila está vacía, imprimir: “El club ha desaparecido en la oscuridad…”\n\nultimo_en_entrar()\n\nMuestra quién está en la cima de la pila sin sacarlo\nRetorna el nombre del último que entró\nSi la posiion aun no fue cubierta, retorna None\n\nmostrar_club()\n\nMuestra todos los hackers en el club, del más reciente al más antiguo\nIndica cuántos hay en total\nFormato: [Top] Neo -&gt; Trinity -&gt; Anonymous [Base]\n\nesta_en_club(nombre)\n\nVerifica si un hacker específico está dentro\nRetorna True o False\nIMPORTANTE: No destruir la pila al buscar\n\n\n\n\nEjemplo de uso esperado\nentrar(\"Morpheus\")\nentrar(\"Trinity\")\nentrar(\"Neo\")\n\nmostrar_club()\n# Salida:  Club (3 hackers): [Top] Neo -&gt; Trinity -&gt; Morpheus [Base]\n\nprint(ultimo_en_entrar())\n# Salida: Neo\n\nsalir()\n# Salida: Neo ha salido del club\n\nprint(esta_en_club(\"Trinity\"))\n# Salida: True\n\nprint(esta_en_club(\"Cypher\"))\n# Salida: False\n\n\nEjemplo de uso esperado\n# Caso 1: Club vacío\nclub.clear()\nsalir()  # Debe mostrar mensaje\n\n# Caso 2: Verificar LIFO\nentrar(\"A\")\nentrar(\"B\")\nentrar(\"C\")\nsalir()  # Debe salir C (último en entrar)\nsalir()  # Debe salir B\nultimo_en_entrar()  # Debe ser A\n\n# Caso 3: Club lleno\nfor i in range(12):\n    entrar(f\"Hacker{i}\")  # En el 11vo debe avisar que está lleno\n\n# Caso 4: Buscar sin destruir\nentrar(\"Neo\")\nentrar(\"Trinity\")\nprint(esta_en_club(\"Neo\"))  # True\nmostrar_club()  # Neo debe seguir en la pila\n\n\nNivel 2: Desafío 🚀\nNueva funcionalidad: Control de acceso con violaciones\nImpelmente las siguentes funciones:\n\nsalir_especifico(nombre)\n\n\nSi nombre es el TOP: sacarlo sin registrar violación, retornar True.\nSi no es el TOP pero está en la pila: - Desapilar a un buffer hasta encontrar nombre. - Remover nombre. - Reapilar en orden original todo lo que sacaste.\nRegistrar violación en _log_violaciones con formato: \"{HH:MM} - Violación: {nombre} salió fuera de orden\" (usar datetime.now().strftime(\"%H:%M\")). Retornar True.\nSi no se encuentra: retornar False.\n\n\nhistorial_violaciones()\n\nMuestra todas las violaciones de seguridad registradas\nFormato: [\"17:30 - Violación: Trinity salió fuera de orden\"]\n\n\n\n\nEjemplo de uso\nentrar(\"Morpheus\")\nentrar(\"Trinity\")\nentrar(\"Neo\")\nentrar(\"Cypher\")\n\n# Neo y Cypher están encima de Trinity\nsalir_especifico(\"Trinity\")\n# Salida: VIOLACIÓN DE SEGURIDAD: Trinity salió fuera de orden\n\nmostrar_club()\n# Salida: [Top] Cypher -&gt; Neo -&gt; Morpheus [Base]\n# Trinity ya no está",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#torre-de-control-aéreo",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#torre-de-control-aéreo",
    "title": "🛠️ Ejercicios",
    "section": "6 Torre de control aéreo",
    "text": "6 Torre de control aéreo\n\nContexto\nLa Autoridad de Tráfico Aéreo necesita optimizar las operaciones de una torre de control. Tu tarea es modelar el sistema que gestiona los permisos de movimiento de los aviones.\nExisten dos tipos de solicitudes pendientes:\n\nAviones esperando despegue: Estos aviones forman una fila de espera. Se les debe dar permiso para despegar siguiendo un principio estricto: el avión que lleva más tiempo esperando en la fila es el primero en recibir permiso.\nAviones en aproximación de emergencia: Estos aviones requieren aterrizaje inmediato debido a una situación crítica. Estos permisos de aterrizaje se apilan, y la torre debe procesar la emergencia más reciente antes que cualquier otra, es decir: el último avión en reportar la emergencia es el primero en recibir la autorización de aterrizaje.\n\n\n\nPrioridad de la torre\nLa torre de control siempre otorga permisos siguiendo una estricta jerarquía:\n\nPrioridad absoluta: Si hay alguna emergencia pendiente, la torre siempre debe autorizar primero un aterrizaje de emergencia.\nPrioridad secundaria: Solo cuando no haya ninguna emergencia pendiente, la torre podrá autorizar el despegue del avión que le corresponda.\n\n\n\nDatos iniciales\nComienza con la siguiente situación en el aeropuerto:\n# Lista de aviones esperando para Despegar\nsolicitudes_despegue = [\"Vuelo 101\", \"Vuelo 205\"]\n# Lista de aviones reportando Emergencia\nsolicitudes_emergencia = [\"Vuelo 999\"]\n\n\nRequisitos funcionales\nSe debe crear un sistema con las siguientes acciones:\n\nUna función para registrar la llegada de un nuevo avión a la lista de despegue.\nUna función para registrar una nueva solicitud de aterrizaje de emergencia.\nUna función principal, procesar_evento(), que simule la acción de la torre de control al otorgar un permiso según las reglas de prioridad.\n\nPunto extra: Si la torre intenta otorgar un permiso y ambas listas están vacías, debe notificarlo con el mensaje: \"Torre en silencio\".",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#alerta-de-virus-zombie",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#alerta-de-virus-zombie",
    "title": "🛠️ Ejercicios",
    "section": "7 Alerta de virus zombie",
    "text": "7 Alerta de virus zombie\n\nContexto\nSos un científico/a de un laboratorio secreto que está procesando muestras de virus zombies. Debes implementar un sistema de gestión usando colas para manejar el flujo de trabajo.\nAlerta importante: Si hay más de 5 muestras del mismo tipo de virus en la cola, se activa una alerta biológica (riesgo de propagación masiva).\n\n\nDatos iniciales\nfrom collections import deque\n\nmuestras = deque([\"virus_tank\", \"virus_witch\", \"virus_charger\"])\n\n\nTareas\nImplementa las siguientes funciones:\n\nagregar_muestra(nombre)\n\nAgrega una muestra al final de la cola\nMuestra mensaje confirmando la operación\nVerifica si hay más de 5 muestras del mismo tipo\nSi se cumple la condición, imprime: \"¡Alerta biológica! Detectadas X muestras de [nombre_virus]\"\n\nprocesar_muestra()\n\nProcesa (elimina) la primera muestra de la cola\nRetorna el nombre de la muestra procesada\nSi la cola está vacía, muestra un mensaje de error\n\nmostrar_pendientes()\n\nMuestra la lista de muestras pendientes\nRetorna la lista de muestras\nIndica cuántas muestras hay en espera\n\ncontar_por_tipo()\n\nRetorna un diccionario con el conteo de cada tipo de virus\nEjemplo: {\"virus_tank\": 3, \"virus_witch\": 2}\n\n\n\n\nEjemplo de uso esperado\nprint(mostrar_pendientes())\n# Salida: Muestras pendientes (3): ['virus_tank', 'virus_witch', 'virus_charger']\n\nagregar_muestra(\"virus_tank\")\nagregar_muestra(\"virus_tank\")\nagregar_muestra(\"virus_tank\")\nagregar_muestra(\"virus_tank\")\nagregar_muestra(\"virus_tank\")\n# Salida en la 5ta: ¡Alerta biológica! Detectadas X muestras de virus_tank ☣️\n\nprint(contar_por_tipo())\n# Salida: {'virus_tank': 6, 'virus_witch': 1, 'virus_charger': 1}\n\nprocesar_muestra()\n# Salida: Procesando 'virus_tank'\n# Retorna: 'virus_tank'\n\n\nCasos a probar\n# Caso 1: Cola vacía\nmuestras.clear()\nprocesar_muestra()  # Debe mostrar error\n\n# Caso 2: Alerta biológica por acumulación\nfor i in range(6):\n    agregar_muestra(\"virus_hunter\")  # Debe activar alerta en la 6ta\n\n# Caso 3: Verificar que la alerta sea por tipo específico\nagregar_muestra(\"virus_tank\")\nagregar_muestra(\"virus_witch\")\nagregar_muestra(\"virus_tank\")\n# No debe haber alerta (solo 2 de cada tipo)\n\n# Caso 4: Procesar reduce el conteo\nfor i in range(7):\n    agregar_muestra(\"virus_smoker\")  # Alerta: 7 smoker\nprocesar_muestra()  # Procesa 1 virus_tank (de los iniciales)\nprint(contar_por_tipo())  # Debería seguir mostrando 7 smoker\n\n\nNivel 2: Desafío 🚀\n\n\nNueva funcionalidad: Muestras prioritarias\nAlgunas muestras son urgentes y deben procesarse antes que las normales.\n\n\nDatos iniciales\nfrom collections import deque\n\nmuestras_normales = deque([\"virus_tank\", \"virus_witch\"])\nmuestras_urgentes = deque()\n\n\nTareas adicionales\n\nagregar_muestra(nombre, urgente=False)\n\nSi urgente=True, agrega a la cola de urgentes\nSi urgente=False, agrega a la cola normal\nLa alerta biológica debe contar en AMBAS colas (misma cepa puede estar en las dos)\n\nprocesar_muestra() (modificada)\n\nPrimero procesa muestras urgentes\nSi no hay urgentes, procesa normales\nSi ambas colas están vacías, muestra error\n\nmostrar_todas()\n\nMuestra ambas colas por separado\nIndica cuántas muestras hay en cada una\nMuestra el conteo total por tipo de virus\n\ncontar_por_tipo() (modificada)\n\nDebe contar en ambas colas\nRetorna el conteo global de cada tipo\n\n\n\n\nEjemplo de uso\n# Agregar 4 tank normales y 3 tank urgentes\nfor i in range(4):\n    agregar_muestra(\"virus_tank\", urgente=False)\n\nfor i in range(3):\n    agregar_muestra(\"virus_tank\", urgente=True)\n    # En la 3ra debe activarse la alerta (total: 4+3=7 tanks)\n\nmostrar_todas()\n# Salida:\n# Urgentes (3): ['virus_tank', 'virus_tank', 'virus_tank']\n# Normales (6): ['virus_tank', 'virus_witch', 'virus_tank', ...]\n# Conteo por tipo: {'virus_tank': 7, 'virus_witch': 1}",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#batalla-pokémon",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#batalla-pokémon",
    "title": "🛠️ Ejercicios",
    "section": "8 Batalla Pokémon",
    "text": "8 Batalla Pokémon\n\nContexto\nUn gimnasio Pokémon necesita un sistema para gestionar los batallas entre equipos. Para lograrlo te contratan y te dan la siguiente infromación:\n\nLos entrenadores Pokémon pueden capturar nuevos Pokémones y agregarlos a su equipo\nLos entrenadores necesitan poder buscar un Pokémon específico por su nombre para usarlo en batalla\nLos entrenadores tienen que poder retirar del equipo a los Pokémon debilitados o que ya no quieren usar\nLos entrenadores deben poder revisar su equipo completo para decidir su estrategia\n\nTu trabajo sera implementar la clase Equipo, para eso puedes usar la siguente clase ya implementada:\nclass Pokemon:\n    \"\"\"Representa un Pokémon individual\"\"\"\n    def __init__(self, nombre, tipo, nivel, max_hp, ataque):\n        self.nombre = nombre\n        self.tipo = tipo\n        self.nivel = nivel\n        self.max_hp = max_hp\n        self.hp = max_hp  # Empieza con vida completa\n        self.ataque = ataque\n\n    def recibir_daño(self, puntos):\n        \"\"\"Reduce HP, no puede ser negativo\"\"\"\n        self.hp = max(0, self.hp - puntos)\n\n    def curar(self, puntos):\n        \"\"\"Aumenta HP, no puede superar el máximo\"\"\"\n        self.hp = min(self.max_hp, self.hp + puntos)\n\n    def esta_debilitado(self):\n        \"\"\"Retorna True si el Pokémon no puede combatir\"\"\"\n        return self.hp == 0\n\n    def subir_nivel(self):\n        \"\"\"Sube de nivel y aumenta stats\"\"\"\n        self.nivel += 1\n        self.max_hp += 5\n        self.hp = self.max_hp  # Se cura completamente\n\n    def __str__(self):\n        return f\"{self.nombre} ({self.tipo.capitalize()}) Nv.{self.nivel} [HP: {self.hp}/{self.max_hp}]\"\n\n\nEjemplo de uso\npikachu = Pokemon(\"Pikachu\", \"eléctrico\", nivel=25, max_hp=35, ataque=14)\nprint(pikachu)  # Pikachu (Eléctrico) Nv.25 [HP: 35/35]\n\npikachu.recibir_daño(10)\nprint(pikachu)  # Pikachu (Eléctrico) Nv.25 [HP: 25/35]\n\n\nRequerimientos para implementar la clase Equipo\nLos maestros/as Pokémon necesitan gestionar su equipo de forma dinámica. Las operaciones que más realizan son:\n\nAgregar un Pokémon recién capturado (siempre al final)\nBuscar un Pokémon específico por nombre\nEliminar un Pokémon específico del equipo\nListar todos los Pokémon para revisarlos\nEliminar todos los debilitados después de una batalla\nContar cuántos Pokémon tiene\n\nImportante\n\nNo se te permite usar listas normales de Python con acceso por índice** (lista[0], lista[2], etc.)\nLa clase debe ser eficiente para agregar y eliminar elementos\nPodes crear clases auxiliares si lo necesitas (como Nodo).\n\n\n\nMétodos necesarios\n\n__init__(nombre_entrenador). Inicializa un equipo vacío para el entrenador.\nagregar_pokemon(pokemon). Agrega un Pokémon al final del equipo.\nbuscar(nombre). Busca un Pokémon por nombre. Retorna el objeto Pokemon si lo encuentra, None si no existe.\neliminar(nombre). Elimina un Pokémon específico del equipo. Retorna True si lo eliminó, False si no existía. Importante: este metodo debe manejar correctamente los casos de elimnar un elemento que sea el primero, uno del medio o el ultimo.\neliminar_debilitados(). Elimina todos los Pokémon con HP igual a 0. Retorna una lista con los nombres de los eliminados.\ncontar(). Retorna cuántos Pokémon hay en el equipo.\nesta_vacio(). Retorna True si no hay ningún Pokémon en el equipo.\nlistar(). Retorna una lista de cadenas de texto con todos los Pokémon en orden. Formato: [\"1. Pikachu (Eléctrico) Nv.25 [HP: 35/35]\", \"2. Charmander...\", ...]\nobtener_primero(). Retorna el primer Pokémon del equipo sin eliminarlo. None si está vacío.\nobtener_mas_fuerte(). Retorna el Pokémon con mayor ataque. None si está vacío.\npokemon_por_tipo(tipo). Retorna una lista con todos los Pokémon de un tipo específico. Ejemplo: pokemon_por_tipo(\"fuego\") → lista con Charmander, Vulpix, etc.\n\n\n\nEjemplo de uso completo\n# Crear Pokémon\npikachu = Pokemon(\"Pikachu\", \"eléctrico\", nivel=25, max_hp=35, ataque=14)\ncharmander = Pokemon(\"Charmander\", \"fuego\", nivel=20, max_hp=39, ataque=12)\nsquirtle = Pokemon(\"Squirtle\", \"agua\", nivel=22, max_hp=44, ataque=9)\nbulbasaur = Pokemon(\"Bulbasaur\", \"planta\", nivel=21, max_hp=45, ataque=10)\neevee = Pokemon(\"Eevee\", \"normal\", nivel=18, max_hp=55, ataque=8)\n\n# Crear equipo\nequipo_ash = Equipo(\"Ash\")\n\n# Agregar Pokémon\nequipo_ash.agregar_pokemon(pikachu)\nequipo_ash.agregar_pokemon(charmander)\nequipo_ash.agregar_pokemon(squirtle)\nequipo_ash.agregar_pokemon(bulbasaur)\n\nprint(f\"Pokémon en el equipo: {equipo_ash.contar()}\")  # 4\n\n# Listar equipo\nprint(\"\\n=== EQUIPO DE ASH ===\")\nfor info in equipo_ash.listar():\n    print(info)\n\n# Buscar un Pokémon\nencontrado = equipo_ash.buscar(\"Squirtle\")\nif encontrado:\n    print(f\"\\n Encontrado: {encontrado}\")\n\n# Obtener el más fuerte\nfuerte = equipo_ash.obtener_mas_fuerte()\nprint(f\"\\n  Más fuerte: {fuerte}\")\n\n# Simular batalla\nprint(\"\\n=== SIMULANDO BATALLA ===\")\ncharmander.recibir_daño(39)  # Charmander se debilita\nsquirtle.recibir_daño(20)    # Squirtle pierde HP pero sobrevive\n\nprint(f\"Charmander debilitado: {charmander.esta_debilitado()}\")\n\n# Eliminar debilitados\neliminados = equipo_ash.eliminar_debilitados()\nprint(f\"Pokémon eliminados: {eliminados}\")  # ['Charmander']\n\n# Ver equipo actualizado\nprint(f\"\\nPokémon restantes: {equipo_ash.contar()}\")  # 3\nfor info in equipo_ash.listar():\n    print(info)\n\n# Agregar nuevo Pokémon\nequipo_ash.agregar_pokemon(eevee)\nprint(f\"\\n Eevee agregado. Total: {equipo_ash.contar()}\")\n\n# Buscar por tipo\nfuego = equipo_ash.pokemon_por_tipo(\"fuego\")\nprint(f\"\\nPokémon de fuego: {[str(p) for p in fuego]}\")\n\n# Eliminar un Pokémon específico\nequipo_ash.eliminar(\"Pikachu\")\nprint(f\"\\n Pikachu liberado. Restantes: {equipo_ash.contar()}\")\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPreguntas para reflexionar ANTES de programar\n\n¿Qué estructura me permite conectar elementos sin índices?\n¿Necesito crear una clase auxiliar (como Nodo)?\nAl eliminar un elemento, ¿qué debo hacer con los enlaces?\n\nPista: Debes “saltar” al elemento eliminado reconectando los que estaban antes y después\n\n¿Cómo recorro todos los elementos sin índices?\n\nPista: Empezas por el primero y seguis los enlaces hasta llegar al final\n\n¿Qué pasa si elimino el primer elemento? ¿Es diferente a eliminar del medio?\n\nPista: El primer elemento es especial, no tiene un elemento anterior",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#uno-más-dos",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#uno-más-dos",
    "title": "🛠️ Ejercicios",
    "section": "9 Uno más dos",
    "text": "9 Uno más dos\nProponer e implementar dos algoritmos que calculen la suma de los primeros N números naturales.\n\nUno con complejidad \\(O(N)\\) (lineal).\nUno con complejidad \\(O(1)\\) (constante).",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#uno-más-tres",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#uno-más-tres",
    "title": "🛠️ Ejercicios",
    "section": "10 Uno más tres",
    "text": "10 Uno más tres\nProponer e implementar dos algoritmos que calculen la suma de los primeros N números naturales impares.\n\nUno con complejidad \\(O(N)\\) (lineal).\nUno con complejidad \\(O(1)\\) (constante).",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#más-y-más-datos",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#más-y-más-datos",
    "title": "🛠️ Ejercicios",
    "section": "11 Más y más datos",
    "text": "11 Más y más datos\n\nConsidere el siguiente código que calcula un acumulado de promedios para una lista de tamaño N.\n\ndef promedios_acumulados(lista):\n    \"\"\"\n    Ejemplo:  Entrada -&gt; [1, 2, 3, 5]\n              Salida  -&gt; [1, 1.5, 2, 2.75]\n    \"\"\"\n    N = len(lista)\n    promedios = []\n    for i in range(1, N+1):\n        promedio = sum(lista[:i]) / i\n        promedios.append(promedio)\n    return promedios\nDetermine la complejidad de este algoritmo.\n\nSiendo \\(\\overline{X}_n\\) el promedio de los primeros \\(n\\) números en la lista, vale la siguiente identidad recursiva: \\[\n\\overline{X}_{n+1} = \\frac{n \\cdot \\overline{X}_n + x_{n+1}}{n+1}\n\\]\ndonde \\(x_{n+1}\\) es el elemento \\((n+1)\\)-ésimo de la lista.\n\nUtilice este resultado para implementar un algoritmo más eficiente.",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#el-regreso-de-fibonacci",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#el-regreso-de-fibonacci",
    "title": "🛠️ Ejercicios",
    "section": "12 El regreso de Fibonacci",
    "text": "12 El regreso de Fibonacci\nEn el Ejercicio 4 de la Unidad 2 se implementó una función recursiva para calcular el \\(n\\)-ésimo número en la sucesión de Fibonacci.\nEsta implementación, sin embargo, es muy ineficiente. De hecho, se puede demostrar que su complejidad es \\(O(2^n)\\) (exponencial).\nUtilice memoización para mejorar la eficiencia del algoritmo recursivo. Este nuevo programa tendrá eficiencia lineal: \\(O(n)\\).\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nAl inicio de la función se debe crear un diccionario vacío: valores = {}.\nAnte cada valor \\(f(n)\\) de la sucesión que toque calcular, se deberá chequear si \\(n\\) está entre las claves existentes del diccionario.\n\nSi no lo está, se deberá calcular recursivamente y luego almacenar su resultado: valores[n] = f(n).\nSi lo está, se devolverá el valor f(n) sin efectuar más cálculos.",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#vinieron-los-primos",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#vinieron-los-primos",
    "title": "🛠️ Ejercicios",
    "section": "13 Vinieron los primos",
    "text": "13 Vinieron los primos\nImplementar un algoritmo para determinar si un número natural N es primo, con complejidad \\(O(\\sqrt{N})\\).\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nNótese que, dado un número natural \\(N\\), para verificar su primalidad es suficiente con verificar si es divisible por algún entero entre \\(1\\) y \\(\\sqrt{N}\\).\nSi fuese un número compuesto, jamás podría expresarse como el producto de dos números mayores a \\(\\sqrt{N}\\).\n\\[\na &gt; \\sqrt{N}, \\quad b &gt; \\sqrt{N} \\implies a \\cdot b &gt; \\sqrt{N} \\cdot \\sqrt{N} = N\n\\]",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#el-bueno-el-malo-y-el-eficiente",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#el-bueno-el-malo-y-el-eficiente",
    "title": "🛠️ Ejercicios",
    "section": "14 El bueno, el malo y el eficiente",
    "text": "14 El bueno, el malo y el eficiente\nSe tiene una lista con N números enteros. Se quiere saber si en la lista existe al menos un par de elementos tales que su suma sea impar.\nProponga e implemente dos algoritmos para esta tarea:\n\nUno con complejidad \\(O(N^2)\\) (cuadrática).\nUno con complejidad \\(O(N)\\) (lineal).",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#seamos-sinceros",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#seamos-sinceros",
    "title": "🛠️ Ejercicios",
    "section": "15 Seamos sinceros",
    "text": "15 Seamos sinceros\nUtilizando el módulo time, compare el tiempo que tardan estos dos métodos para determinar si una lista incluye ceros:\n\nUn bucle for que evalúa cada elemento.\n0 in mi_lista\n\n¿Cuál es más rápido? ¿Qué complejidad parece tener cada uno?\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nUtilice la función random.randint de NumPy para generar un arreglo grande con números al azar.\nimport numpy as np\n\nN = 3\n\n# Arreglo de números enteros aleatorios\nmi_lista = np.random.randint(0, 10**N, size=10**N)\nHaga variar el valor de N entre 3 y 6 para ver cómo cambia el tiempo de cómputo en cada método.\n(En el Ejercicio 10 de la Unidad 2 se explica cómo usar el módulo time.)",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#seamos-originales",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#seamos-originales",
    "title": "🛠️ Ejercicios",
    "section": "16 Seamos originales",
    "text": "16 Seamos originales\nUtilizando el módulo time, compare el tiempo que tardan estos dos métodos para remover duplicados de una lista:\n\nConviertiendo la lista a dict y luego de nuevo a list.\nConviertiendo la lista a set y luego de nuevo a list.\n\n¿Cuál es más rápido? ¿Qué complejidad parece tener cada uno?\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nEl primer método implica crear un diccionario a partir de una lista.\nEsto debe hacerse de forma tal que cada elemento en la lista pase a ser una clave, y a cada ella se le asigna un valor arbitrario (por ejemplo, None). De este modo, Python se encargará de que no haya claves duplicadas.\nPor último, se deberá tomar el conjunto de claves y convertirlo a una lista. Esto devolverá una lista similar a la original, pero sin duplicados.",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#altas-dimensiones",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#altas-dimensiones",
    "title": "🛠️ Ejercicios",
    "section": "17 Altas dimensiones",
    "text": "17 Altas dimensiones\nImplemente un algoritmo para multiplicar dos matrices de dimensión N x N.\n¿Qué complejidad tiene?",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/ejercicios.html#mediana-complejidad",
    "href": "practica/04_estructuras_y_algoritmos/ejercicios.html#mediana-complejidad",
    "title": "🛠️ Ejercicios",
    "section": "18 Mediana complejidad",
    "text": "18 Mediana complejidad\nSe tiene una lista desordenada con 2N+1 números distintos (es decir, la lista es de tamaño impar).\nImplemente un algoritmo naive para hallar la mediana. ¿Qué complejidad tiene?\nLuego, utilice un algoritmo de ordenamiento que permita resolver el problema de forma más eficiente.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nPara una lista de tamaño 2N+1, la mediana es el valor tal que N elementos son menores (o iguales) a él.",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/problemas.html",
    "href": "practica/04_estructuras_y_algoritmos/problemas.html",
    "title": "🧩 Problemas",
    "section": "",
    "text": "El recurso Arreglos manuales muestra como implementar un arreglo en Python sin utilizar ninguna estructura de datos de alto nivel como las listas o las tuplas.\nSi bien la clase Array provee métodos elementales para interactuar con los arreglos, carece de otros métodos convenientes que encontramos en estructuras como las listas.\nImplemente los siguientes métodos en la clase Array.\n\nappend(self, valor): agrega el elemento valor al final del arreglo. Análogo al método append de las listas.\nextend(self, arreglo): agrega todos los elementos del arreglo arreglo al final del arreglo. Análogo al método extend de las listas.\nreverse(self): invierte el orden de los elementos en el arreglo, modificandolo in-place.\ncount(self, valor): devuelve la cantidad de veces que aparece valor en el arreglo.\nclear(self): elimina todos los elementos del arreglo, dejandolo vacío in-place.\n__repr__(self): modifíquelo para que muestre solo los tres elementos iniciales y finales cuando la cantidad de elementos sea mayor a 10. En el medio, debe mostrar .... Por ejemplo Array(10, 22, -10, ..., 5, 5, 5).\n__iter__(self): permite iterar sobre el arreglo. Debe contener un bucle for que entrega (con yield) los valores del arreglo de a uno.\n\nFinalmente, modifique la clase Array para que encoja el tamaño del bloque de memoria cuando la cantidad de elementos sea menor al 20% de la capacidad.",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🧩 Problemas"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/problemas.html#arreglos-manuales-completos",
    "href": "practica/04_estructuras_y_algoritmos/problemas.html#arreglos-manuales-completos",
    "title": "🧩 Problemas",
    "section": "",
    "text": "El recurso Arreglos manuales muestra como implementar un arreglo en Python sin utilizar ninguna estructura de datos de alto nivel como las listas o las tuplas.\nSi bien la clase Array provee métodos elementales para interactuar con los arreglos, carece de otros métodos convenientes que encontramos en estructuras como las listas.\nImplemente los siguientes métodos en la clase Array.\n\nappend(self, valor): agrega el elemento valor al final del arreglo. Análogo al método append de las listas.\nextend(self, arreglo): agrega todos los elementos del arreglo arreglo al final del arreglo. Análogo al método extend de las listas.\nreverse(self): invierte el orden de los elementos en el arreglo, modificandolo in-place.\ncount(self, valor): devuelve la cantidad de veces que aparece valor en el arreglo.\nclear(self): elimina todos los elementos del arreglo, dejandolo vacío in-place.\n__repr__(self): modifíquelo para que muestre solo los tres elementos iniciales y finales cuando la cantidad de elementos sea mayor a 10. En el medio, debe mostrar .... Por ejemplo Array(10, 22, -10, ..., 5, 5, 5).\n__iter__(self): permite iterar sobre el arreglo. Debe contener un bucle for que entrega (con yield) los valores del arreglo de a uno.\n\nFinalmente, modifique la clase Array para que encoja el tamaño del bloque de memoria cuando la cantidad de elementos sea menor al 20% de la capacidad.",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🧩 Problemas"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/problemas.html#lista-enlazada",
    "href": "practica/04_estructuras_y_algoritmos/problemas.html#lista-enlazada",
    "title": "🧩 Problemas",
    "section": "2 Lista enlazada",
    "text": "2 Lista enlazada\nModifique la ListaEnlazada del apunte  para que:\n\nImplemente el método especial __len__.\nMantenga un conteo interno de la cantidad de elementos en la lista de forma tal que no sea necesario recorrerla para obtener su longitud.\nImplemente un método eliminar_siguiente que reciba como argumento un nodo de una lista enlazada y elimine el nodo que se encuentra inmediatamente después del nodo dado.\nImplemente un método elimiar_valor que reciba como argumento un valor y elimine de la lista enlazada todos los nodos que contengan ese valor.\n\nLuego, implemente el método reverse(self) que invierte los elementos de la lista enlazada.",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🧩 Problemas"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/problemas.html#pila-como-lista-enlazada",
    "href": "practica/04_estructuras_y_algoritmos/problemas.html#pila-como-lista-enlazada",
    "title": "🧩 Problemas",
    "section": "3 Pila como lista enlazada",
    "text": "3 Pila como lista enlazada\nImplemente una clase Pila que utilice una lista enlazada para almacenar los elementos de la pila.",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🧩 Problemas"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/problemas.html#cola-como-lista-doblemente-enlazada",
    "href": "practica/04_estructuras_y_algoritmos/problemas.html#cola-como-lista-doblemente-enlazada",
    "title": "🧩 Problemas",
    "section": "4 Cola como lista doblemente enlazada",
    "text": "4 Cola como lista doblemente enlazada\nImplemente una clase Cola que utilice una lista doblemente enlazada para almacenar los elementos de la pila.\nImplemente un método concatenar(self, C2) que agregue todos los elementos de la cola C2 al final de la cola C1 (es decir, la cola sobre la que se realiza la llamada). La operación debe ejecutarse en tiempo constante (O(1)) y debe dejar a C2 convertida en una cola vacía.",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🧩 Problemas"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/problemas.html#eliminar-nodo-de-lista-enlazada",
    "href": "practica/04_estructuras_y_algoritmos/problemas.html#eliminar-nodo-de-lista-enlazada",
    "title": "🧩 Problemas",
    "section": "5 Eliminar nodo de lista enlazada",
    "text": "5 Eliminar nodo de lista enlazada\nSuponga que tiene acceso a un nodo ubicado en algún punto intermedio de una lista enlazada clásica, pero no tiene acceso a la lista completa. Es decir, se tiene una variable que apunta a una instancia de Nodo, pero no al objeto ListaEnlazada.\nEn esta situación es posible acceder a todos los valores desde este nodo hasta el final de la lista, pero no hay forma de acceder a los nodos que lo preceden.\nEscriba un programa que elimine el nodo de la lista original. La lista original restante debe permanecer completa, con solo este nodo eliminado.",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🧩 Problemas"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/problemas.html#arreglos-indexados",
    "href": "practica/04_estructuras_y_algoritmos/problemas.html#arreglos-indexados",
    "title": "🧩 Problemas",
    "section": "6 Arreglos indexados",
    "text": "6 Arreglos indexados\nAgregue el método __getitem__(self, indice) a la clase Array para que sea posible acceder a sus valores de la siguiente manera:\narreglo = Array(10, 20, 150)\narreglo[0] # 10\narreglo[1] # 20\narreglo[2] # 150\narreglo[3] # IndexError\nAsegúrese de que el método __getitem__ soporta índices negativos.",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🧩 Problemas"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/problemas.html#pilas-y-colas-ruidosas",
    "href": "practica/04_estructuras_y_algoritmos/problemas.html#pilas-y-colas-ruidosas",
    "title": "🧩 Problemas",
    "section": "7 Pilas y colas ruidosas",
    "text": "7 Pilas y colas ruidosas\nLa implementación actual de Pila y Cola devuelve None cuando se intenta extraer un elemento de una pila (o cola) vacía. Modifique estas clases para que eleven un error llamado EmptyStructure.",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🧩 Problemas"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/problemas.html#pilas-y-colas-limitadas",
    "href": "practica/04_estructuras_y_algoritmos/problemas.html#pilas-y-colas-limitadas",
    "title": "🧩 Problemas",
    "section": "8 Pilas y colas limitadas",
    "text": "8 Pilas y colas limitadas\nModifique la implementación de Pila y Cola para que tengan una capacidad limitada, establecida mediante el parámetro capacidad_maxima el método inicializador, cuyo valor por defecto es None. Cuando se intente agregar un elemento en una pila o cola que está a máxia capaciad, se debe arrojar un error FullCapacity.",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🧩 Problemas"
    ]
  },
  {
    "objectID": "practica/04_estructuras_y_algoritmos/problemas.html#inversión-recursiva",
    "href": "practica/04_estructuras_y_algoritmos/problemas.html#inversión-recursiva",
    "title": "🧩 Problemas",
    "section": "9 Inversión recursiva",
    "text": "9 Inversión recursiva\nDescriba un algoritmo recursivo eficiente para invertir una lista simplemente enlazada.",
    "crumbs": [
      "Práctica",
      "U4 - Estructuras de Datos y Algoritmos",
      "🧩 Problemas"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html",
    "href": "practica/01_programacion_en_python/autoevaluacion.html",
    "title": "🪞 Autoevaluación",
    "section": "",
    "text": "¿Qué valor contiene la variable contador luego de ejecutar el siguiente código?\ncontador = 20\ncontador + 1\nComplete la siguiente tabla indicando si el nombre es válido para una variable de Python.\n\n\n\nNombre\n¿Válido?\nJustificación\n\n\n\n\nbalance\n\n\n\n\nbalanceActual\n\n\n\n\nbalance-actual\n\n\n\n\nbalance actual\n\n\n\n\nbalance_actual\n\n\n\n\nmis.datos\n\n\n\n\n0cuenta\n\n\n\n\ncuenta0\n\n\n\n\n_cuenta\n\n\n\n\nSPAM\n\n\n\n\ncantidad$",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🪞 Autoevaluación"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#variables",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#variables",
    "title": "🪞 Autoevaluación",
    "section": "",
    "text": "¿Qué valor contiene la variable contador luego de ejecutar el siguiente código?\ncontador = 20\ncontador + 1\nComplete la siguiente tabla indicando si el nombre es válido para una variable de Python.\n\n\n\nNombre\n¿Válido?\nJustificación\n\n\n\n\nbalance\n\n\n\n\nbalanceActual\n\n\n\n\nbalance-actual\n\n\n\n\nbalance actual\n\n\n\n\nbalance_actual\n\n\n\n\nmis.datos\n\n\n\n\n0cuenta\n\n\n\n\ncuenta0\n\n\n\n\n_cuenta\n\n\n\n\nSPAM\n\n\n\n\ncantidad$",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🪞 Autoevaluación"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#números",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#números",
    "title": "🪞 Autoevaluación",
    "section": "2 Números",
    "text": "2 Números\n\n¿Cuál es el tipo de 10 / 2? ¿Por qué?\n¿Cuál es el tipo de 5 * 2? ¿Por qué?\n¿Por qué 5 == 5.0 es True?",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🪞 Autoevaluación"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#booleanos",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#booleanos",
    "title": "🪞 Autoevaluación",
    "section": "3 Booleanos",
    "text": "3 Booleanos\n\n¿Cuál es el resultado de las siguientes expresiones? ¿Por qué?\nFalse or not False\nnot (True and True)\nnot True and True\n\"True\" != True\n10 &gt; 5 + 3\nNone is None\nFalse is False\nEjecute línea por línea los siguientes bloques y analice los resultados.\nint(True) * 50\nTrue * 50\n1 is True\nbool(1) is True\nid(True)\nid(bool(1))\nid(bool(1024))\n¿Cuáles son los 3 operadores booleanos?",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🪞 Autoevaluación"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#cadenas-de-caracteres",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#cadenas-de-caracteres",
    "title": "🪞 Autoevaluación",
    "section": "4 Cadenas de caracteres",
    "text": "4 Cadenas de caracteres\n\n¿Por qué la siguiente comparación resulta en True?\n\"spam\" + \"spamspam\" == \"spam\" * 3\n¿Por qué la siguiente expresión resulta en un error? ¿Cómo se puede arreglar?\n\"Me comí \" + 6 + \" panchos.\"\n¿Encuentra algo extraño en la siguiente expresión? ¿Cómo la mejoraría?\nmateria = \"Programación 2\"\nprint(\"¡Sean bienvenidos a la materia {materia}!\")\nExplique por qué es redundante utilizar str() en el siguiente bloque de código:\nx, y = 10, 20\nprint(f\"La suma de {str(x)} y {str(y)} es: {str(x + y)}.\")\nConsidere el siguiente bloque de código:\nmensaje = \"Hola, ¿cómo estes?\"\nmensaje[-3] = \"á\"\n\n¿Cuál es la intención detrás del programa?\n¿Por qué no funciona?\n¿Cómo podría arreglarlo? Alerta: la solución no es muy elegante.\n\n¿Cuál es el resultado de list(\"abcdefgh\")? ¿Por qué?\n¿Por qué set(\"abcde\") es distinto de {\"abcde\"}?",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🪞 Autoevaluación"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#funciones",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#funciones",
    "title": "🪞 Autoevaluación",
    "section": "5 Funciones",
    "text": "5 Funciones\n\n¿Cuál es la diferencia entre una función y una llamada a función?\n¿Cuál es el valor que devuelve una función que no tiene return?\n¿Cuándo se ejecuta el código dentro de una función: cuando la función se define o cuando se la llama? Considere la siguiente función:\ndef suma(x, y):\n    print(100 / 0)\n    return x + y\nLuego, ejecute el siguiente bloque:\nsuma(2, 4)",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🪞 Autoevaluación"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#listas",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#listas",
    "title": "🪞 Autoevaluación",
    "section": "6 Listas",
    "text": "6 Listas\n\n¿Qué es []? ¿Cuál es el resultado de len([])?\n¿Por qué la siguiente expresión resulta en False? Ayuda: use la función id().\n[] is []\n¿Por qué se obtiene un error en el siguiente bloque de código?\nl = []\nl[0]\nSi [0][0] devuelve 0, ¿por qué [1][1] no devuelve [1]?\n¿Cuál es el valor de x en el siguiente bloque de código? ¿Por qué?\nl = [\"hola\", \"hola hola\", \"hasta luego\"]\nx = l.remove(\"hola\")\n¿Cómo le asignaría el valor \"hola\" como el tercer valor en una lista almacenada en una variable llamada cosas? Asuma que cosas contiene [2, 4, 6, 8, 10].\nAsuma que letras contiene la lista [\"a\", \"b\", \"c\", \"d\"]:\n\n¿A qué evalúa letras[-1]?\n¿A qué evalúa letras[:2]?\n¿A qué evalúa letras[int(int('3' * 2) // 11)]? ¿Es necesario usar dos veces int()?\n\nAsuma que bartulos contiene la lista [3.14, \"casa\", 11, \"casa\", True]:\n\n¿A qué evalúa bartulos.index(\"casa\")? ¿Por qué?\n¿Cómo queda la lista en bartulos después de ejecutar bartulos.append(99)?\n¿Cómo queda la lista en bartulos después de ejecutar bartulos.remove(\"casa\"') ?¿Por qué?\n\n¿Cuáles son los operadores para la concatenación y la replicación de listas?\n¿Cuál es la diferencia entre los métodos append() e insert() de las listas?\n¿Cuáles son dos formas de eliminar valores de una lista?\nEl siguiente bloque de código imprime ['a', 'b', True, 30]. ¿Por qué?\ncosas = [\"a\", \"b\", True]\nbartulos = cosas\nbartulos.append(20 + 10)\nprint(cosas)\nConsidere el siguiente bloque de código:\nmarcas = [\"Milka\", \"Cofler\", \"Águila\", \"Cadbury\", \"Lindt\", \"Toblerone\", \"After Eight\"]\nmarcas[2:5]\nque correctamente muestra [\"Águila\", \"Cadbury\", \"Lindt\"]. ¿Por qué el siguiente bloque de código no funciona?\nmarcas = [\"Milka\", \"Cofler\", \"Águila\", \"Cadbury\", \"Lindt\", \"Toblerone\", \"After Eight\"]\nindices = 2:5\nmarcas[indices]",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🪞 Autoevaluación"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#tuplas",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#tuplas",
    "title": "🪞 Autoevaluación",
    "section": "7 Tuplas",
    "text": "7 Tuplas\n\n¿Por qué la tupla no implementa un método similar al método .extend() de las listas?\nLas tuplas de Python son conocidas por ser inmutables. Por ejemplo, el siguiente bloque de código resulta en un error:\ntupla = (1, 2, 3)\ntupla[1] = 10\nSin embargo, el siguiente bloque no arroja ningún error y pareciera que se logra modificar la tupla exitosamente:\nbartulos = [\"Hola\", 10, None]\ntupla = (1, bartulos, 3)\n\ntupla[1].append(\"¡Sorpesa!\")\n\nprint(tupla)\n¿Qué pasó?",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🪞 Autoevaluación"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#diccionarios",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#diccionarios",
    "title": "🪞 Autoevaluación",
    "section": "8 Diccionarios",
    "text": "8 Diccionarios\n\n¿Cómo se escribe en código un diccionario vacío?\n¿Cómo se ve un diccionario que tiene la clave \"cosa\" y el valor 15?\n¿Cuál es la principal diferencia entre un diccionario y una lista?\n¿Qué ocurre si se intenta acceder a bartulos[\"cosa\"] cuando bartulos es {\"coso\": 100}?\nSi un diccionario está almacenado en bartulos, ¿cuál es la diferencia entre las siguientes expresiones?\n\"cosa\" in bartulos\n\"cosa\" in bartulos.keys()\nSuponga el diccionario datos = {\"nombre\": \"Juan\"}. ¿Por qué la siguiente expresión resulta en False?\n\"Juan\" in datos",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🪞 Autoevaluación"
    ]
  },
  {
    "objectID": "practica/01_programacion_en_python/autoevaluacion.html#control-de-flujo",
    "href": "practica/01_programacion_en_python/autoevaluacion.html#control-de-flujo",
    "title": "🪞 Autoevaluación",
    "section": "9 Control de flujo",
    "text": "9 Control de flujo\n\n9.1 Condicionales\n\nExplique qué es una condición y en qué situaciones se utilizaría.\nIdentifique los tres bloques de código en el siguiente ejemplo:\ncodigo = 0\n\nif codigo == 10:\n    print(\"mensaje 1\")\n    if codigo &gt; 5:\n        print(\"mensaje 2\")\n    else:\n        print(\"mensaje alternativo\")\n    print(\"mensaje final\")\n\nprint(\"Fin del programa\")\n¿Tienen sentido las comparaciones utilizadas?\n¿Cuál es el problema con el siguiente programa? Proponga una solución.\nnumero = 10\nif numero &lt; 0:\n    print(f\"El numero {numero} es negativo\")\nelif numero &lt; -5:\n    print(f\"El numero {numero} es menor a -5\")\nelif numero &gt; 0:\n    print(f\"El numero {numero} es positivo\")\nelse:\n    print(f\"El numero {numero} es 0\")\n\n\n\n9.2 Bucles\n\nConsidere el siguiente programa:\nfor i in range(10):\n    print(i)\nEscriba un programa que realice la misma tarea utilizando un bucle while.\n¿Cuál es la diferencia entre range(10), range(0, 10) y range(0, 10, 1) en un bucle for?\nSuponga que numeros es una lista que contiene numeros enteros, ¿en qué se diferencian los siguientes bloques de código?\nfor i in numeros:\n    if i % 2 == 0:\n        break\n    print(i)\nfor i in numeros:\n    if i % 2 == 0:\n        continue\n    print(i)\n¿Es posible re-escribir el siguiente bloque de código usando while True? ¿Qué modificaciones habría que hacer?\nsuma = 0\ni = 0\nwhile suma &lt;= limite:\n    suma += numeros[i]\n    i += 1",
    "crumbs": [
      "Práctica",
      "U1 - Programación en Python",
      "🪞 Autoevaluación"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html",
    "href": "practica/03_oop/ejercicios.html",
    "title": "🛠️ Ejercicios",
    "section": "",
    "text": "Defina una clase Contador que represente un contador numérico. Por defecto, las instancias comienzan con el valor 0, aunque debe permitirse inicializarlas con un valor distinto.\nImplemente los siguientes métodos:\n\nincrementar: aumenta el valor del contador en una cantidad arbitraria (por defecto, 1).\ndecrementar: disminuye el valor del contador en una cantidad arbitraria (por defecto, 1).\nreiniciar: restablece el contador a su valor inicial (¡que puede ser distinto de 0!).\nvalor: devuelve el valor actual del contador.\n\nEjemplo de uso\ncontador = Contador()\ncontador.incrementar(5)    # El valor interno es 5\ncontador.decrementar(2)    # El valor interno es 3\nprint(contador.valor())    # Imprime 3\ncontador.reiniciar()\nprint(contador.valor())    # Imprime 0",
    "crumbs": [
      "Práctica",
      "U3 - Programación Orientada a Objetos",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html#contador",
    "href": "practica/03_oop/ejercicios.html#contador",
    "title": "🛠️ Ejercicios",
    "section": "",
    "text": "Defina una clase Contador que represente un contador numérico. Por defecto, las instancias comienzan con el valor 0, aunque debe permitirse inicializarlas con un valor distinto.\nImplemente los siguientes métodos:\n\nincrementar: aumenta el valor del contador en una cantidad arbitraria (por defecto, 1).\ndecrementar: disminuye el valor del contador en una cantidad arbitraria (por defecto, 1).\nreiniciar: restablece el contador a su valor inicial (¡que puede ser distinto de 0!).\nvalor: devuelve el valor actual del contador.\n\nEjemplo de uso\ncontador = Contador()\ncontador.incrementar(5)    # El valor interno es 5\ncontador.decrementar(2)    # El valor interno es 3\nprint(contador.valor())    # Imprime 3\ncontador.reiniciar()\nprint(contador.valor())    # Imprime 0",
    "crumbs": [
      "Práctica",
      "U3 - Programación Orientada a Objetos",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html#magia-para-programadores",
    "href": "practica/03_oop/ejercicios.html#magia-para-programadores",
    "title": "🛠️ Ejercicios",
    "section": "2 Magia para programadores",
    "text": "2 Magia para programadores\nEsta es tu primera clase de Pociones en Hogwarts y el profesor te dio como tarea descubrir de qué color se volverá una poción si se mezcla con otra. Todas las pociones tienen un color definido en formato RGB, desde [0, 0, 0] hasta [255, 255, 255].\nPara complicar un poco más la tarea, el profesor realizará varias mezclas seguidas y luego te preguntará por el color final. Además del color, también deberás calcular qué volumen tendrá la poción después de la mezcla final.\nGracias a tu experiencia en programación descubriste que al mezclar dos pociones, los colores se combinan como si se mezclaran dos colores en formato RGB. Por ejemplo, si mezclas una poción con color [255, 255, 0] y volumen 10 con otra de color [0, 254, 0] y volumen 5, obtendrás una nueva poción con:\n\ncolor [170, 255, 0]\nvolumen 15\n\nPor lo tanto, decidís crear una clase Pocion que tenga:\n\ndos propiedades:\n\ncolor (una lista o tupla con 3 enteros)\nvolumen (un número)\n\nun método mezclar que acepte otra Pocion y devuelva una nueva Pocion ya mezclada.\n\nEjemplo:\nfelix_felicis = Pocion([255, 255, 255],  7)\npocion_multijugos = Pocion([51, 102, 51], 12)\nnueva_pocion = felix_felicis.mezclar(pocion_multijugos)\n\nnueva_pocion.color # Devuelve [127, 159, 127]\nnueva_pocion.volumen # Devuelve 19\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nLos colores de las pociones deben representarse como tríos de números enteros en formato RGB. Al realizar una mezcla de colores, se debe redondear hacia arriba utilizando math.ceil.",
    "crumbs": [
      "Práctica",
      "U3 - Programación Orientada a Objetos",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html#mensaje-secreto",
    "href": "practica/03_oop/ejercicios.html#mensaje-secreto",
    "title": "🛠️ Ejercicios",
    "section": "3 Mensaje secreto",
    "text": "3 Mensaje secreto\nUn cifrado por sustitución simple reemplaza cada carácter de un alfabeto con un carácter de un alfabeto alternativo. Cada posición en el alfabeto original se mapea a la posición correspondiente en el alfabeto alternativo, y esto sirve tanto para codificar como para decodificar.\nEl objetivo es crear una clase que, al inicializarse, reciba dos alfabetos (original y alternativo). La clase debe tener un método para encriptar mensajes y otro para revertir la encriptación.\nEjemplo:\nalfabeto = \"abcdefghijklmnopqrstuvwxyz\"\nalfabeto_mezclado = \"etaoinshrdlucmfwypvbgkjqxz\"\n\nmi_cifrado = Cifrado(alfabeto, alfabeto_mezclado)\n\nmi_cifrado.codificar(\"abc\")    # =&gt; \"eta\"\nmi_cifrado.codificar(\"xyz\")    # =&gt; \"qxz\"\nmi_cifrado.codificar(\"aeiou\")  # =&gt; \"eirfg\"\n\nmi_cifrado.decodificar(\"eta\")    # =&gt; \"abc\"\nmi_cifrado.decodificar(\"qxz\")    # =&gt; \"xyz\"\nmi_cifrado.decodificar(\"eirfg\")  # =&gt; \"aeiou\"\n\nPunto extra\nVerifique en el método __init__ que la longitud de los alfabetos sea la misma. Caso contrario, levante una excepción ValueError indicando cuál es el problema.",
    "crumbs": [
      "Práctica",
      "U3 - Programación Orientada a Objetos",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html#real-envido",
    "href": "practica/03_oop/ejercicios.html#real-envido",
    "title": "🛠️ Ejercicios",
    "section": "4 Real envido",
    "text": "4 Real envido\nConstruir una clase ManoDeTruco que, al inicializarse, reciba una lista o tupla de hasta tres números enteros, correspondientes a los valores de las cartas en una mano de truco.\nLa clase debe incluir un método llamado comparar_con que recibe otra mano de truco y determine cuál de las dos suma más puntos para el envido. En caso de empate, se considera ganadora la mano que invocó el método.\nEjemplo de uso\nmano1 = ManoDeTruco([7, 5, 6])\nmano2 = ManoDeTruco([4, 11, 2])\n\nganadora = mano1.comparar_con(mano2)\n\n\n\n\n\n\nConsideraciones\n\n\n\n\n\n\nAsuma que todas las cartas cargadas en la mano son del mismo palo.\nPara calcular los puntos del envido, solo se consideran dos de las tres cartas, no la suma de las tres.",
    "crumbs": [
      "Práctica",
      "U3 - Programación Orientada a Objetos",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html#la-muestra-infinita",
    "href": "practica/03_oop/ejercicios.html#la-muestra-infinita",
    "title": "🛠️ Ejercicios",
    "section": "5 La muestra infinita",
    "text": "5 La muestra infinita\nDefina una clase Muestra que represente un conjunto de datos numéricos. La clase debe inicializarse a partir de un iterable de números e implementar los siguientes métodos:\n\nagregar(x): agrega un número a la muestra.\nn(): devuelve la cantidad de elementos.\nsuma(): devuelve la suma de los valores.\nmedia(): devuelve el promedio de los valores.\nvarianza(muestral=False): calcula la varianza.\n\nSi muestral=False, se usa el denominador n (varianza poblacional).\nSi muestral=True, se usa el denominador n-1 (varianza muestral).\n\n\nEjemplo de uso\nmuestra = Muestra([10, 12, 13, 15])\nmuestra.agregar(20)\nmuestra.n()                     # 5\nmuestra.suma()                  # 70\nmuestra.media()                 # 14.0\nmuestra.varianza()              # varianza poblacional\nmuestra.varianza(muestral=True) # varianza muestral\n\nPunto extra\nModifique la clase para que:\n\nGuarde los datos en un atributo “privado” llamado _datos.\nProvea una propiedad de solo lectura valores, que devuelva una copia inmutable de los datos (por ejemplo, una tupla).",
    "crumbs": [
      "Práctica",
      "U3 - Programación Orientada a Objetos",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html#orden-en-el-laboratorio",
    "href": "practica/03_oop/ejercicios.html#orden-en-el-laboratorio",
    "title": "🛠️ Ejercicios",
    "section": "6 ¡Orden en el laboratorio!",
    "text": "6 ¡Orden en el laboratorio!\nEn un laboratorio se necesita llevar un registro ordenado de los experimentos realizados. Cada experimento debe contar con un número identificador único, un nombre y, de manera opcional, el nombre de la persona responsable.\nEl objetivo de este ejercicio es construir una clase que facilite dicha organización.\nPara ello, implemente una clase llamada Experimento que se inicializa con el nombre del experimento y, opcionalmente, con el nombre del responsable. La clase debe asignar automáticamente un número identificador único a cada instancia. Para lograrlo, utilice un atributo de clase llamado total_creados, que comience en 0.\nCada instancia debe contar con:\n\nUn identificador numérico único (asignado automáticamente de forma incremental por la clase).\nUn nombre.\nUn responsable, si se proporciona.\n\nEjemplo de uso\ne1 = Experimento(\"Piloto A\", responsable=\"Dolores\")\ne2 = Experimento(\"Piloto Z\")\nExperimento.total_creados  # Devuelve 2\n\nPuntos extra\nModifique la clase para que también:\n\nSe puedan crear objetos utilizando un método de clase llamado desde_dict que reciba un diccionario de la forma {\"nombre\": ..., \"responsable\": ...} y devuelva una instancia de Experimento.\nImplemente el método mágico __repr__ que devuelva una cadena de texto con el siguiente formato: python     Experimento(id=1, nombre=\"A/B\", responsable=\"Sosa\")\n\nEjemplo de uso\ne = Experimento.desde_dict({\"nombre\": \"Piloto B\", \"responsable\": \"Ana\"})\nrepr(e)\n# Experimento(id=3, nombre=\"Piloto B\", responsable=\"Ana\")",
    "crumbs": [
      "Práctica",
      "U3 - Programación Orientada a Objetos",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html#sensores-descalibrados",
    "href": "practica/03_oop/ejercicios.html#sensores-descalibrados",
    "title": "🛠️ Ejercicios",
    "section": "7 Sensores descalibrados",
    "text": "7 Sensores descalibrados\nEste ejercicio requiere diseñar una pequeña jerarquía de clases para simular sensores utilizados en un laboratorio.\nEn la práctica, los sensores no siempre son completamente precisos: pueden registrar valores ligeramente superiores o inferiores al valor real. Para corregir ese desvío, se aplica una calibración, que consiste en ajustar las lecturas mediante un valor adicional o corrector llamado offset.\n\nJerarquía de clases\nClase base: Sensor\nLa clase Sensor debe incluir:\n\nUn atributo nombre para identificar al sensor.\nUn método leer que levante una excepción NotImplementedError, indicando que debe ser implementado por las subclases.\nUn método calibrar(offset) que permita almacenar un valor de ajuste (offset) que se aplicará a las lecturas.\n\nSubclases\nSe deben definir dos subclases: SensorTemperatura y SensorHumedad, ambas con su propia implementación del método leer:\n\nSensorTemperatura: simula una medición utilizando random.uniform(18, 28).\nSensorHumedad: simula una medición utilizando random.uniform(30, 70).\n\nEn ambos casos, la medición debe ser ajustada por el offset correspondiente (si fue calibrado).\n\n\nFunción auxiliar\nAdemás, implemente una función llamada promedio_lecturas que reciba dos argumentos: una secuencia de sensores y un número entero n, que indica cuántas lecturas realizar con cada sensor.\nLa función debe realizar n lecturas para cada sensor utilizando su método leer, calcular el promedio de esas lecturas y devolver un diccionario que asocie el nombre de cada sensor con su promedio correspondiente.\nEjemplo de uso\nst = SensorTemperatura(\"T1\")\nsh = SensorHumedad(\"H1\")\nst.calibrar(0.5)\n\npromedios = promedio_lecturas([st, sh], n=3)\n# {'T1': ..., 'H1': ...}",
    "crumbs": [
      "Práctica",
      "U3 - Programación Orientada a Objetos",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html#python-para-matemáticos",
    "href": "practica/03_oop/ejercicios.html#python-para-matemáticos",
    "title": "🛠️ Ejercicios",
    "section": "8 Python para matemáticos",
    "text": "8 Python para matemáticos\nConstruya una clase Fraccion que acepte dos argumentos: numerador y denominador. Se desea que esta clase:\n\nSea representable como cadena de texto.\nImplemente la suma entre fracciones.\nDevuelva siempre el resultado en la mínima representación posible (fracción irreducible).\n\nEjemplo:\nfraccion1 = Fraccion(4, 5)\nprint(fraccion1 + Fraccion(1, 8))\n#&gt; \"37/40\"\n\nPunto extra\nExtender la funcionalidad de la clase incluyendo las operaciones de resta, multiplicación y división.",
    "crumbs": [
      "Práctica",
      "U3 - Programación Orientada a Objetos",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "practica/03_oop/ejercicios.html#tiempo-al-tiempo",
    "href": "practica/03_oop/ejercicios.html#tiempo-al-tiempo",
    "title": "🛠️ Ejercicios",
    "section": "9 Tiempo al tiempo ⏳",
    "text": "9 Tiempo al tiempo ⏳\nEl módulo estándar datetime de Python incluye, entre otras cosas, la clase date para trabajar con fechas. El objetivo de este ejercicio es implementar, desde cero, una nueva clase Date que permita representar fechas y operar con ellas.\n\nPrimera implementación\n\nConstruya la clase Date. El método __init__ debe tomar 3 parámetros: year, month y day, y asignarlos como atributos de la instancia. Cree un objeto que represente el 6 de noviembre de 1995 y verifique que los atributos contengan los valores esperados.\nImplemente el método __str__, que debe devolver una cadena con el formato YYYY-MM-DD, donde YYYY representa el año, MM el mes y DD el día. Ayuda: Puede utilizar el método .rjust de las cadenas de texto para agregar ceros a la izquierda cuando sea necesario. Por ejemplo, para el 6 de noviembre de 1995, str(fecha) debe devolver \"1995-11-06\".\nImplemente el método __repr__, que debe devolver una representación similar a la utilizada para crear la instancia. Para la fecha 6 de noviembre de 1995, debe devolver la cadena \"Date(year=1995, month=11, day=6)\".\nImplemente un método de clase que permita crear una Date a partir de una cadena en formato YYYY-MM-DD. Por ejemplo, Date.from_str(\"2025-03-08\") debe devolver un objeto Date que representa al 8 de marzo de 2025. Ayuda: Puede utilizar el método .lstrip(\"0\") para eliminar ceros a la izquierda en una cadena.\nImplemente los métodos de comparación entre objetos Date.\n\n__eq__: igualdad (==)\n__ne__: desigualdad (!=)\n__lt__: menor que (&lt;)\n__gt__: mayor que (&gt;)\n__le__: menor o igual que (&lt;=)\n__ge__: mayor o igual que (&gt;=)\n\nAyuda: Dos fechas se consideran iguales si sus atributos year, month, y day coinciden. Para las comparaciones, considere primero el año, luego el mes y finalmente el día.\n\n\n\nA prueba de balas\nA esta altura, se cuenta con una implementación razonablemente completa y funcional para representar objetos de tipo fecha. Sin embargo, la clase Date no garantiza la validez ni la robustez de las instancias que se crean. Es posible construir objetos Date que representen fechas inválidas, como el 31 de abril o el 55.8 del mes 25.3, y operar con ellos sin que el programa emita ningún tipo de advertencia.\n\nModifique la implementación de los atributos year, month y day de modo que sean privados y que su asignación incluya una verificación de validez. Para ello, se propone lo siguiente:\n\nUtilice atributos privados llamados _year, _month y _day.\nDefina métodos year, month y day, decorados con @property, que expongan dichos atributos para su lectura. Estos métodos deben devolver el valor del atributo correspondiente.\nPara permitir la asignación controlada, implemente un setter para cada atributo Para ello, decore el mismo método con @&lt;nombre&gt;.setter (por ejemplo, @year.setter) y defina allí la lógica de verificación. Por el momento, verifique únicamente que el valor asignado sea un número entero y positivo. Eleve un ValueError en caso de que el valor por asignar no pase la verificación.\n\n\nUtilice los siguientes ejemplos de verificación\nd = Date(2022, 7, 1)\nrepr(d) # Date(year=2022, month=7, day=1)\nstr(d)  # \"2022-07-01\"\n(d.year, d.month, d.day) # (2022, 7, 1)\nDate(2022, 0, 1)       # Falla: el mes no es positivo\nDate(2022, 3, 5.5)     # Falla: el día no es un entero\nDate(\"11\", 3, 1)       # Falla: el año es una cadena de texto\nd = Date(2022, 7, 1)\nd.day = 11             # Funciona: pasa la verificación\nstr(d)                 # \"2022-07-11\"\n\nd.month = -1           # Falla\nd.year = -1            # Falla\n\nMejore ahora las verificaciones de los valores asignados para que sean más robustas:\n\nEl año debe ser entero y mayor o igual a 0.\nEl mes debe ser un número entero entre 1 y 12 inclusive.\nEl día debe ser un número entero mayor o igual a 1 y menor o igual a la cantidad de días del mes correspondiente.\n\n\nLa cantidad de días depende del mes. Para todos los meses excepto febrero, utilice el diccionario provisto en la ayuda debajo. Para el caso de febrero, implemente un método estático que reciba un año como argumento y devuelva un booleano indicando si ese año es bisiesto.\n\n\n\n\n\n\nAyuda\n\n\n\n\n\nDiccionario de días por mes:\nDOM = {\n    1: 31,  # Enero\n    2: 28,  # Febrero (29 en año bisiesto)\n    3: 31,  # Marzo\n    4: 30,  # Abril\n    5: 31,  # Mayo\n    6: 30,  # Junio\n    7: 31,  # Julio\n    8: 31,  # Agosto\n    9: 30,  # Septiembre\n    10: 31, # Octubre\n    11: 30, # Noviembre\n    12: 31, # Diciembre\n}\n\nDOM[5] # Devuelve 31, porque es mayo\nPor otro lado, un año es bisiesto si:\n\nEs divisible por 4,\nexcepto que sea divisible por 100,\nsalvo que tambien sea divisibles por 400\n\nEn Python\n(year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)\n\n\n\nFinalmente, verifique que su clase Date funciona correctamente con los siguientes ejemplos:\n# Definición de fechas\nd1 = Date(1990, 5, 20)\nd2 = Date(1998, 9, 21)\nd3 = Date(1998, 9, 20)\nd4 = Date(2022, 12, 18)\n\nd1 &lt; d2\nd1 &gt; d2\nd1 != d3\nd4 &gt;= d3\n\nDate(2000, 2, 29) # Funciona, es bisiesto\nDate(2001, 2, 29) # Falla, no es bisiesto\n\n\nl = [d1, d2, d3, d4]\nsorted(l) # Funciona, ¿por qué?",
    "crumbs": [
      "Práctica",
      "U3 - Programación Orientada a Objetos",
      "🛠️ Ejercicios"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/05_generadores.html",
    "href": "teoria/02_programacion_funcional/05_generadores.html",
    "title": "5 - Generadores 🧩",
    "section": "",
    "text": "En este capítulo vamos a introducirnos en los generadores, tanto en las funciones como en las expresiones generadoras. A diferencia de las funciones regulares, que devuelven un resultado con return, los generadores no devuelven un único resultado, sino que van entregando valores de a uno a medida que se lo solicita. Cada vez que se entrega un valor, la ejecución queda en pausa y se conserva el estado de las variables, de modo que puede reanudarse más adelante. De este modo, los generadores resultan ideales para definir iteradores y trabajar con grandes volúmenes de datos sin necesidad de almacenarlos al mismo tiempo en memoria.",
    "crumbs": [
      "Teoría",
      "U2 - Programación Funcional",
      "5 - Generadores 🧩"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/05_generadores.html#introducción",
    "href": "teoria/02_programacion_funcional/05_generadores.html#introducción",
    "title": "5 - Generadores 🧩",
    "section": "",
    "text": "En este capítulo vamos a introducirnos en los generadores, tanto en las funciones como en las expresiones generadoras. A diferencia de las funciones regulares, que devuelven un resultado con return, los generadores no devuelven un único resultado, sino que van entregando valores de a uno a medida que se lo solicita. Cada vez que se entrega un valor, la ejecución queda en pausa y se conserva el estado de las variables, de modo que puede reanudarse más adelante. De este modo, los generadores resultan ideales para definir iteradores y trabajar con grandes volúmenes de datos sin necesidad de almacenarlos al mismo tiempo en memoria.",
    "crumbs": [
      "Teoría",
      "U2 - Programación Funcional",
      "5 - Generadores 🧩"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/05_generadores.html#funciones-generadoras",
    "href": "teoria/02_programacion_funcional/05_generadores.html#funciones-generadoras",
    "title": "5 - Generadores 🧩",
    "section": "Funciones generadoras",
    "text": "Funciones generadoras\nUna función generadora se define igual que una función común con def, pero en lugar de devolver un valor con return, lo hace con yield.\nCuando se ejecuta una función generadora, no se ejecuta el código en su cuerpo de manera inmediata ni se obtiene un resultado. En cambio, se obtiene un generador que luego puede entregar valores.\n\ndef gen():\n    yield \"¡Resultado!\"\n\ng = gen()\ng\n\n&lt;generator object gen at 0x7f90c8738ca0&gt;\n\n\nComo los generadores son iteradores (ver Iterables e iteradores), se puede usar next para obtener el siguiente valor de manera manual:\n\nnext(g)\n\n'¡Resultado!'\n\n\nEste primer ejemplo es demasiado simple para apreciar la verdadera utilidad de los generadores. Si solo necesitáramos devolver un único valor, bastaría con usar una función común.\nLa ventaja de los generadores está en que pueden entregar varios valores de a uno, a medida que se los solicita, mientras conservan el estado de las variables.\nVeamos ahora una segunda función generadora, esta vez con dos instrucciones yield en lugar de una. En la primera llamada a next, obtenemos \"Primer resultado\".\n\ndef gen():\n    yield \"Primer resultado\"\n    yield \"Segundo resultado\"\n\ng = gen()\nnext(g)\n\n'Primer resultado'\n\n\nY en la segunda llamada a next el generador entrega el segundo valor: \"Segundo resultado\".\n\nnext(g)\n\n'Segundo resultado'\n\n\nEn la primera llamada a next, la función se ejecuta hasta llegar a la primera instrucción yield. Allí el generador devuelve un valor y suspende su ejecución. Con la segunda llamada, la ejecución se reanuda desde ese punto y continúa hasta encontrar el siguiente yield, entregando otro valor.\nAhora bien, ¿qué ocurre si llamamos a next cuando el generador ya entregó todos los valores disponibles?\nnext(g)\n\n    next(g)\n    ~~~~^^^\nStopIteration\n\nUna vez que un generador se agota, cualquier llamada adicional a next elevará la excepción StopIteration, que señala que ya no quedan valores por producir.\nPara observar con más detalle cómo funciona la ejecución y suspensión en los generadores, vamos a implementar una función que mantiene el estado de una variable numérica e imprime un mensaje justo antes de cada yield.\n\ndef generador(x):\n    print(\"Recibí el valor\", x)\n\n    x = x + 18\n    print(\"Entrego el valor\", x)\n    yield x\n\n    x = x - 5\n    print(\"Esto una entrega siguiente, devuelvo el valor\", x)\n    yield x\n\n    print(\"Este mensaje está bien al final\")\n\ng = generador(7)\n\nComo se puede observar, la ejecución de la función generadora no imprimió ningún mensaje, ya que esto no ejecuta el cuerpo de la función. Recién al pedir el primer valor se ejecutan los dos print previos al primer yield. Además, el valor inicial 7 se incrementa en 18 y luego es devuelto.\n\nnext(g)\n\nRecibí el valor 7\nEntrego el valor 25\n\n\n25\n\n\nEn la segunda llamada a next(g) se imprime un mensaje y se entrega el valor 25 - 5 = 20. Esto muestra que el generador conserva el estado de las variables: en lugar de usar el valor original de x, utiliza el valor actualizado en la entrega anterior.\n\nnext(g)\n\nEsto una entrega siguiente, devuelvo el valor 20\n\n\n20\n\n\nSin embargo, el print al final, debajo del último yield, aún no se ejecutó. Para eso, usamos next(g) nuevamente.\nnext(g)\n\nEste mensaje está bien al final\n\n    next(g)\n    ~~~~^^^\nStopIteration\n\nComo no hay ningún otro valor por entregar, se imprime el mensaje y luego se obtiene la excepción StopIteration.\n\nEjemplo 1: Secuencia de números naturales\nLos generadores también permiten crear secuencias infinitas. Para ello, basta con escribir un bucle infinito dentro de la función generadora. Esto no representa un problema, ya que el generador produce un valor a la vez, únicamente cuando se le solicita.\n\ndef numeros_naturales():\n    n = 0\n    while True:\n        yield n\n        n = n + 1\n\nsecuencia = numeros_naturales()\n\nLuego, pedimos los valores de a uno:\n\nprint(next(secuencia))\nprint(next(secuencia))\nprint(next(secuencia))\nprint(next(secuencia))\nprint(next(secuencia))\n\n0\n1\n2\n3\n4\n\n\nVale la pena notar que un generador no tiene longitud, ya que podría ser infinito, ni permite acceder a sus elementos por índice. Solo sabe cómo producir el próximo valor, sin conocer de antemano cuántos quedan por generar.\nlen(secuencia)\n\n    len(secuencia)\n    ~~~^^^^^^^^^^\nTypeError: object of type 'generator' has no len()\n\nsecuencia[0]\n\n    secuencia[0]\n    ~~~~~~~~~^^^\nTypeError: 'generator' object is not subscriptable\n\nComo los generadores son iteradores, podemos recorrerlos con un bucle for. En el caso de secuencias infinitas, es necesario usar un break para evitar que el bucle nunca termine.\n\ni = 0\nfor n in secuencia:\n    print(n)\n    i += 1\n    if i &gt;= 5:\n        break\n\n5\n6\n7\n8\n9\n\n\nSi nuestro único objetivo es recorrer los elementos del generador, podemos inicializarlo directamente en el bucle for.\n\nfor n in numeros_naturales():\n    print(n)\n    if n &gt;= 7:\n        break\n\n0\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\nEjemplo 2: Secuencia de Fibonacci\nLas secuencias infinitas no se limitan a los números naturales. Como los generadores conservan el estado de las variables dentro de la función, también pueden usarse para producir otras secuencias, como la de Fibonacci.\n\\[\nF_n =\n\\begin{cases}\n0 & \\text{si } n = 0 \\\\\n1 & \\text{si } n = 1 \\\\\nF_{n-1} + F_{n - 2} & \\text{si } n \\ge 2 \\\\\n\\end{cases}\n\\]\n\ndef fibonacci():\n    a = 0\n    b = 1\n    while True:\n        yield a\n        a, b = b, a + b\n\nSi queremos los primeros 10 números de la secuencia, podemos utilizar un bucle for que ejecuta next(g) 10 veces seguidas.\n\ng = fibonacci()\nfor _ in range(10):\n    print(next(g))\n\n0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n\n\nAl volver a pedir un nuevo valor a nuestro generador, este continúa avanzando en la secuencia de Fibonacci.\n\nnext(g)\n\n55\n\n\n\nnext(g)\n\n89\n\n\n\n\nEjemplo 3: Promedio acumulado\nEn este ejemplo se muestra un generador que procesa una secuencia numérica y va devolviendo el promedio acumulado a medida que avanza.\nComo los valores se producen bajo demanda, en memoria solo se conserva la secuencia original y el último promedio calculado.\n\ndef promedio_acumulado(numeros):\n    numerador = 0\n    for i, numero in enumerate(numeros):\n        numerador += numero\n        yield numerador / (i + 1)\n\nvalores = [2, 4, 9, 1, 7, 11] # Supongamos una lista muy grande de números\n\nfor m in promedio_acumulado(valores):\n    print(f\"Promedio acumulado: {m:.2f}\")\n\nPromedio acumulado: 2.00\nPromedio acumulado: 3.00\nPromedio acumulado: 5.00\nPromedio acumulado: 4.00\nPromedio acumulado: 4.60\nPromedio acumulado: 5.67",
    "crumbs": [
      "Teoría",
      "U2 - Programación Funcional",
      "5 - Generadores 🧩"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/05_generadores.html#expresiones-generadoras",
    "href": "teoria/02_programacion_funcional/05_generadores.html#expresiones-generadoras",
    "title": "5 - Generadores 🧩",
    "section": "Expresiones generadoras",
    "text": "Expresiones generadoras\nLas expresiones generadoras, del inglés generator expressions, proveen una manera concisa para construir generadores. Se parecen a las list comprehensions, pero usan paréntesis en vez de corchetes.\nSupongamos una lista de números cualquiera y que usamos una list comprehension para obtener el triple de cada número.\n\nnumeros = [3, 14, 2, 7, 1, 28]\ntriples = [n * 3 for n in numeros]\n\nprint(numeros)\nprint(triples)\n\n[3, 14, 2, 7, 1, 28]\n[9, 42, 6, 21, 3, 84]\n\n\nLa expresión generadora equivalente es la siguiente:\n\ntriples = (n * 3 for n in numeros)\ntriples\n\n&lt;generator object &lt;genexpr&gt; at 0x7f90c87702b0&gt;\n\n\nComo todo generador, implementa la estrategia de evaluación perezosa. Esto quiere decir que el triple de cada número se calcula justo en el momento en que se solicita, no antes.\nAsí, podemos obtener los valores mediante un bucle:\n\nfor n in triples:\n    print(n)\n\n9\n42\n6\n21\n3\n84\n\n\nUn generador creado con una expresión generadora es equivalente a uno definido con una función generadora. En ambos casos, si se intenta obtener un valor de un generador ya agotado, se producirá un error.\nnext(triples)\n\n    next(triples)\n    ~~~~^^^^^^^^^\nStopIteration\n\nY al intentar obtener una lista a partir de un generador agotado, obtendremos una lista vacía.\n\nlist(triples)\n\n[]\n\n\nAdemás de ser perezosos, los generadores son de único uso. Sus valores se generan a medida que se solicitan y no se guardan en memoria, de modo que, una vez consumidos, no es posible volver a iterarlos.\nEsta aparente limitación es en realidad una ventaja. A diferencia de una lista, que construye y guarda todos sus elementos en memoria, un generador solo define una receta para producirlos cuando se necesiten. En el siguiente ejemplo se muestra cómo esto impacta en el consumo de memoria frente a una lista.\n\nimport sys\n\n# Enteros divisibles por 3 o 5 entre 1 y 10,000,000\nlista = [n for n in range(1, 10_000_001) if n % 3 == 0 or n % 5 == 0]\ngenexpr = (n for n in range(1, 10_000_001) if n % 3 == 0 or n % 5 == 0)\n\nprint(sys.getsizeof(lista))   # bytes\nprint(sys.getsizeof(genexpr)) # bytes\n\n39064728\n200\n\n\nY a partir de ambos objetos se puede computar, por ejemplo, la suma.\n\nsum(lista), sum(genexpr)\n\n(23333341666668, 23333341666668)\n\n\nEn resumen, mientras que una lista es una colección de valores, un generador es una receta para producir valores.",
    "crumbs": [
      "Teoría",
      "U2 - Programación Funcional",
      "5 - Generadores 🧩"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/05_generadores.html#sec-iteradores",
    "href": "teoria/02_programacion_funcional/05_generadores.html#sec-iteradores",
    "title": "5 - Generadores 🧩",
    "section": "Iterables e iteradores",
    "text": "Iterables e iteradores\nA lo largo de este capítulo dijimos varias veces que los generadores son iteradores, aunque todavía no definimos con precisión qué significa eso.\nLo que sí sabemos es que un objeto es iterable cuando puede recorrerse con un bucle for. En Python, las listas, las cadenas y los diccionarios son ejemplos de objetos iterables, por lo que los siguientes bloques de código funcionan sin problemas:\nfor i in [10, 55, 2]:\n    print(i + 5)\n\nfor c in \"palabras\":\n    print(c.upper())\n\nfor k in {\"nombre\": \"Juan\", \"apellido\": \"Pérez\"}:\n    print(k)\nComo ya vimos que una lista se puede recorrer con un bucle, podríamos preguntarnos si también es posible usar la función next para obtener su siguiente elemento.\n\nnums = [-10, 0, 10]\n\nnext(nums)\n\n    next(nums)\n    ~~~~^^^^^^\nTypeError: 'list' object is not an iterator\n\nSin embargo, al hacerlo obtenemos un TypeError que indica que la lista no es un iterador. Lo mismo ocurre si intentamos usar next directamente con una cadena o un diccionario.\nnext(\"palabra\")\n\n    next(\"palabra\")\n    ~~~~^^^^^^^^^^^\nTypeError: 'str' object is not an iterator\n\nnext({\"nombre\": \"Juan\", \"apellido\": \"Pérez\"})\n\n    next({\"nombre\": \"Juan\", \"apellido\": \"Pérez\"})\n    ~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: 'dict' object is not an iterator\n\nEl error que aparece al usar next sobre una lista, una cadena o un diccionario muestra que no basta con que un objeto sea iterable para poder aplicarle next directamente.\nLo que sucede, es que, en realidad, nuestra definición inicial de iterable era incompleta: un objeto es iterable cuando puede generar un iterador a partir de él.\nLuego, es el iterador que conoce cómo producir los valores uno a uno y, por eso, es sobre el iterador (y no sobre el iterable) que Python puede aplicar next para avanzar en la secuencia.\nPara crear un iterador a partir de un iterable usamos iter.\n\niterador = iter(nums)\niterador\n\n&lt;list_iterator at 0x7f90c87337f0&gt;\n\n\nY ahora sí es posible avanzar a través de los elementos de la lista original:\n\nnext(iterador)\n\n-10\n\n\n\nnext(iterador)\n\n0\n\n\n\nnext(iterador)\n\n10\n\n\nnext(iterador)\n\n    next(iterador)\n    ~~~~^^^^^^^^^^\nStopIteration\n\nPor último, vale la pena señalar que los iteradores solo pueden construirse a partir de objetos iterables. Por ejemplo, un número entero no es iterable, por lo que no es posible obtener un iterador a partir de él.\niter(10)\n\n    iter(10)\n    ~~~~^^^^\nTypeError: 'int' object is not iterable\n\nEn resumen, en Python solo se puede iterar sobre iteradores. Un objeto es iterable cuando puede generar un iterador a partir de él, y es este último el que sabe cómo devolver los elementos uno a uno mediante la función next. Cuando ya no quedan más valores por producir, el iterador eleva la excepción StopIteration.\nLos generadores son un caso particular de iteradores: producen sus valores bajo demanda y mantienen el estado entre llamadas.\nFinalmente, al usar un bucle for con un iterable, todo este mecanismo ocurre de forma automática: Python crea el iterador por nosotros y se encarga de avanzar en la secuencia hasta agotarla.",
    "crumbs": [
      "Teoría",
      "U2 - Programación Funcional",
      "5 - Generadores 🧩"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html",
    "href": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html",
    "title": "4 - Estrategias de evaluación 🧩",
    "section": "",
    "text": "En este breve capítulo vamos a explorar las diferentes estrategias de evaluación que utiliza Python. En programación, una estrategia de evaluación es el conjunto de reglas que define cómo y cuándo se calculan las expresiones.\nAnalizaremos la evaluación inmediata (eager) y la evaluación perezosa (lazy), así como la diferencia entre evaluación estricta y no estricta.",
    "crumbs": [
      "Teoría",
      "U2 - Programación Funcional",
      "4 - Estrategias de evaluación 🧩"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#introducción",
    "href": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#introducción",
    "title": "4 - Estrategias de evaluación 🧩",
    "section": "",
    "text": "En este breve capítulo vamos a explorar las diferentes estrategias de evaluación que utiliza Python. En programación, una estrategia de evaluación es el conjunto de reglas que define cómo y cuándo se calculan las expresiones.\nAnalizaremos la evaluación inmediata (eager) y la evaluación perezosa (lazy), así como la diferencia entre evaluación estricta y no estricta.",
    "crumbs": [
      "Teoría",
      "U2 - Programación Funcional",
      "4 - Estrategias de evaluación 🧩"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluación-estricta",
    "href": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluación-estricta",
    "title": "4 - Estrategias de evaluación 🧩",
    "section": "Evaluación estricta",
    "text": "Evaluación estricta\nSupongamos una función a la que le pasamos dos números a y b y nos devuelve una lista con todos los enteros entre a y b.\n\ndef intervalo(a, b):\n    return list(range(a, b + 1))\n\nintervalo(5, 12)\n\n[5, 6, 7, 8, 9, 10, 11, 12]\n\n\nPara cumplir su objetivo, esta función solo necesita los valores a y b. Pero, ¿qué pasaría si por error le agregamos otro parámetro y después la llamamos sin darle ningún valor para ese parámetro?\n\ndef intervalo(a, b, c):\n    return list(range(a, b + 1))\n\nintervalo(5, 12)\n\n    intervalo(5, 12)\n    ~~~~~~~~~^^^^^^^\nTypeError: intervalo() missing 1 required positional argument: 'c'\n\nPython devuelve un error indicando que la función intervalo no puede ejecutarse porque falta un valor para el parámetro c. Aunque sepamos que dicho parámetro no se utiliza dentro de la función, Python igualmente exige que se le pase un valor.\nEsta exigencia se debe a que las funciones de Python se evalúan bajo las reglas de la evaluación estricta. Bajo este enfoque, una función no puede producir un resultado si alguno de sus parámetros no está definido. Por eso, aun cuando el valor de c nunca se use en el cuerpo de la función, la ausencia de un valor para él provoca un error.\nPara que la función se ejecute correctamente, basta con pasarle cualquier valor:\n\nintervalo(5, 12, None)\n\n[5, 6, 7, 8, 9, 10, 11, 12]\n\n\nEn Python, todas las llamadas a funciones siguen la estrategia de evaluación estricta, y esto no es algo que podamos modificar: forma parte del diseño del lenguaje. De todas formas, como veremos más adelante, existen ciertas construcciones del propio lenguaje que aplican una estrategia de evaluación no estricta.",
    "crumbs": [
      "Teoría",
      "U2 - Programación Funcional",
      "4 - Estrategias de evaluación 🧩"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluación-inmediata",
    "href": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluación-inmediata",
    "title": "4 - Estrategias de evaluación 🧩",
    "section": "Evaluación inmediata",
    "text": "Evaluación inmediata\nOtro aspecto interesante al trabajar con funciones es el momento en que se evalúan los argumentos que se pasan en las llamadas.\nTomemos de nuevo nuestra función original:\ndef intervalo(a, b):\n    return list(range(a, b + 1))\ny la siguiente llamada:\nintervalo(1 + 3, 5 + 12)\nLa pregunta es: ¿qué pasa primero? ¿Se ejecuta la función intervalo y recién ahí se resuelven las expresiones 1 + 3 y 5 + 12, o esas expresiones se calculan antes y luego se pasan sus resultados a la función?\nPara aclarar esta duda, en lugar de usar una suma directa podemos probar con una función que sume pero que, además, imprima los argumentos que recibe. Del mismo modo, podemos modificar la función intervalo para que muestre un mensaje cuando sea llamada y así ver con más claridad el orden en que ocurren las cosas.\n\ndef suma(x, y):\n    print(f\"suma(x={x}, y={y})\")\n    return x + y\n\n\ndef intervalo(a, b):\n    print(f\"intervalo(a={a}, b={b})\")\n    return list(range(a, b + 1))\n\nintervalo(suma(1, 3), suma(5, 12))\n\nsuma(x=1, y=3)\nsuma(x=5, y=12)\nintervalo(a=4, b=17)\n\n\n[4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]\n\n\nPor el orden en que aparecen los mensajes impresos, vemos que Python primero ejecutó la llamada suma(1, 3), luego suma(5, 12) y recién después invocó a la función intervalo, ya recibiendo los valores resultantes de las llamadas a suma.\nEn otras palabras, antes de llamar a intervalo, Python evaluó las expresiones que se pasaron como argumentos.\nA esta estrategia de evaluación, donde los argumentos se resuelven antes de ejecutar la función, se la conoce como evaluación inmediata, o por su nombre en inglés, eager evaluation.",
    "crumbs": [
      "Teoría",
      "U2 - Programación Funcional",
      "4 - Estrategias de evaluación 🧩"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluación-no-estricta",
    "href": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluación-no-estricta",
    "title": "4 - Estrategias de evaluación 🧩",
    "section": "Evaluación no estricta",
    "text": "Evaluación no estricta\nEn contraste con la evaluación estricta, la evaluación no estricta es una estrategia en la que se puede determinar el resultado de una expresión sin necesidad de evaluar todos sus argumentos u operandos.\nEn Python, solo tres tipos de expresiones siguen esta estrategia: and, or y las expresiones condicionales.\nEn los siguientes ejemplos, vamos a utilizar una función que imprime el valor ingresado y lo devuelve:\n\ndef f(x):\n    print(f\"el valor es {x}\")\n    return x\n\n\nExpresión and\nUna expresión and devuelve True únicamente cuando todos sus argumentos son verdaderos. Por eso, en el siguiente ejemplo, se imprime el valor es True antes de obtener el resultado de la operación and, ya que fue necesario evaluar la función f.\n\nTrue and f(True)\n\nel valor es True\n\n\nTrue\n\n\nEn cambio, cuando el primero de sus argumentos es False, se puede anticipar que el resultado de la operación and será False, sin necesidad de evaluar el segundo argumento. Por este motivo, la función f no se ejecuta en ninguno de los siguientes casos, al punto de que podemos pasarle argumentos absurdos:\n\nFalse and f(True)\n\nFalse\n\n\n\nFalse and f(1 / 0)\n\nFalse\n\n\nEn Python, este mecanismo también se conoce como cortocircuito. Al detectar que el resultado de la operación ya está decidido con el primer argumento, el intérprete “corta camino” y decide no evaluar al resto.\n\n\nExpresión or\nEl mecanismo de cortocircuito también funciona para el operador or:\n\n# El primer argumento es True, el resultado es True\nTrue or f(True)\n\nTrue\n\n\n\n# El primer arugmento es False, hay que evaluar el segundo para determinar el resultado\nFalse or f(True)\n\nel valor es True\n\n\nTrue\n\n\nLas mismas reglas de evaluación se mantienen en expresiones más complejas. En el siguiente ejemplo, es necesario ejecutar f(True) para poder resolver el primer or, pero no hace falta evaluar 1 + [2, 3], que provocaría un error, porque el valor True ya alcanza para determinar el resultado de toda la operación.\n\nFalse or f(True) or (1 + [2, 3])\n\nel valor es True\n\n\nTrue\n\n\n\n\nExpresiones condicionales\nFinalmente, esta estrategia de evaluación no estricta (o cortocircuito) también se aplica en las expresiones condicionales.\nEn el siguiente ejemplo, la expresión devuelve 10 porque la condición es verdadera, sin necesidad de ejecutar f(20).\n\n10 if True else f(20)\n\n10\n\n\nEn cambio, esta segunda expresión sí requiere que se ejecute la llamada en la parte else de la expresión.\n\n10 if False else f(20)\n\nel valor es 20\n\n\n20",
    "crumbs": [
      "Teoría",
      "U2 - Programación Funcional",
      "4 - Estrategias de evaluación 🧩"
    ]
  },
  {
    "objectID": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluación-perezosa",
    "href": "teoria/02_programacion_funcional/04_estrategias_de_evaluacion.html#evaluación-perezosa",
    "title": "4 - Estrategias de evaluación 🧩",
    "section": "Evaluación perezosa",
    "text": "Evaluación perezosa\nPara terminar, veamos una última estrategia de evaluación: la evaluación perezosa (en inglés, lazy evaluation).\nPartimos de una función que recibe un valor, imprime un mensaje con él y lo devuelve:\ndef identidad(x):\n    print(\"Devuelvo\", x)\n    return x\nSi usamos map para aplicar la función identidad a los números 0, 1, 2 y 3:\nmap_obj = map(identidad, range(4))\nmap_obj\n&lt;map at 0x7fedb41f3cd0&gt;\nvemos que se crea un objeto map, pero no aparece ningún mensaje de la función identidad. Esto pasa porque map no ejecuta la función sobre los elementos hasta que realmente hace falta.\nPor ejemplo, si convertimos el objeto map en una lista, recién ahí se produce la evaluación:\nlista = list(map_obj)\nDevuelvo 0\nDevuelvo 1\nDevuelvo 2\nDevuelvo 3\nlista\n[0, 1, 2, 3]\nA esta estrategia, en la que se retrasa la evaluación de las expresiones hasta el último momento posible, se la llama evaluación perezosa o lazy evaluation.\nDe manera similar, filter también utiliza una estrategia de evaluación perezosa. Recién cuando queremos materializar los elementos se aplica la función de filtro.\n\ndef es_multiplo_5(x):\n    print(f\"x={x}\")\n    return x % 5  ==0\n\nfilter_obj = filter(es_multiplo_5, [12, 10, 8, 5, 125, 55, 11, 9])\n\n\nfor x in filter_obj:\n    print(f\"El numero {x} es múltiplo de 5\")\n\nx=12\nx=10\nEl numero 10 es múltiplo de 5\nx=8\nx=5\nEl numero 5 es múltiplo de 5\nx=125\nEl numero 125 es múltiplo de 5\nx=55\nEl numero 55 es múltiplo de 5\nx=11\nx=9\n\n\nComo se puede ver, la función es_multiplo_5 se ejecutó para cada valor de la lista numérica, pero filter únicamente devolvió aquellos que efectivamente son múltiplos de 5.\nEn el próximo y último capítulo vamos a explorar los generadores, un tipo especial de iterador que implementa una estrategia de evaluación perezosa y nos permite recorrer secuencias incluso potencialmente infinitas.",
    "crumbs": [
      "Teoría",
      "U2 - Programación Funcional",
      "4 - Estrategias de evaluación 🧩"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/01_por_que_importan.html",
    "href": "teoria/04_estructuras_y_algoritmos/01_por_que_importan.html",
    "title": "1 - ¿Por qué importan?",
    "section": "",
    "text": "En esta última unidad nos ocuparemos de Estructuras de Datos y Algoritmos.\nPuede que estos términos suenen un tanto abstractos, pero como veremos a lo largo de estos apuntes, dominarlos nos ayudará a escribir código más eficiente, que corre más rápido y consume menos memoria.\nEn pocas palabras, podemos decir que una estructura datos es una forma sistemática de organizar y acceder a datos, mientras que un algoritmo es un procedimiento paso a paso para realizar una tarea en tiempo finito.\n\n\nA lo largo de este curso hemos ido adquiriendo experiencia en la programación con Python y probablemente hayamos empezado a desarrollar un instinto u olfato que nos permite juzgar la calidad de un programa. Al enfrentarnos con dos programas que realizan la misma tarea, podemos determinar si uno es mejor que otro.\nNo hay un único aspecto que determina la calidad de un programa. Uno de ellos, por ejemplo, es la mantenibilidad. Una base de código legible, organizada y modular es más fácil de manetener que otra poco legible, desorganizada y monolítica.\nLa eficiencia es otro aspecto que determina la calidad de un programa. Por ejemplo, podemos contar con dos funciones que resuelven el mismo problema, pero una de ellas es más rápida que la otra.\nLas dos funciones debajo resuelven exactamente el mismo problema: imprimir los números pares entre 2 y 100.\ndef imprimir_numeros_1():\n    numero = 2\n    while numero &lt;= 100:\n        if numero % 2 == 0:\n            print(numero)\n            numero += 1\n\ndef imprimir_numeros_2():\n    numero = 2\n    while numero &lt;= 100:\n        print(numero)\n        numero += 2\nSin embargo, cabe preguntarse: ¿cuál de las dos funciones se ejecuta más rápido?\nLa respuesta correcta es la segunda. La primera función realiza 100 iteraciones, mientras que la segunda solo realiza 50. Por lo tanto, la primera función requiere el doble de pasos que la segunda para resolver el mismo problema.",
    "crumbs": [
      "Teoría",
      "U4 - Estructuras de Datos y Algoritmos",
      "1 - ¿Por qué importan?"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/01_por_que_importan.html#introducción",
    "href": "teoria/04_estructuras_y_algoritmos/01_por_que_importan.html#introducción",
    "title": "1 - ¿Por qué importan?",
    "section": "",
    "text": "En esta última unidad nos ocuparemos de Estructuras de Datos y Algoritmos.\nPuede que estos términos suenen un tanto abstractos, pero como veremos a lo largo de estos apuntes, dominarlos nos ayudará a escribir código más eficiente, que corre más rápido y consume menos memoria.\nEn pocas palabras, podemos decir que una estructura datos es una forma sistemática de organizar y acceder a datos, mientras que un algoritmo es un procedimiento paso a paso para realizar una tarea en tiempo finito.\n\n\nA lo largo de este curso hemos ido adquiriendo experiencia en la programación con Python y probablemente hayamos empezado a desarrollar un instinto u olfato que nos permite juzgar la calidad de un programa. Al enfrentarnos con dos programas que realizan la misma tarea, podemos determinar si uno es mejor que otro.\nNo hay un único aspecto que determina la calidad de un programa. Uno de ellos, por ejemplo, es la mantenibilidad. Una base de código legible, organizada y modular es más fácil de manetener que otra poco legible, desorganizada y monolítica.\nLa eficiencia es otro aspecto que determina la calidad de un programa. Por ejemplo, podemos contar con dos funciones que resuelven el mismo problema, pero una de ellas es más rápida que la otra.\nLas dos funciones debajo resuelven exactamente el mismo problema: imprimir los números pares entre 2 y 100.\ndef imprimir_numeros_1():\n    numero = 2\n    while numero &lt;= 100:\n        if numero % 2 == 0:\n            print(numero)\n            numero += 1\n\ndef imprimir_numeros_2():\n    numero = 2\n    while numero &lt;= 100:\n        print(numero)\n        numero += 2\nSin embargo, cabe preguntarse: ¿cuál de las dos funciones se ejecuta más rápido?\nLa respuesta correcta es la segunda. La primera función realiza 100 iteraciones, mientras que la segunda solo realiza 50. Por lo tanto, la primera función requiere el doble de pasos que la segunda para resolver el mismo problema.",
    "crumbs": [
      "Teoría",
      "U4 - Estructuras de Datos y Algoritmos",
      "1 - ¿Por qué importan?"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/01_por_que_importan.html#estructuras-de-datos",
    "href": "teoria/04_estructuras_y_algoritmos/01_por_que_importan.html#estructuras-de-datos",
    "title": "1 - ¿Por qué importan?",
    "section": "Estructuras de datos",
    "text": "Estructuras de datos\nLa palabra datos es sencilla y amplia a la vez. Puede referirse tanto a valores elementales, como el número 1, como a estructuras más complejas, por ejemplo, los datos contenidos en un diccionario anidado.\nCuando realizamos una operación como 3 + 5, los valores 3 y 5 son los datos con los que trabajamos. En particular, las estructuras de datos se refieren al cómo se organizan los datos.\nObservemos el siguiente bloque de código:\n\nx = \"¡Hola! \"\ny = \"¿Cómo estás? \"\nz = \"¿Todo bien?\"\n\nprint(x + y + z)\n\n¡Hola! ¿Cómo estás? ¿Todo bien?\n\n\nEn este programa sencillo se cuenta con tres datos, todos ellos cadenas de texto, que al combinarse forman un mensaje coherente.\nSi tuvieramos que describir la organización de los datos en este bloque de código, diríamos que se tienen tres cadenas de texto independientes, cada una representada por una variable distina.\nPero esta no es la única forma de organizar estos datos. Otra alternativa consiste en agrupar las cadenas de texto en un arreglo, del inglés array, que en Python se implementa mediante listas.\n\narreglo = [\"¡Hola! \", \"¿Cómo estás? \", \"¿Todo bien?\"]\n\nprint(arreglo[0] + arreglo[1] + arreglo[2])\n\n¡Hola! ¿Cómo estás? ¿Todo bien?\n\n\nEl resultado de ambos bloques es el mismo: se obtiene un único mensaje como resultado de concatenar todas las cadenas de texto, formando un mensaje coherente.\nAhora, si nos preguntamos cuál de los dos programas es mejor, no existe una única respuesta correcta, ya que dependerá del criterio en base al cuál es comparan los bloques de código.\nEl objetivo este ejemplo es mostrar que no existe una única forma de organizar los datos de un programa. Más adelante veremos que la forma en que los organizamos no solo afecta cómo se ve un programa, sino también su velocidad de ejecución. Dependiendo de cómo decidamos representar los datos, un programa puede llegar a ser varias órdenes de magnitud más rápido o más lento que otro.\nPero antes de correr, hay que aprender a caminar. Empecemos por una estructura de datos con la que estamos más que familiarizados: los arreglos.\n\nArreglos\nEl arreglo es una de las estructuras de datos más básicas en la computación. En Python, la estructura built-in que representa al arreglo es la lista, con la que ya hemos trabajado extensamente. Gracias a ello, aprendimos que el arreglo es una estructura de datos muy versátil, que nos puede ayudar en una gran variedad de situaciones.\nSi tuvieramos que describir al arreglo en pocas palabras, diríamos que es una colección de datos en un orden determinado.\nPara lo que sigue, consideremos al siguiente arreglo que contiene diferentes tipos de frutos secos:\n\narray = [\"nueces\", \"almendras\", \"pistachos\", \"maníes\", \"castañas\"]\n\nRápidamente, podríamos decir que trabajamos con arreglo que contiene 5 cadenas de texto, y que cada una representando un fruto seco distinto.\nPero los arreglos, al igual que otras estructuras de datos, cargan con vocabulario técnico propio para describirlos:\n\nEl tamaño (size) del arreglo indica cuántos elementos contiene. En nuestro ejemplo, array es un arreglo de tamaño 5.\nEl índice (index) es el número que identifica la posición de cada elemento dentro de él.\n\nComo en Python el índice comienza en 0, decimos que \"nueces\" está en el índice 0, \"almendras\" en el índice 1 y que \"castañas\" está en el índice 4.\n\n\n\n\n\n\n¿Qué tan buena es una estructura de datos?\nUna forma de determinar que tan buena es una estructura de datos es midiendo su desempeño para realizar diferentes operaciones. Para ello, se suelen considerar cuatro operaciones básicas que se utilizan para interactuar con la estructura:\n\nLectura (read): acceder a un valor en una posición específica dentro de la estructura. En un arreglo, significa obtener el elemento que se encuentra en un índice determinado.\nBúsqueda (search): verificar si un valor existe dentro de la estructura y, de ser así, obtener en qué posición se encuentra.\nInserción (insert): agregar un nuevo valor a la estructura. En un arreglo, sería añadir un elemento en una posición determinada.\nEliminación (delete): quitar un valor existente de la estructura.\n\nEn las próximas secciones analizaremos la eficiencia de cada una de estas operaciones cuando se aplican a un arreglo.\n\n\n\n\n\n\nViejos conocidos\n\n\n\nYa sabemos como realizar operaciones de lectura, búsqueda, inserción y eliminación con listas de Python. De hecho, para cada una de ellas disponemos de un método específico:\n# Lectura\narray[indice]\n\n# Búsqueda\narray.index(valor)\n\n# Inserción\narray.insert(valor, indice)\n\n# Eliminación\narray.pop(indice) # Por índice\narray.remove(valor) # Por valor\nSin embargo, el propósito de esta unidad es comprender cómo funcionan internamente estas operaciones, para así entender las fortalezas y limitaciones de cada estructura de datos.\n\n\n\n\n¿Cómo se mide la velocidad de una operación?\nCuando hablamos de qué tan “rápida” es una operación no nos referimos al tiempo en segundos, sino a la cantidad de pasos que requiere.\nEsto se debe a que el tiempo real depende del hardware donde se ejecuta la operación. Un mismo programa puede tardar más en una computadora antigua y menos en una moderna. En cambio, contar los pasos nos permite comparar operaciones independientemente del equipo donde se ejecuten.\nPor ejemplo, si una operación A necesita 5 pasos y otra B requiere 500, podemos afirmar que A es una operación más rápida que B.\nA este análisis se lo conoce como medida de la complejidad temporal (time complexity) de una operación.\nA continuación, veremos cuántos pasos requiere cada una de las cuatro operaciones básicas de un arreglo.\n\n\nLectura\nLa primera operación que analizaremos es la lectura, que consiste en acceder al valor almacenado en una posición específica del arreglo. En Python, esto se realiza simplemente con el índice:\narray[indice]\nPor ejemplo:\narray = [30, 10, 15, 25, 85]\narray[4]  # Devuelve 85\nGracias al diseño de la memoria RAM (Random Access Memory), que permite acceder directamente a cualquier posición sin recorrer otras, la computadora puede leer un elemento de un arreglo en un solo paso.\nPor ejemplo, en el arreglo [\"nueces\", \"almendras\", \"pistachos\", \"maníes\", \"castañas\"], si pedimos el valor en el índice 2, el procesador accede de inmediato a la posición correspondiente y devuelve \"pistachos\".\n\n¿Por qué esto es posible?\nPodemos imaginar la memoria como una gran colección de celdas numeradas (algunas vacías, otras con datos).\n\n\n\n\n\nCada celda tiene una dirección única.\n\n\n\n\n\nY cuando declaramos un arreglo, la computadora reserva un bloque contiguo de celdas para almacenarlo.\n\n\n\n\n\nAsí, si el arreglo ocupa cinco posiciones, el sistema asigna cinco direcciones consecutivas.\n\n\n\n\n\nLuego, el procesador puede calcular la posición exacta del elemento i mediante una operación aritmética simple:\ndirección_base + i * tamaño_del_elemento\nEsto explica el nombre memoria de acceso aleatorio: cualquier celda puede leerse o modificarse en el mismo tiempo, sin importar su posición, a diferencia de medios secuenciales (como los discos duros), donde hay que desplazarse físicamente hasta el dato.\nEn el siguiente diagrama se muestra nuestro arreglo de frutos secos junto con sus índices y direcciones de memoria:\nCada índice indica la posición lógica del elemento dentro del arreglo, mientras que cada dirección representa la ubicación física de ese dato en la memoria RAM.\n\n\n\n\n\nPor ejemplo, si queremos leer el valor en el índice 3, la computadora toma la dirección inicial (índice 0) y le suma 3, ya que las direcciones de memoria son consecutivas.\nAplicado a nuestro arreglo de frutos secos, que comienza en la dirección 1010:\n\nEl índice 0 está en la dirección 1010.\nEl índice 3 está tres posiciones después.\nPor lo tanto, su dirección es 1013 (1010 + 3).\n\nAsí, la computadora puede saltar directamente a la dirección 1013 y ver que allí se encuentra el valor \"maníes\".\nLeer desde un arreglo es, por tanto, una operación muy eficiente, porque permite acceder a cualquier elemento en un solo paso.\nAhora bien, ¿qué ocurre si en lugar de preguntar “qué valor hay en el índice 3” queremos saber “en qué índice se encuentra ‘pistachos’”?\nEsa es la operación de búsqueda, y será la próxima que analizaremos.\n\n\n\nBúsqueda\nBuscar en un arreglo consiste en comprobar si un valor existe y, de ser así, obtener en qué índice se encuentra.\nA la búsqueda se la puede pensar como la operación inversa a la lectura. Mientras que leer implica dar un índice y obtener un valor, buscar implica dar un valor y obtener su índice.\nAunque parezcan operaciones similares, su eficiencia difiere muchísimo.\nLa lectura es rápida porque la computadora puede saltar directo a cualquier dirección de la memoria. En cambio, la búsqueda es más lenta, ya que la computadora no puede saltar a un valor específico, sino que debe revisar las celdas una por una hasta encontrarlo.\nSi retomamos nuestro arreglo de frutos secos, la computadora no “ve” los nombres de los elementos, solo una secuencia de celdas con direcciones. Al comenzar la búsqueda, para la computadora, el arreglo podría verse de la siguiente manera.\n\n\n\n\n\nPor lo tanto, para buscar un valor dentro del arreglo, la computadora no tiene otra opción que inspeccionar cada celda de la memoria, una por una.\nEn los diagramas siguientes se muestra el proceso que seguiría para buscar \"pistachos\" en nuestro arreglo.\nPrimero, la computadora revisa el índice 0:\n\n\n\n\n\nComo el valor en el índice 0 es “nueces” y no “pistachos”, la computadora avanza al siguiente índice, tal como se muestra a continuación.\n\n\n\n\n\nHasta que al fin encontramos los tan buscados \"pistachos\" y ahora sabemos que se encuentran en el índice 2.\n\n\n\n\n\nEn este punto, la computadora ya no necesita seguir revisando el resto del arreglo, porque encontró el valor que buscaba.\nEn este ejemplo, como la computadora tuvo que inspeccionar tres celdas hasta dar con el resultado, decimos que la operación tomó tres pasos en total.\nEsta forma de búsqueda, en la que la computadora revisa cada celda una por una, se llama búsqueda lineal.\nSi el valor buscado está en la última celda, o no se encuentra en absoluto, la computadora deberá recorrer todo el arreglo.\nAsí, en un arreglo de 5 elementos, la búsqueda lineal puede requerir hasta 5 pasos; en uno de 500, hasta 500. En general, para un arreglo de N elementos, el número máximo de pasos es N.\nEsto demuestra que la búsqueda es menos eficiente que la lectura: leer siempre toma un paso, mientras que buscar puede requerir muchos.\nA continuación veremos la operación de inserción.\n\n\nInserción\nLa eficiencia de insertar un nuevo dato en un arreglo depende del lugar donde se realice la inserción.\nSi queremos agregar \"pasas\" al final de nuestra lista de frutos secos, la operación toma un solo paso. Esto es posible porque la computadora conoce tanto la dirección de memoria inicial del arreglo como su tamaño.\nPor ejemplo, si el arreglo comienza en la dirección 1010 y tiene 5 elementos, el último se encuentra en 1014. Insertar uno nuevo implica simplemente ocupar la siguiente dirección, 1015 (asumiendo que no está ocupada).\nUna vez calculada esa posición, la computadora puede realizar la inserción en un único paso.\n\n\n\n\n\nHay un detalle importante: cuando la computadora reservó memoria para el arreglo, asignó solo cinco celdas. Si agregamos un sexto elemento, puede ser necesario extender el arreglo, lo cual muchos lenguajes hacen automáticamente.\nInsertar al final es simple, pero hacerlo al inicio o en el medio requiere desplazar los elementos para dejar espacio, lo que añade pasos adicionales.\nPor ejemplo, si queremos insertar \"pasas\" en el índice 2, el proceso sería así:\n\n\n\n\n\nPara hacerlo, debemos mover \"pistachos\", \"maníes\" y \"castañas\" una posición a la derecha para hacer espacio a \"pasas\".\nEsto requiere varios pasos: primero se mueve \"castañas\" una celda a la derecha, lo que libera un espacio a la derecha de \"maníes\".\n\n\n\n\n\nLuego, se mueve \"maníes\" a la derecha, dejando un espacio a la derecha de \"pistachos\".\n\n\n\n\n\nPor último, se mueve \"pistachos\" a la derecha y se genera el hueco donde se inserta el valor de \"pasas\".\n\n\n\n\n\n\n\n\n\n\nAl final, se cuenta on un arreglo de longitud 6, donde \"pasas\" ocupa el índice 2.\n\n\n\n\n\nEn este ejemplo la inserción tomó cuatro pasos: tres para mover datos y uno para agregar el nuevo valor.\nEl peor caso ocurre al insertar al inicio del arreglo, ya que hay que desplazar todos los elementos una posición a la derecha. En general, una inserción en el peor escenario requiere N + 1 pasos para un arreglo de N elementos.\nAhora pasemos a la última operación: la eliminación.\n\n\nEliminación\nEliminar un elemento de un arreglo consiste en quitar el valor ubicado en un índice determinado.\nVolviendo a nuestro ejemplo original, eliminemos el valor del índice 1, que corresponde a \"almendras\".\n\n\n\n\n\nAunque la eliminación en sí toma solo un paso, deja una celda vacía en el medio del arreglo. Como un arreglo no puede tener huecos, es necesario mover los elementos \"pistachos\", \"maníes\" y \"castañas\" una posición a la izquierda, lo que agrega pasos adicionales al proceso.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFinalmente, el arreglo se encoje y pasa de tener 5 elementos a tener 4.\n\n\n\n\n\nEn este ejemplo la eliminación toma cuatro pasos: uno para borrar el valor y tres para mover los datos y cerrar el espacio vacío.\nAl igual que con la inserción, el peor caso ocurre al eliminar el primer elemento del arreglo, ya que el índice 0 queda vacío y es necesario desplazar todos los demás elementos una posición a la izquierda.\nEn un arreglo de 5 elementos, eso implica 1 paso para eliminar y 4 para mover; en uno de 500, 1 para eliminar y 499 para desplazar. En general, para un arreglo con N elementos, la eliminación puede requerir hasta N pasos.\nCon esto concluimos el análisis de la complejidad temporal de nuestro primer tipo de estructura de datos.\nAhora que comprendemos cómo evaluar la eficiencia de las operaciones sobre un arreglo, podemos comparar este comportamiento con el de otras estructuras.\nLa siguiente que estudiaremos es el conjunto (set), que a primera vista puede parecer similar a un arreglo, pero veremos que sus operaciones se comportan de manera muy diferente en términos de eficiencia.\n\n\n\nConjuntos\nEn esta breve sección trabajaremos con otra estructura de datos: el conjunto.\nEl conjunto puede ser implementado de diferentes maneras. En Python, por ejemplo, el conjunto es una estructura donde el orden de los elementos no importa.\nPodemos también suponer un conjunto basado en arreglos. Es decir, la estructura consiste en un arreglo que no permite valores duplicados.\nEn un conjunto basado en un arreglo, las operaciones de lectura, búsqueda y eliminación funcionan igual que en los arreglos. Leer un elemento toma un solo paso y buscar o eliminar puede requerir hasta N pasos. La diferencia aparece en la inserción.\nDada la condición de que no se pueden repetir elementos en un conjunto, antes de agregar un valor, la computadora debe verificar que este no exista ya en el conjunto.\nEsta pequeña modificación implica que para cada inserción primero hay que hacer una búsqueda previa y, solo si el valor no está presente, efectuar la inserción.\nPor ejemplo, si un conjunto con nombres de alumnos contiene [\"Ana\", \"Bruno\", \"Carla\", \"Diego\", \"Elena\"] y queremos agregar \"Francisco\", la computadora primero comprobará que \"Francisco\" no esté ya inscripto antes de añadirlo.\nSe inspeccionan los elementos del conjunto uno a uno, hasta que se encuentra el elemento a insertar o se terminar de recorrer el arreglo. Las siguientes imagenes representan el proceso en nuestro ejemplo:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAhora que hemos buscado en todo el conjunto, sabemos con certeza que no contiene a \"Francisco\".\nEn este punto, podemos realizar la inserción sin problema. Y con eso llegamos al paso final:\n\n\n\n\n\nInsertar un valor al final de un conjunto es el mejor caso posible, pero aun así requiere más pasos que en un arreglo.\nEn un conjunto con N elementos, hay que buscar entre los N valores antes de insertar, lo que implica N + 1 pasos, mientras que en un arreglo basta con uno.\nEn el peor caso, al insertar al inicio, el conjunto requiere 2N + 1 pasos (N para buscar, N para mover y uno para insertar), frente a los N + 1 de un arreglo.\n\n\n\n\n\n\nContando pasos\n\n\n\nAnalizar cuántos pasos requiere una operación es clave para entender el rendimiento de una estructura de datos. Elegir la estructura correcta puede marcar la diferencia entre un programa ágil y uno ineficiente.",
    "crumbs": [
      "Teoría",
      "U4 - Estructuras de Datos y Algoritmos",
      "1 - ¿Por qué importan?"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/01_por_que_importan.html#algoritmos",
    "href": "teoria/04_estructuras_y_algoritmos/01_por_que_importan.html#algoritmos",
    "title": "1 - ¿Por qué importan?",
    "section": "Algoritmos",
    "text": "Algoritmos\nEn la sección anterior vimos cómo la elección de una estructura de datos puede afectar el rendimiento del código. Incluso dos estructuras que parecen similares, como los arreglos y los conjuntos, pueden tener eficiencias muy distintas según la operación.\nEn esta sección vamos a descubrir que, además de la estructura de datos, otro factor clave influye en la eficiencia: el algoritmo que usamos.\nAunque la palabra pueda sonar compleja, un algoritmo no es más que un conjunto de pasos definidos para realizar una tarea. Por ejemplo, preparar un mate puede describirse con estos pasos:\n\nCalentar el agua.\nColocar la yerba en el mate.\nInsertar la bombilla.\nServir el agua con cuidado.\n\nSi cambiamos el orden y, por ejemplo, echamos el agua antes de la yerba, el resultado es un mal mate o, aún peor, un enchastre total.\nEn computación, un algoritmo es el conjunto de instrucciones que le damos a la computadora para cumplir una tarea. Cada vez que escribimos código, estamos creando algoritmos que la computadora sigue al pie de la letra para obtener un resultado.\nA veces, distintos algoritmos pueden resolver el mismo problema, pero con eficiencias distintas. Ya vimos un ejemplo al imprimir números pares, donde un algoritmo requería el doble de pasos que otro. En esta sección veremos otro caso similar, en el que una solución resulta mucho más rápida que la otra, y para analizarlo presentaremos una nueva estructura de datos.\n\nArreglos ordenados\nEl arreglo ordenado es casi idéntico al arreglo clásico que vimos antes.\nLa única diferencia es que en un arreglo ordenado los valores deben mantenerse siempre en orden. Cada vez que se agrega un nuevo valor, este se coloca en la posición correcta para conservar ese orden.\nSupongamos que tenemos el arreglo [6, 21, 38, 95] y queremos insertar el valor 30. En un arreglo común podríamos agregarlo simplemente al final y tomaría un solo paso.\nCon un un arreglo ordenado no podemos insertar al final en nu solo paso, ya que podría resultar en un arreglo que no cumple el requisito de que los valores estén ordenados.\n\n\n\n\n\nEn un arreglo ordenado debemos insertar el 30 en el lugar correspondiente para que los valores sigan en orden ascendente, como se muestra debajo:\n\n\n\n\n\nEn la práctica, llevar a cabo esta inserción es más compleja que su simple enunciación. La computadora no puede “poner” el 30 en el lugar correcto en un solo paso. Primero debe encontrar dónde insertarlo y luego desplazar los demás valores para crear el espacio necesario.\nVeamos el proceso paso a paso, partiendo del arreglo ordenado original:\n\n\n\n\n\nPrimero verificamos el valor en el índice 0 para decidir si el número que queremos insertar, EL 30, debe ubicarse a su izquierda o a su derecha.\n\n\n\n\n\nComo el 30 es mayor que 6, sabemos que deberá insertarse en alguna posición a su derecha. Cómo aún no sabemos en cuál posición exactamente, debemos revisar la siguiente celda.\n\n\n\n\n\nComo el 30 también es mayor que el valor en la segunda posición, seguimos avanzando hacia la derecha.\n\n\n\n\n\nEn este punto, encontramos el valor 38, que es mayor que el 30 y, por lo tanto, sabemos que debemos insertar el 30 a su izquierda.\n\n\n\n\n\nPara hacerlo, necesitamos desplazar los datos y dejar espacio para insertar el 30.\n\n\n\n\n\nCuando insertamos en un arreglo ordenado, siempre debemos buscar primero la posición correcta antes de hacer la inserción. Esa búsqueda previa marca una diferencia importante respecto al arreglo clásico.\nEn el ejemplo, con cuatro elementos, la inserción tomó 6 pasos. En términos generales, para un arreglo con N elementos, la inserción requiere N + 2 pasos.\nEl número total de pasos varía poco según la posición del nuevo valor: si se inserta cerca del inicio, hay menos comparaciones y más desplazamientos. Si se inserta al final, hay más comparaciones y menos movimientos. El caso más rápido ocurre cuando el nuevo valor se agrega al final, ya que no hay que mover nada: se necesitan N pasos de comparación y uno de inserción, es decir, N + 1 pasos.\nAunque insertar en un arreglo ordenado es menos eficiente que en uno clásico, esta estructura tiene una gran ventaja cuando se trata de buscar valores, como veremos a continuación.\n\n\nBúsqueda en arreglos ordenados\nEn un arreglo clásico, buscar un valor implica revisar las celdas una por una, de izquierda a derecha, hasta encontrarlo o llegar al final. Este proceso se conoce como búsqueda lineal.\nPor ejemplo, si tenemos el arreglo [67, 25, 13, 6, 132] y buscamos el valor 21, debemos recorrer todos los elementos, ya que podría estar en cualquier posición. Solo podríamos detenernos temprano si encontráramos el valor 21.\nEn cambio, en un arreglo ordenado podemos detener la búsqueda antes, incluso si el valor no está presente. Si el arreglo es [6, 13, 25, 67, 132] y buscamos 21, podemos detenernos al llegar al 67, porque sabemos que ningún valor mayor a 21 aparecerá más adelante.\n\ndef busqueda_lineal(array, valor):\n    for indice, elemento in enumerate(array):\n        if elemento == valor:\n            return indice\n        elif elemento &gt; valor:\n            break\n    return None\n\nEste método recibe dos argumentos: array, que es el arreglo ordenado en el que buscamos, y valor, que es el valor que queremos encontrar. Así es como usaríamos esta función para buscar el número 21 en nuestro arreglo de ejemplo:\n\nprint(busqueda_lineal([6, 13, 25, 67, 132], 21))\n\nNone\n\n\nLa función busqueda_lineal inspecciona cada elemento del arreglo en busca del valor indicado. La búsqueda se detiene en el momento en que el elemento actual es mayor que el valor buscado, ya que sabemos que este no puede encontrarse más adelante en el arreglo.\nEn ciertos casos, la búsqueda lineal puede requerir menos pasos en un arreglo ordenado que en uno clásico. Sin embargo, si el valor buscado está al final o no se encuentra en el arreglo, igualmente habrá que revisar todas los valores.\nA simple vista, los arreglos clásicos y los ordenados no muestran grandes diferencias en eficiencia, al menos en los peores casos: en ambos, una búsqueda lineal puede requerir hasta N pasos.\nPero existe un algoritmo mucho más eficiente que invalida nuestra temprana conclusión. Aunque la búsqueda lineal es una opción para recorrer un arreglo ordenado, no es la única. La gran ventaja de los arreglos ordenados es que permiten aplicar otro tipo de búsqueda: la búsqueda binaria, un algoritmo considerablemente más rápido que la búsqueda lineal.\n\n\nBúsqueda binaria\nSeguro alguna vez jugaste a esto: alguien piensa un número entre 1 y 100, y vos tenés que adivinarlo. Después de cada intento, te dicen si el número buscado es mayor o menor.\nLa estrategia intuitiva no es empezar por el 1, sino por la mitad (por ejemplo, el 50). Así, sin importar la respuesta, se eliminan de una vez la mitad de las posibilidades.\nSi te dicen que el número es mayor, se puede probar con 75; si es menor, con 25. En cada paso, se vuelve a elegir el punto medio y se reduce el conjunto de números a la mitad.\nEse es exactamente el principio detrás de la búsqueda binaria.\nVeamos ahora cómo se aplica la búsqueda binaria sobre un arreglo ordenado.\nSupongamos que tenemos un arreglo con nueve elementos y que estamos buscando el valor 15.\nLa computadora no sabe de antemano qué valor hay en cada posición, así que podemos representarlo de esta forma:\n\n\n\n\n\nSe inspecciona el valor en la posición central:\n\n\n\n\n\nComo el valor encontrado es 11, podemos concluir que el 15 está a su derecha.\nAsí eliminamos la mitad del arreglo: todas las casillas a la izquierda del 11 (incluida la del 11).\n\n\n\n\n\nA continuación es inspecciona el centro de la mitad que puede contener al valor buscado.\n\n\n\n\n\nComo el valor hallado es mayor a 15, inspeccionamos los valores a su izquierda.\nEn este punto quedan dos valores posibles y elegimos arbitrariamente en el de la derecha:\n\n\n\n\n\nNuevamente el valor hallado es mayor a 15, por lo que inspeccionamos la última celda posible. Si el valor 15 no se encuentra allí, entonces no está en el arreglo.\n\n\n\n\n\nEsta vez, lo encontramos y podemos concluir que el 15 está en el arreglo y devolver su posición.\nCon el algoritmo de búsqueda binaria nos llevó cuatro pasos encontrar el valor de interés. Si hubieramos usado búsqueda lineal, nos hubiera llevado 6 pasos.\nEn términos generales la búsqueda binaria será mas rápida que la busqueda lineal, aunque pueden existir ejemplos donde esto no suceda. La gran desventaja de la búsqueda binaria es que solo funciona en arreglos ordenados: en uno desordenado no sabríamos hacia qué lado seguir buscando.\nA continuación, una implementación del algoritmo de búsqueda binaria en Python:\n\ndef busqueda_binaria(array, valor):\n    limite_inferior = 0\n    limite_superior = len(array) - 1\n\n    while limite_inferior &lt;= limite_superior:\n        punto_medio = (limite_inferior + limite_superior) // 2\n        valor_en_punto_medio = array[punto_medio]\n\n        if valor == valor_en_punto_medio:\n            return punto_medio\n        elif valor &lt; valor_en_punto_medio:\n            limite_superior = punto_medio - 1\n        elif valor &gt; valor_en_punto_medio:\n            limite_inferior = punto_medio + 1\n\n    return None\n\n\nprint(busqueda_binaria([3, 17, 75, 80, 202], 22))\n\nNone\n\n\n\n\nBúsqueda lineal vs. búsqueda binaria\nCon arreglos pequeños, la búsqueda binaria no tiene mucha ventaja frente a la lineal. Pero al aumentar el tamaño del arreglo, la diferencia se vuelve notable.\nEn un arreglo de 100 elementos, la búsqueda lineal puede requerir hasta 100 pasos, mientras que la binaria necesita solo 7. Con la búsqueda lineal, si el valor buscado está al final, hay que revisar cada elemento. En cambio, la búsqueda binaria descarta la mitad de las opciones en cada intento: el primer paso ya elimina 50 valores.\nSi el arreglo tiene 3 elementos, la búsqueda binaria requiere 2 pasos; con 7 elementos, 3 pasos; con 15, 4 pasos. Cada vez que se duplica el tamaño del arreglo, solo se suma un paso más. En cambio, la búsqueda lineal duplica su número de pasos cada vez que se duplica el tamaño.\nPor eso, con 10000 elementos la búsqueda binaria necesita como máximo 13 pasos, y con un millón, solo 20. Esta eficiencia explica por qué la búsqueda binaria es tan poderosa en arreglos ordenados.\nLa siguiente figura muestra como crece la cantidad máxima de pasos que requiere cada tipo de búsqueda conforme crece la cantidad de elementos.\n\n\n\n\n\n\n\n\n\nEn el eje horizontal se representa la cantidad de elementos del arreglo: hacia la derecha, el tamaño de los datos aumenta. En el eje vertical, se muestra la cantidad de pasos que requiere el algoritmo: cuanto más arriba, más pasos.\nLa línea de la búsqueda lineal crece de forma proporcional: cada nuevo elemento implica un paso adicional, por eso la gráfica forma una línea diagonal ascendente.\nEn cambio, la búsqueda binaria apenas aumenta su número de pasos al crecer los datos. Para duplicar la cantidad de elementos, solo suma un paso más, lo que produce una curva que crece muy lentamente.\nConviene recordar que los arreglos ordenados no son más rápidos en todo: insertar nuevos valores es más lento que en un arreglo común. El beneficio está en la búsqueda. Por eso, antes de elegir una estructura, hay que considerar el uso: ¿harás muchas inserciones o muchas búsquedas?",
    "crumbs": [
      "Teoría",
      "U4 - Estructuras de Datos y Algoritmos",
      "1 - ¿Por qué importan?"
    ]
  },
  {
    "objectID": "teoria/04_estructuras_y_algoritmos/01_por_que_importan.html#big-o",
    "href": "teoria/04_estructuras_y_algoritmos/01_por_que_importan.html#big-o",
    "title": "1 - ¿Por qué importan?",
    "section": "Big O",
    "text": "Big O\nHasta ahora vimos que la eficiencia de un algoritmo depende, principalmente, de la cantidad de pasos que realiza.\nPero no podemos decir simplemente que un algoritmo tiene “35 pasos” y otro “200 pasos”, porque ese número en realidad depende del tamaño del problema. Por ejemplo, una búsqueda lineal necesita tantos pasos como elementos haya en el arreglo: si hay 35 elementos, toma 35 pasos; si hay 200, toma 200.\nEn lugar de hablar de un número fijo de pasos, decimos que la búsqueda lineal requiere N pasos para N elementos. Para expresar esto de forma más clara y general, la informática usa una herramienta tomada de las matemáticas: la notación Big O.\nLa notación Big O permite describir y comparar la eficiencia de los algoritmos con un lenguaje conciso y consistente. Gracias a esta, describiremos algoritmos con \\(O(1)\\), \\(O(N)\\), \\(O(\\log N)\\), etc. Veamos que significa.\n\nBig O: es relativo\nLa notación Big O permite comparar algoritmos de forma consistente al centrarse en la cantidad de pasos que requieren, dejando detalles específicos de lado.\nVolvamos al ejemplo de la búsqueda lineal. Si el arreglo tiene \\(N\\) elementos, la búsqueda puede requerir hasta \\(N\\) pasos y decimos que es un algoritmo de complejidad \\(O(N)\\) o “de orden N”. A este tipo de comportamiento también se lo llama tiempo lineal, porque el número de pasos crece de forma proporcional al tamaño del arreglo.\nAhora comparemos esto con la operación de lectura en un arreglo común. Como ya vimos, leer un elemento lleva siempre un solo paso, sin importar cuántos elementos haya. Si nos hacemos la misma pregunta, si hay N elementos, ¿cuántos pasos toma leer uno?, la respuesta es siempre la misma: uno. En notación Big O, esto se expresa como \\(O(1)\\), que se pronuncia “O de uno”.\n\\(O(1)\\) es un caso especial: aunque la pregunta se formula en función de \\(N\\), la respuesta no depende de \\(N\\). No importa si el arreglo tiene 10, 100 o un millón de elementos: leer el valor en una posición siempre lleva un paso. Por eso, los algoritmos \\(O(1)\\) se consideran los más rápidos posibles: su tiempo de ejecución es constante, sin importar el tamaño de los datos.\n\n\nBig O: lo que realmente importa\nYa vimos ejemplos de \\(O(N)\\) y \\(O(1)\\). A esta altura, podemos notar que la notación Big O no se trata solo de contar pasos, sino de responder una pregunta clave:\n\nsi hay N elementos, ¿cuántos pasos realiza el algoritmo?\n\nImaginemos, por ejemplo, un algoritmo que siempre ejecuta tres pasos, sin importar el tamaño del conjunto de datos. Podríamos pensar que este algoritmo es \\(O(3)\\), pero en realidad se escribe como \\(O(1)\\).\n¿Por qué? Porque Big O no mide el número exacto de operaciones, sino cómo cambia el tiempo de ejecución cuando el tamaño del problema aumenta.\nPor eso no diferenciamos entre \\(O(1)\\) y \\(O(3)\\), ambos representan algoritmos de tiempo constante, cuyo desempeño no depende de N. En cambio, un algoritmo \\(O(N)\\) es distinto: su tiempo crece proporcionalmente al tamaño de los datos.\nEn resumen, la notación Big O cuenta la historia de cómo aumenta el número de pasos que requiere un algoritmo a medida que la cantidad de datos crece.\nDebajo, se observa como crece la cantidad de pasos de un algoritmo \\(O(n)\\) versus otro \\(O(1)\\).\n\n\n\n\n\n\n\n\n\nLa curva para \\(O(N)\\) es una línea recta perfecta. Cada vez que se agrega un dato nuevo, el algoritmo necesita un paso más. Cuantos más datos haya, más pasos se requerirán.\nEn cambio, la curva para \\(O(1)\\) es una línea horizontal: sin importar la cantidad de datos, el número de pasos se mantiene constante.\nPara entender en profundidad el propósito de la notación Big O, vayamos un poco más allá. Imaginemos un algoritmo de tiempo constante que siempre toma 20 pasos, sin importar el tamaño de los datos.\n¿Podríamos decir que es más o menos eficiente que un algoritmo \\(O(N)\\)?\nPodemos visualizar la relación entre cantidad de elementos y número de pasos debajo.\n\n\n\n\n\n\n\n\n\nCon menos de 20 elementos el algoritmo \\(O(N)\\) realiza menos pasos que el algoritmo \\(O(1)\\), que siempre toma 20. En 20 elementos, ambas líneas se cruzan, los dos algoritmos tardan lo mismo. Pero a partir de ese punto, el \\(O(N)\\) comienza a necesitar más pasos, y la diferencia sigue creciendo a medida que aumenta el tamaño de los datos.\nSiempre existe un punto a partir del cual \\(O(N)\\) se vuelve menos eficiente, sin importar cuántos pasos fijos tenga el \\(O(1)\\). Incluso si un algoritmo \\(O(1)\\) tomara un millón de pasos constantes, llegaría un tamaño de datos lo suficientemente grande donde el \\(O(N)\\) sería más lento, y seguiría siéndolo hasta el infinito.\n\n\n\n\n\n\nBig O es pesimista\n\n\n\nLa búsqueda lineal no siempre tiene un costo O(N). En el mejor caso, cuando el elemento buscado está en la primera posición, se encuentra en tiempo O(1). En el peor caso, cuando está al final o no se encuentra en absoluto, requiere O(N) pasos.\nEn general, la notación Big O se utiliza para describir el peor caso de un algoritmo, a menos que se indique lo contrario. Este enfoque pesimista resulta útil porque permite anticipar el rendimiento más ineficiente y tomar decisiones informadas sobre qué algoritmo usar.\n\n\n\n\nUn tercer tipo\nPreviamente, vimos que la búsqueda binaria en un arreglo ordenado es, en general, mucho más rápida que la búsqueda lineal.\nAhora veamos cómo se expresa eso en términos de notación Big O.\nPara empezar, no podemos decir que la búsqueda binaria sea \\(O(1)\\), porque el número de pasos aumenta cuando crecen los datos. Tampoco es \\(O(N)\\), ya que la velocidad en la que crece la cantidad de pasos es mucho menor. Por ejemplo, con 100 elementos solo requiere unos 7 pasos.\nLa complejidad de la búsqueda binaria se ubica, entonces, entre \\(O(1)\\) y \\(O(N)\\). En notación Big O se expresa como \\(O(\\log N)\\), se lee “O de log N” y se la conoce como un algoritmo de tiempo logarítmico.\nEn pocas palabras, \\(O(log N)\\) describe un algoritmo cuyo número de pasos crece en una unidad cada vez que se duplica la cantidad de datos; exactamente lo que sucede con la búsqueda binaria.\nEl siguiente gráfico muestra la evolución del numero de pasos para las tres complejidades algorítmicas mencionadas.\n\n\n\n\n\n\n\n\n\nSe puede observar que la curva \\(O(\\log N)\\) se eleva apenas, lo que la hace un poco menos eficiente que \\(O(1)\\), pero muchísimo más eficiente que \\(O(N)\\).\n\n\n\n\n\n\nIntuición detrás de \\(O(\\log N)\\)\n\n\n\nCuando un algoritmo es \\(O(\\log N)\\), significa que, para N elementos, realizará \\(\\log_2 N\\) pasos. Por ejemplo, si hay 8 elementos, tomará 3 pasos, porque \\(\\log_2 8 = 3\\).\nPodemos imaginarlo así: si seguimos dividiendo un arreglo de N elementos a la mitad, necesitaremos \\(\\log_2 N\\) divisiones hasta quedarnos con un solo elemento. Eso es exactamente lo que ocurre en la búsqueda binaria.\n\n\nLa siguiente tabla muestra la diferencia entre las eficiencias de \\(O(N)\\) y \\(O(\\log N)\\):\n\n\n\nElementos (N)\n\\(O(N)\\)\n\\(O(\\log N)\\)\n\n\n\n\n8\n8\n3\n\n\n16\n16\n4\n\n\n32\n32\n5\n\n\n64\n64\n6\n\n\n128\n128\n7\n\n\n256\n256\n8\n\n\n512\n512\n9\n\n\n1024\n1024\n10\n\n\n\nMientras que un algoritmo \\(O(N)\\) puede realizar tantas operaciones como elementos hay en los datos, un algoritmo \\(O(\\log N)\\) agrega solo un paso adicional cada vez que se duplica la cantidad de datos.\n\n\nComplejidad cuadrática\nPara finalizar, exploraremos un ejemplo que nos presentará otro tipo de complejidad algorítmica.\nSupongamos que desarrollamos una aplicación en Python que analiza las calificaciones que los usuarios dan a distintos productos, en una escala de 0 a 10. Se quiere implementar función que verifica si un arreglo de calificaciones contiene números repetidos.\nPor ejemplo, el arreglo [1, 5, 3, 9, 1, 4] tiene dos valores iguales a 1, por lo que la función debería devolver True.\nUna primera idea podría ser usar bucles anidados, como se muestra a continuación:\n\ndef contiene_duplicados(array):\n    for i in range(len(array)):\n        for j in range(len(array)):\n            if (i != j) and (array[i] == array[j]):\n                return True\n    return False\n\n\ncontiene_duplicados([1, 5, 3, 9, 4, 6])\n\nFalse\n\n\n\ncontiene_duplicados([1, 5, 3, 9, 1, 4, 6])\n\nTrue\n\n\nEn esta función recorremos cada posición del arreglo con la variable i. En cada posición i, ejecutamos un segundo bucle que recorre nuevamente todos los valores con la variable j, comparando si array[i] y array[j] son iguales. Si encontramos dos valores iguales, devolvemos True, mientras que si completamos todos los bucles sin hallar coincidencias, devolvemos False, ya que no hay duplicados.\nEste algoritmo para buscar duplicados funciona, pero ¿es eficiente? Podemos analizarlo con lo que ya sabemos sobre notación Big O.\nBig O describe cuántos pasos realiza un algoritmo en función de la cantidad de datos, N. Entonces, para nuestro caso, debemos preguntarnos: si el arreglo tiene N valores, ¿cuántos pasos realiza la función en el peor escenario?\nEl peor caso ocurre cuando no hay duplicados, ya que el código debe realizar todas las comparaciones posibles antes de terminar. Cada iteración externa del bucle se ejecuta N veces, y dentro de cada una se ejecuta otro bucle N veces más. Por lo tanto, el número total de comparaciones es \\(N \\times N = N^2\\).\nDecimos entonces que el algoritmo tiene una complejidad \\(O(N^2)\\), también conocida como tiempo cuadrático.\n\n\n\n\n\n\nBucles anidados\n\n\n\nCon frecuencia (aunque no siempre), cuando un algoritmo tiene un bucle dentro de otro, su complejidad es \\(O(N^2)\\). Así que, cada vez que veas bucles anidados, deberían sonar las alarmas de la complejidad cuadrática\n\n\n\nSolución lineal\nEl hecho de que nuestra función original tenga complejidad \\(O(N^2)\\) debería hacernos reflexionar: este tipo de algoritmos se consideran relativamente lentos. Siempre que nos enfrentemos a uno, conviene preguntarnos si existe una alternativa más eficiente. Puede que no la haya, pero vale la pena analizarlo.\nA continuación se muestra otra versión de la función contiene_duplicados que no usa bucles anidados. La lógica detrás de esta función es un poco más ingeniosa, así que primero veremos cómo funciona y luego evaluaremos si resulta más eficiente que la primera implementación.\n\ndef contiene_duplicados_lineal(array):\n    valores_existentes = [0] * 11\n    for i in range(len(array)):\n        if valores_existentes[array[i]] == 1:\n            return True\n        else:\n            valores_existentes[array[i]] = 1\n    return False\n\n\ncontiene_duplicados_lineal([1, 5, 3, 9, 4, 6])\n\nFalse\n\n\n\ncontiene_duplicados_lineal([1, 5, 3, 9, 1, 4, 6])\n\nTrue\n\n\nEsta función crea un arreglo llamado valores_existentes, que comienza con once ceros, uno para cada valor posible en el arreglo.\nLuego usamos un bucle para revisar cada número del arreglo original. A medida que encontramos cada número, colocamos un valor arbitrario (elegimos usar un 1) en valores_existentes, en la posición correspondiente a ese número.\nPor ejemplo, si el arreglo de entrada es [3, 5, 8]:\n\nAl encontrar el 3, colocamos un 1 en el índice 3 de valores_existentes:\n\n[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]\n\nLuego, al encontrar el 5, colocamos un 1 en el índice 5:\n\n[0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0]\n\nFinalmente, al llegar al 8, el arreglo queda así:\n\n[0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0]\n\n\nEn esencia, estamos usando los índices de valores_existentes para recordar qué números del arreglo ya hemos encontrado.\nAhora viene el punto clave: antes de guardar un 1 en un índice, el código revisa si ese índice ya tiene un 1. Si lo tiene, significa que ya encontramos ese número antes, es decir, que hay un duplicado. En ese caso, la función devuelve True y termina de inmediato. Si recorremos todo el arreglo sin encontrar duplicados, devolvemos False.\nPara determinar la eficiencia de este nuevo algoritmo en términos de Big O, volvemos a analizar cuántos pasos realiza en el peor caso.\nEl paso importante es revisar cada número y comprobar si el valor en el índice correspondiente de valores_existentes es un 1:\nif valores_existentes[array[i]] == 1:\nAdemás de las comparaciones, el algoritmo también realiza asignaciones en valores_existentes, pero consideramos esos pasos triviales en este análisis.\nEl peor caso ocurre cuando el arreglo no contiene duplicados, lo que obliga al código a completar todo el bucle. En consecuencia, para N elementos, el algoritmo realiza N comparaciones: un solo bucle que itera una vez por cada número.\nPor lo tanto, este algoritmo tiene una complejidad \\(O(N)\\), o tiempo lineal.\n\n\n\n\n\n\nLetra chica\n\n\n\nEl algoritmo de complejidad lineal es posible solo porque sabemos que array toma valores en un conjunto finito predeterminado. Si los valores en array fuesen cualquiera, no podríamos ya utilizar este mismo algoritmo.\nFinalmente, otra desventaja de esta nueva implementación es que consume más memoria que la primera debido a valores_existentes.\n\n\n\n\nResumen de complejidades\nEn este apunte vimos ejemplos de complejidad constante, lineal, logarítmica o cuadrática. Pero estas no son las únicas disponibles. Otros ejemplos son la complejidad lineal-logarítmica (\\(O(N \\log N)\\)), cúbica (\\(O(N ^3)\\)), exponencial (\\(O(2 ^ N)\\)) o incluso factorial (\\(O(N!)\\)).",
    "crumbs": [
      "Teoría",
      "U4 - Estructuras de Datos y Algoritmos",
      "1 - ¿Por qué importan?"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/08_io.html",
    "href": "teoria/01_programacion_en_python/08_io.html",
    "title": "8 - Lectura y escritura de archivos",
    "section": "",
    "text": "En nuestros programas de Python utilizamos variables para almacenar datos durante la ejecución. Estos datos pueden estar escritos directamente en el código o ser ingresados por el usuario (por ejemplo, mediante la función input()). Por otro lado, cuando necesitamos mostrar una salida en pantalla, usamos la función print().\nSin embargo, el uso exclusivo de input() y print() para la entrada y salida de datos tiene limitaciones. Por ejemplo:\n\nSi trabajamos con más de unos pocos datos, o ni siquiera sabemos cuáles datos necesitaremos al momento de ejecutar el programa, no resulta práctico declararlos en el código o ingresarlos manualmente.\nSi el resultado de nuestro programa consiste en una gran cantidad de datos que no pueden analizarse visualmente con rapidez, o si necesitamos reutilizarlos en otro programa o proceso más adelante, se hace necesario almacenarlos de manera persistente.\n\nEn resumen, para resolver problemas de mayor complejidad, vamos a necesitar leer y guardar archivos en la computadora.",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "8 - Lectura y escritura de archivos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/08_io.html#introducción",
    "href": "teoria/01_programacion_en_python/08_io.html#introducción",
    "title": "8 - Lectura y escritura de archivos",
    "section": "",
    "text": "En nuestros programas de Python utilizamos variables para almacenar datos durante la ejecución. Estos datos pueden estar escritos directamente en el código o ser ingresados por el usuario (por ejemplo, mediante la función input()). Por otro lado, cuando necesitamos mostrar una salida en pantalla, usamos la función print().\nSin embargo, el uso exclusivo de input() y print() para la entrada y salida de datos tiene limitaciones. Por ejemplo:\n\nSi trabajamos con más de unos pocos datos, o ni siquiera sabemos cuáles datos necesitaremos al momento de ejecutar el programa, no resulta práctico declararlos en el código o ingresarlos manualmente.\nSi el resultado de nuestro programa consiste en una gran cantidad de datos que no pueden analizarse visualmente con rapidez, o si necesitamos reutilizarlos en otro programa o proceso más adelante, se hace necesario almacenarlos de manera persistente.\n\nEn resumen, para resolver problemas de mayor complejidad, vamos a necesitar leer y guardar archivos en la computadora.",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "8 - Lectura y escritura de archivos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/08_io.html#lectura-y-escritura",
    "href": "teoria/01_programacion_en_python/08_io.html#lectura-y-escritura",
    "title": "8 - Lectura y escritura de archivos",
    "section": "Lectura y escritura",
    "text": "Lectura y escritura\n\nArchivos de texto vs archivos binarios\nEn esta sección vamos a aprender a leer y escribir archivos de texto plano.\nLos archivos de texto plano contienen únicamente caracteres básicos de texto, sin ningún tipo de información adicional. Algunos ejemplos son:\n\nArchivos de texto genéricos con extensión .txt\nArchivos de código Python con extensión .py\n\nEstos archivos pueden abrirse sin dificultad en cualquier editor de texto como el Notepad o Positron, y Python puede leer su contenido y tratarlo como cadenas de texto normales (str).\nEn contraste, existen los archivos binarios, que contienen secuencias de bits que no se limitan a representar caracteres de texto. Estos pueden almacenar cualquier tipo de datos, como imágenes, sonidos, videos, PDFs, ejecutables, etc. Aunque en este apunte nos enfocamos en los archivos de texto plato, muchos de los principios que veremos también se aplican a los archivos binarios.\n\n\nLos tres pasos fundamentales\nA la hora de trabajar con archivos en Python, normalmente se siguen tres pasos:\n\nAbrir el archivo con la función open(), que devuelve un objeto de tipo TextIOWrapper.\nLeer o escribir en el archivo con los métodos read() o write() del objeto TextIOWrapper.\nCerrar el archivo con el método close() para liberar los recursos y asegurarse de que todos los cambios se guarden correctamente.\n\n\n\nLeer archivos\nPara abrir un archivo en Python se utiliza la función open(), a la cual se le pasa como argumento la ruta del archivo. Esta ruta puede estar representada con una cadena de texto str o un objeto Path del módulo pathlib (que veremos en una sección más adelante). La función open() devuelve un objeto de tipo TextIOWrapper que representa al archivo abierto y permite interactuar con él.\nSupongamos que tenemos un archivo llamado pensamientos.txt con el siguiente contenido:\nEstoy aprendiendo a leer archivos en Python.\nNo se con qué me voy a encontrar.\nPero acá vamos.\ny usamos la función open() para abrir el archivo.\narchivo = open(\"pensamientos.txt\")\narchivo\n&lt;_io.TextIOWrapper name='pensamientos.txt' mode='r' encoding='cp1252'&gt;\nVemos que el objeto devuelto por open() no solo incluye el nombre del archivo (pensamientos.txt), sino también mode=\"r\" y encoding=\"cp1252\".\nTanto mode como encoding son argumentos de la función open(). El primero indica el modo en el que se abre el archivo. Por defecto, este valor es \"r\", lo que significa que el archivo se abre en modo lectura de texto plano. En este modo es posible leer su contenido, pero no escribir sobre él.\nEl segundo argumento, encoding, especifica la codificación que se usará para convertir los bytes del archivo en cadenas de texto de Python. En macOS y Linux el valor por defecto es \"utf-8\". En cambio, en Windows, la codificación predeterminada es \"cp1252\" (ASCII extendido). Como esto puede generar errores al leer archivos de texto UTF-8 que contengan caracteres no ingleses en Windows, se recomienda siempre incluir explícitamente el argumento encoding=\"utf-8\".\nEl objeto de la variable archivo es de tipo TextIOWrapper. A pesar de que el nombre pueda parecer complicado, no es más que otro tipo de objeto en Python, como son las listas o los diccionarios. Cada vez que necesitemos leer o escribir en el archivo, lo haremos a través de los métodos asociados a este objeto.\n\n\n\n\n\n\nPuede fallar\n\n\n\nSi le pasamos a la función open() un nombre de un archivo que no existe, ya sea porque escribimos mal la ruta o cometimos un error de tipeo, obtendremos un FileNotFoundError.\nopen(\"pensamiento.txt\")\n\nFileNotFoundError: [Errno 2] No such file or directory: 'pensamiento.txt'\n\n\n\n\nLeer todo el contenido\nUna forma de leer un archivo de texto plano en Python es cargar todo su contenido de una sola vez como una única cadena de texto. Para ello se utiliza el método .read() del objeto TextIOWrapper.\n\narchivo = open(\"pensamientos.txt\", encoding=\"utf-8\")\ncontenido = archivo.read()\ncontenido\n\n'Estoy aprendiendo a leer archivos en Python.\\nNo se con qué me voy a encontrar.\\nPero acá vamos.'\n\n\nSe puede observar que, salvo la última, cada línea termina con un carácter de nueva línea (\\n). Si hubiéramos agregado un salto de línea al final del archivo pensamientos.txt, la cadena resultante también habría terminado en \"\\n\".\n\n\nLeer línea a línea\nUna alternativa al método .read(), que carga todo el contenido como una única cadena de texto, es el método .readlines(). Este devuelve una lista de cadenas, donde cada elemento corresponde a una línea del archivo.\n\narchivo = open(\"pensamientos.txt\", encoding=\"utf-8\")\narchivo.readlines()\n\n['Estoy aprendiendo a leer archivos en Python.\\n',\n 'No se con qué me voy a encontrar.\\n',\n 'Pero acá vamos.']\n\n\nTrabajar con una lista de cadenas suele ser más cómodo que manejar un único bloque de texto, ya que te permite acceder directamente a cada línea por separado.\n\n\nLeer solo algunas líneas\nTambién es posible leer un número limitado de líneas en lugar de cargar todo el archivo de una sola vez. Para ello se utiliza el método .readline(), en singular. Cada vez que se invoca, se obtiene la siguiente línea del archivo. Cuando ya no quedan más líneas, devuelve una cadena vacía.\n\narchivo = open(\"pensamientos.txt\", encoding=\"utf-8\")\nwhile True:\n    linea = archivo.readline()\n    if linea == \"\":\n        break\n    print(linea, end=\"\") # `end=\"\"` para que Python no agregue salto de línea\n\nEstoy aprendiendo a leer archivos en Python.\nNo se con qué me voy a encontrar.\nPero acá vamos.\n\n\nEste método también acepta un argumento opcional size, que permite especificar la cantidad de caracteres a leer en cada llamada.\n\n\nCerrar archivo\nCuando terminamos de trabajar con un archivo, es importante cerrarlo con el método .close(). Esto libera los recursos asociados y, en caso de escritura, asegura que todo lo que estaba en el búfer se guarde correctamente.\nAunque Python suele cerrar los archivos automáticamente al final del programa, es una buena práctica hacerlo de forma explícita para evitar comportamientos inesperados.\n\n\n\n\n\n\nLecturas sucesivas\n\n\n\nCuando se lee un archivo en Python, existe un puntero interno (a veces llamado posición en el búfer) que avanza a medida que se consume el contenido. Por eso, después de una primera lectura completa, las siguientes llamadas a métodos como .read() o .readlines() no devuelven nada: el puntero ya está al final del archivo.\narchivo = open(\"pensamientos.txt\")\narchivo.read()\n'Estoy aprendiendo a leer archivos en Python.\\nNo se con qué me voy a encontrar.\\nPero acá vamos.'\narchivo.read()\n''\narchivo.readlines()\n[]\nPara volver a leer desde el inicio, hay dos opciones:\n\nCerrar y volver a abrir el archivo.\nUsar el método .seek(0) para mover el puntero de vuelta al principio.\n\n\n\n\n\n\nEscribir archivos\nPara escribir un archivo en Python, primero debemos abrirlo con la función open(), de la misma manera que al leer. Sin embargo, no podemos usar los argumentos por defecto, ya que en ese caso el archivo se abre en modo lectura, lo que impide escribir en él.\nPara poder escribir, el archivo debe abrirse en uno de los siguientes modos:\n\nModo escritura (\"w\"): sobrescribe por completo el archivo existente, de forma similar a cuando asignamos un nuevo valor a una variable reemplazando el anterior.\nModo adición (\"a\"): agrega nuevo contenido al final del archivo existente, sin borrar lo que ya contenía.\n\nSi el archivo indicado en open() no existe, tanto el modo escritura como el modo adición crearán un archivo nuevo y vacío.\nDebajo, abrimos un archivo llamado conclusiones.txt en modo escritura. Como el archivo todavía no existe, Python lo crea automáticamente. Luego, llamamos a write() sobre el archivo abierto y le pasamos la cadena \"Escribir en Python no es tan grave como parece.\\n\" y el texto se escribe dentro del archivo.\n\narchivo = open(\"conclusiones.txt\", mode=\"w\", encoding=\"utf-8\") # Este paso ya crea el archivo\narchivo.write(\"Escribir en Python no es tan grave como parece.\\n\")\n\n48\n\n\nEl método .write() devuelve el número de caracteres escritos, incluyendo el salto de línea \\n. Después, cerramos el archivo.\n\narchivo.close()\n\nPara agregar texto sin reemplazar el contenido existente, abrimos el archivo en modo adición. Escribimos la cadena \"Es solo cuestión de practica.\" y lo cerramos nuevamente.\n\narchivo = open(\"conclusiones.txt\", mode=\"a\", encoding=\"utf-8\")\narchivo.write(\"Es solo cuestión de practica.\")\narchivo.close()\n\nFinalmente, para mostrar en pantalla el contenido de conclusiones.txt, abrimos el archivo en modo lectura, cargamos su contenido con .read(), lo guardamos en la variable texto, cerramos el archivo y luego imprimimos texto.\n\narchivo = open(\"conclusiones.txt\", mode=\"r\", encoding=\"utf-8\")\ntexto = archivo.read()\narchivo.close()\nprint(texto)\n\nEscribir en Python no es tan grave como parece.\nEs solo cuestión de practica.\n\n\n\n\n\n\n\n\nSaltos de línea\n\n\n\nEs importante tener presente que el método .write() no agrega un salto de línea al final del texto de forma automática, a diferencia de print(). Si queremos que el contenido se escriba en una nueva línea dentro del archivo, debemos incluir manualmente el carácter \\n.\n\n\n\n\nUso de la sentencia with\nCuando abrimos un archivo con open(), debemos cerrarlo después con .close(). El problema es que a veces podemos olvidarlo o que el programa falle antes de llegar a esa línea.\nPara evitarlo, Python ofrece la sentencia with, que se encarga de cerrar el archivo automáticamente al terminar el bloque de código, incluso si ocurre un error en el medio.\nDebajo, utilizamos la sentencia with para crear un archivo y escribir texto en él.\n\nwith open(\"ejemplo.txt\", mode=\"w\", encoding=\"utf-8\") as archivo:\n    archivo.write(\"¡Hola, mundo!\\n\")\n\nprint(archivo.closed) # Verificar que el archivo está cerrado\n\nTrue\n\n\nLuego, podemos utilizar un patrón similar, pero pasando mode=\"r\", para leer el contenido del archivo.\n\nwith open(\"ejemplo.txt\", mode=\"r\", encoding=\"utf-8\") as archivo:\n    contenido = archivo.read()\n\nprint(contenido)\nprint(archivo.closed)\n\n¡Hola, mundo!\n\nTrue\n\n\n\n\n\n\n\n\nContext managers\n\n\n\nLa sentencia with no es exclusiva para leer o escribir archivos: en realidad funciona con un objeto especial llamado context manager.\nUn context manager se usa en Python para manejar recursos que necesitan ser adquiridos y luego liberados de forma segura, como archivos, conexiones de red o bloqueos de concurrencia.\nLa clave es que with define un bloque de código dentro del cual el recurso está disponible. Al entrar en el bloque, el recurso se prepara (por ejemplo, se abre un archivo) y, al salir, se libera automáticamente, sin importar si la salida fue normal, si hubo un return o si se produjo una excepción.\nEsto permite que el código sea más claro y seguro, ya que todo el ciclo de vida del recurso queda encapsulado dentro de ese bloque.",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "8 - Lectura y escritura de archivos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/08_io.html#archivos-y-rutas",
    "href": "teoria/01_programacion_en_python/08_io.html#archivos-y-rutas",
    "title": "8 - Lectura y escritura de archivos",
    "section": "Archivos y rutas",
    "text": "Archivos y rutas\nUn archivo tiene dos características principales: su nombre y su ruta.\nLa ruta indica la ubicación exacta del archivo dentro de la computadora y puede incluir directorios, subdirectorios y el nombre del archivo con su extensión (por ejemplo, .txt, .csv, .py).\nA modo de ejemplo, supongamos que tenemos un archivo con el nombre reporte.docx, que se encuentra en la ruta:\nC:\\Users\\Tomi\\Documentos\nLa parte C:\\ de la ruta es la carpeta raíz (conocida como root directory en inglés), la cual contiene a todas las demás carpetas.\nEn Windows, la carpeta raíz se llama C:\\ y también se le conoce como la unidad C:. En macOS y Linux, la carpeta raíz se representa con una simple barra inclinada: /.\nPor otro lado, Users, Tomi y Documentos son carpetas, también llamadas directorios. Las carpetas pueden contener archivos y también otras carpetas (llamadas subcarpetas o subdirectorios).\n\nEspecificación de rutas con pathlib.Path\n\nPor qué no es suficiente con str\nPor defecto, Python busca los archivos en el directorio de trabajo actual (current working directory). Por ejemplo:\nopen(\"archivo.txt\")\nEn este caso, archivo.txt debe estar en la misma carpeta desde donde se ejecuta el programa. Si no está allí, hay que indicar su ruta absoluta o relativa.\nAunque se pueden usar cadenas de texto (str) para definir rutas, esto puede generar problemas porque los sistemas operativos usan separadores distintos. Mientras que Windows usa la barra inclinada hacia atrás \\, macOS y Linux usan la barra inclinada hacia delante /.\n\n\nLa solución\nPara evitar errores y escribir código que funcione en cualquier sistema, conviene usar Path del módulo pathlib, que maneja automáticamente las diferencias entre las formas de especificar rutas entre los distintos sistemas operativos.\nfrom pathlib import Path\nruta = Path(\"Users/Tomi/Documentos/projecto.docx\")\nprint(ruta)\nEn Windows se mostrará como:\nUsers\\Tomi\\Documentos\\project.docx\nY en macOS o Linux como:\nUsers/Tomi/Documentos/projecto.docx\nSi en Windows convertimos al objeto ruta a una cadena de caracteres, nos encontraremos con el siguiente resultado:\nstr(ruta)\n\"Users\\\\Tomi\\\\Documentos\\\\projecto.docx\"\nLas barras invertidas aparecen como dobles barras invertidas porque en Python cada barra invertida debe escaparse con otra barra invertida.\n\n\n\nCombinación de rutas con el operador /\nEl operador /, que normalmente usamos para dividir números, también sirve en Python para combinar rutas cuando trabajamos con pathlib.Path. Esto permite construir rutas de forma clara y sin preocuparse por los separadores que cambian según el sistema operativo. Por ejemplo:\nfrom pathlib import Path\n\nruta = Path(\"datos\") / \"usuarios\" / \"reporte.txt\"\nprint(ruta)\nEl resultado será distinto según el sistema:\nEn Windows:\ndatos\\usuarios\\reporte.txt\nEn macOS/Linux:\ndatos/usuarios/reporte.txt\nDe esta manera, podemos ir “pegando” carpetas y archivos paso a paso, evitando concatenar cadenas manualmente y asegurando compatibilidad multiplataforma.\n\n\nRutas absolutas y relativas\nExisten dos formas principales de escribir la ruta de un archivo:\n\nRuta absoluta: indica la ubicación completa desde la carpeta raíz. En Windows comienza con la letra de unidad, por ejemplo C:\\, y en macOS/Linux comienza con /.\nRuta relativa: se interpreta a partir del directorio de trabajo actual del programa.\n\nAdemás, es común usar dos “atajos especiales” dentro de una ruta:\n\n.: indica el directorio actual.\n..: indica el directorio padre, del ingles parent directory, que es el directorio que contiene al directorio actual.\n\nPor ejemplo, si el directorio de trabajo es C:\\trabajo y queremos acceder al archivo C:\\trabajo\\datos.txt mediante una ruta relativa, podemos usar simplemente:\ndatos.txt\no\n.\\datos.txt\nPor otro lado, si queremos acceder al archivo C:\\estudio\\reporte.txt, la ruta relativa sería:\n..\\estudio\\reporte.txt\nEsto facilita moverse entre carpetas sin necesidad de escribir rutas absolutas cada vez.\n\n\nAcceso a directorios de interés\n\nDirectorio de trabajo actual\nEl directorio de trabajo actual es la carpeta desde la cual Python busca los archivos cuando usamos rutas relativas. En Python se puede obtener como una cadena de texto usando el método .cwd() (del inglés, current working directory) de Path:\nfrom pathlib import Path\nprint(Path.cwd())\nSi necesitamos cambiar el directorio de trabajo actual, se puede usar chdir del módulo os:\nimport os\nos.chdir(\"nueva_ruta\")\n\n\n\n\n\n\nPrecauciones\n\n\n\nHay que tener en cuenta que al modificar el directorio de trabajo cambian todas las rutas relativas en el programa. Por eso, en proyectos grandes suele ser más seguro usar rutas absolutas o construirlas a partir de un directorio base bien definido.\n\n\n\n\nDirectorio personal (home)\nCada usuario tiene un directorio personal que depende del sistema operativo: en Windows suele estar en C:\\Users\\&lt;usuario&gt;, en macOS en /Users/&lt;usuario&gt; y en Linux en /home/&lt;usuario&gt;.\nEn Python se puede acceder a este directorio con el método Path.home():\nfrom pathlib import Path\nprint(Path.home())\nNormalmente, los programas tienen permisos de lectura y escritura dentro de este directorio, por lo que es un lugar seguro y conveniente para guardar archivos y configuraciones creadas por tus scripts.\n\n\n\nUtilidades\n\nObtención ruta absoluta y normalizada\nEl método .resolve() de Path convierte una ruta relativa en absoluta y, cuando es posible, normaliza la ruta colapsando los atajos . y ... En el siguiente ejemplo, el directorio de trabajo actual es C:\\Users\\Tomi\\Desktop\\proyecto:\nfrom pathlib import Path\n\nruta = Path(\"../datos.txt\")\nprint(ruta.resolve()) # ruta absoluta y normalizada\nC:\\Users\\Tomi\\Desktop\\datos.txt\n\n\nCreación de directorios\nEl método .mkdir() de los objetos Path permite crear un directorio a partir de una ruta.\nfrom pathlib import Path\n\nPath(\"nueva_carpeta\").mkdir(exist_ok=True)\nCon exist_ok=True evitamos errores si la carpeta ya existe.\nPara crear todos los directorios en una ruta de múltiples directorios en una sola llamada, se puede añadir parents=True:\nPath(\"datos/limpios/2025\").mkdir(parents=True, exist_ok=True)\n\n\nVerificación de validez y tipo de rutas\nLos objetos Path permiten comprobar si una ruta existe y qué tipo de recurso representa:\nfrom pathlib import Path\n\nruta = Path(\"C:/Users/Tomi/Documentos/projecto.docx\")\n\nprint(ruta.exists())   # True si existe\nprint(ruta.is_file())  # True si existe y es archivo\nprint(ruta.is_dir())   # True si existe y es directorio",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "8 - Lectura y escritura de archivos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/08_io.html#apéndice",
    "href": "teoria/01_programacion_en_python/08_io.html#apéndice",
    "title": "8 - Lectura y escritura de archivos",
    "section": "Apéndice",
    "text": "Apéndice\n\nEl arugmento mode de open()\n\nCaracteres válidos\n\n\n\n\n\n\n\nCaracter\nSignificado\n\n\n\n\nr\nabrir para lectura (predeterminado)\n\n\nw\nabrir para escritura, truncando primero el archivo\n\n\nx\ncrear un archivo nuevo y abrirlo para escritura\n\n\na\nabrir para escritura, agregando al final del archivo si existe\n\n\nb\nmodo binario\n\n\nt\nmodo texto (predeterminado)\n\n\n+\nabrir un archivo en disco para actualización (lectura y escritura)\n\n\n\n\n\nEjemplos\n\n\n\n\n\n\n\n\nModo\nEjemplo\nDescripción\n\n\n\n\nr\nopen(\"datos.txt\", \"r\")\nAbre datos.txt para leer en modo texto.\n\n\nrb\nopen(\"imagen.png\", \"rb\")\nAbre imagen.png para leer en modo binario (útil para imágenes, PDFs, etc).\n\n\nw\nopen(\"salida.txt\", \"w\")\nAbre salida.txt para escritura en texto, truncando el archivo si existe.\n\n\nwb\nopen(\"audio.raw\", \"wb\")\nAbre audio.raw para escritura en binario, truncando si existe.\n\n\na\nopen(\"log.txt\", \"a\")\nAbre log.txt para añadir texto al final del archivo.\n\n\nab\nopen(\"video.mp4\", \"ab\")\nAbre video.mp4 en binario para añadir datos al final.\n\n\nx\nopen(\"nuevo.txt\", \"x\")\nCrea nuevo.txt y lo abre para escritura en texto. Falla si ya existe.\n\n\nxb\nopen(\"nuevo.dat\", \"xb\")\nCrea nuevo.dat y lo abre para escritura en binario. Falla si ya existe.\n\n\nr+\nopen(\"datos.txt\", \"r+\")\nAbre datos.txt para leer y escribir en texto.\n\n\nrb+\nopen(\"imagen.png\", \"rb+\")\nAbre imagen.png para leer y escribir en binario.\n\n\nw+\nopen(\"datos.txt\", \"w+\")\nAbre datos.txt para leer y escribir en texto, truncando si existe.\n\n\nwb+\nopen(\"datos.bin\", \"wb+\")\nAbre datos.bin para leer y escribir en binario, truncando si existe.",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "8 - Lectura y escritura de archivos"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/07_scripting.html",
    "href": "teoria/01_programacion_en_python/07_scripting.html",
    "title": "7 - Scripting",
    "section": "",
    "text": "En programación, un script es un archivo de texto que contiene una secuencia lógica de pasos que se pueden ejecutar para realizar una tarea específica, ya sea simple o compleja. Esta serie de pasos suele expresarse en un lenguaje de scripting, un lenguaje de programación que permite manipular, personalizar y automatizar tareas.\nA diferencia de los programas compilados, los scripts suelen interpretarse en tiempo de ejecución. Es decir, un intérprete se encarga de leer, procesar y ejecutar cada instrucción en orden.\nEn el caso de Python, un script es un archivo con extensión .py que puede automatizar procesos, analizar datos, crear aplicaciones o prácticamente cualquier otra tarea que el lenguaje permita. El intérprete de Python ejecuta el código línea por línea, lo que facilita probar, modificar y reutilizar el programa de manera ágil\nDebido a su uso frecuente para desarrollar scripts, Python es conocido también como un lenguaje de scripting, aunque en la práctica su uso sea mucho más amplio.",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "7 - _Scripting_"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/07_scripting.html#qué-es-un-script",
    "href": "teoria/01_programacion_en_python/07_scripting.html#qué-es-un-script",
    "title": "7 - Scripting",
    "section": "",
    "text": "En programación, un script es un archivo de texto que contiene una secuencia lógica de pasos que se pueden ejecutar para realizar una tarea específica, ya sea simple o compleja. Esta serie de pasos suele expresarse en un lenguaje de scripting, un lenguaje de programación que permite manipular, personalizar y automatizar tareas.\nA diferencia de los programas compilados, los scripts suelen interpretarse en tiempo de ejecución. Es decir, un intérprete se encarga de leer, procesar y ejecutar cada instrucción en orden.\nEn el caso de Python, un script es un archivo con extensión .py que puede automatizar procesos, analizar datos, crear aplicaciones o prácticamente cualquier otra tarea que el lenguaje permita. El intérprete de Python ejecuta el código línea por línea, lo que facilita probar, modificar y reutilizar el programa de manera ágil\nDebido a su uso frecuente para desarrollar scripts, Python es conocido también como un lenguaje de scripting, aunque en la práctica su uso sea mucho más amplio.",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "7 - _Scripting_"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/07_scripting.html#script-vs-módulo",
    "href": "teoria/01_programacion_en_python/07_scripting.html#script-vs-módulo",
    "title": "7 - Scripting",
    "section": "Script vs módulo",
    "text": "Script vs módulo\nPython es un lenguaje de programación interpretado, y por ello sus programas suelen denominarse scripts. Sin embargo, no siempre es correcto usar este término. Si bien muchos programas en Python consisten en instrucciones destinadas a resolver tareas puntuales, otros programas tienen por objetivo principal implementar herramientas que luego van a ser utilizadas por otros programas.\nUn programa de Python puede denominarse script o módulo. El propósito del código en un archivo de texto .py es lo que determina si lo llamamos de una manera o de la otra. Cuando un archivo contiene código ejecutable cuyo fin es realizar una tarea específica, se lo considera script. En cambio, cuando el archivo está diseñado para ser importado y utilizado desde otro programa de Python, se lo denomina módulo.\nEn síntesis, la principal diferencia entre un módulo y un script es que los módulos almacenan código importable mientras que los scripts contienen código ejecutable.",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "7 - _Scripting_"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/07_scripting.html#script-y-módulo",
    "href": "teoria/01_programacion_en_python/07_scripting.html#script-y-módulo",
    "title": "7 - Scripting",
    "section": "Script y módulo",
    "text": "Script y módulo\nPython es un lenguaje tan flexible que un mismo programa puede funcionar como script y como módulo al mismo tiempo. Esto ocurre cuando el archivo define herramientas reutilizables (por ejemplo, funciones o clases) y, además, incluye código que se ejecuta directamente al correrlo desde la línea de comandos.\nPara ilustrarlo, consideremos un pequeño programa en Python que solicita una fecha al usuario y luego indica cuántos días faltan para llegar a ella:\n\n\ncalcular_dias.py\n\nfrom datetime import datetime\n\ndef diferencia_dias(fecha_str):\n    fecha = datetime.strptime(fecha_str, \"%Y-%m-%d\").date()\n    hoy = datetime.today().date()\n    diferencia = (fecha - hoy).days\n    return diferencia\n\nfecha_str = input(\"Ingresá una fecha (formato AAAA-MM-DD): \")\ndiferencia = diferencia_dias(fecha_str)\n\nif diferencia &gt; 0:\n    print(f\"Faltan {diferencia} días para el {fecha_str}.\")\nelif diferencia == 0:\n    print(\"¡La fecha es hoy!\")\nelse:\n    print(f\"Esa fecha ya pasó hace {-diferencia} días.\")\n\nDebajo se muestra una animación de la ejecución de este script en la terminal:\n\n\n\n\n\nAhora, supongamos que queremos importar la función diferencia_dias en otro programa de Python.\n\n\n\n\n\nCuando importamos una función del módulo calcular_dias, observamos que Python también ejecuta la parte del programa que solicita una fecha y muestra cuántos días faltan para alcanzarla.\nEsto ocurre porque, al importar un módulo (o cualquier objeto definido en él), Python ejecuta todo el código del archivo de principio a fin, sin importar qué elementos en particular estemos importando.\nPara evitar este comportamiento no deseado, y permitir que un mismo archivo pueda funcionar tanto como módulo reutilizable como script ejecutable, se encapsula la parte que debe ejecutarse solo al correr el archivo directamente dentro del siguiente bloque:\nif __name__ == \"__main__\":\n    # código ejecutable\nCon esta estructura, el código dentro de ese bloque se ejecutará únicamente cuando el archivo se ejecute directamente como programa, y no cuando se lo importe desde otro módulo.\nDe esta manera, nuestro programa actualizado quedaría así:\n\n\ncalcular_dias.py\n\nfrom datetime import datetime\n\ndef diferencia_dias(fecha_str):\n    fecha = datetime.strptime(fecha_str, \"%Y-%m-%d\").date()\n    hoy = datetime.today().date()\n    diferencia = (fecha - hoy).days\n    return diferencia\n\nif __name__ == \"__main__\":\n    fecha_str = input(\"Ingresá una fecha (formato AAAA-MM-DD): \")\n    diferencia = diferencia_dias(fecha_str)\n\n    if diferencia &gt; 0:\n        print(f\"Faltan {diferencia} días para el {fecha_str}.\")\n    elif diferencia == 0:\n        print(\"¡La fecha es hoy!\")\n    else:\n        print(f\"Esa fecha ya pasó hace {-diferencia} días.\")\n\nAhora, cuando se importa cualquier objeto desde calcular_dias, Python no ejecuta la parte del programa que interactúa con el usuario.\n\n\n\n\n\n\n\n\n\n\n\nLa variable especial __name__ 🏷️\n\n\n\nLa variable __name__ es una variable especial que indica el nombre del módulo actual. Cuando un archivo Python se ejecuta directamente, __name__ toma el valor \"__main__\", lo que indica que es el módulo principal. En cambio, si el archivo se importa como un módulo en otro script, __name__ contendrá el nombre del archivo (sin la extensión .py).",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "7 - _Scripting_"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/07_scripting.html#clis-con-argparse",
    "href": "teoria/01_programacion_en_python/07_scripting.html#clis-con-argparse",
    "title": "7 - Scripting",
    "section": "CLIs con argparse",
    "text": "CLIs con argparse\nargparse es un módulo de la librería estándar de Python que sirve para crear interfaces de línea de comandos (CLIs, por sus siglas en inglés).\nCon este módulo se pueden definir qué argumentos y opciones acepta nuestra programa. Luego, Python se encargará de:\n\nLeerlos desde la terminal al ejecutar el script.\nConvertirlos al tipo de dato indicado (int, float, str, etc.).\nValidarlos según las reglas definidas.\nGenerar un mensaje de ayuda (--help) sin que tengamos que hacer nada.\n\n\nEjemplo: saludos personalizados\nEl siguiente programa recibe el nombre de una persona como argumento obligatorio y, de manera opcional, la cantidad de veces que se la debe saludar.\nimport argparse\n\nparser = argparse.ArgumentParser(description=\"Saluda a una persona\")\nparser.add_argument(\"nombre\", help=\"El nombre de la persona\") # Argumento posicional\nparser.add_argument(\"--veces\", type=int, default=1, help=\"Cuántas veces saludar\") # Argumento nombrado\n\nargs = parser.parse_args()\n\nfor _ in range(args.veces):\n    print(f\"¡Hola, {args.nombre}!\")\nLuego, en la terminal:\npython hola.py Tomás\n¡Hola, Tomás!\nY si usamos el argumento --veces:\npython hola.py Tomás --veces 3\n¡Hola, Tomás!\n¡Hola, Tomás!\n¡Hola, Tomás!\nLa ayuda se puede ver de la siguiente manera:\npython hola.py --help\nusage: hola.py [-h] [--veces VECES] nombre\n\nSaluda a una persona\n\npositional arguments:\n  nombre         El nombre de la persona\n\noptions:\n  -h, --help     show this help message and exit\n  --veces VECES  Cuántas veces saludar\nSi usamos un valor de tipo erróneo para --veces, obtenemos un error informativo de manera automática:\npython hola.py Tomás --veces 3.5\n\nusage: hola.py [-h] [--veces VECES] nombre\nhola.py: error: argument --veces: invalid int value: '3.5'\n\n\n\n\n\n\n\ninput() vs argparse\n\n\n\nTanto input() como ArgumentParser de argparse permiten pasar datos a nuestro script. La diferencia entre ellos es que input() se usa para pedir datos mientras corre el programa, mientras que el módulo argparse se usa apra pedir datos al momento de ejecutar el programa desde al terminal.",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "7 - _Scripting_"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html",
    "title": "5 - Ejecución repetitiva",
    "section": "",
    "text": "Anteriormente aprendimos a crear objetos que contienen otros objetos (listas, tuplas y diccionarios).\nCuando queríamos realizar una acción con cada uno de los objetos que estos contenían, teníamos que escribir el mismo código para acceder a cada uno de ellos de a uno.\nPor ejemplo, supongamos que tenemos un listado con nombres de nuestros amigos y queremos ponerlos a todos en mayúsculas:\n\nnombres = [\"julieta\", \"facundo\", \"emiliano\", \"lorenzo\", \"victoria\"]\nprint(\"Nombres originales:\")\nprint(nombres)\n\nnombres[0] = nombres[0].upper()\nnombres[1] = nombres[1].upper()\nnombres[2] = nombres[2].upper()\nnombres[3] = nombres[3].upper()\nnombres[4] = nombres[4].upper()\n\nprint(\"\\nNombres modificados:\")\nprint(nombres)\n\nNombres originales:\n['julieta', 'facundo', 'emiliano', 'lorenzo', 'victoria']\n\nNombres modificados:\n['JULIETA', 'FACUNDO', 'EMILIANO', 'LORENZO', 'VICTORIA']\n\n\nVemos que realizamos exactamente la misma acción con cada nombre en la lista… ¿No estaría bueno poder automatizarlo?\nY para eso, en esta sección vamos a aprender sobre bucles.",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "5 - Ejecución repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#introducción",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#introducción",
    "title": "5 - Ejecución repetitiva",
    "section": "",
    "text": "Anteriormente aprendimos a crear objetos que contienen otros objetos (listas, tuplas y diccionarios).\nCuando queríamos realizar una acción con cada uno de los objetos que estos contenían, teníamos que escribir el mismo código para acceder a cada uno de ellos de a uno.\nPor ejemplo, supongamos que tenemos un listado con nombres de nuestros amigos y queremos ponerlos a todos en mayúsculas:\n\nnombres = [\"julieta\", \"facundo\", \"emiliano\", \"lorenzo\", \"victoria\"]\nprint(\"Nombres originales:\")\nprint(nombres)\n\nnombres[0] = nombres[0].upper()\nnombres[1] = nombres[1].upper()\nnombres[2] = nombres[2].upper()\nnombres[3] = nombres[3].upper()\nnombres[4] = nombres[4].upper()\n\nprint(\"\\nNombres modificados:\")\nprint(nombres)\n\nNombres originales:\n['julieta', 'facundo', 'emiliano', 'lorenzo', 'victoria']\n\nNombres modificados:\n['JULIETA', 'FACUNDO', 'EMILIANO', 'LORENZO', 'VICTORIA']\n\n\nVemos que realizamos exactamente la misma acción con cada nombre en la lista… ¿No estaría bueno poder automatizarlo?\nY para eso, en esta sección vamos a aprender sobre bucles.",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "5 - Ejecución repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#qué-son-los-bucles",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#qué-son-los-bucles",
    "title": "5 - Ejecución repetitiva",
    "section": "¿Qué son los bucles?",
    "text": "¿Qué son los bucles?\nLos bucles son una estrcutura de los lenguajes de programación que nos permite repetir la ejecución de código de manera automática.\nEn otras palabras, los bucles hacen que sea muy fácil ejecutar el mismo bloque de código una y otra vez.\nA la repetición del mismo bloque de código una y otra vez le decimos iteración. Entonces, los bucles nos ayudan a iterar.\nEn Python tenemos dos tipos de bucles:\n\nEl bucle for (for-loop).\nEl bucle while (while-loop).\n\nLa diferencia entre este tipo de bucles es que con el for conocemos la cantidad de iteraciones que vamos a realizar de antemano.\nEn cambio, con el while no conocemos la cantidad de iteraciones que vamos a realizar de antemano.\nVeamos el ejemplo anterior pero utilizando un bucle for. En este caso, generamos una nueva lista llamada nombres_modificados donde vamos a almacenar los nombres modificados.\n\nnombres = [\"julieta\", \"facundo\", \"emiliano\", \"mariana\", \"victoria\"]\nnombres_modificados = []\n\n# Bucle for\nfor nombre in nombres:\n    nombres_modificados.append(nombre.upper())\n\nprint(\"Nombres originales:\")\nprint(nombres)\n\nprint(\"\\nNombres modificados:\")\nprint(nombres_modificados)\n\nNombres originales:\n['julieta', 'facundo', 'emiliano', 'mariana', 'victoria']\n\nNombres modificados:\n['JULIETA', 'FACUNDO', 'EMILIANO', 'MARIANA', 'VICTORIA']",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "5 - Ejecución repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#el-bucle-for",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#el-bucle-for",
    "title": "5 - Ejecución repetitiva",
    "section": "El bucle for",
    "text": "El bucle for\n\nPresentación\nEn un bucle for encontramos los siguientes componentes.\n\nLa palabra clave for\nEl nombre de una variable que se usa para iterar (variable de iteración)\nLa palabra clave in\nEl objeto sobre el cual iteramos, seguido por :\nEn la siguiente linea y con indentación, el bloque de código a ejecutar\n\n\n\n\n\n\nEn Python, al igual que en las sentencias if, else y otras estructuras de control, los dos puntos (:) se utilizan para indicar el comienzo de un bloque de código, y la indentación define el contenido de ese bloque. Nunca se emplean llaves {} como en otros lenguajes.\nEn el caso de un bucle for, se declara una variable que va tomando, en cada iteración, uno de los valores del iterable que se está recorriendo. Por ejemplo, si el iterable contiene 10 objetos, el bucle ejecutará 10 iteraciones y la variable de iteración (por convención llamada i, aunque puede tener cualquier nombre) irá adoptando esos valores, uno por uno.\n\n\nEjemplos\nDado que a iterar se aprende iterando, veamos algunos ejemplos:\n\nfor i in [3, 1, 2]:\n    print(f\"El número es {i}.\")\n\nEl número es 3.\nEl número es 1.\nEl número es 2.\n\n\nTambién podemos ordenar los valores de la lista sobre la que iteramos:\n\nfor i in sorted([3, 1, 2]):\n    print(f\"El número es {i}.\")\n\nEl número es 1.\nEl número es 2.\nEl número es 3.\n\n\nPero no es necesario iterar sobre listas. De hecho, podemos iterar sobre cualquier secuencia, por ejemplo, una tupla:\n\nfor i in (3, 1, 2):\n    print(f\"El número es {i}.\")\n\nEl número es 3.\nEl número es 1.\nEl número es 2.\n\n\n\nfor i in sorted((3, 1, 2)):\n    print(f\"El número es {i}.\")\n\nEl número es 1.\nEl número es 2.\nEl número es 3.\n\n\nE incluso una cadena de caracteres:\n\nfor c in \"Hola Curso\":\n    print(c)\n\nH\no\nl\na\n \nC\nu\nr\ns\no\n\n\n\n\n\n\n\n\nVariable de iteración\n\n\n\nEl nombre de la variable que se usa para iterar es arbitrario. Sin embargo, es recomendable no utilizar el mismo nombre que el de otra variable en nuestro programa. Por ejemplo:\ni = 1\nfor i in [1, 2, 3]:\n    print(i)\nprint(i)\n1\n2\n3\n3\nLa variable de iteración i va pisando su valor y cualquier valor que esta pudo haber tenido antes.\nAsí, luego de la finalizar el bucle, el valor de i es 3.\n\n\nLos bucles permiten generar nuevos objetos de forma automática.\nEn el siguiente ejemplo, partimos de una lista con cadenas que pueden contener números o letras. Mediante un for, crearemos tres listas: una con los números, otra con el texto y una tercera con los elementos que no sean ninguno de los dos.\n\nlista_original = [\"1\", \"@\", \"x\", \"y\", \"?\", \"3\", \"4\", \"7\", \"f\", \"l\", \"9\", \"10\", \"!\"]\n\n\n# Crear tres listas vacías (que contienen los diferentes tipos de datos)\nnumeros = []\ntexto = []\notros = []\n\n# Iterar a traves de los valores de la lista original\nfor valor in lista_original:\n    # Si es numérico, lo agregamos en la lista 'numeros'\n    if valor.isnumeric():\n        numeros.append(valor)\n    # Sino es numérico, pregunto si es alfabético (o una letra del abecedario)\n    elif valor.isalpha():\n        texto.append(valor)\n    # Caso contrario, lo metemos en la lista de otros\n    else:\n        print(f\"La cadena '{valor}' no es ni numérica ni alfabética.\")\n        otros.append(valor)\n\nprint(lista_original)\nprint(numeros)\nprint(texto)\nprint(otros)\n\nLa cadena '@' no es ni numérica ni alfabética.\nLa cadena '?' no es ni numérica ni alfabética.\nLa cadena '!' no es ni numérica ni alfabética.\n['1', '@', 'x', 'y', '?', '3', '4', '7', 'f', 'l', '9', '10', '!']\n['1', '3', '4', '7', '9', '10']\n['x', 'y', 'f', 'l']\n['@', '?', '!']\n\n\n\n\nCrear listas numéricas con range().\nPython provee una función llamada range() que hace que sea muy fácil generar una secuencia de números. Por ejemplo, podemos usar range() para imprimir una serie de números.\n\nfor i in range(1, 5):\n    print(i)\n\n1\n2\n3\n4\n\n\nrange() funciona de manera similar a los slices, es decir, no incluye el límite superior. Además, si se usa con un solo argumento, es equivalente a range(0, numero).\n\nfor i in range(5):\n    print(i)\n\n0\n1\n2\n3\n4\n\n\nUna forma útil de entender range(n) es verlo como la creación de una secuencia con los primeros n números, comenzando desde 0.\n\nx = range(5)\nprint(x)\nprint(type(x))\n\nrange(0, 5)\n&lt;class 'range'&gt;\n\n\nPodemos obtener una lista a partir de un range usando la función list().\n\nlist(x)\n\n[0, 1, 2, 3, 4]\n\n\nY, por qué no, una tupla también.\n\ntuple(x)\n\n(0, 1, 2, 3, 4)\n\n\nrange() admite un tercer argumento opcional que especifica el paso entre valores. Por defecto es 1. Veamos algunos ejemplos:\nLista de números entre 0 y 10 (no inclusivo), avanzando de a 2 en cada paso.\n\nlist(range(0, 10, 2))\n\n[0, 2, 4, 6, 8]\n\n\nIntento de lista de números entre 10 y 0 (no inclusivo).\n\nlist(range(10, 0))\n\n[]\n\n\nVemos que el resultado no es el esperado. Esto se debe a que el paso es por defecto 1 y es imposible recorrer desde el 10 al 0 sumando de a 1. Si cambiamos el paso a -1, funciona correctamente:\n\nlist(range(10, 0, -1))\n\n[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n\n\n\n\n¿Sobre qué cosas podemos iterar en un bucle for?\nRecordemos el diagrama que vimos anteriormente…\n\n\n\n\n\nEn naranja tenemos resaltado iterable. Pero, ¿qué significa que un objeto sea iterable?\n\nQue podemos iterar a través de el.\nQue podemos recorrerlo elemento por elemento.\nQue puede devolver sus elementos de a uno a la vez.\n\nDe manera similar a las secuencias, el término iterable describe una categoría de tipos de datos. De hecho, todas las secuencias son iterables (por eso podemos recorrer listas, tuplas y cadenas), pero no es requisito ser una secuencia para ser iterable. Por ejemplo, los diccionarios no son secuencias y, sin embargo, pueden recorrerse porque implementan un método para entregar sus elementos de uno en uno.\n\nfor i in {\"a\": 1, \"b\": 2}:\n    print(i)\n\na\nb",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "5 - Ejecución repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#el-bucle-while",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#el-bucle-while",
    "title": "5 - Ejecución repetitiva",
    "section": "El bucle while",
    "text": "El bucle while\nEn un bucle while encontramos los siguientes componentes.\n\nLa palabra clave while.\nUna condición, es decir, una expresión que se evalúa a True o False, seguido por los dos puntos :.\nEn la siguiente linea y con indentación, el bloque de código a ejecutar.\n\n\n\n\n\n\n\nnumero = 0\nwhile numero &lt; 5:\n    numero += 1 # Abreviación de x = x + 1\n    print(f\"El numero es {numero}\")\n\nEl numero es 1\nEl numero es 2\nEl numero es 3\nEl numero es 4\nEl numero es 5\n\n\n\n\n\n\n\nAnalicemos el diagrama:\n\nMientras numero &lt; 5 sea True, Python ejecutará el cuerpo del bucle completo.\nEn la primera iteración, numero es 0.\n\nComo 0 es menor a 5, Python imprime el número y luego le agrega 1, haciendo que el número sea 1.\n\nEn la segunda iteración, numero es 1.\n\nComo 1 es menor a 5, Python imprime el número y luego le agrega 1, haciendo que el número sea 2.\n\n\nEl proceso continúa hasta que numero deja de ser menor que 5, momento en el que el bucle se detiene.\n\n\n\n\n\n\nBucles infinitos ♾️\n\n\n\nVeamos el siguiente ejemplo:\nx = 0\nwhile x &lt; 5:\n    print(x)\nSi ejecutamos este código, Python nunca detendrá su ejecución. Esto sucede porque el valor de x nunca cambia, por lo que la condición x &lt; 5 es siempre verdadera. Este es un caso típico de bucle infinito, algo que puede ocurrir con cualquier while, y en particular con while True si no incluimos una forma de salir del bucle (por ejemplo, con break).\nSi entramos en un bucle infinito, la única forma de detenerlo es interrumpir la ejecución manualmente:\n\nEn la terminal: CTRL + C\nEn un editor de código: usar el botón de interrupción\n\n\n\n\nLa sentencia break\nPython provee la sentencia break que sirve para terminar un bucle (for o while) de manera anticipada.\nVeamos algunos ejemplos de uso.\n\nwhile True:\n    print(\"¡Hola!\")\n    break\n\n¡Hola!\n\n\nEn el ejemplo anterior, la condición del bucle era True, lo que implicaría una ejecución infinita. Sin embargo, al final de la primera iteración encontramos un break, que fuerza la salida del bucle. De forma similar, podemos reescribir el primer while utilizando esta estructura alternativa.\n\nnumero = 0\nwhile True:\n    if numero &gt;= 5:\n        break\n    numero += 1\n    print(f\"El numero es {numero}\")\n\nEl numero es 1\nEl numero es 2\nEl numero es 3\nEl numero es 4\nEl numero es 5\n\n\n\nnumero = 0\nwhile True:\n    numero += 1\n    print(f\"El numero es {numero}\")\n    if numero &gt;= 5:\n        break\n\nEl numero es 1\nEl numero es 2\nEl numero es 3\nEl numero es 4\nEl numero es 5\n\n\nSupongamos que queremos sumar los valores de una lista hasta que se cumpla cierta condición, por ejemplo, que el total sea mayor o igual a 20.\nSi partimos de una lista de números cualquiera, no sabemos de antemano cuántos elementos será necesario sumar. Sin embargo, esto no será un problema si utilizamos la estructura while en combinación con la sentencia break.\n\nsuma = 0\numbral = 20\nvalores = [3, 5, 4, 4, 5, 5, 3, 5, 2, 7]\n\nwhile valores:\n    suma += valores.pop(0)\n    print(suma)\n    if suma &gt;= umbral:\n        break\n\n3\n8\n12\n16\n21\n\n\n\nvalores # valores que no se sumaron\n\n[5, 3, 5, 2, 7]\n\n\nEn el bloque de código anterior puede llamar la atención el uso de\nwhile valores:\nEl bucle while valores: se ejecuta mientras la lista tenga elementos. En cada iteración, .pop(0) extrae el primer elemento, se suma a suma y se imprime el total acumulado. Si en algún momento suma alcanza o supera el umbral, se ejecuta break para detener el bucle aunque aún queden elementos en la lista. Si la lista se vacía antes de llegar al umbral, el bucle también finaliza automáticamente gracias a la condición while valores:.\nUn ejemplo más conciso es el siguiente:\n\nif [1, 2, 3]:\n    print(\"Bloque 'if'\")\nelse:\n    print(\"Bloque 'else'\")\n\nBloque 'if'\n\n\n\nif []:\n    print(\"Bloque 'if'\")\nelse:\n    print(\"Bloque 'else'\")\n\nBloque 'else'\n\n\nAhora supongamos que tenemos una lista de números aleatorios que representan algún conteo.\nEstamos interesados en la cantidad de extracciones que se necesitaron hasta que el conteo supere cierto umbral, por ejemplo, 30.\n\nnumeros_aleatorios = [\n    5, 7, 6, 4, 2, 2, 5, 3, 6, 4, 4, 6, 3, 6, 1,\n    3, 3, 1, 9, 5, 5, 6, 5, 1, 7, 3, 3, 1, 3, 4\n]\n\numbral = 30\n\n# Inicializamos suma y cantidad de iteraciones en 0\nsuma = 0\niteraciones = 0\n\n# Mientras la lista no esté vacía\nwhile numeros_aleatorios:\n    # Agregamos 1 al conteo de iteraciones realizadas\n    iteraciones += 1\n\n    # Extraemos el primer número de la lista y lo sumamos a la suma\n    suma += numeros_aleatorios.pop(0)\n\n    # Si la suma es mayor o igual al umbral, dejamos de iterar\n    if suma &gt;= umbral:\n        break\n\nif suma &gt;= umbral:\n    print(f\"Se superó el umbral de {umbral} en la iteración {iteraciones}, sumando {suma}.\")\nelse:\n    print(f\"La suma de los elementos de la lista no llega a superar {umbral}\")\n\nSe superó el umbral de 30 en la iteración 7, sumando 31.\n\n\n\nSolicitar valores de entrada al usuario\nPython provee una función llamada input() que sirve para solicitar al usuario que ingrese un valor.\n\nEl argumento es el mensaje que se mostrará en pantalla.\nEl tipo de dato que se devuelve es str.\n\n\nnombre = input(\"Ingresa tu nombre: \")\nprint(f\"El nombre ingresado es '{nombre}'\")\n\nEl nombre ingresado es 'Tomi'\n\n\nEsta funcion combinada con el bucle while nos permite generar programas interactivos que solicitan entrada al usuario hasta que se cumple una condición. Por ejemplo, supongamos que queremos solicitar una contraseña que tenga 8 caracteres o más.\n\nwhile True:\n    pwd = input(\"Ingrese su contraseña: \")\n    if len(pwd) &gt;= 8:\n        print(\"¡Muchas gracias!\")\n        break\n    else:\n        print(f\"La contraseña '{pwd}' es corta\")\nprint(f\"La contraseña ingresada es '{pwd}'\")\n\nLa contraseña '' es corta\nLa contraseña 'prueba' es corta\n¡Muchas gracias!\nLa contraseña ingresada es 'prueba 2'\n\n\n\n\n\nLa sentencia continue\nAsí como tenemos la sentencia break que le dice a Python que interrumpa la ejecución de un bucle, tenemos la sentencia continue que le dice que pase a la siguiente iteración sin ejecutar el código a continuación de la misma.\nCuando un programa se encuentra con continue se procede a la siguiente iteración del bucle, re-evaluando la condición del while de ser necesario.\nEn el siguiente ejemplo tenemos una lista con números del 1 al 10 y queremos sumar solamente los números pares.\n\n# Crear lista del 1 al 10\nnumeros = list(range(1, 11))\nprint(numeros)\n\nsuma = 0\nwhile numeros:\n    numero = numeros.pop(0)\n    if numero % 2 != 0:\n        continue\n    suma += numero\n    print(\"Sumando el numero\", numero)\n\nprint(\"La suma es\", suma)\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nSumando el numero 2\nSumando el numero 4\nSumando el numero 6\nSumando el numero 8\nSumando el numero 10\nLa suma es 30\n\n\nEn este programa, si numero % 2 != 0, el continue le indica a Python que debe pasar a la siguiente iteración sin evaluar lo que hay debajo. Por lo tanto, cuando el número es impar, no se ejecuta ni la suma ni el print.\nEste problema se puede resolver también utilizando un bucle for en vez de un bucle while.\n\nnumeros = list(range(1, 11))\nsuma = 0\nfor numero in numeros:\n    if numero % 2 != 0:\n        continue\n    suma += numero\n    print(\"Sumando el numero\", numero)\nprint(\"La suma es\", suma)\n\nSumando el numero 2\nSumando el numero 4\nSumando el numero 6\nSumando el numero 8\nSumando el numero 10\nLa suma es 30",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "5 - Ejecución repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#conclusión",
    "href": "teoria/01_programacion_en_python/05_ejecucion_repetitiva.html#conclusión",
    "title": "5 - Ejecución repetitiva",
    "section": "Conclusión",
    "text": "Conclusión\nCuándo usar un bucle for.\n\nSabemos exactamente, y de antemano, cuantas veces queremos iterar.\nQueremos iterar a través de todos los elementos de un objeto determinado.\n\nCuándo usar un bucle while.\n\nNo sabemos exactamente cuantas veces queremos iterar.\nQueremos iterar hasta que se cumpla (o se deje de cumplir) una condición determinada.",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "5 - Ejecución repetitiva"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html",
    "href": "teoria/01_programacion_en_python/01_introduccion.html",
    "title": "1 - Introducción",
    "section": "",
    "text": "Python es un lenguaje de programación interpretado, de propósito general y de alto nivel. Fue creado por Guido Van Rossum y su primera versión pública fue en el año 1991.\n\nInterpretado: no requiere que realicemos un paso explícito de compilación a lenguaje de máquina antes de ejecutarlo. Además, se puede ejecutar línea por línea.\nPropósito general: no se limita a un tipo de aplicación específica, es decir, se puede usar para implementar programas en diferentes dominios:\n\nVox populi: No es el mejor en casi nada, pero suficientemente bueno para casi todo.\nAlgunos dominios:\n\nAnálisis estadístico y ciencia de datos.\nInteligencia artificial.\nDesarrollo web.\nDesarrollo de videojuegos.\nScripting.\n\n\nAlto nivel: se parece más al lenguaje humano que al lenguaje de las máquinas.\n\nAdemás…\n\nEs gratis: no requiere pagar licencias para usarlo, tanto a nivel personal como comercial.\nEs de código abierto: su código fuente está disponible públicamente y puede ser modificado por cualquiera.\nPosee un ecosistema de librerías completísimo: existen miles de paquetes para todo tipo de tareas.\nComunidad: millones de personas lo usan, contribuyen, resuelven dudas y crean contenido, lo que facilita aprender y encontrar ayuda.\n\nPara utilizar Python es necesario instalar un intérprete de Python. La versión oficial puede ser descargada desde python.org. Una vez instalado el intérprete, es posible ejecutar scripts de Python y programar en Python de manera interactiva desde la terminal.\nEn esta materia se utiliza un editor de código para ciencia de datos llamado Positron. Este editor es desarrollado por Posit, los mismos creadores de RStudio, y permite trabajar tanto con Python como con R.\nLas instrucciones para instalar Python y Positron pueden ser encontradas en Instalación de Python y Positron en Windows.\n\n\n\nEmpecemos utilizando a Python como si fuese una calculadora. Para eso vamos a crear un bloque de código en la notebook y escribimos algunas cuentas tal como lo hacemos en cualquier calculadora.\n\n2 * 3\n\n6\n\n\nNo tenemos la necesidad de pisar el código todo el tiempo. Podemos escribir nuevas celdas de código, y así podemos ir mostrando diferentes cómputos y sus resultados.\n\n100 / 3.5\n\n28.571428571428573\n\n\n\n20 + 5\n\n25\n\n\n\n13 - 3\n\n10\n\n\n\n10 * 5.5\n\n55.0",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "1 - Introducción"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#qué-es-python",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#qué-es-python",
    "title": "1 - Introducción",
    "section": "",
    "text": "Python es un lenguaje de programación interpretado, de propósito general y de alto nivel. Fue creado por Guido Van Rossum y su primera versión pública fue en el año 1991.\n\nInterpretado: no requiere que realicemos un paso explícito de compilación a lenguaje de máquina antes de ejecutarlo. Además, se puede ejecutar línea por línea.\nPropósito general: no se limita a un tipo de aplicación específica, es decir, se puede usar para implementar programas en diferentes dominios:\n\nVox populi: No es el mejor en casi nada, pero suficientemente bueno para casi todo.\nAlgunos dominios:\n\nAnálisis estadístico y ciencia de datos.\nInteligencia artificial.\nDesarrollo web.\nDesarrollo de videojuegos.\nScripting.\n\n\nAlto nivel: se parece más al lenguaje humano que al lenguaje de las máquinas.\n\nAdemás…\n\nEs gratis: no requiere pagar licencias para usarlo, tanto a nivel personal como comercial.\nEs de código abierto: su código fuente está disponible públicamente y puede ser modificado por cualquiera.\nPosee un ecosistema de librerías completísimo: existen miles de paquetes para todo tipo de tareas.\nComunidad: millones de personas lo usan, contribuyen, resuelven dudas y crean contenido, lo que facilita aprender y encontrar ayuda.\n\nPara utilizar Python es necesario instalar un intérprete de Python. La versión oficial puede ser descargada desde python.org. Una vez instalado el intérprete, es posible ejecutar scripts de Python y programar en Python de manera interactiva desde la terminal.\nEn esta materia se utiliza un editor de código para ciencia de datos llamado Positron. Este editor es desarrollado por Posit, los mismos creadores de RStudio, y permite trabajar tanto con Python como con R.\nLas instrucciones para instalar Python y Positron pueden ser encontradas en Instalación de Python y Positron en Windows.\n\n\n\nEmpecemos utilizando a Python como si fuese una calculadora. Para eso vamos a crear un bloque de código en la notebook y escribimos algunas cuentas tal como lo hacemos en cualquier calculadora.\n\n2 * 3\n\n6\n\n\nNo tenemos la necesidad de pisar el código todo el tiempo. Podemos escribir nuevas celdas de código, y así podemos ir mostrando diferentes cómputos y sus resultados.\n\n100 / 3.5\n\n28.571428571428573\n\n\n\n20 + 5\n\n25\n\n\n\n13 - 3\n\n10\n\n\n\n10 * 5.5\n\n55.0",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "1 - Introducción"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#tipos-de-datos",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#tipos-de-datos",
    "title": "1 - Introducción",
    "section": "Tipos de datos",
    "text": "Tipos de datos\nComo cualquier lenguaje de programación, Python ofrece diferentes tipos de datos.\nCada tipo de dato nos ayuda a resolver una tarea distinta. Por ejemplo, si quiero hacer operaciones matemáticas voy a necesitar de números, pero si quiero escribir un correo electrónico voy a necesitar de texto.\nA continuación vamos a introducir los tipos de datos más básicos que Python nos ofrece.\nMás adelante también veremos otros tipos de datos más complejos que nos van a permitir resolver problemas (muchísimo) más interesantes.\n\nNúmeros\nAcabamos de hacer cuentas matemáticas somo si tuvieramos una calculadora. Para eso usamos números, los conocidos de toda la vida.\nSin notarlo, utilizamos dos tipos de números distintos: los números de tipo entero (int) y los números de tipo flotante (float).\nLo siguiente es un número entero:\n\n50\n\n50\n\n\nY el siguiente es un ejemplo de un número flotante:\n\n36.8\n\n36.8\n\n\nUtilizando la función type() Python nos devuelve el tipo del objeto.\n\ntype(10)\n\nint\n\n\n\ntype(10.5)\n\nfloat\n\n\n\ntype(10.0)\n\nfloat\n\n\n\ntype(10.)\n\nfloat\n\n\n\n\n\n\n\n\nObservación 👀\n\n\n\nA diferencia de R, Python no es un lenguaje vectorizado. Por lo tanto, los tipos int y float representan valores escalares, no vectores de longitud 1 como ocurre en R.\nEsta observación aplica a todos los tipos de datos elementales que vienen a continuación.\n\n\n\n\nCadenas de texto\nPara ser una lenguaje de programación tan afamado, Python tiene que ser capaz de trabajar con objetos más complejos que los números.\nUn ejemplo de esto es el texto, que se representa con un objeto llamado cadena de texto y se construyen utilizando comillas.\nComo en la mayoría de los lenguajes de programación, las comillas se ponen al principio y al final del texto e indican el principio y el final de la cadena; estas pueden pueden ser dobles \" o simples '.\n\n\"Programando en Python\"\n\n'Programando en Python'\n\n\n\n'Con comillas simples, también.'\n\n'Con comillas simples, también.'\n\n\nEn Python no hay diferencia entre usar comillas simples ' o dobles \", pero es importante que el tipo de comilla que se usa para abrir la cadena sea el mismo que se usa para cerrarla.\nCuando imprimimos una cadena, las comillas no se muestran en la salida. Para imprimir cualquier objeto de Python utilizamos la función print().\n\nprint('Con comillas simples, ¡también!')\n\nCon comillas simples, ¡también!\n\n\nUna forma un poco más exótica, pero muy útil, de crear cadenas es utilizando comillas triples. Con esta sintaxis, se repiten tres comillas seguidas, lo que permite definir cadenas de texto que ocupan varias líneas.\n\nprint(\"\"\"Se puede escribir texto\nen varias lineas.\n¡Está muy bueno!\"\"\")\n\nSe puede escribir texto\nen varias lineas.\n¡Está muy bueno!\n\n\nOtra manera de escribir texto que abarca múltiples líneas es usando el carácter especial \\n, que representa un salto de línea.\n\nprint(\"Primera línea\\nsegunda línea\\ntercera línea.\")\n\nPrimera línea\nsegunda línea\ntercera línea.\n\n\nEn cambio, si mostramos una representación del texto (sin usar print()), los \\n sí se visualizan.\n\n\"Primera línea\\nsegunda línea\\ntercera línea.\"\n\n'Primera línea\\nsegunda línea\\ntercera línea.'\n\n\n\n\n\n\n\n\n¡Atención! 🤓\n\n\n\n¿Cuál es la diferencia entre usar print() y no usarlo?\n\nCuando usamos print() se imprime el objeto de una manera humanamente legible.\nCuando no lo usamos, se muestra una representación del objeto. Esta representación tiene que ser lo menos ambigua posible.\n\nPor este motivo es que se muestran las comillas a la hora de representar una cadena.\n\n\n\n\nOtra situación en la que usar print() genera una diferencia es cuando se quieren mostrar varios objetos en una notebook. Por ejemplo, comparemos el resultado de los siguientes bloques:\n\n\"mensaje 1\"\n10\n\"mensaje 2\"\n\n'mensaje 2'\n\n\n\nprint(\"mensaje 1\")\nprint(10)\nprint(\"mensaje 2\")\n\nmensaje 1\n10\nmensaje 2\n\n\n\n\nLógicos (o Booleanos)\nComo veremos más adelante, nuestros programas suelen tener que decidir entre diferentes acciones a tomar según se cumpla o no cierta condición.\nPara representar esta situación utilizamos un tipo especial de dato conocido como lógico o booleano, que puede tomar únicamente dos valores: True o False.\nSi la condición se cumple, el resultado será True; de lo contrario, será False.\n\nTrue\n\nTrue\n\n\n\nFalse\n\nFalse\n\n\n\ntype(True)\n\nbool\n\n\n\ntype(False)\n\nbool\n\n\n\n\n\n\n\n\nReseña histórica 📜\n\n\n\nEste tipo de datos se llama Booleano en honor al matemático George Boole.\n\n\n\n\nNulo\nEl valor nulo, llamado None en Python, representa la ausencia de valor o el vacío. Se utiliza habitualmente para indicar que algo no tiene un valor asignado. Si intentamos mostrar el valor de None, veremos que no aparece nada.\n\nNone\n\nEn cambio, si imprimimos el objeto None, vemos el mensaje None.\n\nprint(None)\n\nNone\n\n\n¿Y cuál es su tipo?\n\ntype(None)\n\nNoneType\n\n\nSolamente los objetos None son del tipo NoneType.\n\n\n\n\n\n\n¿Por qué existe el valor nulo? 🤔\n\n\n\nMuchas veces nuestro programa, o alguna parte del mismo, realiza una tarea que no devuelve ningún resultado.\nPodríamos ponernos de acuerdo en representar “ningún resultado” usando un número (e.g., 0), una cadena vacía (\"\"), o algo similar. Pero estos valores representan algo específico, no la ausencia total de valor.\nPara expresar claramente que no hay ningún resultado, Python incluye un valor especial llamado None.\n\n\nEjemplos\n\nUn usuario completa un formulario con datos personales, pero algunos campos no son obligatorios y quedan sin completar.\nUna función busca un elemento en una lista; cuando no encuentra lo buscado, devuelve un valor especial indicando que el resultado está ausente.\n\nEn general, cuando se quiera representar la ausencia de información se utilizará None.\n\n\n\n\n\n\nObservación 👀\n\n\n\nEn R existen dos tipos de datos para representar valores faltantes: NULL y NA. El None de Python equivale a NULL en R, ya que ambos indican ausencia de valor.\nPor otro lado, NA en R representa un valor existente pero desconocido, por ejemplo, porque se ha perdido. Python no ofrece un tipo de dato equivalente de forma nativa, aunque algunas librerías sí lo implementan.\n\n\n\n\nConversión entre tipos de datos\nQue existan distintos tipos de datos no significa que un objeto de un tipo no pueda “convertirse” a otro.\nEn muchos casos es posible convertir entre tipos de datos. Por ejemplo, un número siempre se puede convertir a una cadena de caracteres, pero no cualquier cadena puede convertirse a un número.\nPara convertir un objeto a otro tipo utilizamos funciones con el nombre del tipo al que queremos convertir, como str(), int() o bool(). Estas funciones reciben como argumento el objeto a convertir.\nVeamos algunos ejemplos:\n\nstr(256)\n\n'256'\n\n\n\nstr(None)\n\n'None'\n\n\n\nint(165.5)\n\n165\n\n\n\nint(165.8)\n\n165\n\n\n\nint(\"165\")\n\n165\n\n\n\nfloat(\"165.0\")\n\n165.0\n\n\n\n\nResumen\n\nPython tiene distintos tipos de datos.\nCada tipo de dato es útil para resolver diferentes problemas.\n\nA lo largo de la materia veremos muchísimos ejemplos.\n\nAl principio, tener varios tipos de datos puede parecer complejo.\n\nSin embargo, nos resultarán muy naturales a medida que los usemos para resolver problemas concretos.\n\n\n\n\n\n\n\n\n\nTipo de dato\nEjemplos\n\n\n\n\nNúmeros enteros (int)\n-2, -1, 0, 10, 200\n\n\nNúmeros de punto flotante (float)\n-200.789, -1.0, 0.0, 17.8\n\n\nCadenas de texto (str)\n\"a\", \"abc\", \"Rosario, Santa Fe\"\n\n\nBooleanos (bool)\nTrue, False\n\n\nValor nulo (NoneType)\nNone",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "1 - Introducción"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#variables",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#variables",
    "title": "1 - Introducción",
    "section": "Variables",
    "text": "Variables\n¿Es necesario escribir explícitamente los valores con los que trabajamos cada vez que los usamos? Afortunadamente, la respuesta es no.\nLos lenguajes de programación más populares permiten usar variables.\nPodemos pensar las variables como etiquetas o nombres que asignamos a los objetos en nuestro programa.\nUna vez creada una variable con cierto valor, podemos usar directamente su nombre en lugar de volver a escribir el valor completo.\n\nmensaje = \"¡Hola, curso!\"\nprint(mensaje)\n\n¡Hola, curso!\n\n\n\nprint(\"¡Hola, curso!\")\n\n¡Hola, curso!\n\n\nPara crear una variable se necesita:\n\nEl nombre.\nEl operador de asignación.\nEl valor que queremos asignar a la variable.\n\nEn nuestro caso, el nombre de la variable es mensaje y el valor es \"¡Hola, curso!\".\nLuego, cuando accedemos a la variable mensaje dentro de la función print(), Python nos devuelve el valor de la variable, es decir, ¡Hola, curso!\".\nVeamos otros ejemplos…\n\npi = 3.14159\nfruta_favorita = \"manzana\"\npython_bueno = True\n\nEn el siguiente diagrama se muestra cómo las variables que creamos funcionan simplemente como etiquetas para los valores asignados.\nCada vez que utilizamos una de estas etiquetas, accedemos directamente al valor que representa.\n\n\n\n\n\n\nprint(pi * 10)\n\n31.4159\n\n\n\nfruta_favorita\n\n'manzana'\n\n\n\npython_bueno\n\nTrue\n\n\nLas variables no solo evitan que escribamos repetidamente los mismos valores en nuestro programa, sino que también permiten:\n\nGeneralizar el programa\n\nAl cambiar el valor de una variable, todas las partes del programa que la usan se actualizan automáticamente.\n\nMejorar la legibilidad del código\n\nSi elegimos nombres claros y descriptivos, el programa será mucho más fácil de leer y entender.\n\n\nPor ejemplo, los siguientes bloques de código producen el mismo resultado, pero el segundo es mucho más informativo:\n\n1500 * 8\n\n12000\n\n\n\nprecio = 1500\ncantidad = 8\nprecio * cantidad\n\n12000\n\n\n\nNombres permitidos\nNo todos los nombres que imaginemos se pueden utilizar como variables en Python.\nTenemos que tener en cuenta las siguientes reglas. Los nombres de variables…\n\nSolo pueden contener letras, números y guiones bajos (_).\nDeben comenzar con una letra o un guión bajo, pero no con un número.\n\nPor ejemplo, mensaje_1 es válido, pero 1_mensaje no lo es.\n\nNo pueden contener espacios.\n\nPor eso usamos fruta_favorita en lugar de fruta favorita.\n\nNo pueden ser palabras reservadas de Python.\n\nLas palabras reservadas se encuentran al final de este apunte.\n\n\nAdemás, también vale la pena tener presente estos consejos:\n\nUsá nombres breves pero descriptivos.\n\nnombre es preferible a n.\nfruta_favorita es preferible a frut_fav.\n\nEvitá utilizar tildes, la letra ñ u otros caracteres específicos del castellano.\n\n\n\nEliminar variables\nEs posible que, después de crear nuestras variables y realizar las operaciones necesarias, queramos eliminarlas.\nPara borrar una variable, Python ofrece la sentencia del (del inglés delete, que significa eliminar o borrar).\n\ndel fruta_favorita\n\n\n\nAsignación múltiple\nYa vimos que para asignar (o crear) una variable necesitamos hacer variable = &lt;valor&gt;.\nSi queremos crear varias variables, podemos hacerlo en líneas separadas:\n\npi = 3.1416\ne = 2.7182\n\nprint(pi)\nprint(e)\n\n3.1416\n2.7182\n\n\nUna característica conveniente de Python es que permite asignar múltiples variables en una misma línea:\n\npi, e = 3.1416, 2.7182\n\nprint(pi)\nprint(e)\n\n3.1416\n2.7182\n\n\nOtra ventaja es que las variables no tienen que ser del mismo tipo:\n\na, b, c = 100 + 20, \"un mensaje cualquiera\", None\n\nprint(a)\nprint(b)\nprint(c)\n\n120\nun mensaje cualquiera\nNone\n\n\nEsta técnica es útil para escribir código más conciso, pero no conviene abusar de ella porque puede resultar en código poco legible.\n\n\n\n\n\n\nObservación 👀\n\n\n\nLa vida es más compleja de lo que parece, y los lenguajes de programación no son una excepción.\nEn Python, lo que parece una asignación múltiple de variables es en realidad el uso de una técnica más avanzada llamada unpacking.\nA no desesperarse, más adelante vamos a aprender de qué se trata.",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "1 - Introducción"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#operadores",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#operadores",
    "title": "1 - Introducción",
    "section": "Operadores",
    "text": "Operadores\nLos operadores son símbolos que se utilizan para realizar operaciones o acciones sobre los objetos con los que estamos trabajando.\nHasta ahora, vimos que podemos tener números, texto, y otras objetos un poco mas extraños como los booleanos e incluso algo que representa a la nada misma.\nA continuación, comenzamos a ver algunas de las tareas que podemos hacer con ellos.\n\nOperadores aritméticos\nPython incluye los mismos operadores aritméticos que solemos utilizar en nuestro día a día para hacer operaciones matemáticas.\nEstos se parecen muchísimo a los que usamos en una calculadora, por lo que podríamos entenderlo incluso sin saber de Python.\nAlgunos operadores son los siguientes:\n\nSuma (+)\nResta (-)\nMultiplicación (*)\nPotencia (**)\nDivisión (/)\nDivisión entera (//)\nMódulo (%)\n\n\nSuma (+)\n\n10 + 25\n\n35\n\n\n\n10.0 + 25.0\n\n35.0\n\n\n\n-8 + 12.1\n\n4.1\n\n\nEl operador suma también puede ser usado con un solo argumento:\n\n+ 8\n\n8\n\n\nEn este caso no modifica en nada al valor 8.\n\n\n\nResta (-)\n\n11 - 8\n\n3\n\n\n\n100 - 100.0\n\n0.0\n\n\n\n-35 - 28\n\n-63\n\n\nEl operador resta también puede ser usado con un solo argumento:\n\n- 7\n\n-7\n\n\n\n\nMultiplicación (*) y potencia (**)\n\n21 * 5\n\n105\n\n\n\n21 * 5.0\n\n105.0\n\n\n\n21.0 * 5.0\n\n105.0\n\n\n\n2 ** 3\n\n8\n\n\n\n2 ** 3.0\n\n8.0\n\n\n\n\n\n\n\n\nConclusiones\n\n\n\nPara las operaciones de suma, resta, multiplicación y potencia se cumple:\n\nSi ambos valores son enteros, el resultado será un entero.\nSi al menos uno de los valores es flotante, el resultado será flotante.\n\n\n\n\n\nDivisión (/ y //)\nPython provee dos operadores distintos para calcular el cociente entre dos números.\n\nEl operador / que calcula la división flotante.\nEl operador // que calcula la división entera.\n\nEl operador / es el que más se utiliza y siempre devuelve un número de tipo flotante.\n\n10 / 5\n\n2.0\n\n\n\n10 / 5.5\n\n1.8181818181818181\n\n\nLa división entera se suele utilizar cuando uno quiere el resultado entero de la división, sin importar si el resto es 0 o no.\n\n10 // 5\n\n2\n\n\n\n10 // 5.5\n\n1.0\n\n\nVeamos los siguientes ejemplos donde comparamos la división flotante con la división entera, utilizando los mismos argumentos.\n\n15 / 4\n\n3.75\n\n\n\n15.0 // 4.0\n\n3.0\n\n\nConclusión: La división entera no redondea el resultado de la división flotante. Más sobre esto debajo.\n\n\nMódulo (%)\nOtro operador relacionado a la división entera es el operador módulo o resto (%).\nEsta operación nos devuelve el resto que se obtiene al realizar la división entera entre dos números.\n\n17 % 3\n\n2\n\n\nDebajo se puede ver la relación entre la división entera y el módulo:\n\n\n\n\n\nAunque ahora pueda parecer difícil encontrar una aplicación práctica para los operadores de división entera // y resto %, más adelante veremos ejemplos donde haremos un uso intensivo de ellos.\n\n\n\n\n\n\nObservación 👀\n\n\n\nProbablemente en R hayan utilizado principalmente el operador /, que también corresponde a la división flotante.\nEn ese lenguaje, los operadores para división entera y resto son %/% y %%, respectivamente.\n\n\n\n\nPrioridad de los operadores\nHasta ahora vimos operaciones bastante sencillas.\nCuando presentamos la suma, realizamos simplemente una suma. Cuando presentamos la multiplicación, hicimos solo una multiplicación.\nPor supuesto, al momento de hacer cálculos podemos combinar los operadores que ya conocemos, de la misma forma en que lo hacemos al resolver cuentas a mano.\nUn punto importante a tener en cuenta es que, al igual que cuando hacemos cuentas a mano, algunas operaciones se resuelven antes que otras, sin importar el orden en que aparecen. Esto ocurre porque algunos operadores tienen mayor prioridad y, por lo tanto, se evalúan antes.\nEn el siguiente ejemplo, ¿por qué se obtienen resultados distintos?\n\n10 - 2 * 4\n\n2\n\n\n\n(10 - 2) * 4\n\n32\n\n\nIndependientemente de que el símbolo + aparezca antes que el símbolo * en una expresión, Python realiza primero la multiplicación.\nAl igual que cuando hacemos cuentas a mano, la multiplicación tiene mayor prioridad que la suma.\nSi queremos forzar a Python a realizar una operación antes que otra, sin importar la prioridad de los operadores, debemos usar paréntesis.\nOtro ejemplo es el siguiente…\n\n7 + 8 / 2\n\n11.0\n\n\n\n(7 + 8) / 2\n\n7.5\n\n\nA continuación se incluye una tabla con los operadores que vimos y la prioridad que tiene cada uno.\nLos operadores que aparecen más arriba tienen mayor prioridad.\nLos operadores que aparecen en la misma fila tienen el mismo nivel de prioridad y se resuelven según el orden en que aparecen en el código (de izquierda a derecha).\n\n\n\n\n\n\n\nOperador\nSignificado\n\n\n\n\n()\nAgrupamiento\n\n\n**\nPotencia\n\n\n*, /, //, %\nMultiplicación, División, División entera, Módulo\n\n\n+, -\nSuma, Resta\n\n\n\nEsta lista es una versión más sencilla y resumida de la tabla de prioridades de todos los operadores que hay en Python. Una versión más completa se puede encontrar en Programiz.\n\n\n\nOperadores lógicos\nLos operadores lógicos en Python son tres: not, and y or. Se llaman así porque combinan expresiones lógicas (o directamente valores lógicos) y devuelven también valores lógicos, es decir, del tipo bool, que pueden ser True o False. Estos operadores se utilizan para combinar o invertir condiciones en expresiones lógicas.\n\nNegación (not)\nDevuelve el opuesto del valor que le pasamos.\n\nnot False\n\nTrue\n\n\n\nnot True\n\nFalse\n\n\n\n\nConjunción o intersección (and)\nEsta operación devuelve True solamente cuando los dos operadores que le pasamos son True.\n\nTrue and True\n\nTrue\n\n\n\nFalse and True\n\nFalse\n\n\n\n\nDisyunción o unión (or)\nEsta operación devuelve True cuando cualquiera de sus argumentos es True.\n\nTrue or False\n\nTrue\n\n\nSolo devuelve False cuando sus dos argumentos son False.\n\nFalse or False\n\nFalse\n\n\n\n\n\nOperadores de comparación\n\nComparación por identidad\nPython ofrece dos operadores para verificar si dos objetos son o no el mismo en identidad (es decir, en memoria):\n\nis: devuelve True si ambos operandos son el mismo objeto.\nis not: devuelve True si los operandos no son el mismo objeto.\n\n\nFalse is False\n\nTrue\n\n\n\nFalse is True\n\nFalse\n\n\n\nNone is None\n\nTrue\n\n\nEste tipo de comparación es posible porque cada objeto en Python existe en la memoria de la computadora y tiene una identificación única (ID). Para conocer el ID de un objeto, se puede usar la función id().\n\nid(False)\n\n94152411564800\n\n\n\nid(False)\n\n94152411564800\n\n\n\nid(None)\n\n94152411476128\n\n\n\n\nComparación por valor\nPor otro lado, Python también provee operadores para realizar comparaciones entre objetos en términos de sus valores.\nLos operadores que vemos a continuación son los mismos que aprendimos en la secundaria.\n\n\n\n\n\n\n\nOperador\nDescripción\n\n\n\n\n==\nIgualdad: El resultado es True cuando los dos operandos son iguales.\n\n\n!=\nDesigualdad: El resultado es True si los operandos son distintos.\n\n\n&gt;\nMayor a: El resultado es True si el operando de la izquierda es mayor que el de la derecha.\n\n\n&gt;=\nMayor o igual a: El resultado es True si el operando de la izquierda es mayor o igual que el de la derecha.\n\n\n&lt;\nMenor a: El resultado es True si el operando de la izquierda es menor que el de la derecha.\n\n\n&lt;=\nMenor o igual a: El resultado es True si el operando de la izquierda es menor o igual que el de la derecha.\n\n\n\nAlgunos ejemplos…\n\n10 &gt; 5\n\nTrue\n\n\n\n10 &gt; 5 + 3\n\nTrue\n\n\n\n0 &lt; 0\n\nFalse\n\n\n\n1 &gt;= 1\n\nTrue\n\n\n\n10.0 != 10\n\nFalse\n\n\n\n10.0 == 10\n\nTrue\n\n\nA pesar de que 10.0 es de tipo flotante y 10 es de tipo entero, vemos que la comparación de igualdad == dice que son iguales.\nNo siempre que comparemos objetos de distinto tipo va a suceder algo así.\nLa comparación de cadenas de texto distingue mayúsculas de minúsculas\n\n\"UNR\" == \"unr\"\n\nFalse\n\n\nEs posible comparar objetos de distinto tipo, como lo vimos en el ejemplo anterior donde comparamos 10 y 10.0.\nSalvo casos particulares, como son los valores numéricos, estos objetos son considerados siempre distintos.\n\n\"10\" == 10\n\nFalse\n\n\n\n\"False\" == False\n\nFalse\n\n\nEs posible combinar mas de una comparación en la misma línea.\n\n1 &lt; 2 and 2 &lt; 3\n\nTrue\n\n\nIncluso es posible omitir el operador and y tener una expresión más clara\n\n1 &lt; 2 &lt; 3\n\nTrue\n\n\n\n-5 &lt; -4 &lt; -3\n\nTrue\n\n\nTambién podemos mezclar not, and y or a gusto.\n\nFalse or not False\n\nTrue\n\n\nY es válido utilizar paréntesis para agrupar operaciones.\n\n(False or True) and (True or False)\n\nTrue\n\n\nA continuación se incluye una tabla con los operadores de comparación y la prioridad que tiene cada uno.\nLos operadores que aparecen más arriba tienen mayor prioridad.\nLos operadores que aparecen en la misma fila tienen el mismo nivel de prioridad y se resuelven según el orden en que aparecen en el código (de izquierda a derecha).\n\n\n\n\n\n\n\nOperadores\nSignificado\n\n\n\n\n==, !=, &gt;, &gt;=, &lt;, &lt;=, is, is not, in, not in\nComparaciones, identidad, pertenencia\n\n\nnot\nNegación\n\n\nand\nConjunción o intersección\n\n\nor\nDisyunción o unión\n\n\n\nTodos los operadores de comparación tienen menor prioridad que los operadores aritméticos que vimos arriba.\nEn otras palabras, si pegaramos ambas tablas, ésta última quedaría por debajo.\nAnalicemos nuevamente uno de los ejemplos que ya vimos.\n\nnot True and not True\n\nFalse\n\n\nEl operador not tiene mayor prioridad que el operador and porque aparece primero en la tabla.\nEn consecuencia, en el código anterior primero se resuelven los not True y luego el and. Esto es lo mismo que hacer\n\nFalse and False\n\nFalse\n\n\n\n\n\n\n\n\nResumen 📝\n\n\n\nExisten dos operadores para comparar igualdad entre dos objetos de Python:\n\n== → compara el valor (contenido).\nis → compara la identidad (ubicación en memoria).",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "1 - Introducción"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#operaciones-con-cadenas-de-caracteres",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#operaciones-con-cadenas-de-caracteres",
    "title": "1 - Introducción",
    "section": "Operaciones con cadenas de caracteres",
    "text": "Operaciones con cadenas de caracteres\n\nSuma y producto\nAunque al principio pueda parecer extraño, en Python es posible usar operadores matemáticos con objetos que no son numéricos.\nEsto no significa que se puedan aplicar a cualquier objeto, ni que estén disponibles todos los operadores en esos casos.\nSin embargo, vale la pena resaltar el uso del operador de suma (+) y producto (*) con las cadenas de caracteres.\nVeamos que pasa si “sumamos” dos cadenas de caracteres:\n\n\"¿Funciona\" + \"bien?\"\n\n'¿Funcionabien?'\n\n\n\n\"¿esto\" + \" también \" + \"funciona?\"\n\n'¿esto también funciona?'\n\n\nComo se puede observar, el operador de suma (+) aplicado a cadenas de texto indica concatenación: crea una nueva cadena uniendo el contenido de las cadenas originales, en el mismo orden.\nSi la suma tiene sentido para cadenas, entonces el producto también debería tenerlo (al menos con números enteros). Veamos un ejemplo:\n\n\"ja\" * 2\n\n'jaja'\n\n\n\n\"ja\" * 4\n\n'jajajaja'\n\n\nDe manera coherente con la definición de producto para enteros, multiplicar una cadena por un número entero N equivale a concatenar esa cadena consigo misma N veces.\n\n\nCadenas formateadas (formatted strings)\nLas cadenas de texto formateadas son de gran utilidad para crear una cadena de texto a partir de otros objetos.\nEn Python se las conoce como f-strings (abreviación de formatted-strings) y tienen este nombre porque tenemos que poner una f antes de las comillas.\nEl resultado de una f-string no se diferencia de una cadena de texto común y corriente.\n\nf\"Un texto cualquiera\"\n\n'Un texto cualquiera'\n\n\nSin embargo, las f-strings nos permiten interpolar cadenas de texto.\n¿Qué es interpolar texto?\nVeamos algunos ejemplos.\n\nlenguaje = \"Python\"\nprint(\"Programando en \" + lenguaje)\n\nProgramando en Python\n\n\n\nque = \"bayer\"\ncomo = \"bueno\"\nprint(\"Si es \" + que + \" es \" + como + \".\")\n\nSi es bayer es bueno.\n\n\nEl proceso se vuelve un poco engorroso. Hay que estar atentos a las sumas y los espacios para que el resultado quede formateado de una manera correcta.\nLas f-strings vienen a facilitar este proceso y hacerlo menos tedioso.\nLo que tenemos que hacer es pasar el nombre de la variable entre llaves ({}) en el contenido de la f-string.\n\nprint(f\"Programando en {lenguaje}\")\nprint(f\"Si es {que} es {como}.\")\n\nProgramando en Python\nSi es bayer es bueno.\n\n\nVeamos un ejemplo menos trivial, donde utilizar f-strings reduce la cantidad de código y lo hace más claro.\n\nnombre = \"Tomás\"\nedad = 29\nciudad = \"Rosario\"\n\nprint(\"Hola, soy \" + nombre + \", tengo \" + str(edad) + \" años y vivo en \" + ciudad + \".\")\n\nHola, soy Tomás, tengo 29 años y vivo en Rosario.\n\n\nUtilizando f-strings…\n\nprint(f\"Hola, soy {nombre}, tengo {edad} años y vivo en {ciudad}.\")\n\nHola, soy Tomás, tengo 29 años y vivo en Rosario.\n\n\nAdemás, no es necesario convertir la variable edad a al tipo str manualmente.\nNo solo podemos utilizar variables dentro de las f-strings, también podemos incluir expresiones de Python.\n\nminutos_por_hora = 60\nhoras = 2.7\n\nprint(f\"En {horas} horas hay {horas * minutos_por_hora} minutos.\")\n\nEn 2.7 horas hay 162.0 minutos.\n\n\n\n\nCadenas de texto y sus metódos\n\nnombre = \"Lionel Messi\"\n\nLas cadenas de texto, es decir, los objetos de tipo str, vienen con varias funciones (llamados “métodos”) que nos facilitan muchísimas tareas en la práctica.\nPor ejemplo, tenemos los métodos .upper() y .lower(), que ponen el texto en mayúscula y en minúscula, respectivamente.\n\nprint(nombre.upper())\nprint(nombre.lower())\n\nLIONEL MESSI\nlionel messi\n\n\nTambién tenemos .capitalize(), que pone la primer letra en mayúscula y el resto en minúsculas.\nEstos métodos se pueden combinar dentro de una f-string, sin necesidad de modificar los valores de nombre o apellido.\n\nnombre = \"lionel\"\napellido = \"messi\"\nnombre_completo = f\"{nombre.capitalize()} {apellido.capitalize()}\"\nprint(nombre_completo)\n\nLionel Messi\n\n\nOtra opción es usar .title().\nEste método pone la primera letra de cada palabra en mayúsculas y al resto en minúsculas.\n\nmensaje = \"mensaje de prueba\"\nprint(mensaje.capitalize())\nprint(mensaje.title())\n\nMensaje de prueba\nMensaje De Prueba\n\n\n\n\nEliminar espacios en blanco\nEs muy común que en nuestros programas tengamos que lidiar con texto que vienen con espacios en blanco que están demás.\nEl espacio puede estar tanto al principio como al final de una cadena de texto.\nAfortunadamente, Python también provee algunos métodos que nos permiten eliminar estos espacios con muy poco trabajo.\n\nlenguaje_favorito = \"  python  \"\nlenguaje_favorito\n\n'  python  '\n\n\n.rstrip() elimina los espacios en blanco a la derecha del texto.\n\nlenguaje_favorito.rstrip()\n\n'  python'\n\n\n.lstrip() elimina los espacios en blanco a la izquierda del texto.\n\nlenguaje_favorito.lstrip()\n\n'python  '\n\n\ny .strip() elimina los espacios en blanco a la izquierda y a la derecha del texto.\n\nlenguaje_favorito.strip()\n\n'python'\n\n\n\n\nReemplazar y eliminar caracteres no deseados\nTambién es frecuente que el texto contenga caracteres erróneos, o caracteres que simplemente no queremos conservar.\nPara estos casos podemos usar el método .replace().\nA diferencia de los métodos que vimos hasta ahora, .replace() requiere que le pasemos algunos argumentos.\nEl primer valor que le pasamos es el texto que queremos reemplazar y el segundo es el texto de reemplazo.\nPodemos reemplazar caracteres, palabras, o frases enteras.\n\nanimal = \"pato\"\nanimal.replace(\"p\", \"g\")\n\n'gato'\n\n\n\nsaludo = \"Hola Mundo\"\nsaludo.replace(\"Mundo\", \"Curso\")\n\n'Hola Curso'\n\n\nCuando utilizamos el método .replace() se nos devuelve una nueva cadena de texto.\nEsto nos permite “pegar” o “encadenar” mas de un .replace() a la vez, ya que cada nuevo .replace() se aplica sobre el resultado de la operación anterior.\n\nsaludo.replace(\"Mundo\", \"Curso\").replace(\"Hola\", \"Chau\")\n\n'Chau Curso'\n\n\nsaludo.replace(\"Mundo\", \"Curso\") devuelve \"Hola Curso\", al que luego se le aplica .replace(\"Hola\", \"Chau\") y el resultado final es \"Chau Curso\".",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "1 - Introducción"
    ]
  },
  {
    "objectID": "teoria/01_programacion_en_python/01_introduccion.html#apéndice",
    "href": "teoria/01_programacion_en_python/01_introduccion.html#apéndice",
    "title": "1 - Introducción",
    "section": "Apéndice",
    "text": "Apéndice\n\nPalabras claves y funciones predefinidas\nPython tiene un conjunto de palabras conocidas como keywords que sirven para realizar acciones especificas y que no podemos utilizar como nombres de variables.\nCuando intentemos utilizar una keyword como nombre de variable, obtendremos un error.\nPor otro lado, si intentamos utilizar el nombre de una función (o clase) predefinida como nombre de una variable que nosotros creamos, no vamos a obtener un error pero no podremos usar la función nuevamente porque la variable ahora representa otra cosa.\n\nPalabras claves\nFalse      await      else       import     pass\nNone       break      except     in         raise\nTrue       class      finally    is         return\nand        continue   for        lambda     try\nas         def        from       nonlocal   while\nassert     del        global     not        with\nasync      elif       if         or         yield\n\n\nFunciones y clases pre-definidas\nabs()          copyright()    getattr()      list()         range()        vars()\nall()          credits()      globals()      locals()       repr()         zip()\nany()          delattr()      hasattr()      map()          reversed()\nascii()        dict()         hash()         max()          round()\nbin()          dir()          help()         memoryview()   set()\nbool()         display()      hex()          min()          setattr()\nbreakpoint()   divmod()       id()           next()         slice()\nbytearray()    enumerate()    input()        object()       sorted()\nbytes()        eval()         int()          oct()          staticmethod()\ncallable()     exec()         isinstance()   open()         str()\nchr()          filter()       issubclass()   ord()          sum()\nclassmethod()  float()        iter()         pow()          super()\ncompile()      format()       len()          print()        tuple()\ncomplex()      frozenset()    license()      property()     type()\n\n\nMétodos de las cadenas de texto\n\n\n\n\n\n\n\n\n\nMétodo\nDescripción\nEjemplo\nResultado\n\n\n\n\n.endswith(sufijo)\nVerifica si termina con el sufijo\n\"file.txt\".endswith(\".txt\")\nTrue\n\n\n.find(x)\nLa posicion de la primera aparición de x en la cadena (o -1 si no está)\n\"Python\".find(\"t\")\n2\n\n\n.index(x)\nLa posicion de la primera aparición de x en la cadena (error si no está)\n\"Python\".index(\"n\")\n5\n\n\n.isalpha()\nVerifica si los caracteres son alfabéticos\n\"256\".isalpha()\nFalse\n\n\n.isdigit()\nVerifica si los caracteres son numéricos\n\"256\".isdigit()\nTrue\n\n\n.islower()\nVerifica si los caracteres son minúsculas\n\"Python\".islower()\nFalse\n\n\n.isupper()\nVerifica si los caracteres son mayúsculas\n\"Python\".isupper()\nFalse\n\n\n.join(lista)\nUne una lista de cadenas usando la cadena como delimitador\n\" y \".join([\"esto\", \"aquello\"])\n\"esto y aquello\"\n\n\n.lower()\nConvertir a minúsculas\n\"Python\".lower()\n\"python\"\n\n\n.replace(viejo, nuevo)\nReemplaza texto\n\"maximo\".replace(\"ax\", \"in\")\n\"minimo\"\n\n\n.split(sep)\nParte la cadena en una lista de subcadenas\n\"esto y aquello\".split(\" y \")\n[\"esto\", \"aquello\"]\n\n\n.startswith(prefijo)\nVerifica si comienza con un prefijo\n\"file.txt\".endswith(\"a\")\nFalse\n\n\n.strip()\nElimina espacios en blanco al inicio o al final\n\" oh la la \".strip()\n\"oh la la\"\n\n\n.upper()\nConvierte a mayúsculas\n\"Python\".upper()\n\"PYTHON\"",
    "crumbs": [
      "Teoría",
      "U1 - Programación en Python",
      "1 - Introducción"
    ]
  },
  {
    "objectID": "teoria/03_oop/02_encapsulamiento.html",
    "href": "teoria/03_oop/02_encapsulamiento.html",
    "title": "2 - Encapsulamiento",
    "section": "",
    "text": "Los tres principios fundamentales de la programación orientada a objetos son la encapsulación, la herencia y el polimorfismo.\nA lo largo de los próximos apuntes vamos a explorar cada uno en detalle, entendiendo los conceptos que los sustentan y analizando ejemplos concretos de cómo se aplican en Python. En líneas generales, estos principios se pueden describir de la siguiente manera:\n\nEncapsulación: consiste en reunir en un mismo lugar tanto los datos como las operaciones que actúan sobre ellos, ocultando los detalles internos y exponiendo únicamente la interfaz necesaria para interactuar con el objeto.\nHerencia: permite crear nuevas clases a partir de otras ya existentes, reutilizando su comportamiento y ampliándolo o modificándolo según sea necesario.\nPolimorfismo: hace posible que diferentes objetos de diferentes clases respondan de forma distinta a un mismo “mensaje” (por ejemplo, un método con el mismo nombre), adaptando el comportamiento a las particularidades de cada caso.",
    "crumbs": [
      "Teoría",
      "U3 - Programación Orientada a Objetos",
      "2 - Encapsulamiento"
    ]
  },
  {
    "objectID": "teoria/03_oop/02_encapsulamiento.html#prefacio",
    "href": "teoria/03_oop/02_encapsulamiento.html#prefacio",
    "title": "2 - Encapsulamiento",
    "section": "",
    "text": "Los tres principios fundamentales de la programación orientada a objetos son la encapsulación, la herencia y el polimorfismo.\nA lo largo de los próximos apuntes vamos a explorar cada uno en detalle, entendiendo los conceptos que los sustentan y analizando ejemplos concretos de cómo se aplican en Python. En líneas generales, estos principios se pueden describir de la siguiente manera:\n\nEncapsulación: consiste en reunir en un mismo lugar tanto los datos como las operaciones que actúan sobre ellos, ocultando los detalles internos y exponiendo únicamente la interfaz necesaria para interactuar con el objeto.\nHerencia: permite crear nuevas clases a partir de otras ya existentes, reutilizando su comportamiento y ampliándolo o modificándolo según sea necesario.\nPolimorfismo: hace posible que diferentes objetos de diferentes clases respondan de forma distinta a un mismo “mensaje” (por ejemplo, un método con el mismo nombre), adaptando el comportamiento a las particularidades de cada caso.",
    "crumbs": [
      "Teoría",
      "U3 - Programación Orientada a Objetos",
      "2 - Encapsulamiento"
    ]
  },
  {
    "objectID": "teoria/03_oop/02_encapsulamiento.html#introducción",
    "href": "teoria/03_oop/02_encapsulamiento.html#introducción",
    "title": "2 - Encapsulamiento",
    "section": "Introducción",
    "text": "Introducción\nSupongamos que nos encontramos manejando un auto por el centro rosarino y al llegar a la esquina vemos que por la calle perpendicular se aproxima otro vehículo que no aparenta intenciones de frenar.\nTodo indica que tendremos que detener el auto completamente.\nInstantáneamente, presionamos el embrague casi al mismo tiempo que el pedal de freno y colocamos la palanca de cambio en la posición de punto muerto. El auto responde de la manera que esperamos y se detiene.\nUna vez que el otro vehículo cruza, nos disponemos a continuar nuestra marcha. Como aún no soltamos el pie del embrague, movemos la palanca de cambios a la posición de primera, suavemente soltamos el embrague mientras comenzamos a presionar el acelerador, y finalmente cruzamos.\n¿Y qué tiene que ver toda esta escena automovilística con el encapsulamiento? Más de lo que podríamos imaginarnos.\nPara detener el auto, tuvimos que interactuar con los pedales y eventualmente con la palanca de cambios. Todo un esfuerzo, sí.\nSin embargo, no necesitamos saber en realidad como funciona el proceso de frenado de un auto: desconocemos como funcionan los discos, la hidráulica y mucho menos podríamos describir como funciona una caja de cambios. Todos estos mecanismos internos permanecen ocultos dentro del sistema (el auto). Lo único visible es una interfaz sencilla que nos permite lograr nuestro objetivo sin necesidad de saber qué ocurre detrás.\nEn programación ocurre lo mismo: la encapsulación consiste en mantener el estado interno y la lógica de un objeto fuera del alcance del exterior, exponiendo únicamente una forma clara y controlada de interactuar con él. De este modo, el código que interactua con el objeto no necesita conocer sus detalles internos y puede seguir funcionando incluso si estos cambian.",
    "crumbs": [
      "Teoría",
      "U3 - Programación Orientada a Objetos",
      "2 - Encapsulamiento"
    ]
  },
  {
    "objectID": "teoria/03_oop/02_encapsulamiento.html#las-múltiples-caras-del-encapsulamiento",
    "href": "teoria/03_oop/02_encapsulamiento.html#las-múltiples-caras-del-encapsulamiento",
    "title": "2 - Encapsulamiento",
    "section": "Las múltiples caras del encapsulamiento",
    "text": "Las múltiples caras del encapsulamiento\nEn programación no existe una única manera de aplicar el encapsulamiento, es decir, de aislar y proteger los detalles internos de cómo algo funciona. A continuación, veremos cómo esta idea aparece y se utiliza en distintos niveles: funciones, objetos y clases.\n\nFunciones\nLas funciones ofrecen un ejemplo clarísimo de encapsulación: para usarlas, no hace falta conocer como funcionan internamente. De hecho, una función bien diseñada se caracteriza por cumplir una única tarea y tener un nombre que la describa con claridad. De esta manera, con solo leer su nombre podemos anticipar qué hace, sin preocuparnos por los detalles de su implementación.\nPor ejemplo, consideremos la siguiente función que devuelve el número \\(n\\)-ésimo en la secuencia de Fibonacci:\n\ndef fibonacci(n):\n    if n &lt;= 1:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)\n\nprint(fibonacci(10))\nprint(fibonacci(21))\n\n55\n10946\n\n\nSi está clara la interfaz de la función (cantidad y tipos de entradas y salidas), no es necesario conocer detalles de la implementación, ni si el código es largo o complejo. Incluso si se encuentra un mejor algoritmo para resolver el mismo problema, la función puede reescribirse sin cambiar su uso externo, siempre que la interfaz no cambie.\nEsta modularización hace que el código sea más fácil de mantener y adaptar a futuros cambios.\n\n\nObjetos\nEn la programación orientada a objetos hay una distinción clave entre el interior y el exterior de una clase u objeto.\nDesde el interior, al diseñar una clase o implementar sus métodos, debemos cuidar cómo interactúan con los atributos, la eficiencia de los algoritmos y el diseño de la interfaz. El objetivo es construir una estructura coherente y fácil de mantener.\nDesde el exterior, lo que importa no son los detalles internos sino la interfaz pública: qué hace cada método, qué argumentos necesita y qué valores devuelve. Mientras esa interfaz se mantenga, la clase puede usarse sin conocer su implementación.\nLas clases favorecen el encapsulamiento porque:\n\nDefinen una interfaz clara para usar sus métodos sin saber cómo funcionan por dentro.\nProtegen el estado interno, evitando modificaciones directas desde fuera.\n\nY, gracias a ello, permiten cambiar la implementación sin afectar el código que las utiliza.\nAhora bien, ¿cómo es que las clases en Python definen una interfaz clara y protegen el estado interno?",
    "crumbs": [
      "Teoría",
      "U3 - Programación Orientada a Objetos",
      "2 - Encapsulamiento"
    ]
  },
  {
    "objectID": "teoria/03_oop/02_encapsulamiento.html#interfaz-clara",
    "href": "teoria/03_oop/02_encapsulamiento.html#interfaz-clara",
    "title": "2 - Encapsulamiento",
    "section": "Interfaz clara",
    "text": "Interfaz clara\n\nDocstrings\n¿Cómo podemos saber cuántos argumentos debemos pasar y de qué tipo al inicializar una clase? ¿Y cómo saberlo al llamar a uno de sus métodos?\nUna primera opción sería leer directamente su implementación, pero eso es precisamente lo que queremos evitar.\nUna alternativa mucho mejor es consultar la documentación. Para ello, la clase y sus métodos deben contar con docstrings adecuados que describan su uso.\nVeamos el siguiente ejemplo:\n\nclass CuentaBancaria:\n    \"\"\"Cuenta bancaria simple con operaciones básicas.\n\n    Esta clase implementa un modelo básico de cuenta bancaria que permite\n    depositar y retirar dinero, así como consultar el saldo actual.\n    \"\"\"\n    def __init__(self, titular, saldo_inicial=0.0):\n        \"\"\"Inicializa una nueva cuenta bancaria.\n\n        Parameters\n        ----------\n        titular : str\n            Nombre del titular de la cuenta.\n        saldo_inicial : float, optional\n            Saldo inicial de la cuenta. Por defecto es 0.0.\n        \"\"\"\n        self.titular = titular\n        self.saldo = saldo_inicial\n\n    def depositar(self, monto):\n        \"\"\"Depositar dinero en la cuenta.\n\n        Parameters\n        ----------\n        monto : float\n            Monto a depositar. Debe ser un número positivo.\n        \"\"\"\n        if monto &lt;= 0:\n            print(\"Error: El monto a depositar debe ser positivo.\")\n            return\n        self.saldo += monto\n\n\n    def retirar(self, monto):\n        \"\"\"Extrae dinero de la cuenta si hay fondos suficientes.\n\n        Parameters\n        ----------\n        monto : float\n            Monto a retirar.\n        \"\"\"\n        if monto &gt; self.saldo:\n            print(\"Error: Fondos insuficientes.\")\n            return\n        self.saldo -= monto\n\n\n    def consultar_saldo(self):\n        \"\"\"Devuelve el saldo actual.\n\n        Returns\n        -------\n        float\n            Saldo disponible en la cuenta.\n        \"\"\"\n        return self.saldo\n\n\ncuenta = CuentaBancaria(titular=\"José Paso\", saldo_inicial=12000)\ncuenta.consultar_saldo()\n\n12000\n\n\n\ncuenta.retirar(3800)\ncuenta.consultar_saldo()\n\n8200\n\n\n\ncuenta.depositar(1500)\ncuenta.retirar(50000)\ncuenta.consultar_saldo()\n\nError: Fondos insuficientes.\n\n\n9700\n\n\nPara consultar la documentación, podemos usar la función help de Python.\nSi la ejecutamos en Positron, se abrirá una ventana a la derecha que muestra la información disponible. Si, en cambio, la usamos desde una terminal, obtendremos un resultado similar al siguiente:\nAyuda para toda clase:\nhelp(CuentaBancaria)\nHelp on class CuentaBancaria in module __main__:\n\nclass CuentaBancaria(builtins.object)\n |  CuentaBancaria(titular, saldo_inicial=0.0)\n |\n |  Cuenta bancaria simple con operaciones básicas.\n |\n |  Esta clase implementa un modelo básico de cuenta bancaria que permite\n |  depositar y retirar dinero, así como consultar el saldo actual.\n |\n |  Methods defined here:\n |\n |  __init__(self, titular, saldo_inicial=0.0)\n |      Inicializa una nueva cuenta bancaria.\n |\n |      Parameters\n |      ----------\n |      titular : str\n |          Nombre del titular de la cuenta.\n |      saldo_inicial : float, optional\n |          Saldo inicial de la cuenta. Por defecto es 0.0.\nAyuda para el método depositar, que recibe un flotante y no devuelve nada:\nhelp(CuentaBancaria.depositar)\nHelp on function depositar in module __main__:\n\ndepositar(self, monto)\n    Depositar dinero en la cuenta.\n\n    Parameters\n    ----------\n    monto : float\n        Monto a depositar. Debe ser un número positivo.\nAyuda para el método consultar_saldo, que no recibe ningún parametro y devuelve un flotante:\nhelp(CuentaBancaria.consultar_saldo)\nHelp on function consultar_saldo in module __main__:\n\nconsultar_saldo(self)\n    Devuelve el saldo actual.\n\n    Returns\n    -------\n    float\n        Saldo disponible en la cuenta.\nSi bien en algunos casos puede resultar necesario consultar la ayuda con la función help, los editores de código suelen mostrar automáticamente una pequeña ventana junto al código mientras escribimos, donde aparece la documentación de clases, métodos y funciones.\n\n\nAnotaciones de tipo\nSi bien Python es un lenguaje de tipado dinámico e implícito —es decir, no es necesario especificar el tipo de las variables y este puede cambiar durante la ejecución—, es posible utilizar anotaciones de tipo (del inglés type annotations) para indicar qué tipo de dato se espera. Estas anotaciones son opcionales, pero ayudan a que el código sea más claro, fácil de entender y detectar errores antes de ejecutar el programa.\nPara los parámetros de una función o método, las anotaciones de tipo se escriben con el formato &lt;nombre_variable&gt;: &lt;tipo&gt;. En el caso la salida, el tipo se indica después de una flecha (-&gt; &lt;tipo&gt;) al final de la definición.\nPor ejemplo, en la siguiente función se especifica que el parámetro nombre debe ser de tipo str y que la función devuelve también un objeto de tipo str:\n\ndef saludar(nombre: str) -&gt; str:\n    return f\"¡Hola, {nombre}!\"\n\nsaludar(\"Guido\")\n\n'¡Hola, Guido!'\n\n\nEn nuestra clase CuentaBancaria, la anotación de tipos se ve de la siguiente manera:\n\nclass CuentaBancaria:\n1    def __init__(self, titular: str, saldo_inicial: float = 0.0):\n        self.titular = titular\n        self.saldo = saldo_inicial\n\n2    def depositar(self, monto: float):\n        self.saldo += monto\n\n3    def retirar(self, monto: float):\n        self.saldo -= monto\n\n4    def consultar_saldo(self) -&gt; float:\n        return self.saldo\n\n\n1\n\nPara inicializar la clase, se espera un argumento titular de tipo str y otro saldo_inicial de tipo float.\n\n2\n\nEl método depositar espera recibir un argumento de tipo float.\n\n3\n\nEl método retirar también espera recibir un argumento de tipo float.\n\n4\n\nPor último, consultar_saldo devuelve un valor de tipo float.\n\n\n\n\nSi se eligen nombres representativos para los métodos y se utilizan anotaciones de tipo en sus parámetros, es muy probable que no sea necesario escribir un docstring para que el usuario comprenda cómo funciona la clase.\nSin embargo, ni la documentación mediante docstrings ni el uso de anotaciones de tipo garantizan que una función o método se utilice con los tipos de datos adecuados. Por ejemplo, podríamos pasarle un número a nuestra función saludar sin que Python lo impida:\n\nsaludar(128)\n\n'¡Hola, 128!'\n\n\nO incluso podríamos inicializar el saldo_inicial de la cuenta bancaria con una lista y luego intentar “depositar” otra lista.\n\ncuenta = CuentaBancaria(25, saldo_inicial=[\"Cosas\"])\ncuenta.consultar_saldo()\n\n['Cosas']\n\n\n\ncuenta.depositar([\"Otras cosas\", \"Aún más cosas\"])\ncuenta.consultar_saldo()\n\n['Cosas', 'Otras cosas', 'Aún más cosas']\n\n\nEn resumen, si bien Python nos permite especificar la interfaz de funciones y métodos mediante docstrings y anotaciones de tipo, al ser un lenguaje de tipado dinámico nada impide que se utilicen con tipos de datos para los que no fueron diseñados. En algunos casos esto puede resultar en comportamientos inesperados y, en otros, simplemente generar un error en tiempo de ejecución.\n\n\n\n\n\n\nDuck typing 🦆\n\n\n\nEn lenguajes dinámicos como Python, muchas veces no importa de qué tipo es un objeto, sino qué puede hacer. Lo relevante no es su clase, sino si se comporta como necesitamos.\nPor ejemplo, en una función como saludar, el parámetro no tiene que ser necesariamente un str, siempre que pueda usarse dentro de una f-string.\nEste enfoque, donde importa más el comportamiento que el tipo, se llama duck typing y suele expresarse así:\n\nSi camina como un pato y hace cuac como un pato, entonces probablemente es un pato.",
    "crumbs": [
      "Teoría",
      "U3 - Programación Orientada a Objetos",
      "2 - Encapsulamiento"
    ]
  },
  {
    "objectID": "teoria/03_oop/02_encapsulamiento.html#estado-interno",
    "href": "teoria/03_oop/02_encapsulamiento.html#estado-interno",
    "title": "2 - Encapsulamiento",
    "section": "Estado interno",
    "text": "Estado interno\nAhora que sabemos qué estrategias podemos usar para que la interfaz de una clase sea clara, veamos cómo las clases definen y protegen su estado interno.\nConsideremos a la siguiente clase que sirve para representar a estudiantes de la Facultad de Ciencias Económicas y Estadística de la UNR.\n\nclass Estudiante:\n    def __init__(self, nombre, ingreso, carrera):\n        self.nombre = nombre\n        self.ingreso = ingreso\n        self.carrera = carrera\n\n    def resumen(self):\n        return f\"Estudiante(nombre={self.nombre}, ingreso={self.ingreso}, carrera={self.carrera})\"\n\nCada objeto mantiene sus propias variables de instancia, como nombre, ingreso y carrera, con valores independientes de los de otros objetos de la misma clase. Esto implica que modificar los datos de una instancia no afecta en absoluto a las demás: cada objeto gestiona y conserva su propio estado interno, es decir, los objetos son dueños de sus variables.\n\ne1 = Estudiante(\"Mariano González\", 2022, \"Contador Público\")\ne2 = Estudiante(\"Leticia Gallardo\", 2023, \"Licenciatura en Estadística\")\n\nGracias al método resumen, podemos obtener una representación clara e intuitiva de cada objeto.\n\ne1.resumen()\n\n'Estudiante(nombre=Mariano González, ingreso=2022, carrera=Contador Público)'\n\n\nAunque también es posible interactuar con los atributos de cada instancia de manera individual.\n\nprint(e1.nombre, e1.carrera, sep=\": \")\nprint(e2.nombre, e2.carrera, sep=\": \")\n\nMariano González: Contador Público\nLeticia Gallardo: Licenciatura en Estadística\n\n\nEsta interacción no solo implica que podemos acceder a los valores individuales de los atributos, sino también que tenemos la posibilidad de modificarlos.\n\ne1.ingreso = 2019\ne1.resumen()\n\n'Estudiante(nombre=Mariano González, ingreso=2019, carrera=Contador Público)'\n\n\nTenemos tanta flexibilidad al modificar los atributos de una instancia que incluso podemos asignarles valores que no tienen sentido dentro del contexto de la clase.\n\ne1.ingreso = \"Cualquier cosa\"\ne1.resumen()\n\n'Estudiante(nombre=Mariano González, ingreso=Cualquier cosa, carrera=Contador Público)'\n\n\n\nSetters y getters\nEn programación orientada a objetos, los getters y setters son métodos especiales que permiten acceder y modificar el estado interno de un objeto de forma segura y controlada. Su objetivo principal es proteger los atributos, evitando que se acceda o se cambien directamente desde el exterior de la clase.\nEn particular:\n\ngetter: método que obtiene o devuelve el valor de un atributo de un objeto.\nsetter: método que asigna o actualiza el valor de un atributo de un objeto.\n\nNuestra clase Estudiante, incorporando ahora estos métodos para acceder y modificar sus atributos, se vería de la siguiente manera:\n\nclass Estudiante:\n    def __init__(self, nombre):\n1        self.setNombre(nombre)\n\n2    def setNombre(self, nombre):\n        if isinstance(nombre, str):\n            self.nombre = nombre\n        else:\n            print(\"El nombre debe ser de tipo 'str'\")\n\n3    def getNombre(self):\n        return self.nombre\n\n    def resumen(self):\n        return f\"Estudiante(nombre={self.getNombre()})\"\n\n\n1\n\nEl método de inicialización no asigna el atributo directamente, sino que delega la tarea en el setter.\n\n2\n\nEl setter recibe un valor, verifica su tipo y, si es el esperado, lo asigna como atributo de instancia.\n\n3\n\nEl getter simplemente devuelve el valor del atributo, proporcionando un punto de acceso controlado al estado interno.\n\n\n\n\nCreemos un nuevo objeto de tipo Estudiante.\n\ne = Estudiante(\"Macarena Gianetti\")\ne.resumen()\n\n'Estudiante(nombre=Macarena Gianetti)'\n\n\nLuego, obtenemos el nombre de la estudiante mediante su getter.\n\ne.getNombre()\n\n'Macarena Gianetti'\n\n\nSi queremos modificarlo, no asignamos el valor directamente a una variable del objeto, sino que llamamos a su método setter. Este método se encarga de validar el dato y evitar que se asignen valores de tipos no permitidos.\n\ne.setNombre(189)\n\nEl nombre debe ser de tipo 'str'\n\n\n\ne.resumen()\n\n'Estudiante(nombre=Macarena Gianetti)'\n\n\nSin embargo, Python no impide que, como usuarios, accedamos y modifiquemos directamente los atributos del objeto. Por ejemplo, podemos asignar un valor de cualquier tipo directamente a la variable nombre:\n\ne.nombre = 2\ne.resumen()\n\n'Estudiante(nombre=2)'\n\n\nEn ese caso, las ventajas de usar setter y getter dejan de tener efecto si el usuario decide “romper” el objeto ignorando su interfaz.\n\n\nAtributos protegidos\nEn muchos lenguajes de programación existe una distinción clara entre atributos públicos y privados. Los públicos pueden ser accedidos tanto desde dentro como desde fuera de la clase, mientras que los privados solo pueden usarse internamente. Es decir, un método de la clase puede acceder a un atributo o método privado, pero el código externo que usa la clase no.\nEn Python no existe una separación estricta entre atributos públicos y privados: todos son técnicamente públicos. Sin embargo, por convención, si el nombre de un atributo o método comienza con un guion bajo (_), esto indica que no debería ser accedido ni modificado desde el exterior de la clase, ya que está protegido.\nSiguiendo esta convención, en nuestro ejemplo con la clase Estudiante podemos usar un atributo llamado _nombre para almacenar el nombre del estudiante.\n\nclass Estudiante:\n    def __init__(self, nombre):\n        self.setNombre(nombre)\n\n    def setNombre(self, nombre):\n        if isinstance(nombre, str):\n1            self._nombre = nombre\n        else:\n            print(\"El nombre debe ser de tipo 'str'\")\n\n    def getNombre(self):\n2        return self._nombre\n\n    def resumen(self):\n        return f\"Estudiante(nombre={self.getNombre()})\"\n\n\n1\n\nSe guarda el nombre en una variable “privada” _nombre.\n\n2\n\nSe devuelve el nombre usando la variable “privada” _nombre.\n\n\n\n\n\ne = Estudiante(\"Macarena Gianetti\")\ne.resumen()\n\n'Estudiante(nombre=Macarena Gianetti)'\n\n\nSi asignamos un nuevo valor a la variable nombre de la instancia, no ocurre ningún efecto indeseado. El objeto crea y almacena esa nueva variable, pero el método getter no la utiliza, ya que sigue accediendo al atributo _nombre.\n\ne.nombre = \"Algo nuevo\"\ne.resumen()\n\n'Estudiante(nombre=Macarena Gianetti)'\n\n\nSin embargo, Python no evita que reemplacemos el valor de la variable _nombre, nuevamente rompiendo el encapsulamiento del objeto:\n\ne._nombre = \"¡Ahora sí!\"\ne.resumen()\n\n'Estudiante(nombre=¡Ahora sí!)'\n\n\n\n\nAtributos privados\nSi bien los objetos en Python no cuentan con atributos verdaderamente privados, es posible emular ese comportamiento. Para ello, se emplean nombres de variables que comienzan con dos guiones bajos (__). En nuestro ejemplo, podemos usar __nombre.\n\nclass Estudiante:\n    def __init__(self, nombre):\n        self.setNombre(nombre)\n\n    def setNombre(self, nombre):\n        if isinstance(nombre, str):\n            self.__nombre = nombre\n        else:\n            print(\"El nombre debe ser de tipo 'str'\")\n\n    def getNombre(self):\n        return self.__nombre\n\n    def resumen(self):\n        return f\"Estudiante(nombre={self.getNombre()})\"\n\ne = Estudiante(\"Macarena Gianetti\")\ne.resumen()\n\n'Estudiante(nombre=Macarena Gianetti)'\n\n\nSi queremos acceder a la variable, obtendremos un error:\ne.__nombre\n\nAttributeError: 'Estudiante' object has no attribute '__nombre'\n\nPor el contrario, si intentamos asignar un valor a esa variable, Python no mostrará ningún error y el método getter continuará devolviendo el valor esperado:\n\ne.__nombre = \"¿Y ahora?\"\ne.getNombre()\n\n'Macarena Gianetti'\n\n\n\ne._Estudiante__nombre\n\n'Macarena Gianetti'\n\n\n\n\n\n\n\n\nName mangling\n\n\n\nNunca debemos olvidar que Python no soporta atributos privados. Por lo tanto, en algún lado tiene que estar disponible el valor de la variable __nombre que se usa dentro de la clase.\nEn particular, cuando el nombre de una variable comienza con dos guiones bajos, Python utiliza una técnica llamada name mangling o “estropeo de nombre”. Para ello, en realidad opera internamente con otra variable, cuyo nombre es el resultado de concatenar un guión bajo, el nombre de la clase y el nombre del atributo “privado”. Por ejemplo:\n&gt;&gt;&gt; e._Estudiante__nombre\n'Macarena Gianetti'\n\n\n\n\nAtributos (aparentes) con @property\nPython ofrece un decorador built-in llamado property que permite definir un método que se comporta como si fuera un atributo, de modo que al accederlo desde fuera parece una variable de instancia, aunque en realidad está ejecutando código dentro de la clase.\nCon este decorador se pueden definir dos métodos: un getter y un setter.\n\nEl getter se declara con @property, y su nombre determina el nombre de la propiedad que se utilizará desde el código externo.\nEl setter se declara con @&lt;nombre&gt;.setter y permite asignar valores a esa misma propiedad.\n\nVeamos un ejemplo:\n\nclass Estudiante:\n    def __init__(self, nombre):\n3        self.nombre = nombre\n\n1    @property\n    def nombre(self):\n        return self._nombre\n\n2    @nombre.setter\n    def nombre(self, valor):\n        if isinstance(valor, str):\n            self._nombre = valor\n        else:\n            print(\"El nombre debe ser de tipo 'str'\")\n\n    def resumen(self):\n4        return f\"Estudiante(nombre={self.nombre})\"\n\n\n1\n\nCon @property se indica que los objetos de la clase tendrán un “atributo” llamado nombre. Al acceder a él, Python ejecuta el método decorado y devuelve el valor de la variable protegida _nombre.\n\n2\n\nCon @nombre.setter se declara el método setter, que recibe self y el nuevo valor a asignar (valor). Así, cada vez que se asigna un nuevo valor al atributo, Python ejecuta este método y verifica el tipo de dato.\n\n3\n\nIncluso dentro de la clase puede usarse nombre como si fuera un atributo común, sin necesidad de llamar manualmente al método decorado.\n\n4\n\nÍdem al punto anterior.\n\n\n\n\n\ne = Estudiante(\"Fernanda Cattalini\")\ne.resumen()\n\n'Estudiante(nombre=Fernanda Cattalini)'\n\n\nEs posible acceder al “atributo” nombre:\n\ne.nombre\n\n'Fernanda Cattalini'\n\n\nTambién modificarlo:\n\ne.nombre = \"María Fernanda Cattalini\"\ne.resumen()\n\n'Estudiante(nombre=María Fernanda Cattalini)'\n\n\nY si se intenta asignarle un valor del tipo incorrecto, no se realiza la operación:\n\ne.nombre = True\n\nEl nombre debe ser de tipo 'str'\n\n\n\ne.resumen()\n\n'Estudiante(nombre=María Fernanda Cattalini)'\n\n\n\n\nResumen\nPython no ofrece un control absoluto sobre el estado interno de los objetos, pero sí dispone de mecanismos que permiten gestionarlo mejor, como las convenciones de nombres, los getters y setters, o el uso de @property. Estas herramientas ayudan a ocultar detalles internos, validar datos y mantener la coherencia del objeto.\nSin embargo, por la naturaleza dinámica del lenguaje, siempre existe la posibilidad de modificar clases y objetos desde el exterior, por lo que el encapsulamiento funciona más como una convención para un uso correcto que como una barrera estricta.",
    "crumbs": [
      "Teoría",
      "U3 - Programación Orientada a Objetos",
      "2 - Encapsulamiento"
    ]
  },
  {
    "objectID": "teoria/03_oop/02_encapsulamiento.html#atributos-y-métodos-de-clase",
    "href": "teoria/03_oop/02_encapsulamiento.html#atributos-y-métodos-de-clase",
    "title": "2 - Encapsulamiento",
    "section": "Atributos y métodos de clase",
    "text": "Atributos y métodos de clase\nEn Python, no solo los objetos pueden encapsular estado: las clases también.\nUn atributo de clase está asociado a la clase en sí y es compartido por todas sus instancias, en lugar de pertenecer a un objeto específico.\nUn método de clase, en cambio, recibe la propia clase como primer argumento (cls) en lugar de la instancia (self), lo que permite operar sobre la clase en su conjunto.\n\nAtributos\nEs posible asignar un atributo de clase en el código que implementa a la clase misma. Simplemente hay que asignar una variable en el bloque de definción de la clase.\nEn el ejemplo a continuación, creamos una clase Gato que representa animales de la especie Felis catus. Como todos los gatos son de la misma especie, tiene sentido utilizar un atributo de clase en vez de un atributo de instancia.\n\nclass Gato:\n1    especie = \"Felis catus\"\n\n    def __init__(self, nombre, raza=None):\n        self.nombre = nombre\n        self.raza = raza\n\n    def resumen(self):\n        return f\"Gato(nombre={self.nombre}, raza={self.raza})\"\n\n\n1\n\nCreación del atributo de clase especie.\n\n\n\n\nLuego de instanciar dos objetos, podemos ver que ambos tienen asociados el mismo valor de especie.\n\ng1 = Gato(\"Chispitas\")\ng2 = Gato(\"Bigotes\", \"Siamés\")\n\n\nprint(g1.especie)\nprint(g2.especie)\nprint(g1.especie == g2.especie)\n\nFelis catus\nFelis catus\nTrue\n\n\nPodríamos utilizar un atributo de clase análogo para otra especie de animales: Canis lupus familiaris, popularmente conocidos como perro.\n\nclass Perro:\n    especie = \"Canis lupus familiaris\"\n\n    def __init__(self, nombre, raza=None):\n        self.nombre = nombre\n        self.raza = raza\n\n    def resumen(self):\n        return f\"Perro(nombre={self.nombre}, raza={self.raza})\"\n\n\nperro = Perro(\"Bruno\")\nprint(perro.resumen())\nprint(perro.especie)\n\nPerro(nombre=Bruno, raza=None)\nCanis lupus familiaris\n\n\nOtro escenario donde tiene sentido práctico utilizar un atributo de clase es cuando se necesita mantener un estado global.\nLa clase Usuario define usuarios de una cierta aplicación. En ella, se tiene la variable total_usuarios que es un contador de los usuarios que se han creado a partir de la clase.\n\nclass Usuario:\n1    total_usuarios = 0\n\n    def __init__(self, nombre):\n        self.nombre = nombre\n2        Usuario.total_usuarios += 1\n\n\n1\n\nInicialmente, el atributo de clase total_usuarios tiene el valor 0.\n\n2\n\nCada vez que se crea un nuevo usuario, se incrementa el valor del atributo de la clase total_usuarios en 1.\n\n\n\n\n\nu1 = Usuario(\"Ana\")\nu2 = Usuario(\"Luis\")\n\nprint(Usuario.total_usuarios)\n\n2\n\n\nDado que las instancias también pueden acceder a los atributos de clase, se tiene:\n\nprint(u1.total_usuarios)\nprint(u2.total_usuarios)\n\n2\n2\n\n\n\n\nMétodos\nPara definir un método de clase se usa el decorador @classmethod, incluido en Python. Al aplicarlo, el método recibe como primer argumento a la clase en lugar de a una instancia, por lo que la convención es nombrar ese parámetro como cls en vez de self.\n\nclass Estudiante:\n    def __init__(self, nombre, ingreso):\n        self.nombre = nombre\n        self.ingreso = ingreso\n\n1    @classmethod\n2    def desde_texto(cls, texto):\n        nombre, ingreso = texto.split(\",\")\n3        return cls(nombre, int(ingreso))\n\n    def resumen(self):\n        return f\"Estudiante(nombre={self.nombre}, ingreso={self.ingreso})\"\n\n\n1\n\nLa decoración @classmethod indica que el método desde_texto se invoca desde la clase y reciba a la clase como primer argumento.\n\n2\n\nPor convención, ese primer argumento se llama cls.\n\n3\n\nA partir de cls, se crea y devuelve una nueva instancia de la clase (en este caso, Estudiante) utilizando los valores requeridos por su método __init__.\n\n\n\n\nAunque exista exista un método de clase para crear objetos, se puede seguir creando objetos de la manera usual:\n\ne1 = Estudiante(\"El Nombre\", 2023)\ne1.resumen()\n\n'Estudiante(nombre=El Nombre, ingreso=2023)'\n\n\nLa diferencia es que ahora podemos usar el método desde_texto para crear un objeto Estudiante a partir de una cadena de texto con un formato específico.\n\ne2 = Estudiante.desde_texto(\"El Estudiante, 2024\")\ne2.resumen()\n\n'Estudiante(nombre=El Estudiante, ingreso=2024)'\n\n\nLos atributos del objeto muestran los valores que esperamos en este caso.\n\ne2.nombre, e2.ingreso\n\n('El Estudiante', 2024)\n\n\nOtro escenario en el que resulta útil usar métodos de clase es cuando queremos crear objetos “preconfigurados”.\nPor ejemplo, si tenemos una clase que representa sándwiches con una cantidad arbitraria de ingredientes, podemos definir métodos de clase que construyan instancias con combinaciones de ingredientes preestablecidas:\n\nclass Sandwich:\n    def __init__(self, *ingredientes):\n        self.ingredientes = ingredientes\n\n    @classmethod\n    def jyq(cls):\n        return cls(\"jamón\", \"queso\")\n\n    @classmethod\n    def mediterraneo(cls):\n        return cls(\"tomate\", \"mozzarella\", \"rúcula\", \"aceitunas\")\n\n    def resumen(self):\n        return f\"Sandwich de: {', '.join(self.ingredientes)}\"\n\n\ns1 = Sandwich(\"tomate\", \"lechuga\", \"queso\")\ns1.resumen()\n\n'Sandwich de: tomate, lechuga, queso'\n\n\n\nSandwich.jyq().resumen()\n\n'Sandwich de: jamón, queso'\n\n\n\nSandwich.mediterraneo().resumen()\n\n'Sandwich de: tomate, mozzarella, rúcula, aceitunas'\n\n\n\n\n\n\n\n\nAtributos y métodos a posteriori\n\n\n\nPython es tan flexible como lenguaje que incluso podemos asignar atributos y métodos luego de su definición.\nclass Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\ndef f(self):\n    return self.base * self.altura\n\nRectangulo.area = f\nRectangulo.atributo = \"Algo\"\n\nr = Rectangulo(3, 2)\nr.area()\n# 6",
    "crumbs": [
      "Teoría",
      "U3 - Programación Orientada a Objetos",
      "2 - Encapsulamiento"
    ]
  },
  {
    "objectID": "teoria/03_oop/03_herencia.html",
    "href": "teoria/03_oop/03_herencia.html",
    "title": "3 - Herencia",
    "section": "",
    "text": "En el Prefacio del apunte anterior mencionamos lo siguiente sobre el principio de herencia:\n\n\nHerencia: permite crear nuevas clases a partir de otras ya existentes, reutilizando su comportamiento y ampliándolo o modificándolo según sea necesario.\n\n\nSupongamos que necesitamos representar rectángulos en Python. Anteriormente, optamos por por representarlos con una tupla de longitud dos, donde el primer elemento representaba la base y el segundo la altura. Ahora, que ya dimos nuestros primeros pasos con la programación orientada a objetos, podemos crear una clase que no solo nos permite almacenar estado (los atributos de cada rectángulo), sino que nos posibilta implementar métodos que nos permiten obtener otras cantidades de interés.\n\nclass Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    @property\n    def area(self):\n        return self.base * self.altura\n\n    @property\n    def perimetro(self):\n        return self.base * 2 + self.altura * 2\n\n    def resumen(self):\n        return f\"Rectangulo(base={self.base}, altura={self.altura})\"\n\n\nr1 = Rectangulo(4, 7)\nprint(r1.resumen())\nprint(\"Área:\", r1.area)\nprint(\"Perímetro:\", r1.perimetro)\n\nRectangulo(base=4, altura=7)\nÁrea: 28\nPerímetro: 22\n\n\nSi queremos representar cuadrados, podemos crear otra clase:\n\nclass Cuadrado:\n    def __init__(self, lado):\n        self.lado = lado\n\n    @property\n    def area(self):\n        return self.lado * self.lado\n\n    @property\n    def perimetro(self):\n        return self.lado * 4\n\n    def resumen(self):\n        return f\"Cuadrado(lado={self.lado})\"\n\nc1 = Cuadrado(3)\nprint(c1.resumen())\nprint(\"Área:\", c1.area)\nprint(\"Perímetro:\", c1.perimetro)\n\nCuadrado(lado=3)\nÁrea: 9\nPerímetro: 12\n\n\nEn Python podemos usar la función isinstance para verificar si un objeto es instancia de una clase determinada. Por ejemplo, en el siguiente código comprobamos que r1 es una instancia de Rectangulo y que c1 es una instancia de Cuadrado:\n\nprint(isinstance(r1, Rectangulo))\nprint(isinstance(c1, Cuadrado))\n\nTrue\nTrue\n\n\nSabemos que, desde el punto de vista geométrico, un cuadrado es un caso particular de rectángulo: tiene base y altura iguales. En otras palabras, todo cuadrado es también un rectángulo, aunque no todo rectángulo sea un cuadrado.\nSin embargo, si intentamos verificar esta relación en nuestro programa, obtenemos que esto no es asi.\n\nisinstance(c1, Rectangulo)\n\nFalse\n\n\nEsto no significa que los cuadrados no sean rectángulos, sino que nuestro código aún no conoce esa relación entre las clases.",
    "crumbs": [
      "Teoría",
      "U3 - Programación Orientada a Objetos",
      "3 - Herencia"
    ]
  },
  {
    "objectID": "teoria/03_oop/03_herencia.html#introducción",
    "href": "teoria/03_oop/03_herencia.html#introducción",
    "title": "3 - Herencia",
    "section": "",
    "text": "En el Prefacio del apunte anterior mencionamos lo siguiente sobre el principio de herencia:\n\n\nHerencia: permite crear nuevas clases a partir de otras ya existentes, reutilizando su comportamiento y ampliándolo o modificándolo según sea necesario.\n\n\nSupongamos que necesitamos representar rectángulos en Python. Anteriormente, optamos por por representarlos con una tupla de longitud dos, donde el primer elemento representaba la base y el segundo la altura. Ahora, que ya dimos nuestros primeros pasos con la programación orientada a objetos, podemos crear una clase que no solo nos permite almacenar estado (los atributos de cada rectángulo), sino que nos posibilta implementar métodos que nos permiten obtener otras cantidades de interés.\n\nclass Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    @property\n    def area(self):\n        return self.base * self.altura\n\n    @property\n    def perimetro(self):\n        return self.base * 2 + self.altura * 2\n\n    def resumen(self):\n        return f\"Rectangulo(base={self.base}, altura={self.altura})\"\n\n\nr1 = Rectangulo(4, 7)\nprint(r1.resumen())\nprint(\"Área:\", r1.area)\nprint(\"Perímetro:\", r1.perimetro)\n\nRectangulo(base=4, altura=7)\nÁrea: 28\nPerímetro: 22\n\n\nSi queremos representar cuadrados, podemos crear otra clase:\n\nclass Cuadrado:\n    def __init__(self, lado):\n        self.lado = lado\n\n    @property\n    def area(self):\n        return self.lado * self.lado\n\n    @property\n    def perimetro(self):\n        return self.lado * 4\n\n    def resumen(self):\n        return f\"Cuadrado(lado={self.lado})\"\n\nc1 = Cuadrado(3)\nprint(c1.resumen())\nprint(\"Área:\", c1.area)\nprint(\"Perímetro:\", c1.perimetro)\n\nCuadrado(lado=3)\nÁrea: 9\nPerímetro: 12\n\n\nEn Python podemos usar la función isinstance para verificar si un objeto es instancia de una clase determinada. Por ejemplo, en el siguiente código comprobamos que r1 es una instancia de Rectangulo y que c1 es una instancia de Cuadrado:\n\nprint(isinstance(r1, Rectangulo))\nprint(isinstance(c1, Cuadrado))\n\nTrue\nTrue\n\n\nSabemos que, desde el punto de vista geométrico, un cuadrado es un caso particular de rectángulo: tiene base y altura iguales. En otras palabras, todo cuadrado es también un rectángulo, aunque no todo rectángulo sea un cuadrado.\nSin embargo, si intentamos verificar esta relación en nuestro programa, obtenemos que esto no es asi.\n\nisinstance(c1, Rectangulo)\n\nFalse\n\n\nEsto no significa que los cuadrados no sean rectángulos, sino que nuestro código aún no conoce esa relación entre las clases.",
    "crumbs": [
      "Teoría",
      "U3 - Programación Orientada a Objetos",
      "3 - Herencia"
    ]
  },
  {
    "objectID": "teoria/03_oop/03_herencia.html#herencia-simple",
    "href": "teoria/03_oop/03_herencia.html#herencia-simple",
    "title": "3 - Herencia",
    "section": "Herencia simple",
    "text": "Herencia simple\nLa herencia simple, como su nombre indica, es la forma más básica de herencia en programación orientada a objetos. Ocurre cuando una clase (que llamaremos hija, del inglés child) hereda de una única clase (que llamaremos padre, del inglés parent). Al hacerlo, la clase hija obtiene automáticamente los atributos y métodos de la clase padre, y puede utilizarlos directamente, modificarlos o agregar otros nuevos. Esto permite reutilizar y ampliar el comportamiento existente sin tener que volver a implementarlo desde cero.\n\nUn primer intento\nLa sintaxis para definir una clase que hereda de otra es la siguiente:\n1class ClasePadre:\n    ...\n\n\n2class ClaseHija(ClasePadre):\n    ...\n\n1\n\nPrimero se define la clase padre de forma habitual, con sus atributos y métodos.\n\n2\n\nLuego, al crear la clase hija, se coloca el nombre de la clase padre entre paréntesis después del nombre de la nueva clase, de forma similar a cómo se llama a una función.\n\n\nEn el caso de nuestras clases Rectangulo y Cuadrado tendríamos:\n\nclass Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    @property\n    def area(self):\n        return self.base * self.altura\n\n    @property\n    def perimetro(self):\n        return self.base * 2 + self.altura * 2\n\n    def resumen(self):\n        return f\"Rectangulo(base={self.base}, altura={self.altura})\"\n\n\nclass Cuadrado(Rectangulo):\n    def __init__(self, lado):\n        self.lado = lado\n\n    @property\n    def area(self):\n        return self.lado * self.lado\n\n    @property\n    def perimetro(self):\n        return self.lado * 4\n\n    def resumen(self):\n        return f\"Cuadrado(lado={self.lado})\"\n\nAhora, podemos comprobar que los cuadrados sí se reconocen como rectángulos:\n\nr1 = Rectangulo(2, 5)\nc1 = Cuadrado(3)\n\nprint(isinstance(r1, Rectangulo))\nprint(isinstance(c1, Cuadrado))\nprint(isinstance(c1, Rectangulo))\n\nTrue\nTrue\nTrue\n\n\n\n\nSobreescritura de métodos\nLa herencia no solo sirve para que nuestro programa entienda las relaciones entre clases, sino también para reutilizar código sin duplicarlo. Gracias a ella, una clase hija puede aprovechar los atributos y métodos definidos en la clase padre y, al mismo tiempo, modificar solo aquello que necesita cambiar. Este proceso, llamado sobreescritura de métodos, permite adaptar o ampliar el comportamiento heredado sin necesidad de volver a implementarlo desde cero.\nEn nuestro ejemplo, podemos reutilizar los métodos area y perimetro definidos en la clase Rectangulo. Para lograrlo, basta con sobreescribir el método __init__ en la clase Cuadrado, de modo que asigne el valor de lado a los atributos base y altura.\n\n1class Cuadrado(Rectangulo):\n2    def __init__(self, lado):\n3        self.lado = lado\n        self.base = lado\n        self.altura = lado\n\n\n1\n\nSe crea la clase Cuadrado, que hereda de Rectangulo.\n\n2\n\nSe sobreescribe el método __init__, que ahora recibe un único parámetro: lado.\n\n3\n\nComo los métodos heredados utilizan los atributos base y altura, debemos asignarles el valor de lado para que el comportamiento siga siendo correcto.\n\n\n\n\nVemos que es posible acceder a las propiedades area y perimetro (en realidad, métodos decorados) de los objetos de la clase Cuadrado gracias a que los heredan de la clase Rectangulo.\n\nc1 = Cuadrado(3)\nprint(\"Área:\", c1.area)\nprint(\"Perímetro:\", c1.perimetro)\n\nÁrea: 9\nPerímetro: 12\n\n\nPor otro lado, el método resumen indica que se trata de un rectángulo.\n\nc1.resumen()\n\n'Rectangulo(base=3, altura=3)'\n\n\nSi bien la información que se muestra no es incorrecta, sería aún más claro que se devuelva una cadena que indica que el objeto no es un rectángulo cualquiera, sino que es de un tipo particular: un cuadrado. Para lograrlo, tenemos que reescribir el método resumen:\n\nclass Cuadrado(Rectangulo):\n    def __init__(self, lado):\n        self.lado = lado\n        self.base = lado\n        self.altura = lado\n\n1    def resumen(self):\n        return f\"Cuadrado(lado={self.lado})\"\n\n\n1\n\nSe reescribe el método resumen para que devuelva una cadena distinta.\n\n\n\n\n\nCuadrado(3).resumen()\n\n'Cuadrado(lado=3)'\n\n\nEn resumen, nuestro código queda organizado de la siguiente manera:\n\nClase Rectangulo\n\nSe inicializa con dos argumentos: base y altura.\nDefine tres métodos principales:\n\narea(): calcula el área.\nperimetro(): calcula el perímetro.\nresumen(): devuelve una descripción en texto.\n\n\nClase Cuadrado\n\nHereda de Rectangulo, por lo que tiene acceso a todos sus métodos.\nSobreescribe dos de ellos:\n\n__init__(): para inicializar el objeto a partir de un único valor lado.\nresumen(): para personalizar la descripción.\n\nUsa directamente los métodos heredados area() y perimetro() sin necesidad de redefinirlos.\n\n\n\n\n\n\n\n\n¿Sabías que…? 🤓\n\n\n\nTodas las clases en Python heredan de una gran clase base llamada object. Por eso, cualquier instancia, sin importar su tipo, es considerada un objeto:\nisinstance(1, object)                  # True\nisinstance(\"algo\", object)             # True\nisinstance([1, 10, 100], object)       # True\nisinstance(Rectangulo(2, 5), object)   # True\nEn Python 2, si queríamos aprovechar todas las características modernas de la programación orientada a objetos, era necesario declarar explícitamente que nuestra clase heredaba de object. Por eso, era común encontrar definiciones así:\nclass MiClase(object):\n    ...\nEn Python 3, esto ya no es necesario: todas las clases heredan de object de forma implícita.\n\n\n\n\nFormas generales\nUn programa que trabaja con cuadrados y rectángulos probablemente tambíen incluya otros tipos de figuras geométricas, como los círculos. La clase Circulo define círculos en base a su radio y, al igual que Cuadrado y Rectangulo, permite obtener su área y perímetro como si fuera un atributo gracias al decorador @property.\n\nimport math\n\nclass Circulo:\n    def __init__(self, radio):\n        self.radio = radio\n\n    @property\n    def area(self):\n1        return self.radio ** 2 * math.pi\n\n    @property\n    def perimetro(self):\n2        return 2 * self.radio * math.pi\n\n    def resumen(self):\n        return f\"Circulo(radio={self.radio})\"\n\n\n1\n\nEl área de un círculo es \\(r ^ 2 \\pi\\)\n\n2\n\nEl perímetro de un círculo es \\(2 r \\pi\\)\n\n\n\n\n\nc1 = Circulo(3)\nprint(c1.resumen())\nprint(\"Área:\", c1.area)\nprint(\"Perímetro:\", c1.perimetro)\n\nCirculo(radio=3)\nÁrea: 28.274333882308138\nPerímetro: 18.84955592153876\n\n\nEn este caso, no es posible establecer una jerarquía que relacione directamente a la clase Circulo con Cuadrado y Rectangulo; no es ni un caso particular de las otras ni nos permitiría reutilizar ninguno de los métodos implementados.\nSin embargo, sí es posible considerar a todas estas clases como casos particulares de una clase base mayor: las figuras geométricas.\n\n\nInterfaz informal\nVamos a crear una clase llamada Forma, que servirá como clase base para todas las figuras geométricas que implementemos. En ella, estableceremos que cualquier clase hija deberá contar con las propiedades area y perimetro, además de un método resumen.\nComo Forma representa un concepto general, no podemos dar una implementación concreta de estos métodos (ya que el cálculo del área o el perímetro depende de la figura específica). Por eso, en esta primera versión simplemente hacemos que los métodos devuelvan None, indicando que deberán ser implementados por las clases hijas.\n\nclass Forma:\n    @property\n    def area(self):\n        return None\n\n    @property\n    def perimetro(self):\n        return None\n\n    def resumen(self):\n        return \"Forma()\"\n\nf1 = Forma()\nprint(f1.resumen())\nprint(\"Área:\", f1.area)\nprint(\"Perímetro:\", f1.perimetro)\n\nForma()\nÁrea: None\nPerímetro: None\n\n\nAhora, volvemos a implementar las clases Rectangulo y Cuadrado. Comenzamos con Rectangulo, haciendo que esta herede de Forma:\n\nclass Rectangulo(Forma):\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    @property\n    def area(self):\n        return self.base * self.altura\n\n    @property\n    def perimetro(self):\n        return self.base * 2 + self.altura * 2\n\n    def resumen(self):\n        return f\"Rectangulo(base={self.base}, altura={self.altura})\"\n\nY vemos que todos sus métodos funcionan correctamente:\n\nr1 = Rectangulo(5, 2)\nprint(r1.resumen())\nprint(\"Área:\", r1.area)\nprint(\"Perímetro:\", r1.perimetro)\n\nRectangulo(base=5, altura=2)\nÁrea: 10\nPerímetro: 14\n\n\nHacemos lo propio con la clase Cuadrado. En este caso, no es necesario declarar explícitamente que hereda de Forma, porque la relación ya está establecida de manera indirecta: Cuadrado hereda de Rectangulo, y Rectangulo hereda de Forma. En otras palabras, como los rectángulos son formas geométricas y los cuadrados son rectángulos, se tiene que los cuadrados también son formas geométricas.\n\nclass Cuadrado(Rectangulo):\n    def __init__(self, lado):\n        self.lado = lado\n        self.base = lado\n        self.altura = lado\n\n    def resumen(self):\n        return f\"Cuadrado(lado={self.lado})\"\n\nc1 = Cuadrado(2)\nprint(c1.resumen())\nprint(\"Área:\", c1.area)\nprint(\"Perímetro:\", c1.perimetro)\n\nCuadrado(lado=2)\nÁrea: 4\nPerímetro: 8\n\n\nPor otro lado, volvemos a implementar la clase Circulo, esta vez heredando de Forma:\n\nclass Circulo(Forma):\n    def __init__(self, radio):\n        self.radio = radio\n\n    @property\n    def area(self):\n        return self.radio ** 2 * math.pi\n\n    @property\n    def perimetro(self):\n        return 2 * self.radio * math.pi\n\n    def resumen(self):\n        return f\"Circulo(radio={self.radio})\"\n\nci1 = Circulo(3)\nprint(ci1.resumen())\nprint(\"Área:\", ci1.area)\nprint(\"Perímetro:\", ci1.perimetro)\n\nCirculo(radio=3)\nÁrea: 28.274333882308138\nPerímetro: 18.84955592153876\n\n\nY, finalmente, podemos ver que todas las relaciones entre los tipos creados se reflejan correctamente:\n\n# r1 es Rectangulo y Forma\nprint(isinstance(r1, Rectangulo))\nprint(isinstance(r1, Forma))\n\nTrue\nTrue\n\n\n\n# c1 es Cuadrado, Rectangulo y Forma\nprint(isinstance(c1, Cuadrado))\nprint(isinstance(c1, Rectangulo))\nprint(isinstance(c1, Forma))\n\nTrue\nTrue\nTrue\n\n\n\n# ci1 es Circulo y Forma\nprint(isinstance(ci1, Circulo))\nprint(isinstance(ci1, Forma))\n\nTrue\nTrue\n\n\n\n\nInterfaz formal\nEn programación orientada a objetos existe un tipo especial de clase pensado para casos como el de Forma: clases que no se usan para crear objetos directamente, pero que sí definen una interfaz común para sus clases hijas e imponen la implementación de ciertos métodos y propiedades. A este tipo de clases se las conoce como clases abstractas.\nEn Python, podemos crear una clase abstracta haciendo que herede de la clase ABC del módulo estándar abc (cuyas siglas significan abstract base class). Este módulo también ofrece el decorador @abstractmethod, que permite definir métodos abstractos y obliga a las clases hijas a implementarlos. Además, si combinamos @abstractmethod con @property, podemos crear propiedades abstractas que deberán ser definidas en las subclases.\nImplementemos ahora la clase abstracta Forma.\n\nfrom abc import ABC, abstractmethod\n\n1class Forma(ABC):\n2    @property\n    @abstractmethod\n    def area(self):\n        pass\n\n3    @property\n    @abstractmethod\n    def perimetro(self):\n        pass\n\n4    @abstractmethod\n    def resumen(self):\n        pass\n\n\n1\n\nSe comienza a implementar la clase Forma, que hereda de la clase ABC.\n\n2\n\nSe implementa la propiedad abstracta area. La decoración con @property y @abstractmethod obligan a las clases hijas a implementar un método area decorado con @property. Se usa pass porque no se provee una implementación concreta.\n\n3\n\nSe implementa la propiedad abstracta perimetro de manera similar a area.\n\n4\n\nSe implementa el método abstracto resumen, que las clases hijas deben implementar como un método regular.\n\n\n\n\nSi intentamos crear un objeto Forma obtendremos un error porque esta clase no está pensada para crear objetos, sino para servir como modelo o interfaz común de otras clases.\nForma()\n\nTypeError: Can't instantiate abstract class Forma without an implementation for abstract methods 'area', 'perimetro', 'resumen'\n\nTampoco podemos crear una clase que herede de forma e implemente solamente alguno de los métodos abstractos. Por ejemplo, si la clase Rectangulo no implementa el método resumen, también se obtiene un error.\nclass Rectangulo(Forma):\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    @property\n    def area(self):\n        return self.base * self.altura\n\n    @property\n    def perimetro(self):\n        return self.base * 2 + self.altura * 2\n\nRectangulo(2, 1)\n\nTypeError: Can't instantiate abstract class Rectangulo without an implementation for abstract method 'resumen'\n\nPara que la implementación de una clase derivada de una clase abstracta no arroje ningún error, es necesario implementar todos los métodos y propiedades abstractas de la clase base, como se hace a continuación:\n\nclass Rectangulo(Forma):\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    @property\n    def area(self):\n        return self.base * self.altura\n\n    @property\n    def perimetro(self):\n        return self.base * 2 + self.altura * 2\n\n    def resumen(self):\n        return f\"Rectangulo(base={self.base}, altura={self.altura})\"\n\nr = Rectangulo(2, 1)\nr.resumen()\n\n'Rectangulo(base=2, altura=1)'\n\n\nDe manera análoga, se pueden reimplementar las clases Cuadrado y Rectangulo.\n\nclass Cuadrado(Rectangulo):\n    def __init__(self, lado):\n        self.lado = lado\n        self.base = lado\n        self.altura = lado\n\n    def resumen(self):\n        return f\"Cuadrado(lado={self.lado})\"\n\n\nclass Circulo(Forma):\n    def __init__(self, radio):\n        self.radio = radio\n\n    @property\n    def area(self):\n        return self.radio ** 2 * math.pi\n\n    @property\n    def perimetro(self):\n        return self.radio ** 2 * math.pi\n\n    def resumen(self):\n        return f\"Circulo(radio={self.radio})\"\n\nc = Cuadrado(2)\nprint(c.resumen())\nci = Circulo(1.5)\nprint(ci.resumen())\n\nCuadrado(lado=2)\nCirculo(radio=1.5)\n\n\n\nprint(isinstance(r, Forma))\nprint(isinstance(c, Forma))\nprint(isinstance(ci, Forma))\n\nTrue\nTrue\nTrue\n\n\nAl utilizar una clase abstracta como Forma, no solo definimos una clase base que engloba a todos los tipos de figuras geométricas que podamos implementar, sino que también garantizamos que esas clases implementen los métodos y propiedades abstractas necesarias (area, perimetro y resumen). El uso de la clases abstractas impone un contrato claro que hace que el código sea más predecible y fácil de mantener.\n\n\n\n\n\n\nAfinando el vocabulario\n\n\n\nA lo largo de este apunte mencionamos muchos términos relacionados a la programación orientada a objetos, es hora de afinar el vocabulario:\n\nClase padre (o clase base): es la clase de la que heredan otras. Puede ser concreta o abstracta, y define atributos y métodos comunes que las clases hijas pueden reutilizar, extender o modificar.\nClase hija (o clase derivada): es la clase que hereda de una clase padre. Hereda sus atributos y métodos, y puede agregar nueva funcionalidad o redefinir la existente.\nClase abstracta: es una clase que sirve como modelo general y no está pensada para crear objetos directamente. Puede contener métodos sin implementar, que deberán definirse en las clases hijas.\nImplementación concreta: es una clase o método completamente definido y funcional, que puede usarse directamente para crear objetos o ejecutar comportamiento.",
    "crumbs": [
      "Teoría",
      "U3 - Programación Orientada a Objetos",
      "3 - Herencia"
    ]
  },
  {
    "objectID": "teoria/03_oop/03_herencia.html#herencia-múltiple",
    "href": "teoria/03_oop/03_herencia.html#herencia-múltiple",
    "title": "3 - Herencia",
    "section": "Herencia múltiple",
    "text": "Herencia múltiple\nHasta ahora vimos que en programación orientada a objetos una clase puede heredar de otra, lo que permite reutilizar atributos y métodos. En todos los ejemplos anteriores, esa herencia fue simple, ya que cada clase hija tenía una única clase padre, sin importar su complejidad o si era concreta o abstracta.\nSin embargo, al igual que muchos otros lenguajes orientados a objetos, Python también permite la herencia múltiple. El concepto es sencillo: una clase puede heredar de varias clases padre al mismo tiempo, combinando sus funcionalidades y accediendo a todos sus métodos y atributos.\nEn esta sección, utilizaremos herencia múltiple para representar diferentes distribuciones de probabilidad (discretas y continuas). Nuestro objetivo es implementar dos distribuciones: la normal (Normal) y la Poisson (Poisson). Estas clases van a contar con métodos para generar muestras aleatorias y graficar su distribución.\n\nEjemplo básico\nAntes de atrevernos a implementar distribuciones de probabilidad en Python usando herencia múltiple, veamos un ejemplo muy sencillo de cómo funciona:\n\nclass A:\n    def saludar(self):\n        return \"Hola desde A\"\n\nclass B:\n    def despedir(self):\n        return \"Chau desde B\"\n\nclass C(A, B):\n    def saltar(self):\n        return \"Saltando desde C\"\n\n\ncosa = C()\n\n\ncosa.saludar()\n\n'Hola desde A'\n\n\n\ncosa.despedir()\n\n'Chau desde B'\n\n\n\ncosa.saltar()\n\n'Saltando desde C'\n\n\n\n\nDistribución normal\nComencemos implementando una clase abstracta llamada Distribucion que contiene los siguientes métodos abstractos:\n\nmuestra: Genera un valor aleatorio de la distribución\ngraficar: Genera un gráfico que permite apreciar la distribución.\n\nAdemás, también incluye un método concreto que devuelve n muestras de la distribución\n\nclass Distribucion(ABC):\n    @abstractmethod\n    def muestra(self):\n        pass\n\n    @abstractmethod\n    def graficar(self):\n        pass\n\n    def muestras(self, n=1):\n        return [self.muestra() for _ in range(n)]\n\nPara inicializar la distribución normal usamos su media mu y desvío estándar sigma. Incluimos un método pdf que devuelve la función de densidad normal evaluada en un punto x e implementamos los métodos muestra y graficar que son requeridos por la clase padre Distribucion.\n\nimport random\nimport matplotlib.pyplot as plt\n\nclass Normal(Distribucion):\n    def __init__(self, mu, sigma):\n        self.mu = mu\n        self.sigma = sigma\n\n    def pdf(self, x):\n        a = 1 / (self.sigma * (2 * math.pi) ** 0.5)\n        b = math.exp( - 0.5 * ((x - self.mu) ** 2 / self.sigma ** 2))\n        return a * b\n\n    def muestra(self):\n        return random.normalvariate(mu=self.mu, sigma=self.sigma)\n\n    def graficar(self):\n        # Construir valores de 'x'\n        x_inicio = self.mu - self.sigma * 3\n        x_fin = self.mu + self.sigma * 3\n        x_paso = (x_fin - x_inicio) / 500\n        xs = [x_inicio + x_paso * i for i in range(500)]\n\n        # Construir valores de 'y'\n        ys = [self.pdf(x) for x in xs]\n\n        # Crear gráfico\n        plt.plot(xs, ys)\n        plt.xlabel(\"x\")\n        plt.ylabel(\"p(x)\")\n        plt.title(f\"Normal(mu={self.mu}, sigma={self.sigma})\")\n        plt.show()\n\nSi queremos trabajar con una distribución normal de media 3 y desvío 1, basta con inicializarla de la siguiente manera:\n\nnormal = Normal(mu=3, sigma=1)\n\nAhora, podemos obtener uno o múltiples números aleatorios de dicha distribución:\n\nnormal.muestra()\n\n2.248231320099541\n\n\n\nnormal.muestras(10)\n\n[0.6458518679909164,\n 3.9120653695218515,\n 2.1150760712804373,\n 2.9766247862532924,\n 3.9150019616191267,\n 2.4612383165622287,\n 2.0434502376268586,\n 2.3696759257123254,\n 1.8845024386324847,\n 1.9123881947344514]\n\n\nY si queremos evaluar la función de densidad en un punto (es decir, obtener la altura de la curva normal en un punto), usamos el método pdf que implementamos anteriormente.\n\nnormal.pdf(2)\n\n0.24197072451914337\n\n\n\nnormal.pdf(2.5), normal.pdf(3), normal.pdf(3.5) # Simetría alrededor de la media.\n\n(0.3520653267642995, 0.3989422804014327, 0.3520653267642995)\n\n\nFinalmente, nuestro objeto también nos permite visualizar la distribución.\n\nnormal.graficar()\n\n\n\n\n\n\n\n\n\n\nDistribución Poisson\nAhora que ya contamos la distribución normal, podemos continuar con la distribución de Poisson.\nPara inicializarla vamos a usar el parámetro \\(\\lambda\\), que representa tanto la media como la varianza. Pero, como lambda es una palabra reservada en Python, usaremos su versión abreviada lam.\nAdemás, como se trata de una distribución para variables discretas, no corresponde implementar un método pdf (probability density function), sino pmf (probability mass function). Esto también influye en la visualización: en lugar de representar una curva continua, utilizaremos un gráfico de bastones para mostrar la distribución.\n\nclass Poisson(Distribucion):\n    def __init__(self, lam):\n        self.lam = lam\n\n    def pmf(self, x):\n        return (math.exp(-self.lam) * self.lam ** x) / math.factorial(x)\n\n    def muestra(self):\n        S, N = 0, 0\n        while S &lt; 1:\n            u = random.uniform(0, 1)\n            N += 1\n            S += - math.log(u) / self.lam\n        return N - 1\n\n    def graficar(self):\n        # Construir valores de 'x'\n        xs = []\n        x, cdf = 0, 0\n        while cdf &lt; 0.999:\n            xs.append(x)\n            cdf += self.pmf(x)\n            x += 1\n\n        # Construir valores de 'y'\n        ys = [self.pmf(x) for x in xs]\n\n        plt.vlines(xs, ymin=0, ymax=ys, lw=3)\n        plt.xlabel(\"x\")\n        plt.ylabel(\"P(X = x)\")\n        plt.title(f\"Poisson(lam={self.lam})\")\n        plt.show()\n\n\npoisson = Poisson(3)\npoisson.muestra()\n\n1\n\n\n\npoisson.muestras(5)\n\n[3, 6, 7, 3, 9]\n\n\n\npoisson.pmf(3)\n\n0.22404180765538775\n\n\n\npoisson.graficar()\n\n\n\n\n\n\n\n\n\nPoisson(5).graficar()\n\n\n\n\n\n\n\n\n\nPoisson(10).graficar()\n\n\n\n\n\n\n\n\n\n\nHerencia múltiple en acción\nSi bien obtuvimos clases funcionales para trabajar con variables aleatorias normales y Poisson, aún no hemos hecho uso de la herencia múltiple.\nPara hacerlo, vamos a definir tres clases independientes, con responsabilidades bien diferenciadas:\n\nDistribucion: declara métodos genéricos comunes a cualquier distribución de probabilidad.\nDiscreta: define el método abstracto pmf y un método concreto crear_grafico que genera un gráfico de bastones.\nContinua: define el método abstracto pdf y un método crear_grafico que representa la distribución con una curva.\n\nEstas clases servirán como base para construir distribuciones más específicas combinando funcionalidades a través de herencia múltiple.\n\nclass Distribucion(ABC):\n    @abstractmethod\n    def muestra(self):\n        pass\n\n    @abstractmethod\n    def graficar(self):\n        pass\n\n    def muestras(self, n=1):\n        return [self.muestra() for _ in range(n)]\n\n\nclass Discreta(ABC):\n    @abstractmethod\n    def pmf(self, x):\n        pass\n\n    def crear_grafico(self, xs):\n        ys = [self.pmf(x) for x in xs]\n        plt.vlines(xs, ymin=0, ymax=ys, lw=3)\n        plt.xlabel(\"x\")\n        plt.ylabel(\"P(X = x)\")\n\n\nclass Continua(ABC):\n    @abstractmethod\n    def pdf(self, x):\n        pass\n\n    def crear_grafico(self, xs):\n        ys = [self.pdf(x) for x in xs]\n        plt.plot(xs, ys)\n        plt.xlabel(\"x\")\n        plt.ylabel(\"p(x)\")\n\nSi combinamos Distribucion y Continua, tenemos la base para implementar nuestra clase Normal.\n\nclass Normal(Distribucion, Continua):\n    def __init__(self, mu, sigma):\n        self.mu = mu\n        self.sigma = sigma\n\n    def pdf(self, x):\n        a = 1 / (self.sigma * (2 * math.pi) ** 0.5)\n        b = math.exp( - 0.5 * ((x - self.mu) ** 2 / self.sigma ** 2))\n        return a * b\n\n    def muestra(self):\n        return random.normalvariate(mu=self.mu, sigma=self.sigma)\n\n    def graficar(self):\n        x_inicio = self.mu - self.sigma * 3\n        x_fin = self.mu + self.sigma * 3\n        x_paso = (x_fin - x_inicio) / 500\n        xs = [x_inicio + x_paso * i for i in range(500)]\n        self.crear_grafico(xs)\n        plt.title(f\"Normal(mu={self.mu}, sigma={self.sigma})\")\n        plt.show()\n\nnormal = Normal(2, 1)\n\n\nnormal.muestras(5)\n\n[1.9364943585753434,\n 3.431844507514179,\n 4.1148165485370365,\n 0.7869931091513576,\n 1.99320198616381]\n\n\n\nnormal.graficar()\n\n\n\n\n\n\n\n\nCuando llamamos al método muestras, estamos haciendo uso del método concreto implementado en Distribucion, y cuando llamamos a graficar, estamos haciendo uso del método concreto implementado en Continua.\nPor otro lado, si combinamos Distribucion y Discreta tenemos la base para reimplementar nuestra clase Poisson.\n\nclass Poisson(Distribucion, Discreta):\n    def __init__(self, lam):\n        self.lam = lam\n\n    def pmf(self, x):\n        return (math.exp(-self.lam) * self.lam ** x) / math.factorial(x)\n\n    def muestra(self):\n        S, N = 0, 0\n        while S &lt; 1:\n            u = random.uniform(0, 1)\n            N += 1\n            S += - math.log(u) / self.lam\n        return N - 1\n\n    def graficar(self):\n        xs = []\n        x, cdf = 0, 0\n        while cdf &lt; 0.999:\n            xs.append(x)\n            cdf += self.pmf(x)\n            x += 1\n\n        self.crear_grafico(xs)\n        plt.title(f\"Poisson(lam={self.lam})\")\n        plt.show()\n\n\nPoisson(4).graficar()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReflexión sobre el uso de herencia múltiple\n\n\n\nEn el ejemplo de las distribuciones de probabilidad, cada clase concreta hereda de dos clases: Distribucion y Discreta o Continua, según corresponda. Esta no es la única forma posible de estructurar el código: podríamos haber hecho que Discreta y Continua heredaran de Distribucion, y que las distribuciones concretas heredaran solo de una de ellas (obteniendo así a Distribucion de manera indirecta).\nComo el objetivo de esta sección era trabajar con herencia múltiple, decidimos mantener las clases por separado.\n\n\n\n\n\n\n\n\nMethod resolution order (MRO)\n\n\n\nEn la práctica, es sencillo usar herencia múltiple cuando cada clase padre define métodos y atributos con nombres distintos. El problema aparece cuando dos o más clases padre implementan un método con el mismo nombre. En esos casos, Python usa un mecanismo llamado Method resolution order (MRO) para determinar cuál ejecutar.\nEn pocas palabras, Python busca primero en la clase actual, luego en el orden en que fueron listadas las clases padre, y finalmente en la jerarquía de herencia.\nPor ejemplo:\nclass A:\n    def saludar(self):\n        print(\"Hola desde A\")\n\nclass B:\n    def saludar(self):\n        print(\"Hola desde B\")\n\nclass C(A, B):\n    pass\n\nC().saludar()  # Hola desde A\nEn este ejemplo, C hereda de A y B, pero al llamar saludar() se ejecuta el de A porque está primero en el MRO. Podemos inspeccionar este orden con C.__mro__ o C.mro().\n\n\n\n\nUso de super()\nA veces queremos extender el comportamiento de un método heredado sin reescribirlo por completo.\nSupongamos que queremos crear una versión “ruidosa” de las listas, llamada ListaRuidosa, que se comporte exactamente igual que una lista normal salvo por un detalle: cada vez que agreguemos un elemento con append, imprimirá un mensaje adicional.\nPara lograrlo, podemos sobreescribir el método append y, en lugar de copiar toda su lógica, simplemente agregar el print en el lugar adecuado y luego llamar al método original de la clase padre usando super(). Así modificamos solo lo necesario y mantenemos el resto del comportamiento intacto.\n\n1class ListaRuidosa(list):\n2    def append(self, elemento):\n3        print(\"Agregando:\", elemento)\n4        super().append(elemento)\n\n\n1\n\nListaRuidosa hereda de list.\n\n2\n\nSe reimplementa el método append, que recibe un argumento: el elemento a agregar al final.\n\n3\n\nCuando se llama a append se imprime un mensaje indicando el elemento que se agrega.\n\n4\n\nFinalmente, se llama al método append de la clase padre.\n\n\n\n\nObservemos a nuestra nueva clase en acción. Se ve como una lista, porque es una lista.\n\nlista_ruidosa = ListaRuidosa()\nlista_ruidosa\n\n[]\n\n\nPero no es cualquier lista, ¡es ruidosa!\n\nlista_ruidosa.append(\"¿funciona?\")\n\nAgregando: ¿funciona?\n\n\n\nlista_ruidosa\n\n['¿funciona?']\n\n\n\nprint(type(lista_ruidosa)) # Es una lista ruidosa\nprint(isinstance(lista_ruidosa, list)) # ¡Pero también es una lista!\n\n&lt;class '__main__.ListaRuidosa'&gt;\nTrue\n\n\nY podríamos continuar agregando elementos…\n\nlista_ruidosa.append(\"¿y esto?\")\n\nAgregando: ¿y esto?\n\n\n\nlista_ruidosa\n\n['¿funciona?', '¿y esto?']",
    "crumbs": [
      "Teoría",
      "U3 - Programación Orientada a Objetos",
      "3 - Herencia"
    ]
  },
  {
    "objectID": "teoria/03_oop/05_excepciones.html",
    "href": "teoria/03_oop/05_excepciones.html",
    "title": "5 - Excepciones",
    "section": "",
    "text": "Elevacion de errores\nImplementacion de errores",
    "crumbs": [
      "Teoría",
      "U3 - Programación Orientada a Objetos",
      "5 - Excepciones"
    ]
  },
  {
    "objectID": "teoria/03_oop/05_excepciones.html#errores",
    "href": "teoria/03_oop/05_excepciones.html#errores",
    "title": "5 - Excepciones",
    "section": "",
    "text": "Elevacion de errores\nImplementacion de errores",
    "crumbs": [
      "Teoría",
      "U3 - Programación Orientada a Objetos",
      "5 - Excepciones"
    ]
  }
]