---
title: "ğŸª AutoevaluaciÃ³n"
---

## Funciones

### Puras

1.  Â¿Por quÃ© decimos que `fun` es una funciÃ³n con efectos secundarios?

    ```python
    def fun():
        global x
        x = 10
        return x
    ```

1.  Â¿CuÃ¡l es el problema con la siguiente funciÃ³n? Explore el resultado de las llamadas que se
    incluyen luego de la definiciÃ³n.

    ```python
    def agregar_usuario(usuario, listado=[]):
        listado.append(usuario)
        return listado

    base1 = agregar_usuario("AdriÃ¡n")
    base2 = agregar_usuario("Daniela")
    ```

    Explore el contenido y la identidad de `base1` y `base2`. Si es necesario, utilice algÃºn
    agente de IA para explorar en quÃ© parte de la definiciÃ³n de la funciÃ³n se esconde una trampa.

### AnÃ³nimas

1.  Â¿Por quÃ© la siguiente definiciÃ³n devuelve un error?

    ```python
    lambda x: return x + 1
    ```

1.  Â¿QuÃ© hacen los siguientes bloques de cÃ³digo?

    ```python
    (lambda x, y: x + y)(1, 5)
    ```

    ```python
    (lambda f, x: f(x + 10))(lambda y: y * 5, 2)
    ```

1.  Â¿QuÃ© devuelve la siguiente llamada? Â¿Por quÃ©?

    ```python
    (lambda x: print(x))(1)
    ```

    **Ayuda**: asigne el resultado a una variable y explore el valor de esa variable.

### VariÃ¡dicas

1. Â¿CuÃ¡l es el valor de `args` en la siguiente llamada? Â¿Por quÃ©?

   ```python
    def fun(x, *args):
        return x + 10

    fun(128)
   ```

    Â¿Y el valor de `kwargs` debajo?

    ```python
    def fun(x, **kwargs):
        return x + 11

    fun(128)
    ```

1.  Los siguientes intentos por definir una funciÃ³n arrojan un error.
    Investigue por quÃ© y reflexione sobre el sentido de los errores.

    ```python
    def fun(**kwargs, x, y):
        return x + y
    ```

    ```python
    def fun(**kwargs, *args):
        return sum(args)
    ```

1.  Cualquier llamada a la siguiente funciÃ³n que solo pase argumentos posicionales va a resultar
    en un error. Â¿Por quÃ©? Â¿CÃ³mo habrÃ­a que llamarla para que no resulte en un error?

    ```python
    def fun(*args, x, y):
        return sum(args), x + y
    ```

### _Closures_

1.  Ejecute el siguiente bloque de cÃ³digo e inspeccione el objeto que devuelven las sucesivas
    llamadas realizadas. Analice por quÃ© ocurre este comportamiento y piense quÃ© tipo de
    funcionalidades podrÃ­an aprovechar un mecanismo similar.

    ```python
    def fabrica():
        cosas = []
        def fun(elemento):
            cosas.append(elemento)
            return cosas
        return fun

    f = fabrica()
    f(128)
    f(256)
    f(1024)
    ```

    **Ayuda**: Compare el ID de los objetos devueltos en cada llamada.
    Â¿PodrÃ­a observar el mismo comportamiento si en vez de usar una lista para `cosas` se usara
    una tupla?

## RecursiÃ³n

1.  Â¿CuÃ¡l de las siguientes funciones es recursiva?
    ```python
    def f(x):
        return x + 1

    def g(x):
        return f(x)

    def h(x):
        return h(x - 1)
    ```
1.  Â¿QuÃ© son el caso base y el caso recursivo?
1.  Â¿Por quÃ© toda recursiÃ³n necesita un caso base?
1.  Â¿QuÃ© pasa si una funciÃ³n recursiva nunca llega al caso base?
1.  Reflexione sobre ventajas y desventajas de la recursiÃ³n.

## Funciones de orden superior

1.  Explique por quÃ© el primer `print` muestra `10` y el segundo falla:

    ```python
    from functools import partial

    def suma(x, y):
        return x + y

    suma2 = partial(suma, 10, 0)
    print(suma2())
    print(suma2(10))
    ```

1.  Â¿CuÃ¡l de las siguientes funciones es de orden superior?

    ```python
    def f(x):
        return x + 1

    def g(fn, x):
        return fn(x)

    def h():
        return f
    ```

1.  Â¿CuÃ¡l de las siguientes funciones de Python es de orden superior?
    * `sum`
    * `max`
    * `min`
    * `sorted`
    * `print`
    * `functools.partial`

1.  Â¿QuÃ© hace la funciÃ³n `fun`?
    Â¿QuÃ© condicion debe cumplir `f` respecto de sus valores de entrada y salida?

    ```python
    def fun(f, x):
        return f(f(x))
    ```

1.  Â¿Para quÃ© sirve la funciÃ³n definida debajo?

    ```python
    def fun(f, g):
        return lambda x: f(g(x))
    ```

1.  Â¿QuÃ© tipo de funciÃ³n se necesita pasar a `filter`?

1.  Â¿CuÃ¡l es el resultado de la Ãºltima lÃ­nea de cÃ³digo? Â¿Por quÃ©?

    ```python
    filter_obj = filter(lambda x: x > 2, range(5))
    list(filter_obj) # Primera conversiÃ³n a lista
    list(filter_obj) # Segunda conversiÃ³n a lista
    ```

    **Ayuda**: Para comprender lo que sucede en este ejercicio es necesario estar familiarizados
    con los **generadores**.

1.  Â¿CuÃ¡l implementaciÃ³n es mÃ¡s eficiente desde el punto de vista del consumo de memoria?
    Â¿Por quÃ©?

    ```python
    impares = list(filter(lambda x: x % 2, range(1_000)))
    impares_al_cubo = list(map(lambda x: x ** 3, impares))
    ```

    ```python
    impares_al_cubo = list(map(lambda x: x ** 3, filter(lambda x: x % 2, range(1_000))))
    ```

    **Ayuda**: Nuevamente, es necesario estar familiarizados con los **generadores** para
    responder a esta pregunta.

1.  Â¿CuÃ¡l es el resultado de la reducciÃ³n debajo? Â¿Por quÃ©?

    ```python
    from functools import reduce
    reduce(lambda x, y: x + [y], range(3), [])
    ```

    **Ayuda**: `reduce` ejecuta la funciÃ³n que se le pasa solamente 3 veces.
    PodrÃ­a resultar de ayuda enumerar cada una de las llamadas manualmente.

## Comprehensions

1.  Â¿QuÃ© diferencia hay entre las siguientes dos lÃ­neas de cÃ³digo? Asuma que `f` es una funciÃ³n
    y `xs` es una secuencia.

    ```python
    map(f, xs)
    [f(x) for x in xs]
    ```

1.  Â¿CuÃ¡l es el resultado de esta expresiÃ³n?

    ```python
    [x for x in "hola" if x != "o"]
    ```

1.  Escriba una _list comprehension_ para obtener una lista con la primera letra de cada palabra.

    ```python
    palabras = ["hola", "mundo", "python"]
    ```

1.  Escriba una _list comprehension_ que reemplace los `None` por un `-1`.

    ```python
    datos = [1, None, 3, None, 5]
    ```

1.  Convierta este bucle en una _list comprehension_.

    ```python
    resultado = []
    for x in range(5):
        if x % 2 != 0:
            resultado.append(x)
    ```

1.  Â¿Es posible que una _list comprehension_ devuelva una lista vacÃ­a? Â¿CuÃ¡ndo?

1.  Construya una Ãºnica _list comprehension_ que realice lo mismo que el siguiente bloque:

    ```python
    def f(x):
        return 10 / x

    def g(x):
        return x != 0

    numeros = [1, 0, -1, 0, 2, 0, -2, 0, 3, 0, -3]
    list(map(f, filter(g, numeros)))
    ```

## Generadores

1.  Â¿QuÃ© diferencia a una funciÃ³n regular de una funciÃ³n generadora?
1.  Â¿En quÃ© momento se ejecuta el cuerpo de una funciÃ³n generadora? Â¿Siempre se ejecuta todo?
1.  Â¿CÃ³mo se puede obtener una lista a partir de un generador? Â¿CuÃ¡ntas veces se puede realizar
    esa operaciÃ³n sobre el mismo generador?
1.  Â¿QuÃ© ventaja tiene un generador frente a una lista?
1.  Â¿QuÃ© significa que un generador sea perezoso?
1.  Â¿QuÃ© pasa si se llama a `next` sobre un generador mÃ¡s veces que la cantidad de `yield` en Ã©l?
1.  Â¿QuÃ© se obtiene en el siguiente bloque de cÃ³digo?

    ```python
    def f():
        yield 1
        yield 2

    gen = f()
    print(list(gen))
    ```

    Â¿QuÃ© pasa si se corre `next(gen)` a continuaciÃ³n?

1.  Â¿QuÃ© se imprime en pantalla?

    ```python
    print((x * 2 for x in [1, 2, 3]))
    ```

1.  Â¿Por quÃ© es posible implementar un bucle infinito dentro de un generador?

1.  Â¿CuÃ¡ntas veces es posible llamar a `next` sobre el generador `g`?

    ```python
    def fun():
        yield 1
        return 2
        yield 3

    g = fun()
    ```