---
title: "üõ†Ô∏è Ejercicios"
---

## Trasfromando funciones

Debajo se muestra un listado de funciones impuras.
Analice por qu√© son impuras e implemente alternativas puras (manteniendo su l√≥gica):

Funci√≥n 1
```python
contador = 0
def incrementar():
    global contador # <1>
    contador += 1
    return contador
```

1. La palabra `global` es una _keyword_ que indica que se pretende usar y **modificar** una variable
definida fuera del √°mbito de ejecuci√≥n de la funci√≥n.

Funci√≥n 2
```python
def obtener_hora_actual():
    import datetime
    return datetime.datetime.now().hour
```

Funci√≥n 3
```python
def add_time(time, hours, minutes, seconds):
    increment_time(time, hours, minutes, seconds) # <1>
    return time
```

1. Asuma que esta funci√≥n incrementa a `time`, que es un objeto `datetime`, en `hours` horas,
`minutes` minutos y `seconds` segundos.

::: {.callout-tip collapse="true"}
### Ayuda

Represente fechas y horas con el objeto objeto `datetime` del m√≥dulo est√°ndar `datetime`.
Adem√°s, considere el objeto `timedelta` del mismo m√≥dulo para luego calcular diferencias.

```python
import datetime

ahora = datetime.datetime.now() # Devuelve un objeto con la fecha y la hora actual
print(ahora)

una_hora_mas_tarde = datetime.timedelta(hours=1, minutes=0, seconds=0)
print(ahora + una_hora_mas_tarde)
```
```cmd
2025-08-31 09:48:58.327461
2025-08-31 10:48:58.327461
```

:::

Funci√≥n 4
```python
historial_de_nombres = []
def registrar_nombre(nombre):
    historial_de_nombres.append(nombre)
    return f"'{nombre}' ha sido registrado en el historial."
```

Funci√≥n 5
```python
LIMITE_MAXIMO = 100
def verificar_limite(valor):
    if valor > LIMITE_MAXIMO:
        return "Excede el l√≠mite"
    return "Dentro del l√≠mite"
```

## √Årea de aprendizaje

Se cuenta con una lista de tuplas de longitud 2, representando el ancho y alto de distintos rect√°ngulos.

```python
rectangulos = [
    (5, 8),
    (2, 2),
    (9, 2),
    (3, 3),
    (3, 7),
    (6, 3)
]
```

Cree una nueva lista que ordene dichos rect√°ngulos en funci√≥n de su √°rea.

## Socios ordenados

Se cuenta con la siguiente lista de diccionarios, la cual contiene datos personales sobre miembros de un club de atletismo:

```python
datos_socios = [
    {"nombre": "Bautista Carrara", "edad": 22, "altura_cm": 178, "record_100m": 13.4},
    {"nombre": "Valentina Lucci",  "edad": 23, "altura_cm": 163, "record_100m": 14.2},
    {"nombre": "Ger√≥nimo Cuesta",  "edad": 26, "altura_cm": 170, "record_100m": 14.0},
    {"nombre": "Lucio Borga",      "edad": 28, "altura_cm": 186, "record_100m": 13.8},
    {"nombre": "Julia Spoglia",    "edad": 21, "altura_cm": 163, "record_100m": 11.9},
    {"nombre": "Soledad Colombo",  "edad": 22, "altura_cm": 170, "record_100m": 13.5}
]
```

Ordene la lista en base a los r√©cords en la carrera de 100 metros, en forma ascendente.

### Punto extra

Implemente una funci√≥n que tome como argumento una clave de diccionario y devuelva una lista ordenada por los valores de dicha clave.
Si el argumento toma el valor `"nombre"`, ordene los elementos alfab√©ticamente en base a los apellidos.

## F√°brica de promociones

Considere el ejercicio [Promociones](../01_programacion_en_python/ejercicios.qmd#promociones) de la Pr√°ctica 1.
Utilizando el mismo sistema de descuentos cree la funci√≥n `crear_promocion` que reciba como argumento el medio de pago y devuelva una funci√≥n que al aplicarse
sobre un n√∫mero aplique el descuento (o recargo) que le corresponde a ese medio de pago. Por ejemplo:

```python
promo_debito = crear_promocion("d√©bito")
print(promo_debito(1000))
print(promo_debito(2700))
```
```cmd
900
2430.0
```

Luego, cree la funci√≥n `crear_promocion_personalizada` que recibe el medio de pago y, de manera
opcional, el porcentaje de descuento a aplicar. Como resultado devuelve una funci√≥n que
al aplicarse sobre un n√∫mero impacta el descuento o recargo correspondiente.
Adem√°s, considere que:

* Si no se pasa el porcentaje a aplicar, se deben usar los descuentos y recargos detallados en el enunciado del ejercicio en la Pr√°ctica I.
* Caso contrario, la funci√≥n devuelta debe aplicar ese porcentaje personalizado (e.g., `crear_promocion_personalizada("d√©bito", 15)` para 15% de descuento).

Ejemplo de uso:
```python
promo_debito = crear_promocion_personalizada("d√©bito", 15)
promo_debito(1000)
```
```cmd
850
```

## Analistas de temperaturas

Considere una lista de temperaturas en grados Celsius sobre la cual se deben aplicar distintas 
operaciones.

```python
temperaturas_celsius = [
    25.5, 28.0, 19.3, 31.5, 22.8, 17.0, 30.2, 35.6, 14.2,
    32.4, 22.7, 10.1, 29.5, 33.9, 22.1, 38.9, 18.4, 16.3
]
```
1. Convierta las temperaturas a grados Fahrenheit utilizando `map` y almacene el resultado en una
lista llamada `temperaturas_f`. Use la f√≥rmula de conversi√≥n:
    $$
    F = C \times \frac{9}{5} + 32
    $$

1. Utilice `filter` para seleccionar de la lista anterior las temperaturas que sean mayores a 80¬∞F.
Guarde el resultado en una nueva lista. ¬øSe le ocurre una alternativa que no utilice la lista
creada en el primer punto?
1. Utilice `reduce` para sumar las temperaturas filtradas en el paso anterior y calcular el
promedio dividiendo la suma total entre la cantidad de elementos en la lista filtrada.

### Punto extra üò±

Calcule el promedio de temperaturas **sin materializar** ninguna secuencia hasta el √∫ltimo instante.
Para ello, deber√° utilizar `filter` y `reduce`, sin convertir resultados a listas intermedias.

<!--
```python
from functools import reduce
def f(x, y):
    numerador = x[1] + y[1]
    n = y[0] + 1
    return (n, numerador)
reduce(lambda x, y: y / x, reduce(f, enumerate(filter(lambda c: (c * 9/5 + 32) > 80, temperaturas_celsius))))
```
-->

## Listado de rimas

Se tiene la siguiente lista de palabras, la cual se quiere utilizar para formar rimas:

```python
palabras_a_rimar = [
    "actividad",
    "bendici√≥n",
    "cartelera",
    "ciudad",
    "escalera",
    "estaci√≥n",
    "felicidad",
    "funci√≥n",
    "reposera"
]
```

Ordene la lista en base al orden alfab√©tico del reverso de cada palabra, de modo que las palabras que riman se encuentren juntas.

::: {.callout-tip collapse="true"}
### Ayuda

Si la lista fuese `["durazno", "kiwi"]`, el resultado ser√≠a `["kiwi", "durazno"]`, porque `"iwik"` precede a `"onzarud"` en orden alfab√©tico.
:::


## El tiempo vuela

Se quiere medir el tiempo que tarda la computadora en ejecutar distintos bloques de c√≥digo.
Para eso, implemente una funci√≥n `crear_cronometro` que fabrique una funci√≥n `cronometro`,
la cual devuelve el tiempo transcurrido entre su creaci√≥n y la llamada a la funci√≥n.
Luego, utilice dos cron√≥metros en paralelo para evaluar el siguiente c√≥digo:

```python
cronometro1 = crear_cronometro()

for i in range(10**4):
    i ** 2 # Calcula el cuadrado de un n√∫mero pero no lo devuelve

print(f"El bloque entero tard√≥ {cronometro1()} segundos en ejecutarse.")

cronometro2 = crear_cronometro()

for j in range(10**6):
    j // 2 # Calcula la divisi√≥n entera por 2 pero no la devuelve

print(f"El segundo bucle tard√≥ {cronometro2()} segundos en ejecutarse.")
```

### Punto extra

Modifique el funcionamiento del cron√≥metro para que en cada llamada devuelva el tiempo transcurrido
entre la llamada actual y la inmediata anterior (excepto en la primera llamada, que devuelve el tiempo transcurrido desde su creaci√≥n).

::: {.callout-tip collapse="true"}

### Ayuda

Para medir el paso del tiempo en Python podemos usar la funci√≥n `time` del m√≥dulo hom√≥nimo.

```python
from time import time, sleep

inicio = time()
sleep(2) # Detiene la ejecuci√≥n por 2 segundos
print(time() - inicio) # ~ 2 (segundos)
```
:::

## Sucesi√≥n de Fibonacci

Considere la sucesi√≥n que comienza por los n√∫meros 0 y 1. Los siguientes n√∫meros se forman sumando los dos anteriores.

$$
\{\;0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, \cdots\;\}
$$

Esta sucesi√≥n se conoce como **sucesi√≥n de Fibonacci**.

Implemente una funci√≥n recursiva que tome un n√∫mero natural `n` como entrada y devuelva el `n`-√©simo n√∫mero en la sucesi√≥n.

## Subiendo de rango

La funci√≥n `range(start, stop, step)` de Python devuelve un objeto que genera una secuencia de
n√∫meros desde `start` (inclusive) hasta `stop` (exclusive) en incrementos de `step` unidades.
El argumento `step`, sin embargo, s√≥lo puede ser un n√∫mero entero (excepto cero).

Implemente una funci√≥n llamada `frange` que acepte los mismos argumentos, pudiendo `step` ser de tipo `float`.
La funci√≥n debe retornar un **generador** de la secuencia correspondiente.

### Ayuda

::: {.callout-tip collapse="true"}

Utilice el siguiente ejemplo a modo de control:

```python
for i in frange(3, 4, 0.2):
    print(f"{i:.2f}")
```
```
3.00
3.20
3.40
3.60
3.80
```

Adem√°s, tenga en cuenta que la precisi√≥n finita de las computadoras puede afectar el comportamiento
de su generador.

:::

## La cajita musical

Tenemos una caja musical que recita los siguientes versos:

```python
versos = [
    "Tengo que confesar que a veces no me gusta tu forma de ser",
    "Luego te me desapareces y no entiendo muy bien por qu√©",

    "No dices nada rom√°ntico cuando llega el atardecer",
    "Te pones de un humor extra√±o con cada luna llena al mes",

    "Pero a todo lo dem√°s le gana lo bueno que me das",
    "S√≥lo tenerte cerca, siento que vuelvo a empezar"
]
```

Implemente una funci√≥n para darle cuerda a la caja musical. En cada llamada debe devolver un verso distinto, hasta agotarlos todos.

::: {.callout-tip collapse="true"}
### Ayuda

Mediante el uso de `yield` se puede lograr que una funci√≥n se detenga en un punto intermedio y retome desde ese punto en la siguiente llamada.

```python
def mostrar_fase():
    print("Inicio")
    yield
    print("Medio")
    yield
    print("Desenlace")
    yield
```
:::

## El mejor precio

Un supermercado ofrece m√∫ltiples promociones:

- 15% de descuento los d√≠as lunes y mi√©rcoles.
- 10% de descuento en compras con monto superior a $50.000.
- 20% de descuento a clientes mayores de 65 a√±os.

Para determinar la promoci√≥n a aplicar, el supermercado utiliza un programa con la siguiente estructura:

```python
def promo_dia_semana(compra):
    """Aplica un 15% de descuento si la compra se realiza un lunes o mi√©rcoles."""
    return None # hay que implementar esta funci√≥n

def promo_monto_grande(compra):
    """Aplica un 10% de descuento si la compra tiene un monto superior a $50.000."""
    return None # hay que implementar esta funci√≥n

def promo_edad(compra):
    """Aplica un 20% de descuento si el cliente tiene 65 a√±os o m√°s."""
    return None # hay que implementar esta funci√≥n

promos = [promo_dia_semana, promo_monto_grande, promo_edad]

def mejor_promo(compra):
    """Construye diccionario con el monto luego de aplicar la mejor promoci√≥n.

    Esta funci√≥n devuelve un diccionario con el monto original, el monto final, y el descuento
    aplicado.
    """
    # Obtener el multiplicador del mayor descuento
    multiplicador = sorted([promo(compra) for promo in promos])[0]

    return {
    "monto_original": compra["monto"],
    "monto_final": compra["monto"] * multiplicador,
    "descuento": f"{round((1 - multiplicador) * 100)}%"
    }

ejemplo_compra = {"dia": "mi√©rcoles", "edad_cliente": 42, "monto": 66420}
mejor_promo(ejemplo_compra) # {"dia": "mi√©rcoles", "edad_cliente": 42, "monto": 56457.0}
```

El problema con esta implementaci√≥n es que, cada vez que se a√±ade o elimina una promoci√≥n,
el cambio debe llevarse a cabo tanto en la funci√≥n de la promoci√≥n como en la lista de promociones.
Para evitar el trabajo duplicado, implemente los siguientes cambios:

1. Defina primero la lista `promos`, la cual comienza estando vac√≠a.
2. Defina un decorador `promo` que a√±ade una funci√≥n a la lista `promos` antes de ejecutarla.
3. Implemente las tres funciones de promoci√≥n y dec√≥relas con el decorador del paso anterior.

## Bromas pesadas üò±

Nuestro amigo programador est√° armando una p√°gina web, con una funci√≥n que saluda a los nuevos usuarios por su nombre cuando se registran.
Nosotros queremos gastarle una broma a nuestro amigo, metiendo en su c√≥digo un decorador que haga que su funci√≥n corra normalmente excepto cada `n`-√©sima corrida,
fallando silenciosamente (no imprime nada). El valor `n` es un n√∫mero entero de nuestra elecci√≥n.

```python
@romper_cada(3)
def saludar(nombre):
  print(f"¬°Hola, {nombre}!")

saludar("Carlos")     # "¬°Hola, Carlos!"
saludar("Mar√≠a Luz")  # "¬°Hola, Mar√≠a Luz!"
saludar("Mirna")      # Nada (la funci√≥n devuelve None)
saludar("Diego")      # "¬°Hola, Diego!"
```

### Ayuda

Para crear un decorador que reciba argumentos, podemos crear una f√°brica de decoradores:

```python
def mi_decorador(n):
    def decorar(funcion):
        print(f"Ejecutando decorador con argumento {n}")
        return funcion
    return decorar

@mi_decorador(7)
def imprimir(mensaje):
    print(mensaje)

imprimir("Hola mundo")
# > Ejecutando decorador con argumento 7
# > Hola mundo
```

## Procesamiento de datos paso a paso üò±

Este ejercicio tiene como objetivo implementar un sistema de preprocesamiento para una lista de
diccionarios, donde cada diccionario representa una fila con sus columnas como pares clave‚Äìvalor.
Un conjunto de datos de ejemplo es el siguiente:

```python
datos = [
    {"edad": 20, "ingresos": 2000},
    {"edad": 30, "ingresos": 3000},
    {"edad": None, "ingresos": 2500},
    {"edad": 40, "ingresos": None},
    {"edad": 25, "ingresos": 4000},
]
```

El primer paso consiste en definir tres funciones:

1. `eliminar_nulos`: elimina las filas con al menos un valor `None`.
2. `calcular_log`: que calcula el logaritmo en base 10 para los valores de la variable indicada.
3. `filtrar`: recibe el listado, el nombre de una columna y una funci√≥n booleana que se aplica para
determinar que registros se conservan.

Que deben funcionar como se muestra en los ejemplos:

```python
eliminar_nulos(datos)
```
```python
[
    {"edad": 20, "ingresos": 2000},
    {"edad": 30, "ingresos": 3000},
    {"edad": 25, "ingresos": 4000},
]
```

```python
calcular_log(datos, "ingresos")
```
```python
[
    {"edad": 20, "ingresos": 3.301},
    {"edad": 30, "ingresos": 3.477},
    {"edad": None, "ingresos": 3.397},
    {"edad": 40, "ingresos": None},
    {"edad": 25, "ingresos": 3.602},
]
```

```python
filtrar(datos, "edad", lambda e: e > 25)
```
```python
[
    {"edad": 30, "ingresos": 3000},
    {"edad": 40, "ingresos": None},
]
```

En el segundo paso, se debe implementar una funci√≥n `crear_pipeline`, que recibe una **cantidad arbitraria** de funciones de procesamiento,
junto a sus argumentos, y debe devolver una funci√≥n que, al pasarle un listado de datos, los aplica de manera secuencial y devuelve un conjunto de datos
procesado. Por ejemplo:

```python
pipeline = crear_pipeline(
    {"fun": eliminar_nulos, "kwargs": {}},
    {"fun": calcular_log, "kwargs": {"var_name": "ingresos"}},
    {"fun": filtrar, "kwargs": {"var_name": edad, "key": lambda e: e > 25}}
)
pipeline(datos)
```
```python
[{"edad": 30, "ingresos": 3.477}]
```

## Tiempo o memoria

Trabaj√°s en el equipo de an√°lisis de datos de un e-commerce y recibiste la lista de ventas del √∫ltimo mes. Ten√©s que extraer informaci√≥n clave de esos datos, pero probando dos maneras distintas de resolver cada tarea.

**1. Preparaci√≥n de los datos**

Para empezar, us√° esta funci√≥n que genera datos de ejemplo de ventas de diferente tama√±o:

```python

import random
CATEGORIAS = ("electr√≥nica", "hogar", "accesorios", "deportes")

def generar_ventas(n=100_000, seed=123):

    """
    Devuelve una lista de n ventas simuladas.
    Cada venta es un dict con: id, precio, categoria.
    Podes ajustar el par√°metro n para obtener un dataset m√°s grande o m√°s chico (p.ej., 100_000,        200_000, 500_000).
    """
    rnd = random.Random(seed)
    ventas = []
    for i in range(1, n + 1):
        ventas.append({
            "id": f"P{i:06d}",
            "precio": round(rnd.uniform(5.0, 500.0), 2),
            "categoria": CATEGORIAS[i % len(CATEGORIAS)],
        })
    return ventas
```
Gener√° un dataset con 100.000 ventas:

```python
`ventas = generar_ventas(n=100_000)`
```

**2. Implementaci√≥n de operaciones**

Ahora vamos a realizar dos operaciones sobre este conjunto de datos, cada una con dos versiones:

a) Calcular Precios con IVA (21%)

  Versi√≥n A: Us√° una list comprehension para crear una nueva lista `llamada precios_con_iva_1` que    contenga todos los precios con el 21% de IVA ya calculado.

  Versi√≥n B: Us√° una expresi√≥n generadora para crear un objeto `precios_con_iva_2` que represente la   operaci√≥n, pero sin calcular ni guardar los resultados todav√≠a.

b) Filtrar Ventas de "electr√≥nica"

  Versi√≥n A: Us√° una list comprehension para crear una nueva lista llamada `electronica_1` que        contenga todas las ventas de la categor√≠a "electr√≥nica".

  Versi√≥n B: Us√° una expresi√≥n generadora para crear un objeto `electronica_2` que represente el      filtro, sin materializar la lista.

**3. An√°lisis y comparaci√≥n**

c) Calcul√° el total de las ventas de electr√≥nica usando `sum()` en ambas versiones (`electronica_1` y `electronica_2`).

d) Para cada operaci√≥n, antes y despu√©s de `sum()`, med√≠ el tiempo de ejecuci√≥n y el uso de memoria del objeto. Para el tiempo, pod√©s usar `time.time()` del modulo `time`. Para la memoria, `sys.getsizeof()` del modulo sys. Registr√° los resultados (si no ves diferencias claras, duplica n al generar el dataset)

**4. Reutilizaci√≥n del objeto:**

e) Intent√° calcular el total de ventas de electr√≥nica una segunda vez para ambos objetos (`electronica_1` y `electronica_2`).

f) Observ√° qu√© sucede en cada caso. ¬øQu√© objeto se puede volver a usar y cu√°l no?

**5) Preguntas para reflexi√≥n:**

g) ¬øQu√© diferencias fundamentales encontraste entre las dos maneras de procesar los datos?             (consider√° cu√°ndo se realiza la operaci√≥n, el uso de memoria y el tiempo de ejecuci√≥n)

h) ¬øQu√© pas√≥ cuando intentaste recorrer o usar el mismo resultado dos veces?

i) ¬øSe comportaron de la misma manera la lista generada y el objeto generador? ¬øPor qu√© cre√©s           que sucede esto?

j) ¬øEn qu√© situaciones elegir√≠as un enfoque u otro? Da un ejemplo de un escenario donde la             ejecuci√≥n A sea mejor y otro donde la B sea la opci√≥n m√°s eficiente.