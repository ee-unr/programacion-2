---
title: "üõ†Ô∏è Ejercicios"
---

## √Årea de aprendizaje

Se cuenta con una lista de tuplas de longitud 2, representando el ancho y alto de distintos rect√°ngulos.

```python
rectangulos = [
  (5, 8),
  (2, 2),
  (9, 2),
  (3, 3),
  (3, 7),
  (6, 3)
]
```

Cree una nueva lista que ordene dichos rect√°ngulos en funci√≥n de su √°rea.

## Socios ordenados

Se cuenta con la siguiente lista de diccionarios, la cual contiene datos personales sobre miembros de un club de atletismo:

```python
datos_socios = [
  {"nombre": "Bautista Carrara", "edad": 22, "altura_cm": 178, "record_100m": 13.4},
  {"nombre": "Valentina Lucci",  "edad": 23, "altura_cm": 163, "record_100m": 14.2},
  {"nombre": "Ger√≥nimo Cuesta",  "edad": 26, "altura_cm": 170, "record_100m": 14.0},
  {"nombre": "Lucio Borga",      "edad": 28, "altura_cm": 186, "record_100m": 13.8},
  {"nombre": "Julia Spoglia",    "edad": 21, "altura_cm": 163, "record_100m": 11.9},
  {"nombre": "Soledad Colombo",  "edad": 22, "altura_cm": 170, "record_100m": 13.5}
]
```

Ordene la lista en base a los r√©cords en la carrera de 100 metros, en forma ascendente.

### Punto extra

Implemente una funci√≥n que tome como argumento una clave de diccionario y devuelva una lista ordenada por los valores de dicha clave. Si el argumento toma el valor `"nombre"`, ordene los elementos alfab√©ticamente en base a los apellidos.

## Listado de rimas

Se tiene la siguiente lista de palabras, la cual se quiere utilizar para formar rimas:

```python
palabras_a_rimar = [
  "actividad", 
  "bendici√≥n", 
  "cartelera", 
  "ciudad", 
  "escalera", 
  "estaci√≥n", 
  "felicidad", 
  "funci√≥n", 
  "reposera"
]
```

Ordene la lista en base al orden alfab√©tico del reverso de cada palabra, de modo que las palabras que riman se encuentren juntas.

::: {.callout-tip collapse="true"}
### Ayuda

Si la lista fuese `["durazno", "kiwi"]`, el resultado ser√≠a `["kiwi", "durazno"]`, porque `"iwik"` precede a `"onzarud"` en orden alfab√©tico.
:::

## El tiempo vuela

Se quiere medir el tiempo que tarda la computadora en ejecutar distintos bloques de c√≥digo. Para eso, implemente una funci√≥n `crear_cronometro` que fabrique una funci√≥n `cronometro`, la cual devuelve el tiempo transcurrido entre su creaci√≥n y la llamada a la funci√≥n. Luego, utilice dos cron√≥metros en paralelo para evaluar el siguiente c√≥digo:

```python
cronometro1 = crear_cronometro()

for i in range(10**4):
  i ** 2 # Calcula el cuadrado de un n√∫mero pero no lo devyelve

cronometro2 = crear_cronometro()

for j in range(10**6):
  j // 2 # Calcula la divisi√≥n entera por 2 pero no la devuelve

print(f"El segundo bucle tard√≥ {cronometro2()} segundos en ejecutarse.")
print(f"El bloque entero tard√≥ {cronometro1()} segundos en ejecutarse.")
```

### Punto extra

Modifique el funcionamiento del cron√≥metro para que en cada llamada devuelva el tiempo transcurrido entre la llamada actual y la inmediata anterior (excepto en la primera llamada, que devuelve el tiempo transcurrido desde su creaci√≥n).

::: {.callout-tip collapse="true"}

### Ayuda

Para medir el paso del tiempo en Python podemos usar la funci√≥n `time` del m√≥dulo hom√≥nimo.

```python
from time import time, sleep

inicio = time()
sleep(2) # Detiene la ejecuci√≥n por 2 segundos
print(time() - inicio) # ~ 2 (segundos)
```
:::

## Sucesi√≥n de Fibonacci

Considere la sucesi√≥n que comienza por los n√∫meros 0 y 1. Los siguientes n√∫meros se forman sumando los dos anteriores.

$$
\{\;0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, \cdots\;\}
$$

Esta sucesi√≥n se conoce como **sucesi√≥n de Fibonacci**.

Implemente una funci√≥n recursiva que tome un n√∫mero natural `n` como entrada y devuelva el `n`-√©simo n√∫mero en la sucesi√≥n.

## Subiendo de rango

La funci√≥n `range(start, stop, step)` de Python devuelve un objeto que genera una secuencia de n√∫meros desde `start` (inclusive) hasta `stop` (exclusive) en incrementos de `step` unidades. El argumento `step`, sin embargo, s√≥lo puede ser un n√∫mero entero (excepto cero).

Implemente una funci√≥n llamada `frange` que acepte los mismos argumentos, pudiendo `step` ser de tipo `float`. La funci√≥n debe retornar un **generador** de la secuencia correspondiente.

## La cajita musical

Tenemos una caja musical que recita los siguientes versos:

```python
versos = [
  "Tengo que confesar que a veces no me gusta tu forma de ser",
  "Luego te me desapareces y no entiendo muy bien por qu√©",

  "No dices nada rom√°ntico cuando llega el atardecer",
  "Te pones de un humor extra√±o con cada luna llena al mes",

  "Pero a todo lo dem√°s le gana lo bueno que me das",
  "S√≥lo tenerte cerca, siento que vuelvo a empezar"
]
```

Implemente una funci√≥n para darle cuerda a la caja musical. En cada llamada debe devolver un verso distinto, hasta agotarlos todos.

::: {.callout-tip collapse="true"}
### Ayuda

Mediante el uso de `yield` se puede lograr que una funci√≥n se detenga en un punto intermedio y retome desde ese punto en la siguiente llamada.

```python
def mostrar_fase():
  print("Inicio")
  yield
  print("Medio")
  yield
  print("Desenlace")
  yield
```
:::

## El mejor precio

Un supermercado ofrece m√∫ltiples promociones:

- 15% de descuento los d√≠as lunes y mi√©rcoles.
- 10% de descuento en compras con monto superior a $50.000.
- 20% de descuento a clientes mayores de 65 a√±os.

Para determinar la promoci√≥n a aplicar, el supermercado utiliza un programa con la siguiente estructura:

```python
def promo_dia_semana(compra):
  """Aplica un 15% de descuento si la compra se realiza un lunes o mi√©rcoles.""" 
  return None # hay que implementar esta funci√≥n

def promo_monto_grande(compra):
  """Aplica un 10% de descuento si la compra tiene un monto superior a $50.000.""" 
  return None # hay que implementar esta funci√≥n

def promo_edad(compra):
  """Aplica un 20% de descuento si el cliente tiene 65 a√±os o m√°s.""" 
  return None # hay que implementar esta funci√≥n
  
promos = [promo_dia_semana, promo_monto_grande, promo_edad]

def mejor_promo(compra):
  """Ordena los descuentos de mayor a menor y aplica el mejor disponible."""
  descuentos = sorted([promo(compra) for promo in promos], key = lambda x: x["monto"])
  return descuentos[0]
  
ejemplo_compra = {"dia": "mi√©rcoles", "edad_cliente": 42, "monto": 66420}
mejor_promo(ejemplo_compra) # {"dia": "mi√©rcoles", "edad_cliente": 42, "monto": 56457.0}
```

El problema con esta implementaci√≥n es que, cada vez que se a√±ade o elimina una promoci√≥n, el cambio debe llevarse a cabo tanto en la funci√≥n de la promoci√≥n como en la lista de promociones. Para evitar el trabajo duplicado, implemente los siguientes cambios:

1. Defina primero la lista `promos`, la cual comienza estando vac√≠a.
2. Defina un decorador `promo` que a√±ade una funci√≥n a la lista `promos` antes de ejecutarla.
3. Implemente las tres funciones de promoci√≥n y dec√≥relas con el decorador del paso anterior.

## Bromas pesadas üò±

Nuestro amigo programador est√° armando una p√°gina web, con una funci√≥n que saluda a los nuevos usuarios por su nombre cuando se registran. Nosotros queremos gastarle una broma a nuestro amigo, metiendo en su c√≥digo un decorador que haga que su funci√≥n corra normalmente excepto cada `n`-√©sima corrida, fallando silenciosamente (no imprime nada). El valor `n` es un n√∫mero entero de nuestra elecci√≥n.

```python
@romper_cada(3)
def saludar(nombre):
  print(f"¬°Hola, {nombre}!")
  
saludar("Carlos")     # "¬°Hola, Carlos!"
saludar("Mar√≠a Luz")  # "¬°Hola, Mar√≠a Luz!"
saludar("Mirna")      # Nada (la funci√≥n devuelve None)
saludar("Diego")      # "¬°Hola, Diego!"
```

### Ayuda

Para crear un decorador que reciba argumentos, podemos crear una f√°brica de decoradores:

```python
def mi_decorador(n):
  def decorar(funcion):
    print(f"Ejecutando decorador con argumento {n}")
    return funcion
  return decorar
  
@mi_decorador(7)
def imprimir(mensaje):
  print(mensaje)
  
imprimir("Hola mundo")
# > Ejecutando decorador con argumento 7
# > Hola mundo
```
-----------------------------------------------------------------------------------------------

## Trasfromando funciones

Transforma estas funciones impuras en puras (manteniendo su l√≥gica):

Funci√≥n 1
```python
contador = 0
def incrementar():
    global contador
    contador += 1
    return contador
```

Funci√≥n 2
```python
def obtener_hora_actual():
    import datetime
    return datetime.datetime.now().hour
```

Funci√≥n 3
```python
def add_time(time, hours, minutes, seconds):
    increment_time(time, hours, minutes, seconds) 
    return time
```

Funci√≥n 4
```python
historial_de_nombres = []
def registrar_nombre(nombre):
    historial_de_nombres.append(nombre)
    return f"'{nombre}' ha sido registrado en el historial."
```

Funci√≥n 5:
```python
LIMITE_MAXIMO = 100 
def verificar_limite(valor):
    if valor > LIMITE_MAXIMO:
        return "Excede el l√≠mite"
    return "Dentro del l√≠mite"
```

## F√°brica de promociones

Volve al **ejercicio II de la pr√°ctica de la U1** (‚ÄúPromociones‚Äù). Utilizando el mismo sistema de descuentos crea una funci√≥n `crear_promocion` que reciba como argumentos un `medio_de_pago` y un `porcentaje`:

- sino se pasa ning√∫n `porcentaje` se usan los valores por defecto detallados en el enunciado de la practica I (10% d√©bito, 5% cr√©dito).

- Si se pasa `porcentaje`: aplic√° ese porcentaje personalizado (ej: `crear_promocion("d√©bito", 15)` para 15% de descuento).

**Ejemplo de uso:**
```python
promo_debito_personalizada = crear_promocion("d√©bito", 15)`  
print(promo_debito_personalizada(1000))   # Output: 850 (1000 - 15%)
```
## Procesando datos paso a paso

Este ejercicio tiene como objetivo implementar un sistema de preprocesamiento para un DataFrame de pandas (df) que permita encadenar funciones como pasos de un flujo de trabajo, aplicarlas secuencialmente y documentar cada paso utilizando el m√≥dulo inspect.

**Primer paso:**
Defina tres funciones para procesar datos (agregar una breve descripci√≥n de lo que hacen entre `"""` dentro de la definici√≥n de cada una):

-	`eliminar_nulos`: recibe un df. Elimina filas que contengan valores nulos en cualquier columna y devuelve un nuevo df sin filas con `NaN`.

-	`transformacion_logaritmica`: recibe el nombre de una columna num√©rica, devuelve una funci√≥n que recibe  el df, transforma la columna indicada usando el logaritmo natural en base 10 y retorna el df modificado.

-	`filtrar_valores`: recibe el nombre de la columna num√©rica que se filtrar√° y un valor de umbral (valor num√©rico de corte) y devuelve una funci√≥n que recibe el df y conserva solo las filas donde el valor de columna sea mayor que el umbral.

**Segundo paso:** Una vez definidas, crear una lista de funciones que detalle el orden en el que se realizaran las operaciones (pasos), con los nombres de las columnas que desea filtrar y el umbral de corte que desee usar, por ejemplo:

```python
# Creamos un df de ejemplo:
df = pd.DataFrame({
        "edad": [20, 30, None, 40, 25],
        "ingresos": [2000, 3000, 2500, None, 4000]
    })

      # Definimos una lista de pasos de ejemplo:
    pasos = [
        eliminar_nulos,
        normalizar_columna("ingresos"),
        filtrar_valores("edad", 18)
    ]
```
**Tercer paso**: implementa la funci√≥n `ejecutar_pasos` que recibe el df a procesar y la lista de pasos y devuelve el df procesado. Adem√°s, esta funci√≥n debe llamar a otra funci√≥n externa `describir_pasos` que recibe los pasos e imprime el nombre del paso y la descripci√≥n de lo que hace.


## Analistas de temperaturas

Imagina que tenes una lista de temperaturas diarias en grados Celsius y necesitas realizar varias operaciones sobre ellas:

```python
temperaturas_celsius = [
    25.5, 28.0, 19.3, 31.5, 22.8,
    17.0, 30.2, 35.6, 14.2, 32.4,
    22.7, 10.1, 29.5, 33.9, 22.1,
    38.9, 18.4
]
```

a) Converti la lista de temperaturas_celsius a lista_fahrenheit.

  La f√≥rmula de conversi√≥n es: 

  `Fahrenheit = (Celsius * 9/5) + 32`

  Gu√°rda la nueva lista en una variable.

b) De la lista anterior selecciona nada m√°s las temperaturas que sean mayores a 80¬∞F. Guarda el resultado en una nueva lista y asigna la lista a una nueva variable.

c) Utiliza `reduce` para sumar todas las temperaturas filtradas en el paso anterior y calcular el promedio dividiendo la suma total entre la cantidad de elementos en la lista filtrada.


## Tiempo o memoria

Trabaj√°s en el equipo de an√°lisis de datos de un e-commerce y recibiste la lista de ventas del √∫ltimo mes. Ten√©s que extraer informaci√≥n clave de esos datos, pero probando dos maneras distintas de resolver cada tarea.

**1. Preparaci√≥n de los datos**

Para empezar, us√° esta funci√≥n que genera datos de ejemplo de ventas de diferente tama√±o:

```python

import random
CATEGORIAS = ("electr√≥nica", "hogar", "accesorios", "deportes")

def generar_ventas(n=100_000, seed=123):

    """
    Devuelve una lista de n ventas simuladas.
    Cada venta es un dict con: id, precio, categoria.
    Podes ajustar el par√°metro n para obtener un dataset m√°s grande o m√°s chico (p.ej., 100_000,        200_000, 500_000).
    """
    rnd = random.Random(seed)
    ventas = []
    for i in range(1, n + 1):
        ventas.append({
            "id": f"P{i:06d}",
            "precio": round(rnd.uniform(5.0, 500.0), 2),
            "categoria": CATEGORIAS[i % len(CATEGORIAS)],
        })
    return ventas
```
Gener√° un dataset con 100.000 ventas:

```python
`ventas = generar_ventas(n=100_000)`
```

**2. Implementaci√≥n de operaciones**

Ahora vamos a realizar dos operaciones sobre este conjunto de datos, cada una con dos versiones:

a) Calcular Precios con IVA (21%)

  Versi√≥n A: Us√° una list comprehension para crear una nueva lista `llamada precios_con_iva_1` que    contenga todos los precios con el 21% de IVA ya calculado.

  Versi√≥n B: Us√° una expresi√≥n generadora para crear un objeto `precios_con_iva_2` que represente la   operaci√≥n, pero sin calcular ni guardar los resultados todav√≠a.

b) Filtrar Ventas de "electr√≥nica"

  Versi√≥n A: Us√° una list comprehension para crear una nueva lista llamada `electronica_1` que        contenga todas las ventas de la categor√≠a "electr√≥nica".

  Versi√≥n B: Us√° una expresi√≥n generadora para crear un objeto `electronica_2` que represente el      filtro, sin materializar la lista.

**3. An√°lisis y comparaci√≥n**

c) Calcul√° el total de las ventas de electr√≥nica usando `sum()` en ambas versiones (`electronica_1` y `electronica_2`).

d) Para cada operaci√≥n, antes y despu√©s de `sum()`, med√≠ el tiempo de ejecuci√≥n y el uso de memoria del objeto. Para el tiempo, pod√©s usar `time.time()` del modulo `time`. Para la memoria, `sys.getsizeof()` del modulo sys. Registr√° los resultados (si no ves diferencias claras, duplica n al generar el dataset)

**4. Reutilizaci√≥n del objeto:**

e) Intent√° calcular el total de ventas de electr√≥nica una segunda vez para ambos objetos (`electronica_1` y `electronica_2`).

f) Observ√° qu√© sucede en cada caso. ¬øQu√© objeto se puede volver a usar y cu√°l no?

**5) Preguntas para reflexi√≥n:**

g) ¬øQu√© diferencias fundamentales encontraste entre las dos maneras de procesar los datos?             (consider√° cu√°ndo se realiza la operaci√≥n, el uso de memoria y el tiempo de ejecuci√≥n)

h) ¬øQu√© pas√≥ cuando intentaste recorrer o usar el mismo resultado dos veces?

i) ¬øSe comportaron de la misma manera la lista generada y el objeto generador? ¬øPor qu√© cre√©s           que sucede esto?

j) ¬øEn qu√© situaciones elegir√≠as un enfoque u otro? Da un ejemplo de un escenario donde la             ejecuci√≥n A sea mejor y otro donde la B sea la opci√≥n m√°s eficiente.