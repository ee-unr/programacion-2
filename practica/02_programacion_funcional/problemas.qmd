---
title: "游빌 Problemas"
---

## Registro de llamadas

En programaci칩n, el _logging_ es el proceso de registrar eventos durante la ejecuci칩n de un
programa. Estos registros, llamados _logs_, permiten mantener un historial de lo que ocurri칩,
incluyendo estados del sistema, acciones realizadas y posibles errores o advertencias.

En este problema se propone implementar un decorador llamado `log` que registre, en un archivo,
los valores de entrada y salida de cada llamada a las funciones decoradas.
El decorador debe recibir como argumento la ruta del archivo donde se guardar치n los mensajes.

Por ejemplo, el siguiente c칩digo:

```python
import time

@log("registro.log")
def f(x, y):
    return x + y

@log("registro.log")
def g(a, b):
    return a + b ** 2

f(3, 9)
time.sleep(1)
f(256, 256)
time.sleep(3)
g(3, 2)
f(7, 8)
```

Deber칤a generar un archivo `registro.log` con un contenido similar al siguiente:

```{.txt filename="registro.log"}
2025-09-02 18:04:07 - | f(x=3, y=9) -> 12
2025-09-02 18:04:08 - | f(x=256, y=256) -> 512
2025-09-02 18:04:11 - | g(a=3, b=2) -> 7
2025-09-02 18:04:11 - | f(x=7, y=8) -> 15
```

### Requisitos

* Si el archivo no existe, debe crearse autom치ticamente.
* Si el archivo ya existe, los nuevos registros deben agregarse al final, sin sobrescribir los anteriores.

### Ayuda

* Para obtener el momento exacto de la llamada, puede usar `datetime.now()` del m칩dulo `datetime`.
* Para formatear ese valor como texto, utilice el m칠todo `.strftime`.

Por ejemplo:

```python
datetime.datetime.now().strftime("%Y-%m-%d%H:%M:%S")
```
```cmd
2025-09-02 18:30:39
```

## Fibonacci el memorioso

La implementaci칩n recursiva m치s directa de la secuencia de Fibonacci es tan concisa como ineficiente.

```python
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)
```

Al invocar `fibonacci(7)`, se realizan llamadas a `fibonacci(6)` y `fibonacci(5)`.
Luego, `fibonacci(6)` vuelve a llamar a `fibonacci(5)` y `fibonacci(4)`, y as칤 sucesivamente.
Muchas de estas llamadas se repiten: por ejemplo, `fibonacci(5)` se calcula m치s de una vez.

Este comportamiento muestra que los subproblemas se superponen:
los mismos valores se recalculan de manera redundante.

El objetivo de este ejercicio es dise침ar una funci칩n capaz de recordar resultados ya obtenidos,
evitando recomputarlos cada vez que aparecen. Para lograrlo, podemos construir una funci칩n recursiva
que memorice sus valores anteriores y, as칤, avance en la secuencia sin rehacer todos los c치lculos
previos.

### Ayuda

Considere una _function factory_ que devuelva la funci칩n recursiva.
Dentro del 치mbito de la _function factory_ puede existir una estructura de datos mutable que
almacene los resultados ya calculados.