---
title: "üõ†Ô∏è Ejercicios"
---
## El estante de la Farmacia üíä 

üìã**Contexto**: 

Imagin√° un estante de farmacia con N posiciones perfectamente contiguas (sin huecos), numeradas desde 0 hasta N-1. Cada posici√≥n guarda exactamente una caja de un medicamento.

Para este ejercicio, asumiremos que N = 100.

**Reglas de Costo (Lo que cuenta como 1 paso)**

Para medir el costo de cada operaci√≥n, definimos un paso como la unidad de tiempo m√°s peque√±a:

1.  **Observar (Leer):** Mirar qu√© medicamento hay en una posici√≥n espec√≠fica. **(1 paso)**
2.  **Mover:** Deslizar una caja una posici√≥n a la izquierda o derecha. **(1 paso por caja movida)**
3.  **Colocar (Escribir):** Poner una caja nueva en una posici√≥n vac√≠a. **(1 paso)**

**Suposiciones Clave:**

* **Inserci√≥n:** Para hacer un hueco en medio del estante, hay que mover todas las cajas desde esa posici√≥n en adelante hacia la derecha.
* **Eliminaci√≥n:** Para cerrar un hueco en medio del estante, hay que mover todas las cajas desde la posici√≥n eliminada en adelante hacia la izquierda.
* El estante debe permanecer siempre contiguo (sin huecos).

**Tareas de An√°lisis y C√°lculo**

Para cada escenario, calcul√° el costo en pasos y deduc√≠ su complejidad asint√≥tica (Big O), bas√°ndote en la analog√≠a f√≠sica.

| Operaci√≥n | Descripci√≥n del Escenario | Pasos (Con N=100) | Expresi√≥n con N (Big O impl√≠cito) | Justificaci√≥n (¬øPor qu√©?) |
| :--- | :--- | :--- | :--- | :--- |
| **a) Lectura por Posici√≥n** | Decime qu√© medicamento hay en la posici√≥n **37**. | | | |
| **b) B√∫squeda (Peor Caso)** | ¬øEst√° el medicamento X en el estante? (Asum√≠ que **NO est√°** y debes revisar todo el estante). | | | |
| **c) Inserci√≥n al Inicio** | Pon√© un nuevo medicamento en la **posici√≥n 0** y corr√© todo lo dem√°s. | | | |
| **d) Inserci√≥n al Final** | Agreg√° un nuevo medicamento en la **posici√≥n N** (al final del estante). | | | |
| **e) Eliminaci√≥n al Inicio** | Sac√° la caja de la **posici√≥n 0** y corr√© el resto para cerrar el hueco. | | | |
| **f) Eliminaci√≥n al Final** | Sac√° la √∫ltima caja del estante (posici√≥n N‚àí1). | | | |

## Cita con el dentista ü¶∑

üìã **Contexto**

Una cl√≠nica odontol√≥gica necesita un sistema sencillo para gestionar su agenda de turnos. Los turnos se agregan a la lista en orden de llegada, sin preocuparse inicialmente por el orden cronol√≥gico.

**Datos iniciales**

La agenda se mantiene en un arreglo (lista) de diccionarios.

```python
agenda = [
    {"paciente": "Juana P√©rez", "hora": "08:30"},
    {"paciente": "Mario G√≥mez", "hora": "09:00"},
    {"paciente": "Sof√≠a L√≥pez", "hora": "09:30"},
    {"paciente": "Ana Fern√°ndez", "hora": "10:15"},
]
```

**Funciones a implementar**

Usando operaciones b√°sicas sobre el arreglo (sin usar remove ni pop directamente):

`leer_pos(i)`: Devuelve el turno en la posici√≥n `i`.
Si `i` no existe, devuelve `None`.

`insertar(turno)`: Agrega un nuevo diccionario
`{"paciente": ..., "hora": "HH:MM"}` al final de la lista
(simulando la llegada de un nuevo paciente). Devuelve `True`.

`eliminar(hora)`: Busca el primer turno con esa hora y lo elimina.
Devuelve `True` si lo elimin√≥, `False` si el horario no estaba en la lista.

`buscar(hora)`: Recorre la lista desde el principio hasta el final.
Devuelve la posici√≥n (√≠ndice) donde est√° ese horario, o `-1` si no existe.

`listar()`: Devuelve una lista de strings con el formato:
`["0) 08:30 - Juana P√©rez", "1) 09:00 - Mario G√≥mez", ...]`

**Ejemplo de uso**

```python
print(leer_pos(1))
# {'paciente': 'Mario G√≥mez', 'hora': '09:00'}

nuevo = {"paciente": "Diego Romero", "hora": "09:45"}
insertar(nuevo)  # Se agrega al final

print(buscar("09:45"))
# 4  (Si era el quinto elemento, ya que la lista creci√≥)

print(eliminar("09:00")) 
# True

print(listar())
# ['0) 08:30 - Juana P√©rez', 
#  '1) 09:30 - Sof√≠a L√≥pez', 
#  '2) 10:15 - Ana Fern√°ndez',
#  '3) 09:45 - Diego Romero']

```

‚úÖ Casos a probar:

- Insertar "08:15" (debe ir al inicio).
- Insertar "12:00" (debe ir al final).
- Insertar repetido "09:30" (debe rechazarse).
- Buscar un horario inexistente (debe devolver -1).
- Eliminar uno inexistente (debe devolver False).

**Mini-consigna te√≥rica**
Responde:

¬øQu√© ocurre con los √≠ndices cuando elimin√°s o insert√°s un turno en el medio de la lista?
(Pista: ¬øqu√© pasa con los elementos que estaban despu√©s?)

¬øPor qu√© acceder a agenda[i] es una operaci√≥n O(1)
pero buscar un turno por hora es O(N)?

¬øQu√© estructura te parecer√≠a m√°s conveniente si hubiera miles de turnos?
Explic√° brevemente por qu√©.


## La lista de Reproducci√≥n del DJÔ∏èüéµ

üìã **Contexto**

Un DJ est√° gestionando su lista principal de canciones, almacenada en una secuencia ordenada de reproducci√≥n. Necesitas desarrollar las herramientas para manipular esta lista de forma eficiente y precisa antes del show.

**Requerimientos de Manipulaci√≥n**

Tu sistema debe soportar las siguientes acciones, considerando que la lista es una secuencia lineal donde el orden es fundamental:

- **Consulta por Ubicaci√≥n**: El DJ debe poder pedir la canci√≥n que est√° en una posici√≥n exacta de la secuencia (ej. "Dime qu√© canci√≥n est√° en el tercer lugar").

- **Adici√≥n Controlada**: Se debe poder insertar una nueva canci√≥n exactamente en una posici√≥n espec√≠fica de la secuencia (ej. "Pon 'Nueva Canci√≥n' justo antes de la canci√≥n que actualmente est√° en la posici√≥n 5"). Esto implica que las canciones que estaban en esa posici√≥n y despu√©s deben moverse para hacer espacio.

- **Remoci√≥n Dirigida**: El DJ debe poder quitar una canci√≥n conociendo su nombre de la lista. Una vez retirada, las canciones que estaban despu√©s deben moverse para cerrar el hueco y mantener la secuencia contigua.

- **Identificaci√≥n por Nombre**: Se requiere una funci√≥n para localizar una canci√≥n por su nombre y devolver su ubicaci√≥n actual en la secuencia.

**Datos Iniciales**

```python
canciones = ["Thunderstruck", "Billie Jean", "Smells Like Teen Spirit"]
```

**Ejemplos de uso:**

```python
# Ejemplo de requerimiento: Inserci√≥n
# Intentamos poner "One" en la posici√≥n 2 (el tercer espacio)
insertar_cancion(2, "One")
# La lista debe ajustarse autom√°ticamente: ["Thunderstruck", "Billie Jean", "One", "Smells Like Teen Spirit"]

# Ejemplo de requerimiento: Eliminaci√≥n
eliminar_cancion("Billie Jean")
# La lista debe reajustarse: ["Thunderstruck", "One", "Smells Like Teen Spirit"]
```

üí° Punto Extra: Visualizaci√≥n del √çndice

- Mostra al DJ la lista completa, indicando claramente la posici√≥n inicial de cada pista en la secuencia.

## Scanner Pro 3000 ü§ñ

üìã Contexto:

En un recital, cada entrada tiene un c√≥digo. Al ingresar, el lector va guardando los c√≥digos en una lista en el orden en que se escanean. La producci√≥n te pide detectar si hubo c√≥digos repetidos (fraude o doble escaneo).

Te entregan una lista escaneos con miles de c√≥digos (strings).

```python
escaneos = [
    "A1F3", "B9K2", "X7Z1", "A1F3", "L0P9", "M2Q5", "B9K2", ...
]
```
‚û°Ô∏è**Parte A**

Escrib√≠ una funci√≥n que encuentre si hay alg√∫n c√≥digo repetido comparando cada elemento con todos los que le siguen (doble for).

**Responde:**

- ¬øCu√°ntas comparaciones hace en el peor caso con N elementos?
- ¬øQu√© pasa cuando N crece x10?

‚û°Ô∏è**Parte B**:

Implement√° una versi√≥n lineal usando un set para registrar c√≥digos ya vistos.

**Responde**: 

- ¬øPor qu√© ahora es O(N)?
- ¬øQu√© operaci√≥n te permite ‚Äúsaltar‚Äù comparaciones?


‚û°Ô∏è**Parte C:**

Usa esta funcion que crea codigos aleatorios para generar listas de codigos de tama√±os crecientes y medi el tiempo de ejecucion de cada funcion anteior:

```python

import random, string, time

def generar_codigos(n, dup_ratio=0.0, seed=0):
    rng = random.Random(seed)
    base = set()
    # crear c√≥digos √∫nicos
    while len(base) < int(n * (1 - dup_ratio)):
        base.add(''.join(rng.choices(string.ascii_uppercase + string.digits, k=6)))
    lista = list(base)
    # inyectar duplicados
    while len(lista) < n:
        lista.append(rng.choice(list(base)))
    rng.shuffle(lista)
    return lista

```
## El Club Secreto de los Hackers üï∂Ô∏è

üìã **Contexto**: Un grupo de hackers tiene un club secreto con reglas muy estrictas sobre qui√©n puede entrar y salir. Los miembros se ordenan seg√∫n su entrada: desde el fundador hasta el √∫ltimo ingresante. En caso de ser necesaria una reducci√≥n de miembros, los primeros en irse deben ser los que menos experiencia tienen (el √∫ltimo en entrar al club debe ser el primero en salir). Si un hacker que no es el √∫ltimo en entrar sale del grupo fuera de orden, se considera una violaci√≥n de seguridad y se registra la acci√≥n en el sistema.

**Datos iniciales**
```python

club = [
    {"nombre": "Anonymous"},
    {"nombre": "Mitnick"},  
    {"nombre": "Soupnazi"},  
    {"nombre": "D-Dante"}    
]

```

Teniendo en cuenta el contexto implementa las siguientes funciones para regular la entrada y salida de los miembros del club:

1. **`entrar(nombre)`**
   - Agrega un hacker a la pila del club
   - Cada entrada debe registrarse como un diccionario: `{"nombre": "Neo"}`
   - Si hay m√°s de 10 hacker, imprimir: **"‚ö†Ô∏è El Club esta lleno, capacidad m√°xima alcanzada"**

2. **`salir()`**
   - Saca al √∫ltimo hacker que entr√≥ 
   - Retorna el nombre del hacker que sali√≥
   - Si la pila est√° vac√≠a, imprimir: **"üåë El club ha desaparecido en la oscuridad..."**

3. **`ultimo_en_entrar()`**
   - Muestra qui√©n est√° en el top de la pila **sin sacarlo**
   - Retorna el nombre del √∫ltimo que entr√≥
   - Si la posiion aun no fue cubierta, retorna None

4. **`mostrar_club()`**
   - Muestra todos los hackers en el club, del m√°s reciente al m√°s antiguo
   - Indica cu√°ntos hay en total
   - Formato: `[Top] Neo -> Trinity -> Anonymous [Base]`

5. **`esta_en_club(nombre)`**
   - Verifica si un hacker espec√≠fico est√° dentro
   - Retorna True o False
   - **IMPORTANTE**: No destruir la pila al buscar

**Ejemplo de uso esperado**
```python
entrar("Morpheus")
entrar("Trinity")
entrar("Neo")

mostrar_club()
# Output:  Club (3 hackers): [Top] Neo -> Trinity -> Morpheus [Base]

print(ultimo_en_entrar())
# Output: Neo

salir()
# Output: üëã Neo ha salido del club

print(esta_en_club("Trinity"))
# Output: True

print(esta_en_club("Cypher"))
# Output: False
```

**Casos a probar**
```python
# Caso 1: Club vac√≠o
club.clear()
salir()  # Debe mostrar mensaje

# Caso 2: Verificar LIFO
entrar("A")
entrar("B")
entrar("C")
salir()  # Debe salir C (√∫ltimo en entrar)
salir()  # Debe salir B
ultimo_en_entrar()  # Debe ser A

# Caso 3: Club lleno
for i in range(12):
    entrar(f"Hacker{i}")  # En el 11vo debe avisar que est√° lleno

# Caso 4: Buscar sin destruir
entrar("Neo")
entrar("Trinity")
print(esta_en_club("Neo"))  # True
mostrar_club()  # Neo debe seguir en la pila
```

### üöÄ Nivel 2: Desaf√≠o

Nueva funcionalidad: Control de acceso con violaciones

Impelmente las siguentes funciones:

6. **`salir_especifico(nombre)`**
  -  Si nombre es el TOP: sacarlo sin registrar violaci√≥n, retornar True.
  -  Si no es el TOP pero est√° en la pila:
  -  Desapilar a un buffer hasta encontrar nombre.
  -  Remover nombre.
  -  Reapilar en orden original todo lo que sacaste.
  -  Registrar violaci√≥n en _log_violaciones con formato:
     "{HH:MM} - Violaci√≥n: {nombre} sali√≥ fuera de orden"
     (usar datetime.now().strftime("%H:%M")).
     Retornar True.
  -  Si no se encuentra: retornar False.
   

7. **`historial_violaciones()`**
   - Muestra todas las violaciones de seguridad registradas
   - Formato: `["17:30 - Violaci√≥n: Trinity sali√≥ fuera de orden"]`

### Ejemplo de uso
```python
entrar("Morpheus")
entrar("Trinity")
entrar("Neo")
entrar("Cypher")

# Neo y Cypher est√°n encima de Trinity
salir_especifico("Trinity")
# Output: üö® VIOLACI√ìN DE SEGURIDAD: Trinity sali√≥ fuera de orden

mostrar_club()
# Output: [Top] Cypher -> Neo -> Morpheus [Base]
# Trinity ya no est√°

```
## Torre de control aereo ‚úàÔ∏è 

üìã**Contexto**

La Autoridad de Tr√°fico A√©reo necesita optimizar las operaciones de una torre de control. Tu tarea es modelar el sistema que gestiona los permisos de movimiento de los aviones.

Existen dos tipos de solicitudes pendientes:

**Aviones esperando Despegue:** Estos aviones forman una fila de espera. Se les debe dar permiso para despegar siguiendo un principio estricto: el avi√≥n que lleva m√°s tiempo esperando en la fila es el primero en recibir permiso.

**Aviones en Aproximaci√≥n de Emergencia:** Estos aviones requieren aterrizaje inmediato debido a una situaci√≥n cr√≠tica. Estos permisos de aterrizaje se apilan, y la torre debe procesar la emergencia m√°s reciente antes que cualquier otra, es decir: el √∫ltimo avi√≥n en reportar la emergencia es el primero en recibir la autorizaci√≥n de aterrizaje.

**Prioridad de la Torre: **
La torre de control siempre otorga permisos siguiendo una estricta jerarqu√≠a:

- Prioridad Absoluta: Si hay alguna emergencia pendiente, la torre siempre debe autorizar primero un aterrizaje de emergencia.
- Prioridad Secundaria: Solo cuando no haya ninguna emergencia pendiente, la torre podr√° autorizar el despegue del avi√≥n que le corresponda.

Datos Iniciales
Comienza con la siguiente situaci√≥n en el aeropuerto:
```python
# Lista de aviones esperando para Despegar
solicitudes_despegue = ["Vuelo 101", "Vuelo 205"] 
# Lista de aviones reportando Emergencia
solicitudes_emergencia = ["Vuelo 999"]
```
**Requisitos Funcionales**

Debes crear un sistema con las siguientes acciones:

- Una funci√≥n para registrar la llegada de un nuevo avi√≥n a la lista de despegue.

- Una funci√≥n para registrar una nueva solicitud de aterrizaje de emergencia.

- Una funci√≥n principal, `procesar_evento()`, que simule la acci√≥n de la torre de control al otorgar un permiso seg√∫n las reglas de prioridad.

**Punto extra:** Si la torre intenta otorgar un permiso y ambas listas est√°n vac√≠as, debe notificarlo con el mensaje: ‚ÄúTorre en silencio‚Äù.

## Alerta de Virus Zombie üßü 

üìã **Contexto**: Sos un cientifico/a de un laboratorio secreto que est√° procesando muestras de virus zombies. Debes implementar un sistema de gesti√≥n usando colas para manejar el flujo de trabajo.

‚ö†Ô∏è **Alerta importante**: Si hay **m√°s de 5 muestras del mismo tipo de virus** en la cola, se activa una **alerta biol√≥gica** (riesgo de propagaci√≥n masiva).

### üéØ Nivel 1:

**Datos iniciales**
```python
from collections import deque

muestras = deque(["virus_tank", "virus_witch", "virus_charger"])
```

**Tareas:**

Implementa las siguientes funciones:

1. **`agregar_muestra(nombre)`**
   - Agrega una muestra al final de la cola
   - Muestra mensaje confirmando la operaci√≥n
   - Verifica si hay m√°s de 5 muestras del mismo tipo
   - Si se cumple la condici√≥n, imprime: **"¬°Alerta biol√≥gica! Detectadas X muestras de [nombre_virus] ‚ò£Ô∏è"**

2. **`procesar_muestra()`**
   - Procesa (elimina) la primera muestra de la cola
   - Retorna el nombre de la muestra procesada
   - Si la cola est√° vac√≠a, muestra un mensaje de error

3. **`mostrar_pendientes()`**
   - Muestra la lista de muestras pendientes
   - Retorna la lista de muestras
   - Indica cu√°ntas muestras hay en espera

4. **`contar_por_tipo()`**
   - Retorna un diccionario con el conteo de cada tipo de virus
   - Ejemplo: `{"virus_tank": 3, "virus_witch": 2}`

**Ejemplo de uso esperado**
```python
print(mostrar_pendientes())  
# Output: Muestras pendientes (3): ['virus_tank', 'virus_witch', 'virus_charger']

agregar_muestra("virus_tank")
agregar_muestra("virus_tank")
agregar_muestra("virus_tank")
agregar_muestra("virus_tank")
agregar_muestra("virus_tank")
# Output en la 5ta: ¬°Alerta biol√≥gica! Detectadas 6 muestras de virus_tank ‚ò£Ô∏è

print(contar_por_tipo())
# Output: {'virus_tank': 6, 'virus_witch': 1, 'virus_charger': 1}

procesar_muestra()  
# Output: üî¨ Procesando 'virus_tank'
# Retorna: 'virus_tank'
```

**Casos a probar**
```python
# Caso 1: Cola vac√≠a
muestras.clear()
procesar_muestra()  # Debe mostrar error

# Caso 2: Alerta biol√≥gica por acumulaci√≥n
for i in range(6):
    agregar_muestra("virus_hunter")  # Debe activar alerta en la 6ta

# Caso 3: Verificar que la alerta sea por tipo espec√≠fico
agregar_muestra("virus_tank")
agregar_muestra("virus_witch")
agregar_muestra("virus_tank")
# No debe haber alerta (solo 2 de cada tipo)

# Caso 4: Procesar reduce el conteo
for i in range(7):
    agregar_muestra("virus_smoker")  # Alerta: 7 smoker
procesar_muestra()  # Procesa 1 virus_tank (de los iniciales)
print(contar_por_tipo())  # Deber√≠a seguir mostrando 7 smoker
```

### üöÄ Nivel 2: Desaf√≠o

**Nueva funcionalidad: Muestras prioritarias**

Algunas muestras son urgentes y deben procesarse antes que las normales.

**Datos iniciales**
```python
from collections import deque

muestras_normales = deque(["virus_tank", "virus_witch"])
muestras_urgentes = deque()
```

**Tareas adicionales**

5. **`agregar_muestra(nombre, urgente=False)`**
   - Si `urgente=True`, agrega a la cola de urgentes
   - Si `urgente=False`, agrega a la cola normal
   - **La alerta biol√≥gica debe contar en AMBAS colas** (misma cepa puede estar en las dos)

6. **`procesar_muestra()`** (modificada)
   - Primero procesa muestras urgentes
   - Si no hay urgentes, procesa normales
   - Si ambas colas est√°n vac√≠as, muestra error

7. **`mostrar_todas()`**
   - Muestra ambas colas por separado
   - Indica cu√°ntas muestras hay en cada una
   - Muestra el conteo total por tipo de virus

8. **`contar_por_tipo()`** (modificada)
   - Debe contar en ambas colas
   - Retorna el conteo global de cada tipo

**Ejemplo de uso**
```python
# Agregar 4 tank normales y 3 tank urgentes
for i in range(4):
    agregar_muestra("virus_tank", urgente=False)
    
for i in range(3):
    agregar_muestra("virus_tank", urgente=True)
    # En la 3ra debe activarse la alerta (total: 4+3=7 tanks)

mostrar_todas()
# Output: 
# üö® Urgentes (3): ['virus_tank', 'virus_tank', 'virus_tank']
# üìã Normales (6): ['virus_tank', 'virus_witch', 'virus_tank', ...]
# üìä Conteo por tipo: {'virus_tank': 7, 'virus_witch': 1}
```

##  Batalla Pok√©mon ‚öîÔ∏è

üìã **Contexto**: Un gimnasio Pok√©mon necesita un sistema para gestionar los batallas entre equipos. Para lograrlo te contratan y te dan la siguiente infromaci√≥n:

- Los entrenadores pokemon pueden capturar nuevos Pok√©mones y agregarlos a su equipo
- Los entrenadores necesitan poder buscar un Pok√©mon espec√≠fico por su nombre para usarlo en batalla
- Los entrenadores tienen que poder retirar del equipo a los Pok√©mon debilitados o que ya no quieren usar
- Los entrenadores deben poder revisar su equipo completo para decidir su estrategia

Tu trabajo sera implementar la Clase`equipo`, para eso puedes usar la siguente clase ya implementada:

```python
class Pokemon:
    """Representa un Pok√©mon individual"""
    
    def __init__(self, nombre, tipo, nivel, max_hp, ataque):
        self.nombre = nombre
        self.tipo = tipo
        self.nivel = nivel
        self.max_hp = max_hp
        self.hp = max_hp  # Empieza con vida completa
        self.ataque = ataque
    
    def recibir_da√±o(self, puntos):
        """Reduce HP, no puede ser negativo"""
        self.hp = max(0, self.hp - puntos)
    
    def curar(self, puntos):
        """Aumenta HP, no puede superar el m√°ximo"""
        self.hp = min(self.max_hp, self.hp + puntos)
    
    def esta_debilitado(self):
        """Retorna True si el Pok√©mon no puede combatir"""
        return self.hp == 0
    
    def subir_nivel(self):
        """Sube de nivel y aumenta stats"""
        self.nivel += 1
        self.max_hp += 5
        self.hp = self.max_hp  # Se cura completamente
    
    def __str__(self):
        return f"{self.nombre} ({self.tipo.capitalize()}) Nv.{self.nivel} [HP: {self.hp}/{self.max_hp}]"
```

**Ejemplo de uso:**
```python
pikachu = Pokemon("Pikachu", "el√©ctrico", nivel=25, max_hp=35, ataque=14)
print(pikachu)  # Pikachu (El√©ctrico) Nv.25 [HP: 35/35]

pikachu.recibir_da√±o(10)
print(pikachu)  # Pikachu (El√©ctrico) Nv.25 [HP: 25/35]
```

**Requerimientos para implementar la Clase `Equipo`:**

Los maestros/as Pokemon necesitan gestionar su equipo de forma din√°mica. Las operaciones que m√°s realizan son:

1. **Agregar** un Pok√©mon reci√©n capturado (siempre al final)
2. **Buscar** un Pok√©mon espec√≠fico por nombre
3. **Eliminar** un Pok√©mon espec√≠fico del equipo
4. **Listar** todos los Pok√©mon para revisarlos
5. **Eliminar todos los debilitados** despu√©s de una batalla
6. **Contar** cu√°ntos Pok√©mon tiene

**Requisitos importantes:**

- No se te permite usar listas normales de Python con acceso por √≠ndice** (`lista[0]`, `lista[2]`, etc.)
- La calse debe ser eficiente para agregar y eliminar elementos
- Podes crear clases auxiliares si lo necesitas (como Nodo).

**M√©todos necesarios:**

- `__init__(nombre_entrenador)`
Inicializa un equipo vac√≠o para el entrenador.
- `agregar_pokemon(pokemon)`
Agrega un Pok√©mon al final del equipo.
- `buscar(nombre)`
Busca un Pok√©mon por nombre. Retorna el objeto Pokemon si lo encuentra, `None` si no existe.
- `eliminar(nombre)`
Elimina un Pok√©mon espec√≠fico del equipo. Retorna `True` si lo elimin√≥, `False` si no exist√≠a. **Importante:**  este metodo debe manejar correctamente los casos de elimnar un elemento que sea el primero, uno del medio o el ultimo.
- `eliminar_debilitados()`
Elimina todos los Pok√©mon con HP = 0. Retorna una lista con los nombres de los eliminados.
- `contar()`
Retorna cu√°ntos Pok√©mon hay en el equipo.
- `esta_vacio()`
Retorna `True` si no hay Pok√©mon en el equipo.
-`listar()`
Retorna una lista de strings con todos los Pok√©mon en orden.
Formato: `["1. Pikachu (El√©ctrico) Nv.25 [HP: 35/35]", "2. Charmander...", ...]`
- `obtener_primero()`
Retorna el primer Pok√©mon del equipo sin eliminarlo. `None` si est√° vac√≠o.
- `obtener_mas_fuerte()`
Retorna el Pok√©mon con mayor ataque. `None` si est√° vac√≠o.
- `pokemon_por_tipo(tipo)`
Retorna una lista con todos los Pok√©mon de un tipo espec√≠fico.
Ejemplo: `pokemon_por_tipo("fuego")` ‚Üí lista con Charmander, Vulpix, etc.

**Ejemplo de uso completo**

```python
# Crear Pok√©mon
pikachu = Pokemon("Pikachu", "el√©ctrico", nivel=25, max_hp=35, ataque=14)
charmander = Pokemon("Charmander", "fuego", nivel=20, max_hp=39, ataque=12)
squirtle = Pokemon("Squirtle", "agua", nivel=22, max_hp=44, ataque=9)
bulbasaur = Pokemon("Bulbasaur", "planta", nivel=21, max_hp=45, ataque=10)
eevee = Pokemon("Eevee", "normal", nivel=18, max_hp=55, ataque=8)

# Crear equipo
equipo_ash = Equipo("Ash")

# Agregar Pok√©mon
equipo_ash.agregar_pokemon(pikachu)
equipo_ash.agregar_pokemon(charmander)
equipo_ash.agregar_pokemon(squirtle)
equipo_ash.agregar_pokemon(bulbasaur)

print(f"Pok√©mon en el equipo: {equipo_ash.contar()}")  # 4

# Listar equipo
print("\n=== EQUIPO DE ASH ===")
for info in equipo_ash.listar():
    print(info)

# Buscar un Pok√©mon
encontrado = equipo_ash.buscar("Squirtle")
if encontrado:
    print(f"\n Encontrado: {encontrado}")

# Obtener el m√°s fuerte
fuerte = equipo_ash.obtener_mas_fuerte()
print(f"\n  M√°s fuerte: {fuerte}")

# Simular batalla
print("\n=== SIMULANDO BATALLA ===")
charmander.recibir_da√±o(39)  # Charmander se debilita
squirtle.recibir_da√±o(20)    # Squirtle pierde HP pero sobrevive

print(f"Charmander debilitado: {charmander.esta_debilitado()}")

# Eliminar debilitados
eliminados = equipo_ash.eliminar_debilitados()
print(f"Pok√©mon eliminados: {eliminados}")  # ['Charmander']

# Ver equipo actualizado
print(f"\nPok√©mon restantes: {equipo_ash.contar()}")  # 3
for info in equipo_ash.listar():
    print(info)

# Agregar nuevo Pok√©mon
equipo_ash.agregar_pokemon(eevee)
print(f"\n Eevee agregado. Total: {equipo_ash.contar()}")

# Buscar por tipo
fuego = equipo_ash.pokemon_por_tipo("fuego")
print(f"\nPok√©mon de fuego: {[str(p) for p in fuego]}")

# Eliminar un Pok√©mon espec√≠fico
equipo_ash.eliminar("Pikachu")
print(f"\n Pikachu liberado. Restantes: {equipo_ash.contar()}")
```

::: {.callout-tip collapse="true"}

### Ayuda

**Preguntas para reflexionar ANTES de programar**

1. ¬øQu√© estructura me permite conectar elementos sin √≠ndices?

2. ¬øNecesito crear una clase auxiliar (como Nodo)?

3. Al eliminar un elemento, ¬øqu√© debo hacer con los enlaces?
   - Pista: Debes "saltar" al elemento eliminado reconectando los que estaban antes y despu√©s

4. ¬øC√≥mo recorro todos los elementos sin √≠ndices?
   - Pista: Empezas por el primero y seguis los enlaces hasta llegar al final

5. ¬øQu√© pasa si elimino el primer elemento? ¬øEs diferente a eliminar del medio?
   - Pista: El primer elemento es especial, no tiene un elemento anterior
   
:::