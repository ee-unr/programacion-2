---
title: "ğŸ› ï¸ Ejercicios"
---
## El estante de la Farmacia ğŸ’Š 

ğŸ“‹**Contexto**: 

ImaginÃ¡ un estante de farmacia con N posiciones perfectamente contiguas (sin huecos), numeradas desde 0 hasta N-1. Cada posiciÃ³n guarda exactamente una caja de un medicamento.

Para este ejercicio, asumiremos que N = 100.

**Reglas de Costo (Lo que cuenta como 1 paso)**

Para medir el costo de cada operaciÃ³n, definimos un paso como la unidad de tiempo mÃ¡s pequeÃ±a:

1.  **Observar (Leer):** Mirar quÃ© medicamento hay en una posiciÃ³n especÃ­fica. **(1 paso)**
2.  **Mover:** Deslizar una caja una posiciÃ³n a la izquierda o derecha. **(1 paso por caja movida)**
3.  **Colocar (Escribir):** Poner una caja nueva en una posiciÃ³n vacÃ­a. **(1 paso)**

**Suposiciones Clave:**

* **InserciÃ³n:** Para hacer un hueco en medio del estante, hay que mover todas las cajas desde esa posiciÃ³n en adelante hacia la derecha.
* **EliminaciÃ³n:** Para cerrar un hueco en medio del estante, hay que mover todas las cajas desde la posiciÃ³n eliminada en adelante hacia la izquierda.
* El estante debe permanecer siempre contiguo (sin huecos).

**Tareas de AnÃ¡lisis y CÃ¡lculo**

Para cada escenario, calculÃ¡ el costo en pasos y deducÃ­ su complejidad asintÃ³tica (Big O), basÃ¡ndote en la analogÃ­a fÃ­sica.

| OperaciÃ³n | DescripciÃ³n del Escenario | Pasos (Con N=100) | ExpresiÃ³n con N (Big O implÃ­cito) | JustificaciÃ³n (Â¿Por quÃ©?) |
| :--- | :--- | :--- | :--- | :--- |
| **a) Lectura por PosiciÃ³n** | Decime quÃ© medicamento hay en la posiciÃ³n **37**. | | | |
| **b) BÃºsqueda (Peor Caso)** | Â¿EstÃ¡ el medicamento X en el estante? (AsumÃ­ que **NO estÃ¡** y debes revisar todo el estante). | | | |
| **c) InserciÃ³n al Inicio** | PonÃ© un nuevo medicamento en la **posiciÃ³n 0** y corrÃ© todo lo demÃ¡s. | | | |
| **d) InserciÃ³n al Final** | AgregÃ¡ un nuevo medicamento en la **posiciÃ³n N** (al final del estante). | | | |
| **e) EliminaciÃ³n al Inicio** | SacÃ¡ la caja de la **posiciÃ³n 0** y corrÃ© el resto para cerrar el hueco. | | | |
| **f) EliminaciÃ³n al Final** | SacÃ¡ la Ãºltima caja del estante (posiciÃ³n Nâˆ’1). | | | |

## Cita con el dentista ğŸ¦·

ğŸ“‹ **Contexto**

Una clÃ­nica odontolÃ³gica necesita un sistema sencillo para gestionar su agenda de turnos. Los turnos se agregan a la lista en orden de llegada, sin preocuparse inicialmente por el orden cronolÃ³gico.

**Datos iniciales**

La agenda se mantiene en un arreglo (lista) de diccionarios.

```python
agenda = [
    {"paciente": "Juana PÃ©rez", "hora": "08:30"},
    {"paciente": "Mario GÃ³mez", "hora": "09:00"},
    {"paciente": "SofÃ­a LÃ³pez", "hora": "09:30"},
    {"paciente": "Ana FernÃ¡ndez", "hora": "10:15"},
]
```

**Funciones a implementar**

Usando operaciones bÃ¡sicas sobre el arreglo (sin usar remove ni pop directamente):

`leer_pos(i)`: Devuelve el turno en la posiciÃ³n `i`.
Si `i` no existe, devuelve `None`.

`insertar(turno)`: Agrega un nuevo diccionario
`{"paciente": ..., "hora": "HH:MM"}` al final de la lista
(simulando la llegada de un nuevo paciente). Devuelve `True`.

`eliminar(hora)`: Busca el primer turno con esa hora y lo elimina.
Devuelve `True` si lo eliminÃ³, `False` si el horario no estaba en la lista.

`buscar(hora)`: Recorre la lista desde el principio hasta el final.
Devuelve la posiciÃ³n (Ã­ndice) donde estÃ¡ ese horario, o `-1` si no existe.

`listar()`: Devuelve una lista de strings con el formato:
`["0) 08:30 - Juana PÃ©rez", "1) 09:00 - Mario GÃ³mez", ...]`

**Ejemplo de uso**

```python
print(leer_pos(1))
# {'paciente': 'Mario GÃ³mez', 'hora': '09:00'}

nuevo = {"paciente": "Diego Romero", "hora": "09:45"}
insertar(nuevo)  # Se agrega al final

print(buscar("09:45"))
# 4  (Si era el quinto elemento, ya que la lista creciÃ³)

print(eliminar("09:00")) 
# True

print(listar())
# ['0) 08:30 - Juana PÃ©rez', 
#  '1) 09:30 - SofÃ­a LÃ³pez', 
#  '2) 10:15 - Ana FernÃ¡ndez',
#  '3) 09:45 - Diego Romero']

```

âœ… Casos a probar:

- Insertar "08:15" (debe ir al inicio).
- Insertar "12:00" (debe ir al final).
- Insertar repetido "09:30" (debe rechazarse).
- Buscar un horario inexistente (debe devolver -1).
- Eliminar uno inexistente (debe devolver False).

**Mini-consigna teÃ³rica**
Responde:

Â¿QuÃ© ocurre con los Ã­ndices cuando eliminÃ¡s o insertÃ¡s un turno en el medio de la lista?
(Pista: Â¿quÃ© pasa con los elementos que estaban despuÃ©s?)

Â¿Por quÃ© acceder a agenda[i] es una operaciÃ³n O(1)
pero buscar un turno por hora es O(N)?

Â¿QuÃ© estructura te parecerÃ­a mÃ¡s conveniente si hubiera miles de turnos?
ExplicÃ¡ brevemente por quÃ©.


## La lista de ReproducciÃ³n del DJï¸ğŸµ

ğŸ“‹ **Contexto**

Un DJ estÃ¡ gestionando su lista principal de canciones, almacenada en una secuencia ordenada de reproducciÃ³n. Necesitas desarrollar las herramientas para manipular esta lista de forma eficiente y precisa antes del show.

**Requerimientos de ManipulaciÃ³n**

Tu sistema debe soportar las siguientes acciones, considerando que la lista es una secuencia lineal donde el orden es fundamental:

- **Consulta por UbicaciÃ³n**: El DJ debe poder pedir la canciÃ³n que estÃ¡ en una posiciÃ³n exacta de la secuencia (ej. "Dime quÃ© canciÃ³n estÃ¡ en el tercer lugar").

- **AdiciÃ³n Controlada**: Se debe poder insertar una nueva canciÃ³n exactamente en una posiciÃ³n especÃ­fica de la secuencia (ej. "Pon 'Nueva CanciÃ³n' justo antes de la canciÃ³n que actualmente estÃ¡ en la posiciÃ³n 5"). Esto implica que las canciones que estaban en esa posiciÃ³n y despuÃ©s deben moverse para hacer espacio.

- **RemociÃ³n Dirigida**: El DJ debe poder quitar una canciÃ³n conociendo su nombre de la lista. Una vez retirada, las canciones que estaban despuÃ©s deben moverse para cerrar el hueco y mantener la secuencia contigua.

- **IdentificaciÃ³n por Nombre**: Se requiere una funciÃ³n para localizar una canciÃ³n por su nombre y devolver su ubicaciÃ³n actual en la secuencia.

**Datos Iniciales**

```python
canciones = ["Thunderstruck", "Billie Jean", "Smells Like Teen Spirit"]
```

**Ejemplos de uso:**

```python
# Ejemplo de requerimiento: InserciÃ³n
# Intentamos poner "One" en la posiciÃ³n 2 (el tercer espacio)
insertar_cancion(2, "One")
# La lista debe ajustarse automÃ¡ticamente: ["Thunderstruck", "Billie Jean", "One", "Smells Like Teen Spirit"]

# Ejemplo de requerimiento: EliminaciÃ³n
eliminar_cancion("Billie Jean")
# La lista debe reajustarse: ["Thunderstruck", "One", "Smells Like Teen Spirit"]
```

ğŸ’¡ Punto Extra: VisualizaciÃ³n del Ãndice

- Mostra al DJ la lista completa, indicando claramente la posiciÃ³n inicial de cada pista en la secuencia.

## Scanner Pro 3000 ğŸ¤–

ğŸ“‹ Contexto:

En un recital, cada entrada tiene un cÃ³digo. Al ingresar, el lector va guardando los cÃ³digos en una lista en el orden en que se escanean. La producciÃ³n te pide detectar si hubo cÃ³digos repetidos (fraude o doble escaneo).

Te entregan una lista escaneos con miles de cÃ³digos (strings).

```python
escaneos = [
    "A1F3", "B9K2", "X7Z1", "A1F3", "L0P9", "M2Q5", "B9K2", ...
]
```
â¡ï¸**Parte A**

EscribÃ­ una funciÃ³n que encuentre si hay algÃºn cÃ³digo repetido comparando cada elemento con todos los que le siguen (doble for).

**Responde:**

- Â¿CuÃ¡ntas comparaciones hace en el peor caso con N elementos?
- Â¿QuÃ© pasa cuando N crece x10?

â¡ï¸**Parte B**:

ImplementÃ¡ una versiÃ³n lineal usando un set para registrar cÃ³digos ya vistos.

**Responde**: 

- Â¿Por quÃ© ahora es O(N)?
- Â¿QuÃ© operaciÃ³n te permite â€œsaltarâ€ comparaciones?


â¡ï¸**Parte C:**

Usa esta funcion que crea codigos aleatorios para generar listas de codigos de tamaÃ±os crecientes y medi el tiempo de ejecucion de cada funcion anteior:

```python

import random, string, time

def generar_codigos(n, dup_ratio=0.0, seed=0):
    rng = random.Random(seed)
    base = set()
    # crear cÃ³digos Ãºnicos
    while len(base) < int(n * (1 - dup_ratio)):
        base.add(''.join(rng.choices(string.ascii_uppercase + string.digits, k=6)))
    lista = list(base)
    # inyectar duplicados
    while len(lista) < n:
        lista.append(rng.choice(list(base)))
    rng.shuffle(lista)
    return lista

```
## El Club Secreto de los Hackers ğŸ•¶ï¸

ğŸ“‹ **Contexto**: Un grupo de hackers tiene un club secreto con reglas muy estrictas sobre quiÃ©n puede entrar y salir. Los miembros se ordenan segÃºn su entrada: desde el fundador hasta el Ãºltimo ingresante. En caso de ser necesaria una reducciÃ³n de miembros, los primeros en irse deben ser los que menos experiencia tienen (el Ãºltimo en entrar al club debe ser el primero en salir). Si un hacker que no es el Ãºltimo en entrar sale del grupo fuera de orden, se considera una violaciÃ³n de seguridad y se registra la acciÃ³n en el sistema.

**Datos iniciales**
```python

club = [
    {"nombre": "Anonymous"},
    {"nombre": "Mitnick"},  
    {"nombre": "Soupnazi"},  
    {"nombre": "D-Dante"}    
]

```

Teniendo en cuenta el contexto implementa las siguientes funciones para regular la entrada y salida de los miembros del club:

1. **`entrar(nombre)`**
   - Agrega un hacker a la pila del club
   - Cada entrada debe registrarse como un diccionario: `{"nombre": "Neo"}`
   - Si hay mÃ¡s de 10 hacker, imprimir: **"âš ï¸ El Club esta lleno, capacidad mÃ¡xima alcanzada"**

2. **`salir()`**
   - Saca al Ãºltimo hacker que entrÃ³ 
   - Retorna el nombre del hacker que saliÃ³
   - Si la pila estÃ¡ vacÃ­a, imprimir: **"ğŸŒ‘ El club ha desaparecido en la oscuridad..."**

3. **`ultimo_en_entrar()`**
   - Muestra quiÃ©n estÃ¡ en el top de la pila **sin sacarlo**
   - Retorna el nombre del Ãºltimo que entrÃ³
   - Si la posiion aun no fue cubierta, retorna None

4. **`mostrar_club()`**
   - Muestra todos los hackers en el club, del mÃ¡s reciente al mÃ¡s antiguo
   - Indica cuÃ¡ntos hay en total
   - Formato: `[Top] Neo -> Trinity -> Anonymous [Base]`

5. **`esta_en_club(nombre)`**
   - Verifica si un hacker especÃ­fico estÃ¡ dentro
   - Retorna True o False
   - **IMPORTANTE**: No destruir la pila al buscar

**Ejemplo de uso esperado**
```python
entrar("Morpheus")
entrar("Trinity")
entrar("Neo")

mostrar_club()
# Output:  Club (3 hackers): [Top] Neo -> Trinity -> Morpheus [Base]

print(ultimo_en_entrar())
# Output: Neo

salir()
# Output: ğŸ‘‹ Neo ha salido del club

print(esta_en_club("Trinity"))
# Output: True

print(esta_en_club("Cypher"))
# Output: False
```

**Casos a probar**
```python
# Caso 1: Club vacÃ­o
club.clear()
salir()  # Debe mostrar mensaje

# Caso 2: Verificar LIFO
entrar("A")
entrar("B")
entrar("C")
salir()  # Debe salir C (Ãºltimo en entrar)
salir()  # Debe salir B
ultimo_en_entrar()  # Debe ser A

# Caso 3: Club lleno
for i in range(12):
    entrar(f"Hacker{i}")  # En el 11vo debe avisar que estÃ¡ lleno

# Caso 4: Buscar sin destruir
entrar("Neo")
entrar("Trinity")
print(esta_en_club("Neo"))  # True
mostrar_club()  # Neo debe seguir en la pila
```

### ğŸš€ Nivel 2: DesafÃ­o

Nueva funcionalidad: Control de acceso con violaciones

Impelmente las siguentes funciones:

6. **`salir_especifico(nombre)`**
  -  Si nombre es el TOP: sacarlo sin registrar violaciÃ³n, retornar True.
  -  Si no es el TOP pero estÃ¡ en la pila:
  -  Desapilar a un buffer hasta encontrar nombre.
  -  Remover nombre.
  -  Reapilar en orden original todo lo que sacaste.
  -  Registrar violaciÃ³n en _log_violaciones con formato:
     "{HH:MM} - ViolaciÃ³n: {nombre} saliÃ³ fuera de orden"
     (usar datetime.now().strftime("%H:%M")).
     Retornar True.
  -  Si no se encuentra: retornar False.
   

7. **`historial_violaciones()`**
   - Muestra todas las violaciones de seguridad registradas
   - Formato: `["17:30 - ViolaciÃ³n: Trinity saliÃ³ fuera de orden"]`

### Ejemplo de uso
```python
entrar("Morpheus")
entrar("Trinity")
entrar("Neo")
entrar("Cypher")

# Neo y Cypher estÃ¡n encima de Trinity
salir_especifico("Trinity")
# Output: ğŸš¨ VIOLACIÃ“N DE SEGURIDAD: Trinity saliÃ³ fuera de orden

mostrar_club()
# Output: [Top] Cypher -> Neo -> Morpheus [Base]
# Trinity ya no estÃ¡

```
## Torre de control aereo âœˆï¸ 

ğŸ“‹**Contexto**

La Autoridad de TrÃ¡fico AÃ©reo necesita optimizar las operaciones de una torre de control. Tu tarea es modelar el sistema que gestiona los permisos de movimiento de los aviones.

Existen dos tipos de solicitudes pendientes:

**Aviones esperando Despegue:** Estos aviones forman una fila de espera. Se les debe dar permiso para despegar siguiendo un principio estricto: el aviÃ³n que lleva mÃ¡s tiempo esperando en la fila es el primero en recibir permiso.

**Aviones en AproximaciÃ³n de Emergencia:** Estos aviones requieren aterrizaje inmediato debido a una situaciÃ³n crÃ­tica. Estos permisos de aterrizaje se apilan, y la torre debe procesar la emergencia mÃ¡s reciente antes que cualquier otra, es decir: el Ãºltimo aviÃ³n en reportar la emergencia es el primero en recibir la autorizaciÃ³n de aterrizaje.

**Prioridad de la Torre: **
La torre de control siempre otorga permisos siguiendo una estricta jerarquÃ­a:

- Prioridad Absoluta: Si hay alguna emergencia pendiente, la torre siempre debe autorizar primero un aterrizaje de emergencia.
- Prioridad Secundaria: Solo cuando no haya ninguna emergencia pendiente, la torre podrÃ¡ autorizar el despegue del aviÃ³n que le corresponda.

Datos Iniciales
Comienza con la siguiente situaciÃ³n en el aeropuerto:
```python
# Lista de aviones esperando para Despegar
solicitudes_despegue = ["Vuelo 101", "Vuelo 205"] 
# Lista de aviones reportando Emergencia
solicitudes_emergencia = ["Vuelo 999"]
```
**Requisitos Funcionales**

Debes crear un sistema con las siguientes acciones:

- Una funciÃ³n para registrar la llegada de un nuevo aviÃ³n a la lista de despegue.

- Una funciÃ³n para registrar una nueva solicitud de aterrizaje de emergencia.

- Una funciÃ³n principal, `procesar_evento()`, que simule la acciÃ³n de la torre de control al otorgar un permiso segÃºn las reglas de prioridad.

**Punto extra:** Si la torre intenta otorgar un permiso y ambas listas estÃ¡n vacÃ­as, debe notificarlo con el mensaje: â€œTorre en silencioâ€.

## Alerta de Virus Zombie ğŸ§Ÿ 

ğŸ“‹ **Contexto**: Sos un cientifico/a de un laboratorio secreto que estÃ¡ procesando muestras de virus zombies. Debes implementar un sistema de gestiÃ³n usando colas para manejar el flujo de trabajo.

âš ï¸ **Alerta importante**: Si hay **mÃ¡s de 5 muestras del mismo tipo de virus** en la cola, se activa una **alerta biolÃ³gica** (riesgo de propagaciÃ³n masiva).

### ğŸ¯ Nivel 1:

**Datos iniciales**
```python
from collections import deque

muestras = deque(["virus_tank", "virus_witch", "virus_charger"])
```

**Tareas:**

Implementa las siguientes funciones:

1. **`agregar_muestra(nombre)`**
   - Agrega una muestra al final de la cola
   - Muestra mensaje confirmando la operaciÃ³n
   - Verifica si hay mÃ¡s de 5 muestras del mismo tipo
   - Si se cumple la condiciÃ³n, imprime: **"Â¡Alerta biolÃ³gica! Detectadas X muestras de [nombre_virus] â˜£ï¸"**

2. **`procesar_muestra()`**
   - Procesa (elimina) la primera muestra de la cola
   - Retorna el nombre de la muestra procesada
   - Si la cola estÃ¡ vacÃ­a, muestra un mensaje de error

3. **`mostrar_pendientes()`**
   - Muestra la lista de muestras pendientes
   - Retorna la lista de muestras
   - Indica cuÃ¡ntas muestras hay en espera

4. **`contar_por_tipo()`**
   - Retorna un diccionario con el conteo de cada tipo de virus
   - Ejemplo: `{"virus_tank": 3, "virus_witch": 2}`

**Ejemplo de uso esperado**
```python
print(mostrar_pendientes())  
# Output: Muestras pendientes (3): ['virus_tank', 'virus_witch', 'virus_charger']

agregar_muestra("virus_tank")
agregar_muestra("virus_tank")
agregar_muestra("virus_tank")
agregar_muestra("virus_tank")
agregar_muestra("virus_tank")
# Output en la 5ta: Â¡Alerta biolÃ³gica! Detectadas 6 muestras de virus_tank â˜£ï¸

print(contar_por_tipo())
# Output: {'virus_tank': 6, 'virus_witch': 1, 'virus_charger': 1}

procesar_muestra()  
# Output: ğŸ”¬ Procesando 'virus_tank'
# Retorna: 'virus_tank'
```

**Casos a probar**
```python
# Caso 1: Cola vacÃ­a
muestras.clear()
procesar_muestra()  # Debe mostrar error

# Caso 2: Alerta biolÃ³gica por acumulaciÃ³n
for i in range(6):
    agregar_muestra("virus_hunter")  # Debe activar alerta en la 6ta

# Caso 3: Verificar que la alerta sea por tipo especÃ­fico
agregar_muestra("virus_tank")
agregar_muestra("virus_witch")
agregar_muestra("virus_tank")
# No debe haber alerta (solo 2 de cada tipo)

# Caso 4: Procesar reduce el conteo
for i in range(7):
    agregar_muestra("virus_smoker")  # Alerta: 7 smoker
procesar_muestra()  # Procesa 1 virus_tank (de los iniciales)
print(contar_por_tipo())  # DeberÃ­a seguir mostrando 7 smoker
```

### ğŸš€ Nivel 2: DesafÃ­o

**Nueva funcionalidad: Muestras prioritarias**

Algunas muestras son urgentes y deben procesarse antes que las normales.

**Datos iniciales**
```python
from collections import deque

muestras_normales = deque(["virus_tank", "virus_witch"])
muestras_urgentes = deque()
```

**Tareas adicionales**

5. **`agregar_muestra(nombre, urgente=False)`**
   - Si `urgente=True`, agrega a la cola de urgentes
   - Si `urgente=False`, agrega a la cola normal
   - **La alerta biolÃ³gica debe contar en AMBAS colas** (misma cepa puede estar en las dos)

6. **`procesar_muestra()`** (modificada)
   - Primero procesa muestras urgentes
   - Si no hay urgentes, procesa normales
   - Si ambas colas estÃ¡n vacÃ­as, muestra error

7. **`mostrar_todas()`**
   - Muestra ambas colas por separado
   - Indica cuÃ¡ntas muestras hay en cada una
   - Muestra el conteo total por tipo de virus

8. **`contar_por_tipo()`** (modificada)
   - Debe contar en ambas colas
   - Retorna el conteo global de cada tipo

**Ejemplo de uso**
```python
# Agregar 4 tank normales y 3 tank urgentes
for i in range(4):
    agregar_muestra("virus_tank", urgente=False)
    
for i in range(3):
    agregar_muestra("virus_tank", urgente=True)
    # En la 3ra debe activarse la alerta (total: 4+3=7 tanks)

mostrar_todas()
# Output: 
# ğŸš¨ Urgentes (3): ['virus_tank', 'virus_tank', 'virus_tank']
# ğŸ“‹ Normales (6): ['virus_tank', 'virus_witch', 'virus_tank', ...]
# ğŸ“Š Conteo por tipo: {'virus_tank': 7, 'virus_witch': 1}
```

##  Batalla PokÃ©mon âš”ï¸

ğŸ“‹ **Contexto**: Un gimnasio PokÃ©mon necesita un sistema para gestionar los batallas entre equipos. Para lograrlo te contratan y te dan la siguiente infromaciÃ³n:

- Los entrenadores pokemon pueden capturar nuevos PokÃ©mones y agregarlos a su equipo
- Los entrenadores necesitan poder buscar un PokÃ©mon especÃ­fico por su nombre para usarlo en batalla
- Los entrenadores tienen que poder retirar del equipo a los PokÃ©mon debilitados o que ya no quieren usar
- Los entrenadores deben poder revisar su equipo completo para decidir su estrategia

Tu trabajo sera implementar la Clase`equipo`, para eso puedes usar la siguente clase ya implementada:

```python
class Pokemon:
    """Representa un PokÃ©mon individual"""
    
    def __init__(self, nombre, tipo, nivel, max_hp, ataque):
        self.nombre = nombre
        self.tipo = tipo
        self.nivel = nivel
        self.max_hp = max_hp
        self.hp = max_hp  # Empieza con vida completa
        self.ataque = ataque
    
    def recibir_daÃ±o(self, puntos):
        """Reduce HP, no puede ser negativo"""
        self.hp = max(0, self.hp - puntos)
    
    def curar(self, puntos):
        """Aumenta HP, no puede superar el mÃ¡ximo"""
        self.hp = min(self.max_hp, self.hp + puntos)
    
    def esta_debilitado(self):
        """Retorna True si el PokÃ©mon no puede combatir"""
        return self.hp == 0
    
    def subir_nivel(self):
        """Sube de nivel y aumenta stats"""
        self.nivel += 1
        self.max_hp += 5
        self.hp = self.max_hp  # Se cura completamente
    
    def __str__(self):
        return f"{self.nombre} ({self.tipo.capitalize()}) Nv.{self.nivel} [HP: {self.hp}/{self.max_hp}]"
```

**Ejemplo de uso:**
```python
pikachu = Pokemon("Pikachu", "elÃ©ctrico", nivel=25, max_hp=35, ataque=14)
print(pikachu)  # Pikachu (ElÃ©ctrico) Nv.25 [HP: 35/35]

pikachu.recibir_daÃ±o(10)
print(pikachu)  # Pikachu (ElÃ©ctrico) Nv.25 [HP: 25/35]
```

**Requerimientos para implementar la Clase `Equipo`:**

Los maestros/as Pokemon necesitan gestionar su equipo de forma dinÃ¡mica. Las operaciones que mÃ¡s realizan son:

1. **Agregar** un PokÃ©mon reciÃ©n capturado (siempre al final)
2. **Buscar** un PokÃ©mon especÃ­fico por nombre
3. **Eliminar** un PokÃ©mon especÃ­fico del equipo
4. **Listar** todos los PokÃ©mon para revisarlos
5. **Eliminar todos los debilitados** despuÃ©s de una batalla
6. **Contar** cuÃ¡ntos PokÃ©mon tiene

**Requisitos importantes:**

- No se te permite usar listas normales de Python con acceso por Ã­ndice** (`lista[0]`, `lista[2]`, etc.)
- La calse debe ser eficiente para agregar y eliminar elementos
- Podes crear clases auxiliares si lo necesitas (como Nodo).

**MÃ©todos necesarios:**

- `__init__(nombre_entrenador)`
Inicializa un equipo vacÃ­o para el entrenador.
- `agregar_pokemon(pokemon)`
Agrega un PokÃ©mon al final del equipo.
- `buscar(nombre)`
Busca un PokÃ©mon por nombre. Retorna el objeto Pokemon si lo encuentra, `None` si no existe.
- `eliminar(nombre)`
Elimina un PokÃ©mon especÃ­fico del equipo. Retorna `True` si lo eliminÃ³, `False` si no existÃ­a. **Importante:**  este metodo debe manejar correctamente los casos de elimnar un elemento que sea el primero, uno del medio o el ultimo.
- `eliminar_debilitados()`
Elimina todos los PokÃ©mon con HP = 0. Retorna una lista con los nombres de los eliminados.
- `contar()`
Retorna cuÃ¡ntos PokÃ©mon hay en el equipo.
- `esta_vacio()`
Retorna `True` si no hay PokÃ©mon en el equipo.
-`listar()`
Retorna una lista de strings con todos los PokÃ©mon en orden.
Formato: `["1. Pikachu (ElÃ©ctrico) Nv.25 [HP: 35/35]", "2. Charmander...", ...]`
- `obtener_primero()`
Retorna el primer PokÃ©mon del equipo sin eliminarlo. `None` si estÃ¡ vacÃ­o.
- `obtener_mas_fuerte()`
Retorna el PokÃ©mon con mayor ataque. `None` si estÃ¡ vacÃ­o.
- `pokemon_por_tipo(tipo)`
Retorna una lista con todos los PokÃ©mon de un tipo especÃ­fico.
Ejemplo: `pokemon_por_tipo("fuego")` â†’ lista con Charmander, Vulpix, etc.

**Ejemplo de uso completo**

```python
# Crear PokÃ©mon
pikachu = Pokemon("Pikachu", "elÃ©ctrico", nivel=25, max_hp=35, ataque=14)
charmander = Pokemon("Charmander", "fuego", nivel=20, max_hp=39, ataque=12)
squirtle = Pokemon("Squirtle", "agua", nivel=22, max_hp=44, ataque=9)
bulbasaur = Pokemon("Bulbasaur", "planta", nivel=21, max_hp=45, ataque=10)
eevee = Pokemon("Eevee", "normal", nivel=18, max_hp=55, ataque=8)

# Crear equipo
equipo_ash = Equipo("Ash")

# Agregar PokÃ©mon
equipo_ash.agregar_pokemon(pikachu)
equipo_ash.agregar_pokemon(charmander)
equipo_ash.agregar_pokemon(squirtle)
equipo_ash.agregar_pokemon(bulbasaur)

print(f"PokÃ©mon en el equipo: {equipo_ash.contar()}")  # 4

# Listar equipo
print("\n=== EQUIPO DE ASH ===")
for info in equipo_ash.listar():
    print(info)

# Buscar un PokÃ©mon
encontrado = equipo_ash.buscar("Squirtle")
if encontrado:
    print(f"\n Encontrado: {encontrado}")

# Obtener el mÃ¡s fuerte
fuerte = equipo_ash.obtener_mas_fuerte()
print(f"\n  MÃ¡s fuerte: {fuerte}")

# Simular batalla
print("\n=== SIMULANDO BATALLA ===")
charmander.recibir_daÃ±o(39)  # Charmander se debilita
squirtle.recibir_daÃ±o(20)    # Squirtle pierde HP pero sobrevive

print(f"Charmander debilitado: {charmander.esta_debilitado()}")

# Eliminar debilitados
eliminados = equipo_ash.eliminar_debilitados()
print(f"PokÃ©mon eliminados: {eliminados}")  # ['Charmander']

# Ver equipo actualizado
print(f"\nPokÃ©mon restantes: {equipo_ash.contar()}")  # 3
for info in equipo_ash.listar():
    print(info)

# Agregar nuevo PokÃ©mon
equipo_ash.agregar_pokemon(eevee)
print(f"\n Eevee agregado. Total: {equipo_ash.contar()}")

# Buscar por tipo
fuego = equipo_ash.pokemon_por_tipo("fuego")
print(f"\nPokÃ©mon de fuego: {[str(p) for p in fuego]}")

# Eliminar un PokÃ©mon especÃ­fico
equipo_ash.eliminar("Pikachu")
print(f"\n Pikachu liberado. Restantes: {equipo_ash.contar()}")
```

::: {.callout-tip collapse="true"}

### Ayuda

**Preguntas para reflexionar ANTES de programar**

1. Â¿QuÃ© estructura me permite conectar elementos sin Ã­ndices?

2. Â¿Necesito crear una clase auxiliar (como Nodo)?

3. Al eliminar un elemento, Â¿quÃ© debo hacer con los enlaces?
   - Pista: Debes "saltar" al elemento eliminado reconectando los que estaban antes y despuÃ©s

4. Â¿CÃ³mo recorro todos los elementos sin Ã­ndices?
   - Pista: Empezas por el primero y seguis los enlaces hasta llegar al final

5. Â¿QuÃ© pasa si elimino el primer elemento? Â¿Es diferente a eliminar del medio?
   - Pista: El primer elemento es especial, no tiene un elemento anterior
   
:::

## Uno mÃ¡s dos 1ï¸âƒ£â•2ï¸âƒ£

Proponer e implementar dos algoritmos que calculen la suma de los primeros `N` nÃºmeros naturales.

* Uno con complejidad $O(N)$ (lineal).
* Uno con complejidad $O(1)$ (constante).

## Uno mÃ¡s tres 1ï¸âƒ£â•3ï¸âƒ£

Proponer e implementar dos algoritmos que calculen la suma de los primeros `N` nÃºmeros naturales **impares**.

* Uno con complejidad $O(N)$ (lineal).
* Uno con complejidad $O(1)$ (constante).

## MÃ¡s y mÃ¡s datos ğŸ“‹ğŸ“ˆ

a. Considere el siguiente cÃ³digo que calcula un acumulado de promedios para una lista de tamaÃ±o `N`.

```python
def promedios_acumulados(lista):
  """
  Ejemplo:  Entrada -> [1, 2, 3, 5]
            Salida  -> [1, 1.5, 2, 2.75]
  """
  N = len(lista)
  promedios = []
  for i in range(1, N+1):
    promedio = sum(lista[:i]) / i
    promedios.append(promedio)
  return promedios
```

Determine la complejidad de este algoritmo.

b. Siendo $\overline{X}_n$ el promedio de los primeros $n$ nÃºmeros en la lista, vale la siguiente identidad recursiva:
$$\overline{X}_{n+1} = \frac{n \cdot \overline{X}_n + x_{n+1}}{n+1}$$
donde $x_{n+1}$ es el elemento $(n+1)$-Ã©simo de la lista.

Utilice este resultado para implementar un algoritmo mÃ¡s eficiente.

## El regreso de Fibonacci ğŸ‡ğŸ‡

En el `Ejercicio 4` de la `Unidad 2` se implementÃ³ una funciÃ³n recursiva para calcular el $n$-Ã©simo nÃºmero en la sucesiÃ³n de Fibonacci.

Esta implementaciÃ³n, sin embargo, es muy ineficiente. De hecho, se puede demostrar que su complejidad es $O(2^n)$ (exponencial).

Utilice [memoizaciÃ³n](https://es.stackoverflow.com/questions/398370/qu%C3%A9-es-memoizaci%C3%B3n-y-c%C3%B3mo-se-usa) para mejorar la eficiencia del algoritmo recursivo. Este nuevo programa tendrÃ¡ eficiencia lineal: $O(n)$.

::: {.callout-tip collapse="true"}

### Ayuda

Al inicio de la funciÃ³n se debe crear un diccionario vacÃ­o: `valores = {}`.

Ante cada valor $f(n)$ de la sucesiÃ³n que toque calcular, se deberÃ¡ chequear si $n$ estÃ¡ entre las claves existentes del diccionario.

* Si no lo estÃ¡, se deberÃ¡ calcular recursivamente y luego almacenar su resultado: `valores[n] = f(n)`.
* Si lo estÃ¡, se devolverÃ¡ el valor `f(n)` sin efectuar mÃ¡s cÃ¡lculos.

:::

## Vinieron los primos ğŸ‘ª

Implementar un algoritmo para determinar si un nÃºmero natural `N` es primo, con complejidad $O(\sqrt{N})$.

::: {.callout-tip collapse="true"}

### Ayuda

NÃ³tese que, dado un nÃºmero natural $N$, para verificar su primalidad es suficiente con verificar si es divisible por algÃºn entero entre $1$ y $\sqrt{N}$. Si fuese un nÃºmero compuesto, jamÃ¡s podrÃ­a expresarse como el producto de dos nÃºmeros mayores a $\sqrt{N}$.
$$a>\sqrt{N},\; b>\sqrt{N} \implies a \cdot b > \sqrt{N} \cdot \sqrt{N} = N$$
:::

## El bueno, el malo y el eficiente ğŸ¤ 

Se tiene una lista con `N` nÃºmeros enteros. Se quiere saber si en la lista existe al menos un par de elementos tales que su suma sea impar.

Proponga e implemente dos algoritmos para esta tarea:

* Uno con complejidad $O(N^2)$ (cuadrÃ¡tica).
* Uno con complejidad $O(N)$ (lineal).

## Seamos sinceros 0ï¸âƒ£ğŸš«

Utilizando el mÃ³dulo `time`, compare el tiempo que tardan estos dos mÃ©todos para determinar si una lista incluye ceros:

* Un bucle `for` que evalÃºa cada elemento.
* `0 in mi_lista`

Â¿CuÃ¡l es mÃ¡s rÃ¡pido? Â¿QuÃ© complejidad parece tener cada uno?

::: {.callout-tip collapse="true"}

### Ayuda

Utilice la funciÃ³n `random.randint` de NumPy para generar un arreglo grande con nÃºmeros al azar.

```python
import numpy as np

N = 3

# Arreglo de nÃºmeros enteros aleatorios
mi_lista = np.random.randint(0, 10**N, size=10**N)
```

Haga variar el valor de `N` entre 3 y 6 para ver cÃ³mo cambia el tiempo de cÃ³mputo en cada mÃ©todo.

(En el `Ejercicio 10` de la `Unidad 2` se explica cÃ³mo usar el mÃ³dulo `time`.)
:::

## Seamos originales ğŸ“šğŸš«

Utilizando el mÃ³dulo `time`, compare el tiempo que tardan estos dos mÃ©todos para remover duplicados de una lista:

* Conviertiendo la lista a `dict` y luego de nuevo a `list`.
* Conviertiendo la lista a `set` y luego de nuevo a `list`.

Â¿CuÃ¡l es mÃ¡s rÃ¡pido? Â¿QuÃ© complejidad parece tener cada uno?

::: {.callout-tip collapse="true"}

### Ayuda

El primer mÃ©todo implica crear un diccionario a partir de una lista.

Esto debe hacerse de forma tal que cada elemento en la lista pase a ser una clave, y a cada ella se le asigna un valor arbitrario (por ejemplo, `None`). De este modo, Python se encargarÃ¡ de que no haya claves duplicadas.

Por Ãºltimo, se deberÃ¡ tomar el conjunto de claves y convertirlo a una lista. Esto devolverÃ¡ una lista similar a la original, pero sin duplicados.
:::

## Altas dimensiones ğŸ¤¯

Implemente un algoritmo para multiplicar dos matrices de dimensiÃ³n `N x N`.

Â¿QuÃ© complejidad tiene?

## Mediana complejidad âš–ï¸

Se tiene una lista desordenada con `2N+1` nÃºmeros distintos (es decir, la lista es de tamaÃ±o impar).

Implemente un algoritmo *naive* para hallar la mediana. Â¿QuÃ© complejidad tiene?

Luego, utilice un algoritmo de ordenamiento que permita resolver el problema de forma mÃ¡s eficiente.

::: {.callout-tip collapse="true"}

### Ayuda

Para una lista de tamaÃ±o `2N+1`, la mediana es el valor tal que `N` elementos son menores (o iguales) a Ã©l.
:::