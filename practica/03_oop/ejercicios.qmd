---
title: "ðŸ› ï¸ Ejercicios"
---

## Contador

Defina una clase `Contador` que represente un contador numÃ©rico.
Por defecto, las instancias comienzan con el valor `0`, aunque debe permitirse inicializarlas con
un valor distinto.

Implemente los siguientes mÃ©todos:

* `incrementar`: aumenta el valor del contador en una cantidad arbitraria (por defecto, 1).
* `decrementar`: disminuye el valor del contador en una cantidad arbitraria (por defecto, 1).
* `reiniciar`: restablece el contador a su valor inicial (Â¡que puede ser distinto de 0!).
* `valor`: devuelve el valor actual del contador.

**Ejemplo de uso**

```python
contador = Contador()
contador.incrementar(5)    # El valor interno es 5
contador.decrementar(2)    # El valor interno es 3
print(contador.valor())    # Imprime 3
contador.reiniciar()
print(contador.valor())    # Imprime 0
```

## Magia para programadores

Esta es tu primera clase de Pociones en Hogwarts y el profesor te dio como tarea descubrir de quÃ© color se volverÃ¡ una pociÃ³n si se mezcla con otra.
Todas las pociones tienen un color definido en formato [RGB](https://www.w3schools.com/html/html_colors_rgb.asp), desde `[0, 0, 0]` hasta `[255, 255, 255]`.

Para complicar un poco mÃ¡s la tarea, el profesor realizarÃ¡ varias mezclas seguidas y luego te preguntarÃ¡ por el color final.
AdemÃ¡s del color, tambiÃ©n deberÃ¡s calcular quÃ© volumen tendrÃ¡ la pociÃ³n despuÃ©s de la mezcla final.

Gracias a tu experiencia en programaciÃ³n descubriste que al mezclar dos pociones, los colores se combinan como si se mezclaran dos colores en formato RGB.
Por ejemplo, si mezclas una pociÃ³n con color `[255, 255, 0]` y volumen `10` con otra de color `[0, 254, 0]` y volumen `5`, obtendrÃ¡s una nueva pociÃ³n con:

- color `[170, 255, 0]`
- volumen `15`

Por lo tanto, decidÃ­s crear una clase `Pocion` que tenga:

- dos propiedades:
  - `color` (una lista o tupla con 3 enteros)
  - `volumen` (un nÃºmero)
- un mÃ©todo `mezclar` que acepte otra `Pocion` y devuelva una nueva `Pocion` ya mezclada.

Ejemplo:

```python
felix_felicis = Pocion([255, 255, 255],  7)
pocion_multijugos = Pocion([51, 102, 51], 12)
nueva_pocion = felix_felicis.mezclar(pocion_multijugos)

nueva_pocion.color # Devuelve [127, 159, 127]
nueva_pocion.volumen # Devuelve 19
```

::: {.callout-tip collapse="true"}
### Ayuda

Los colores de las pociones deben representarse como trÃ­os de nÃºmeros enteros en formato RGB.
Al realizar una mezcla de colores, se debe redondear hacia arriba utilizando `math.ceil`.

:::


## Mensaje secreto

Un **cifrado por sustituciÃ³n simple** reemplaza cada carÃ¡cter de un alfabeto con un carÃ¡cter de un
alfabeto alternativo. Cada posiciÃ³n en el alfabeto original se mapea a la posiciÃ³n correspondiente
en el alfabeto alternativo, y esto sirve tanto para codificar como para decodificar.

El objetivo es crear una clase que, al inicializarse, reciba dos alfabetos (original y alternativo).
La clase debe tener un mÃ©todo para encriptar mensajes y otro para revertir la encriptaciÃ³n.

Ejemplo:

```python
alfabeto = "abcdefghijklmnopqrstuvwxyz"
alfabeto_mezclado = "etaoinshrdlucmfwypvbgkjqxz"

mi_cifrado = Cifrado(alfabeto, alfabeto_mezclado)

mi_cifrado.codificar("abc")    # => "eta"
mi_cifrado.codificar("xyz")    # => "qxz"
mi_cifrado.codificar("aeiou")  # => "eirfg"

mi_cifrado.decodificar("eta")    # => "abc"
mi_cifrado.decodificar("qxz")    # => "xyz"
mi_cifrado.decodificar("eirfg")  # => "aeiou"
```

### Punto extra

Verifique en el mÃ©todo `__init__` que la longitud de los alfabetos sea la misma. Caso contrario,
levante una excepciÃ³n `ValueError` indicando cuÃ¡l es el problema.

## Real envido

Construir una clase `ManoDeTruco` que, al inicializarse, reciba una lista o tupla de hasta tres nÃºmeros enteros,
correspondientes a los valores de las cartas en una mano de truco.

La clase debe incluir un mÃ©todo llamado `comparar_con` que recibe otra mano de truco y determine cuÃ¡l de las dos suma mÃ¡s puntos para el envido.
En caso de empate, se considera ganadora la mano que invocÃ³ el mÃ©todo.

**Ejemplo de uso**

```python
mano1 = ManoDeTruco([7, 5, 6])
mano2 = ManoDeTruco([4, 11, 2])

ganadora = mano1.comparar_con(mano2)
```

::: {.callout-tip collapse="true"}
### Consideraciones

* Asuma que todas las cartas cargadas en la mano son del mismo palo.
* Para calcular los puntos del envido, solo se consideran dos de las tres cartas, no la suma de las tres.

:::


## La muestra infinita

Defina una clase `Muestra` que represente un conjunto de datos numÃ©ricos.
La clase debe inicializarse a partir de un iterable de nÃºmeros e implementar los siguientes
mÃ©todos:

* `agregar(x)`: agrega un nÃºmero a la muestra.
* `n()`: devuelve la cantidad de elementos.
* `suma()`: devuelve la suma de los valores.
* `media()`: devuelve el promedio de los valores.
* `varianza(muestral=False)`: calcula la varianza.
  * Si `muestral=False`, se usa el denominador `n` (varianza poblacional).
  * Si `muestral=True`, se usa el denominador `n-1` (varianza muestral).

**Ejemplo de uso**

```python
muestra = Muestra([10, 12, 13, 15])
muestra.agregar(20)
muestra.n()                     # 5
muestra.suma()                  # 70
muestra.media()                 # 14.0
muestra.varianza()              # varianza poblacional
muestra.varianza(muestral=True) # varianza muestral
```

### Punto extra

Modifique la clase para que:

* Guarde los datos en un atributo "privado" llamado `_datos`.
* Provea una propiedad de solo lectura `valores`, que devuelva una copia inmutable de los datos
(por ejemplo, una tupla).

## Â¡Orden en el laboratorio!

En un laboratorio se necesita llevar un registro ordenado de los experimentos realizados.
Cada experimento debe contar con un nÃºmero identificador Ãºnico, un nombre y, de manera opcional,
el nombre de la persona responsable.

El objetivo de este ejercicio es construir una clase que facilite dicha organizaciÃ³n.

Para ello, implemente una clase llamada `Experimento` que se inicializa con el nombre del
experimento y, opcionalmente, con el nombre del responsable.
La clase debe asignar automÃ¡ticamente un nÃºmero identificador Ãºnico a cada instancia.
Para lograrlo, utilice un **atributo de clase** llamado `total_creados`, que comience en 0.

Cada instancia debe contar con:

* Un identificador numÃ©rico Ãºnico (asignado automÃ¡ticamente de forma incremental por la clase).
* Un nombre.
* Un responsable, si se proporciona.


**Ejemplo de uso**

```python
e1 = Experimento("Piloto A", responsable="Dolores")
e2 = Experimento("Piloto Z")
Experimento.total_creados  # Devuelve 2
```

### Puntos extra

Modifique la clase para que tambiÃ©n:

* Se puedan crear objetos utilizando un **mÃ©todo de clase** llamado `desde_dict` que reciba
un diccionario de la forma  `{"nombre": ..., "responsable": ...}` y devuelva una instancia de `Experimento`.
* Implemente el mÃ©todo mÃ¡gico `__repr__` que devuelva una cadena de texto con el siguiente formato:
    ```python
    Experimento(id=1, nombre="A/B", responsable="Sosa")
    ```

**Ejemplo de uso**

```python
e = Experimento.desde_dict({"nombre": "Piloto B", "responsable": "Ana"})
repr(e)
# Experimento(id=3, nombre="Piloto B", responsable="Ana")
```

## La forma es lo de menos

El objetivo de este ejercicio es construir una jerarquÃ­a de clases que represente diferentes figuras
geomÃ©tricas planas. Todas las figuras deben poder calcular su Ã¡rea y su perÃ­metro.

Se debe comenzar definiendo una clase base llamada `Forma`, que sirva como plantilla comÃºn.
Esta clase debe incluir los mÃ©todos `area` y `perimetro`, que deben levantar una excepciÃ³n
`NotImplementedError`, ya que no se puede calcular el Ã¡rea ni el perÃ­metro de una forma genÃ©rica sin
mÃ¡s informaciÃ³n.

A partir de esta clase base, se deben implementar las siguientes subclases:

* `Circulo`: se inicializa con el radio.
* `Triangulo`: se inicializa con la longitud de sus tres lados.
* `Rectangulo`: se inicializa con base y altura.
* `Cuadrado`: una forma particular de rectÃ¡ngulo, que se inicializa con un solo lado.

Cada subclase debe implementar sus propios mÃ©todos `area` y `perimetro` de forma adecuada.

Por otro lado, implemente una funciÃ³n llamada `clasificar_formas` que reciba una secuencia de
elementos y devuelva un diccionario. Las claves del diccionario deben ser los nombres de las clases
("Circulo", "Rectangulo", etc.) y los valores, listas con las instancias correspondientes que
estaban en la secuencia original. Finalmente, implemente tambiÃ©n una funciÃ³n llamada `sumar_areas`
que reciba una secuencia de formas y devuelva la suma total de sus Ã¡reas.

Si alguno de los elementos no es una instancia de `Forma`, la funciÃ³n debe lanzar una excepciÃ³n.

## Sensores descalibrados

Este ejercicio requiere diseÃ±ar una pequeÃ±a jerarquÃ­a de clases para simular sensores utilizados en
un laboratorio.

En la prÃ¡ctica, los sensores no siempre son completamente precisos: pueden registrar valores
ligeramente superiores o inferiores al valor real.
Para corregir ese desvÃ­o, se aplica una **calibraciÃ³n**, que consiste en ajustar las lecturas
mediante un valor adicional o corrector llamado _offset_.

### JerarquÃ­a de clases

**Clase base**: `Sensor`

La clase `Sensor` debe incluir:

* Un atributo `nombre` para identificar al sensor.
* Un mÃ©todo `leer` que levante una excepciÃ³n `NotImplementedError`, indicando que debe ser implementado por las subclases.
* Un mÃ©todo `calibrar(offset)` que permita almacenar un valor de ajuste (`offset`) que se aplicarÃ¡ a las lecturas.

**Subclases**

Se deben definir dos subclases: `SensorTemperatura` y `SensorHumedad`, ambas con su propia implementaciÃ³n del mÃ©todo `leer`:

* `SensorTemperatura`: simula una mediciÃ³n utilizando `random.uniform(18, 28)`.
* `SensorHumedad`: simula una mediciÃ³n utilizando `random.uniform(30, 70)`.

En ambos casos, la mediciÃ³n debe ser ajustada por el _offset_ correspondiente (si fue calibrado).

### FunciÃ³n auxiliar

AdemÃ¡s, implemente una funciÃ³n llamada `promedio_lecturas` que reciba dos argumentos:
una secuencia de sensores y un nÃºmero entero `n`, que indica cuÃ¡ntas lecturas realizar con cada sensor.

La funciÃ³n debe realizar `n` lecturas para cada sensor utilizando su mÃ©todo `leer`,
calcular el promedio de esas lecturas y devolver un diccionario que asocie el nombre de cada sensor
con su promedio correspondiente.

**Ejemplo de uso**

```python
st = SensorTemperatura("T1")
sh = SensorHumedad("H1")
st.calibrar(0.5)

promedios = promedio_lecturas([st, sh], n=3)
# {'T1': ..., 'H1': ...}
```

## Python para matemÃ¡ticos

Construya una clase `Fraccion` que acepte dos argumentos: numerador y denominador.
Se desea que esta clase:

a. Sea representable como cadena de texto.
b. Implemente la suma entre fracciones.
c. Devuelva siempre el resultado en la **mÃ­nima representaciÃ³n posible** (fracciÃ³n irreducible).

Ejemplo:

```python
fraccion1 = Fraccion(4, 5)
print(fraccion1 + Fraccion(1, 8))
#> "37/40"
```

### Punto extra

Extender la funcionalidad de la clase incluyendo las operaciones de resta, multiplicaciÃ³n y divisiÃ³n.

## Tiempo al tiempo [WIP]

Construya una clase para representar y trabajar con fechas llamada `Date`.

1. El mÃ©todo `__init__` debe tomar 3 parÃ¡metros: `year`, `month`, y `day`. Cree un objeto fecha
que represente el 6 de noviembre de 1995.
2. Implemente el mÃ©todo `__str__` de forma tal que devuelva una cadena con el formato `YYYY-MM-DD`,
donde `YYYY` representa el aÃ±o, `MM` el mes y `DD` el dÃ­a.
3. Implemente un mÃ©todo de clase que permita crear una `Date` a partir de una cadena de texto
en formato `YYYY-MM-DD`.
4. Implemente los siguientes mÃ©todos de comparaciÃ³n para objetos `Date`.
    i. `__eq__`: igualdad
    i. `__ne__`: desigualdad
    i. `__lt__`: menor que
    i. `__gt__`: mayor que
    i. `__le__`: menor o igual que
    i. `__ge__`: mayor o igual que


QUIERO LLEGAR A QUE IMPLEMENTEMOS ESTO

```python
DOM = {
    1: 31,  # Enero
    2: 28,  # Febrero (29 en aÃ±o bisiesto)
    3: 31,  # Marzo
    4: 30,  # Abril
    5: 31,  # Mayo
    6: 30,  # Junio
    7: 31,  # Julio
    8: 31,  # Agosto
    9: 30,  # Septiembre
    10: 31, # Octubre
    11: 30, # Noviembre
    12: 31, # Diciembre
}

class Date:
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day

    @property
    def year(self):
        return self._year

    @year.setter
    def year(self, value):
        assert isinstance(value, int)
        assert value > 0
        self._year = value

    @property
    def month(self):
        return self._month

    @month.setter
    def month(self, value):
        assert isinstance(value, int)
        assert 1 <= value <= 12
        self._month = value

    @property
    def day(self):
        return self._day

    @day.setter
    def day(self, value):
        assert isinstance(value, int)
        assert 1 <= value <= Date._dias_del_mes(self.year, self.month)
        self._day = value

    @classmethod
    def from_str(cls, value):
        parts = value.split("-")
        assert len(parts) == 3
        year, month, day = map(int, parts)

        assert year > 0
        assert 1 <= month <= 12
        assert 1 <= day <= Date._dias_del_mes(year, month)

        return cls(year=year, month=month, day=day)

    def __eq__(self, other):
        if isinstance(other, type(self)):
            return self.year == other.year and self.month == other.month and self.day == other.day
        return False

    def __neq__(self, other):
        return not self == other

    def __gt__(self, other):
        if self.year > other.year:
            return True
        elif self.year == other.year:
            if self.month > other.month:
                return True
            elif self.month == other.month:
                return self.day > other.day
        return False

    def __ge__(self, other):
        return (self > other) or (self == other)

    def __lt__(self, other):
        if self.year < other.year:
            return True
        elif self.year == other.year:
            if self.month < other.month:
                return True
            elif self.month == other.month:
                return self.day < other.day
        return False

    def __le__(self, other):
        return (self < other) or (self == other)

    def __str__(self):
        year = str(self.year).rjust(4, "0")
        month = str(self.month).rjust(2, "0")
        day = str(self.day).rjust(2, "0")

        return f"{year}-{month}-{day}"

    def __repr__(self):
        return f"Date(year={self.year}, month={self.month}, day={self.day})"

    @staticmethod
    def _es_bisiesto(year):
        # Divisible por 4,
        # excepto que sea divisible por 100,
        # salvo que tambien sea divisibles por 400
        return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)

    @staticmethod
    def _dias_del_mes(year, month):
        if month == 2 and Date._es_bisiesto(year):
            return 29
        return DOM[month]


d = Date(2025, 11, 12)
d2 = Date(2025, 11, 12)
d3 = Date(2025, 11, 13)

d == d3
d > d3
d3 > d
d < d3

Date.from_str("2025-11-28")

Date(2000, 2, 29)
```


Por otro lado, implemente otra clase llamada `TimeDelta` que representa diferencias temporales.
El mÃ©todo `__init__` tine los parÃ¡metros opcionales `year`, `month` y `day`. Si estos no se especifican,
son todos iguales a 0, lo que representa una diferencia temporal nula (es decir, no hay diferencia temporal).


<!--

Completos

* Objetos, clases e instancias.
* Atributos y mÃ©todos.
* Propiedades publicas
* Metodos de instancia
* Herencia simple
* Metodos de clase
* Propiedades privadas
* Sobrecarga de operadores
* MÃ©todos especiales (dunder methods)

Parcialmente completos

* Polimorfismo

Sin cubrir

* Encapsulamiento
* Herencia multiple
* Decoradores aplicados a mÃ©todos.


-->