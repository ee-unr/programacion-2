---
title: "üõ†Ô∏è Ejercicios"
---

## Contador

Defina una clase `Contador` que represente un contador num√©rico.
Por defecto, las instancias comienzan con el valor `0`, aunque debe permitirse inicializarlas con
un valor distinto.

Implemente los siguientes m√©todos:

* `incrementar`: aumenta el valor del contador en una cantidad arbitraria (por defecto, 1).
* `decrementar`: disminuye el valor del contador en una cantidad arbitraria (por defecto, 1).
* `reiniciar`: restablece el contador a su valor inicial (¬°que puede ser distinto de 0!).
* `valor`: devuelve el valor actual del contador.

**Ejemplo de uso**

```python
contador = Contador()
contador.incrementar(5)    # El valor interno es 5
contador.decrementar(2)    # El valor interno es 3
print(contador.valor())    # Imprime 3
contador.reiniciar()
print(contador.valor())    # Imprime 0
```

## Magia para programadores

Esta es tu primera clase de Pociones en Hogwarts y el profesor te dio como tarea descubrir de qu√© color se volver√° una poci√≥n si se mezcla con otra.
Todas las pociones tienen un color definido en formato [RGB](https://www.w3schools.com/html/html_colors_rgb.asp), desde `[0, 0, 0]` hasta `[255, 255, 255]`.

Para complicar un poco m√°s la tarea, el profesor realizar√° varias mezclas seguidas y luego te preguntar√° por el color final.
Adem√°s del color, tambi√©n deber√°s calcular qu√© volumen tendr√° la poci√≥n despu√©s de la mezcla final.

Gracias a tu experiencia en programaci√≥n descubriste que al mezclar dos pociones, los colores se combinan como si se mezclaran dos colores en formato RGB.
Por ejemplo, si mezclas una poci√≥n con color `[255, 255, 0]` y volumen `10` con otra de color `[0, 254, 0]` y volumen `5`, obtendr√°s una nueva poci√≥n con:

- color `[170, 255, 0]`
- volumen `15`

Por lo tanto, decid√≠s crear una clase `Pocion` que tenga:

- dos propiedades:
  - `color` (una lista o tupla con 3 enteros)
  - `volumen` (un n√∫mero)
- un m√©todo `mezclar` que acepte otra `Pocion` y devuelva una nueva `Pocion` ya mezclada.

Ejemplo:

```python
felix_felicis = Pocion([255, 255, 255],  7)
pocion_multijugos = Pocion([51, 102, 51], 12)
nueva_pocion = felix_felicis.mezclar(pocion_multijugos)

nueva_pocion.color # Devuelve [127, 159, 127]
nueva_pocion.volumen # Devuelve 19
```

::: {.callout-tip collapse="true"}
### Ayuda

Los colores de las pociones deben representarse como tr√≠os de n√∫meros enteros en formato RGB.
Al realizar una mezcla de colores, se debe redondear hacia arriba utilizando `math.ceil`.

:::


## Mensaje secreto

Un **cifrado por sustituci√≥n simple** reemplaza cada car√°cter de un alfabeto con un car√°cter de un
alfabeto alternativo. Cada posici√≥n en el alfabeto original se mapea a la posici√≥n correspondiente
en el alfabeto alternativo, y esto sirve tanto para codificar como para decodificar.

El objetivo es crear una clase que, al inicializarse, reciba dos alfabetos (original y alternativo).
La clase debe tener un m√©todo para encriptar mensajes y otro para revertir la encriptaci√≥n.

Ejemplo:

```python
alfabeto = "abcdefghijklmnopqrstuvwxyz"
alfabeto_mezclado = "etaoinshrdlucmfwypvbgkjqxz"

mi_cifrado = Cifrado(alfabeto, alfabeto_mezclado)

mi_cifrado.codificar("abc")    # => "eta"
mi_cifrado.codificar("xyz")    # => "qxz"
mi_cifrado.codificar("aeiou")  # => "eirfg"

mi_cifrado.decodificar("eta")    # => "abc"
mi_cifrado.decodificar("qxz")    # => "xyz"
mi_cifrado.decodificar("eirfg")  # => "aeiou"
```

### Punto extra

Verifique en el m√©todo `__init__` que la longitud de los alfabetos sea la misma. Caso contrario,
levante una excepci√≥n `ValueError` indicando cu√°l es el problema.

## Real envido

Construir una clase `ManoDeTruco` que, al inicializarse, reciba una lista o tupla de hasta tres n√∫meros enteros,
correspondientes a los valores de las cartas en una mano de truco.

La clase debe incluir un m√©todo llamado `comparar_con` que recibe otra mano de truco y determine cu√°l de las dos suma m√°s puntos para el envido.
En caso de empate, se considera ganadora la mano que invoc√≥ el m√©todo.

**Ejemplo de uso**

```python
mano1 = ManoDeTruco([7, 5, 6])
mano2 = ManoDeTruco([4, 11, 2])

ganadora = mano1.comparar_con(mano2)
```

::: {.callout-tip collapse="true"}
### Consideraciones

* Asuma que todas las cartas cargadas en la mano son del mismo palo.
* Para calcular los puntos del envido, solo se consideran dos de las tres cartas, no la suma de las tres.

:::


## La muestra infinita

Defina una clase `Muestra` que represente un conjunto de datos num√©ricos.
La clase debe inicializarse a partir de un iterable de n√∫meros e implementar los siguientes
m√©todos:

* `agregar(x)`: agrega un n√∫mero a la muestra.
* `n()`: devuelve la cantidad de elementos.
* `suma()`: devuelve la suma de los valores.
* `media()`: devuelve el promedio de los valores.
* `varianza(muestral=False)`: calcula la varianza.
  * Si `muestral=False`, se usa el denominador `n` (varianza poblacional).
  * Si `muestral=True`, se usa el denominador `n-1` (varianza muestral).

**Ejemplo de uso**

```python
muestra = Muestra([10, 12, 13, 15])
muestra.agregar(20)
muestra.n()                     # 5
muestra.suma()                  # 70
muestra.media()                 # 14.0
muestra.varianza()              # varianza poblacional
muestra.varianza(muestral=True) # varianza muestral
```

### Punto extra

Modifique la clase para que:

* Guarde los datos en un atributo "privado" llamado `_datos`.
* Provea una propiedad de solo lectura `valores`, que devuelva una copia inmutable de los datos
(por ejemplo, una tupla).

## ¬°Orden en el laboratorio!

En un laboratorio se necesita llevar un registro ordenado de los experimentos realizados.
Cada experimento debe contar con un n√∫mero identificador √∫nico, un nombre y, de manera opcional,
el nombre de la persona responsable.

El objetivo de este ejercicio es construir una clase que facilite dicha organizaci√≥n.

Para ello, implemente una clase llamada `Experimento` que se inicializa con el nombre del
experimento y, opcionalmente, con el nombre del responsable.
La clase debe asignar autom√°ticamente un n√∫mero identificador √∫nico a cada instancia.
Para lograrlo, utilice un **atributo de clase** llamado `total_creados`, que comience en 0.

Cada instancia debe contar con:

* Un identificador num√©rico √∫nico (asignado autom√°ticamente de forma incremental por la clase).
* Un nombre.
* Un responsable, si se proporciona.


**Ejemplo de uso**

```python
e1 = Experimento("Piloto A", responsable="Dolores")
e2 = Experimento("Piloto Z")
Experimento.total_creados  # Devuelve 2
```

### Puntos extra

Modifique la clase para que tambi√©n:

* Se puedan crear objetos utilizando un **m√©todo de clase** llamado `desde_dict` que reciba
un diccionario de la forma  `{"nombre": ..., "responsable": ...}` y devuelva una instancia de `Experimento`.
* Implemente el m√©todo m√°gico `__repr__` que devuelva una cadena de texto con el siguiente formato:
    ```python
    Experimento(id=1, nombre="A/B", responsable="Sosa")
    ```

**Ejemplo de uso**

```python
e = Experimento.desde_dict({"nombre": "Piloto B", "responsable": "Ana"})
repr(e)
# Experimento(id=3, nombre="Piloto B", responsable="Ana")
```

<!--

LO VOY A USAR EN EL MATERIAL DE TEORIA

## La forma es lo de menos

El objetivo de este ejercicio es construir una jerarqu√≠a de clases que represente diferentes figuras
geom√©tricas planas. Todas las figuras deben poder calcular su √°rea y su per√≠metro.

Se debe comenzar definiendo una clase base llamada `Forma`, que sirva como plantilla com√∫n.
Esta clase debe incluir los m√©todos `area` y `perimetro`, que deben levantar una excepci√≥n
`NotImplementedError`, ya que no se puede calcular el √°rea ni el per√≠metro de una forma gen√©rica sin
m√°s informaci√≥n.

A partir de esta clase base, se deben implementar las siguientes subclases:

* `Circulo`: se inicializa con el radio.
* `Triangulo`: se inicializa con la longitud de sus tres lados.
* `Rectangulo`: se inicializa con base y altura.
* `Cuadrado`: una forma particular de rect√°ngulo, que se inicializa con un solo lado.

Cada subclase debe implementar sus propios m√©todos `area` y `perimetro` de forma adecuada.

Por otro lado, implemente una funci√≥n llamada `clasificar_formas` que reciba una secuencia de
elementos y devuelva un diccionario. Las claves del diccionario deben ser los nombres de las clases
("Circulo", "Rectangulo", etc.) y los valores, listas con las instancias correspondientes que
estaban en la secuencia original. Finalmente, implemente tambi√©n una funci√≥n llamada `sumar_areas`
que reciba una secuencia de formas y devuelva la suma total de sus √°reas.

Si alguno de los elementos no es una instancia de `Forma`, la funci√≥n debe lanzar una excepci√≥n.
-->

## Sensores descalibrados

Este ejercicio requiere dise√±ar una peque√±a jerarqu√≠a de clases para simular sensores utilizados en
un laboratorio.

En la pr√°ctica, los sensores no siempre son completamente precisos: pueden registrar valores
ligeramente superiores o inferiores al valor real.
Para corregir ese desv√≠o, se aplica una **calibraci√≥n**, que consiste en ajustar las lecturas
mediante un valor adicional o corrector llamado _offset_.

### Jerarqu√≠a de clases

**Clase base**: `Sensor`

La clase `Sensor` debe incluir:

* Un atributo `nombre` para identificar al sensor.
* Un m√©todo `leer` que levante una excepci√≥n `NotImplementedError`, indicando que debe ser implementado por las subclases.
* Un m√©todo `calibrar(offset)` que permita almacenar un valor de ajuste (`offset`) que se aplicar√° a las lecturas.

**Subclases**

Se deben definir dos subclases: `SensorTemperatura` y `SensorHumedad`, ambas con su propia implementaci√≥n del m√©todo `leer`:

* `SensorTemperatura`: simula una medici√≥n utilizando `random.uniform(18, 28)`.
* `SensorHumedad`: simula una medici√≥n utilizando `random.uniform(30, 70)`.

En ambos casos, la medici√≥n debe ser ajustada por el _offset_ correspondiente (si fue calibrado).

### Funci√≥n auxiliar

Adem√°s, implemente una funci√≥n llamada `promedio_lecturas` que reciba dos argumentos:
una secuencia de sensores y un n√∫mero entero `n`, que indica cu√°ntas lecturas realizar con cada sensor.

La funci√≥n debe realizar `n` lecturas para cada sensor utilizando su m√©todo `leer`,
calcular el promedio de esas lecturas y devolver un diccionario que asocie el nombre de cada sensor
con su promedio correspondiente.

**Ejemplo de uso**

```python
st = SensorTemperatura("T1")
sh = SensorHumedad("H1")
st.calibrar(0.5)

promedios = promedio_lecturas([st, sh], n=3)
# {'T1': ..., 'H1': ...}
```

## Python para matem√°ticos

Construya una clase `Fraccion` que acepte dos argumentos: numerador y denominador.
Se desea que esta clase:

a. Sea representable como cadena de texto.
b. Implemente la suma entre fracciones.
c. Devuelva siempre el resultado en la **m√≠nima representaci√≥n posible** (fracci√≥n irreducible).

Ejemplo:

```python
fraccion1 = Fraccion(4, 5)
print(fraccion1 + Fraccion(1, 8))
#> "37/40"
```

### Punto extra

Extender la funcionalidad de la clase incluyendo las operaciones de resta, multiplicaci√≥n y divisi√≥n.

## Tiempo al tiempo ‚è≥

El m√≥dulo est√°ndar `datetime` de Python incluye, entre otras cosas, la clase `date` para trabajar con fechas.
El objetivo de este ejercicio es implementar, desde cero, una nueva clase `Date` que permita
representar fechas y operar con ellas.

### Primera implementaci√≥n

1. Construya la clase `Date`. El m√©todo `__init__` debe tomar 3 par√°metros: `year`, `month` y `day`,
y asignarlos como atributos de la instancia. Cree un objeto que represente el 6 de noviembre de 1995
y verifique que los atributos contengan los valores esperados.
2. Implemente el m√©todo `__str__`, que debe devolver una cadena con el formato `YYYY-MM-DD`,
donde `YYYY` representa el a√±o, `MM` el mes y `DD` el d√≠a.
**Ayuda**: Puede utilizar el m√©todo `.rjust` de las cadenas de texto para agregar ceros a la
izquierda cuando sea necesario. Por ejemplo, para el 6 de noviembre de 1995, `str(fecha)` debe
devolver `"1995-11-06"`.
3. Implemente el m√©todo `__repr__`, que debe devolver una representaci√≥n similar a la utilizada para
crear la instancia. Para la fecha 6 de noviembre de 1995, debe devolver la cadena
`"Date(year=1995, month=11, day=6)"`.
4. Implemente un m√©todo de clase que permita crear una `Date` a partir de una cadena en formato
`YYYY-MM-DD`. Por ejemplo, `Date.from_str("2025-03-08")` debe devolver un objeto `Date`
que representa al 8 de marzo de 2025.
**Ayuda**: Puede utilizar el m√©todo `.lstrip("0")` para eliminar ceros a la izquierda en una cadena.
5. Implemente los m√©todos de comparaci√≥n entre objetos `Date`.
    i. `__eq__`: igualdad (`==`)
    i. `__ne__`: desigualdad (`!=`)
    i. `__lt__`: menor que (`<`)
    i. `__gt__`: mayor que (`>`)
    i. `__le__`: menor o igual que (`<=`)
    i. `__ge__`: mayor o igual que (`>=`)

    **Ayuda**: Dos fechas se consideran iguales si sus atributos `year`, `month`, y `day` coinciden.
    Para las comparaciones, considere primero el a√±o, luego el mes y finalmente el d√≠a.

### A prueba de balas

A esta altura, se cuenta con una implementaci√≥n razonablemente completa y funcional para representar
objetos de tipo fecha. Sin embargo, la clase `Date` no garantiza la validez ni la robustez de las
instancias que se crean.
Es posible construir objetos `Date` que representen fechas inv√°lidas, como el 31 de abril o el
55.8 del mes 25.3, y operar con ellos sin que el programa emita ning√∫n tipo de advertencia.


6. Modifique la implementaci√≥n de los atributos `year`, `month` y `day` de modo que sean privados y
que su asignaci√≥n incluya una verificaci√≥n de validez. Para ello, se propone lo siguiente:
    i. Utilice atributos privados llamados `_year`, `_month` y `_day`.
    ii. Defina m√©todos `year`, `month` y `day`, decorados con `@property`, que expongan dichos
    atributos para su lectura. Estos m√©todos deben devolver el valor del atributo correspondiente.
    iii. Para permitir la asignaci√≥n controlada, implemente un _setter_ para cada atributo
    Para ello, decore el mismo m√©todo con `@<nombre>.setter` (por ejemplo, `@year.setter`) y defina
    all√≠ la l√≥gica de verificaci√≥n.
    Por el momento, verifique √∫nicamente que el valor asignado sea un n√∫mero entero y positivo.
    Eleve un `ValueError` en caso de que el valor por asignar no pase la verificaci√≥n.

Utilice los siguientes ejemplos de verificaci√≥n

```python
d = Date(2022, 7, 1)
repr(d) # Date(year=2022, month=7, day=1)
str(d)  # "2022-07-01"
(d.year, d.month, d.day) # (2022, 7, 1)
```

```python
Date(2022, 0, 1)       # Falla: el mes no es positivo
Date(2022, 3, 5.5)     # Falla: el d√≠a no es un entero
Date("11", 3, 1)       # Falla: el a√±o es una cadena de texto
```

```python
d = Date(2022, 7, 1)
d.day = 11             # Funciona: pasa la verificaci√≥n
str(d)                 # "2022-07-11"

d.month = -1           # Falla
d.year = -1            # Falla
```


7. Mejore ahora las verificaciones de los valores asignados para que sean m√°s robustas:
    * El a√±o debe ser entero y mayor o igual a 0.
    * El mes debe ser un n√∫mero entero entre 1 y 12 inclusive.
    * El d√≠a debe ser un n√∫mero entero mayor o igual a 1 y menor o igual a la cantidad de d√≠as del
    mes correspondiente.


La cantidad de d√≠as depende del mes.
Para todos los meses excepto febrero, utilice el diccionario provisto en la ayuda debajo.
Para el caso de febrero, implemente un m√©todo est√°tico que reciba un a√±o como argumento y devuelva
un booleano indicando si ese a√±o es bisiesto.


::: {.callout-tip collapse="true"}
##### Ayuda

Diccionario de d√≠as por mes:

```python
DOM = {
    1: 31,  # Enero
    2: 28,  # Febrero (29 en a√±o bisiesto)
    3: 31,  # Marzo
    4: 30,  # Abril
    5: 31,  # Mayo
    6: 30,  # Junio
    7: 31,  # Julio
    8: 31,  # Agosto
    9: 30,  # Septiembre
    10: 31, # Octubre
    11: 30, # Noviembre
    12: 31, # Diciembre
}

DOM[5] # Devuelve 31, porque es mayo
```

Por otro lado, un a√±o es bisiesto si:

* Es divisible por 4,
* excepto que sea divisible por 100,
* salvo que tambien sea divisibles por 400

En Python

```python
(year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)
```

:::


Finalmente, verifique que su clase `Date` funciona correctamente con los siguientes ejemplos:

```python
# Definici√≥n de fechas
d1 = Date(1990, 5, 20)
d2 = Date(1998, 9, 21)
d3 = Date(1998, 9, 20)
d4 = Date(2022, 12, 18)

d1 < d2
d1 > d2
d1 != d3
d4 >= d3

Date(2000, 2, 29) # Funciona, es bisiesto
Date(2001, 2, 29) # Falla, no es bisiesto


l = [d1, d2, d3, d4]
sorted(l) # Funciona, ¬øpor qu√©?
```

<!--

Completos

* Objetos, clases e instancias.
* Atributos y m√©todos.
* Propiedades publicas
* Metodos de instancia
* Herencia simple
* Metodos de clase
* Propiedades privadas
* Sobrecarga de operadores
* M√©todos especiales (dunder methods)
* Encapsulamiento

Parcialmente completos

* Polimorfismo

Sin cubrir

* Herencia multiple
* Decoradores aplicados a m√©todos.


-->