---
title: "üõ†Ô∏è Ejercicios"
---

## Contador

Defina una clase `Contador` que represente un contador num√©rico.
Por defecto, las instancias comienzan con el valor `0`, aunque debe permitirse inicializarlas con
un valor distinto.

Implemente los siguientes m√©todos:

* `incrementar`: aumenta el valor del contador en una cantidad arbitraria (por defecto, 1).
* `decrementar`: disminuye el valor del contador en una cantidad arbitraria (por defecto, 1).
* `reiniciar`: restablece el contador a su valor inicial (¬°que puede ser distinto de 0!).
* `valor`: devuelve el valor actual del contador.

**Ejemplo de uso**

```python
contador = Contador()
contador.incrementar(5)    # El valor interno es 5
contador.decrementar(2)    # El valor interno es 3
print(contador.valor())    # Imprime 3
contador.reiniciar()
print(contador.valor())    # Imprime 0
```

## Magia para programadores

Esta es tu primera clase de Pociones en Hogwarts y el profesor te dio como tarea descubrir de qu√© color se volver√° una poci√≥n si se mezcla con otra.
Todas las pociones tienen un color definido en formato [RGB](https://www.w3schools.com/html/html_colors_rgb.asp), desde `[0, 0, 0]` hasta `[255, 255, 255]`.

Para complicar un poco m√°s la tarea, el profesor realizar√° varias mezclas seguidas y luego te preguntar√° por el color final.
Adem√°s del color, tambi√©n deber√°s calcular qu√© volumen tendr√° la poci√≥n despu√©s de la mezcla final.

Gracias a tu experiencia en programaci√≥n descubriste que al mezclar dos pociones, los colores se combinan como si se mezclaran dos colores en formato RGB.
Por ejemplo, si mezclas una poci√≥n con color `[255, 255, 0]` y volumen `10` con otra de color `[0, 254, 0]` y volumen `5`, obtendr√°s una nueva poci√≥n con:

- color `[170, 255, 0]`
- volumen `15`

Por lo tanto, decid√≠s crear una clase `Pocion` que tenga:

- dos propiedades:
  - `color` (una lista o tupla con 3 enteros)
  - `volumen` (un n√∫mero)
- un m√©todo `mezclar` que acepte otra `Pocion` y devuelva una nueva `Pocion` ya mezclada.

Ejemplo:

```python
felix_felicis = Pocion([255, 255, 255],  7)
pocion_multijugos = Pocion([51, 102, 51], 12)
nueva_pocion = felix_felicis.mezclar(pocion_multijugos)

nueva_pocion.color # Devuelve [127, 159, 127]
nueva_pocion.volumen # Devuelve 19
```

::: {.callout-tip collapse="true"}
### Ayuda

Los colores de las pociones deben representarse como tr√≠os de n√∫meros enteros en formato RGB.
Al realizar una mezcla de colores, se debe redondear hacia arriba utilizando `math.ceil`.

:::


## Mensaje secreto

Un **cifrado por sustituci√≥n simple** reemplaza cada car√°cter de un alfabeto con un car√°cter de un
alfabeto alternativo. Cada posici√≥n en el alfabeto original se mapea a la posici√≥n correspondiente
en el alfabeto alternativo, y esto sirve tanto para codificar como para decodificar.

El objetivo es crear una clase que, al inicializarse, reciba dos alfabetos (original y alternativo).
La clase debe tener un m√©todo para encriptar mensajes y otro para revertir la encriptaci√≥n.

Ejemplo:

```python
alfabeto = "abcdefghijklmnopqrstuvwxyz"
alfabeto_mezclado = "etaoinshrdlucmfwypvbgkjqxz"

mi_cifrado = Cifrado(alfabeto, alfabeto_mezclado)

mi_cifrado.codificar("abc")    # => "eta"
mi_cifrado.codificar("xyz")    # => "qxz"
mi_cifrado.codificar("aeiou")  # => "eirfg"

mi_cifrado.decodificar("eta")    # => "abc"
mi_cifrado.decodificar("qxz")    # => "xyz"
mi_cifrado.decodificar("eirfg")  # => "aeiou"
```

### Punto extra

Verifique en el m√©todo `__init__` que la longitud de los alfabetos sea la misma. Caso contrario,
levante una excepci√≥n `ValueError` indicando cu√°l es el problema.

## Real envido

Construir una clase `ManoDeTruco` que, al inicializarse, reciba una lista o tupla de hasta tres n√∫meros enteros,
correspondientes a los valores de las cartas en una mano de truco.

La clase debe incluir un m√©todo llamado `comparar_con` que recibe otra mano de truco y determine cu√°l de las dos suma m√°s puntos para el envido.
En caso de empate, se considera ganadora la mano que invoc√≥ el m√©todo.

**Ejemplo de uso**

```python
mano1 = ManoDeTruco([7, 5, 6])
mano2 = ManoDeTruco([4, 11, 2])

ganadora = mano1.comparar_con(mano2)
```

::: {.callout-tip collapse="true"}
### Consideraciones

* Asuma que todas las cartas cargadas en la mano son del mismo palo.
* Para calcular los puntos del envido, solo se consideran dos de las tres cartas, no la suma de las tres.

:::


## La muestra infinita

Defina una clase `Muestra` que represente un conjunto de datos num√©ricos.
La clase debe inicializarse a partir de un iterable de n√∫meros e implementar los siguientes
m√©todos:

* `agregar(x)`: agrega un n√∫mero a la muestra.
* `n()`: devuelve la cantidad de elementos.
* `suma()`: devuelve la suma de los valores.
* `media()`: devuelve el promedio de los valores.
* `varianza(muestral=False)`: calcula la varianza.
  * Si `muestral=False`, se usa el denominador `n` (varianza poblacional).
  * Si `muestral=True`, se usa el denominador `n-1` (varianza muestral).

**Ejemplo de uso**

```python
muestra = Muestra([10, 12, 13, 15])
muestra.agregar(20)
muestra.n()                     # 5
muestra.suma()                  # 70
muestra.media()                 # 14.0
muestra.varianza()              # varianza poblacional
muestra.varianza(muestral=True) # varianza muestral
```

### Punto extra

Modifique la clase para que:

* Guarde los datos en un atributo "privado" llamado `_datos`.
* Provea una propiedad de solo lectura `valores`, que devuelva una copia inmutable de los datos
(por ejemplo, una tupla).

## ¬°Orden en el laboratorio!

En un laboratorio se necesita llevar un registro ordenado de los experimentos realizados.
Cada experimento debe contar con un n√∫mero identificador √∫nico, un nombre y, de manera opcional,
el nombre de la persona responsable.

El objetivo de este ejercicio es construir una clase que facilite dicha organizaci√≥n.

Para ello, implemente una clase llamada `Experimento` que se inicializa con el nombre del
experimento y, opcionalmente, con el nombre del responsable.
La clase debe asignar autom√°ticamente un n√∫mero identificador √∫nico a cada instancia.
Para lograrlo, utilice un **atributo de clase** llamado `total_creados`, que comience en 0.

Cada instancia debe contar con:

* Un identificador num√©rico √∫nico (asignado autom√°ticamente de forma incremental por la clase).
* Un nombre.
* Un responsable, si se proporciona.


**Ejemplo de uso**

```python
e1 = Experimento("Piloto A", responsable="Dolores")
e2 = Experimento("Piloto Z")
Experimento.total_creados  # Devuelve 2
```

### Puntos extra

Modifique la clase para que tambi√©n:

* Se puedan crear objetos utilizando un **m√©todo de clase** llamado `desde_dict` que reciba
un diccionario de la forma  `{"nombre": ..., "responsable": ...}` y devuelva una instancia de `Experimento`.
* Implemente el m√©todo m√°gico `__repr__` que devuelva una cadena de texto con el siguiente formato:
    ```python
    Experimento(id=1, nombre="A/B", responsable="Sosa")
    ```

**Ejemplo de uso**

```python
e = Experimento.desde_dict({"nombre": "Piloto B", "responsable": "Ana"})
repr(e)
# Experimento(id=3, nombre="Piloto B", responsable="Ana")
```

## Sensores descalibrados

Este ejercicio requiere dise√±ar una peque√±a jerarqu√≠a de clases para simular sensores utilizados en
un laboratorio.

En la pr√°ctica, los sensores no siempre son completamente precisos: pueden registrar valores
ligeramente superiores o inferiores al valor real.
Para corregir ese desv√≠o, se aplica una **calibraci√≥n**, que consiste en ajustar las lecturas
mediante un valor adicional o corrector llamado _offset_.

### Jerarqu√≠a de clases

**Clase base**: `Sensor`

La clase `Sensor` debe incluir:

* Un atributo `nombre` para identificar al sensor.
* Un m√©todo `leer` que levante una excepci√≥n `NotImplementedError`, indicando que debe ser implementado por las subclases.
* Un m√©todo `calibrar(offset)` que permita almacenar un valor de ajuste (`offset`) que se aplicar√° a las lecturas.

**Subclases**

Se deben definir dos subclases: `SensorTemperatura` y `SensorHumedad`, ambas con su propia implementaci√≥n del m√©todo `leer`:

* `SensorTemperatura`: simula una medici√≥n utilizando `random.uniform(18, 28)`.
* `SensorHumedad`: simula una medici√≥n utilizando `random.uniform(30, 70)`.

En ambos casos, la medici√≥n debe ser ajustada por el _offset_ correspondiente (si fue calibrado).

### Funci√≥n auxiliar

Adem√°s, implemente una funci√≥n llamada `promedio_lecturas` que reciba dos argumentos:
una secuencia de sensores y un n√∫mero entero `n`, que indica cu√°ntas lecturas realizar con cada sensor.

La funci√≥n debe realizar `n` lecturas para cada sensor utilizando su m√©todo `leer`,
calcular el promedio de esas lecturas y devolver un diccionario que asocie el nombre de cada sensor
con su promedio correspondiente.

**Ejemplo de uso**

```python
st = SensorTemperatura("T1")
sh = SensorHumedad("H1")
st.calibrar(0.5)

promedios = promedio_lecturas([st, sh], n=3)
# {'T1': ..., 'H1': ...}
```

## Python para matem√°ticos

Construya una clase `Fraccion` que acepte dos argumentos: numerador y denominador.
Se desea que esta clase:

a. Sea representable como cadena de texto.
b. Implemente la suma entre fracciones.
c. Devuelva siempre el resultado en la **m√≠nima representaci√≥n posible** (fracci√≥n irreducible).

Ejemplo:

```python
fraccion1 = Fraccion(4, 5)
print(fraccion1 + Fraccion(1, 8))
#> "37/40"
```

### Punto extra

Extender la funcionalidad de la clase incluyendo las operaciones de resta, multiplicaci√≥n y divisi√≥n.