---
title: "üõ†Ô∏è Ejercicios"
---

## El estante de la Farmacia

### Contexto

Imagin√° un estante de farmacia con $N$ posiciones perfectamente contiguas (sin huecos), numeradas desde 0 hasta $N-1$.
Cada posici√≥n guarda exactamente una caja de un medicamento.

Para este ejercicio, asumiremos que N = 100.

### Reglas de costo

Para medir el costo de cada operaci√≥n, definimos un paso como la unidad de tiempo m√°s peque√±a:

1.  **Observar (Leer):** Mirar qu√© medicamento hay en una posici√≥n espec√≠fica. **(1 paso)**
2.  **Mover:** Deslizar una caja una posici√≥n a la izquierda o derecha. **(1 paso por cada caja movida)**
3.  **Colocar (Escribir):** Poner una caja nueva en una posici√≥n vac√≠a. **(1 paso)**

### Suposiciones clave

* **Inserci√≥n:** Para hacer un hueco en medio del estante, hay que mover todas las cajas desde esa posici√≥n en adelante hacia la derecha.
* **Eliminaci√≥n:** Para cerrar un hueco en medio del estante, hay que mover todas las cajas desde la posici√≥n eliminada en adelante hacia la izquierda.
* El estante debe permanecer siempre contiguo (sin huecos).

### Tareas de an√°lisis y c√°lculo

Para cada escenario, calcule el costo en pasos y deduzca su complejidad asint√≥tica (_Big_ O), bas√°ndote en la analog√≠a f√≠sica.

| Operaci√≥n                    | Descripci√≥n del escenario                                                                      | Pasos (Con N=100) | Expresi√≥n con N (Big O impl√≠cito) | Justificaci√≥n (¬øPor qu√©?) |
| :--------------------------- | :--------------------------------------------------------------------------------------------- | ----------------- | --------------------------------- | ------------------------- |
| **a) Lectura por Posici√≥n**  | Decime qu√© medicamento hay en la posici√≥n **37**.                                              |                   |                                   |                           |
| **b) B√∫squeda (peor caso)**  | ¬øEst√° el medicamento X en el estante? (Asum√≠ que **NO est√°** y debes revisar todo el estante). |                   |                                   |                           |
| **c) Inserci√≥n al Inicio**   | Pon√© un nuevo medicamento en la **posici√≥n 0** y corr√© todo lo dem√°s.                          |                   |                                   |                           |
| **d) Inserci√≥n al Final**    | Agreg√° un nuevo medicamento en la **posici√≥n N** (al final del estante).                       |                   |                                   |                           |
| **e) Eliminaci√≥n al Inicio** | Sac√° la caja de la **posici√≥n 0** y corr√© el resto para cerrar el hueco.                       |                   |                                   |                           |
| **f) Eliminaci√≥n al Final**  | Sac√° la √∫ltima caja del estante (posici√≥n N‚àí1).                                                |                   |                                   |                           |


## Cita con el dentista

### Contexto

Una cl√≠nica odontol√≥gica necesita un sistema sencillo para gestionar su agenda de turnos.
Los turnos se agregan a la lista en orden de llegada, sin preocuparse inicialmente por el orden cronol√≥gico.

### Datos iniciales

La agenda se mantiene en un arreglo (lista) de diccionarios.

```python
agenda = [
    {"paciente": "Juana P√©rez", "hora": "08:30"},
    {"paciente": "Mario G√≥mez", "hora": "09:00"},
    {"paciente": "Sof√≠a L√≥pez", "hora": "09:30"},
    {"paciente": "Ana Fern√°ndez", "hora": "10:15"},
]
```

### Funciones a implementar

Usando operaciones b√°sicas sobre el arreglo (sin usar `.remove` ni `.pop` directamente):

* `leer_pos(i)`: Devuelve el turno en la posici√≥n `i`. Si `i` no existe, devuelve `None`.
* `insertar(turno)`: Agrega un nuevo diccionario `{"paciente": ..., "hora": "HH:MM"}` al final de la lista
(simulando la llegada de un nuevo paciente). Devuelve `True`.
* `eliminar(hora)`: Busca el primer turno con esa hora y lo elimina.
Devuelve `True` si lo elimin√≥, `False` si el horario no estaba en la lista.
* `buscar(hora)`: Recorre la lista desde el principio hasta el final. Devuelve la posici√≥n (√≠ndice) donde est√° ese horario, o `-1` si no existe.
* `listar()`: Devuelve una lista de strings con el formato: `["0) 08:30 - Juana P√©rez", "1) 09:00 - Mario G√≥mez", ...]`

### Ejemplo de uso

```python
print(leer_pos(1))
# {'paciente': 'Mario G√≥mez', 'hora': '09:00'}

nuevo = {"paciente": "Diego Romero", "hora": "09:45"}
insertar(nuevo)  # Se agrega al final

print(buscar("09:45"))
# 4  (Si era el quinto elemento, ya que la lista creci√≥)

print(eliminar("09:00"))
# True

print(listar())
# ['0) 08:30 - Juana P√©rez',
#  '1) 09:30 - Sof√≠a L√≥pez',
#  '2) 10:15 - Ana Fern√°ndez',
#  '3) 09:45 - Diego Romero']

```

### Casos a probar

- Insertar `"08:15"` (debe ir al inicio).
- Insertar `"12:00"` (debe ir al final).
- Insertar repetido `"09:30"` (debe rechazarse).
- Buscar un horario inexistente (debe devolver `-1`).
- Eliminar uno inexistente (debe devolver `False`).

### Mini-consigna te√≥rica

Responda:

* ¬øQu√© ocurre con los √≠ndices cuando elimin√°s o insert√°s un turno en el medio de la lista? (Pista: ¬øqu√© pasa con los elementos que estaban despu√©s?)
* ¬øPor qu√© acceder a `agenda[i]` es una operaci√≥n $O(1)$ pero buscar un turno por hora es $O(N)$?
* ¬øQu√© estructura te parecer√≠a m√°s conveniente si hubiera miles de turnos? Explic√° brevemente por qu√©.

## La lista de reproducci√≥n del DJÔ∏è

### Contexto

Un DJ est√° gestionando su lista principal de canciones, almacenada en una secuencia ordenada de reproducci√≥n.
Se necesita desarrollar las herramientas para manipular esta lista de forma eficiente y precisa antes del show.

### Requerimientos de manipulaci√≥n

El sistema debe soportar las siguientes acciones, considerando que la lista es una secuencia lineal donde el orden es fundamental:

- **Consulta por ubicaci√≥n**: El DJ debe poder pedir la canci√≥n que est√° en una posici√≥n exacta de la secuencia (ej. "Dime qu√© canci√≥n est√° en el tercer lugar").
- **Adici√≥n controlada**: Se debe poder insertar una nueva canci√≥n exactamente en una posici√≥n espec√≠fica de la secuencia (ej. "Pon 'Nueva Canci√≥n' justo antes de la canci√≥n que actualmente est√° en la posici√≥n 5").
Esto implica que las canciones que estaban en esa posici√≥n y despu√©s deben moverse para hacer espacio.
- **Remoci√≥n dirigida**: El DJ debe poder quitar una canci√≥n conociendo su nombre de la lista. Una vez retirada, las canciones que estaban despu√©s deben moverse para cerrar el hueco y mantener la secuencia contigua.
- **Identificaci√≥n por nombre**: Se requiere una funci√≥n para localizar una canci√≥n por su nombre y devolver su ubicaci√≥n actual en la secuencia.

### Datos iniciales

```python
canciones = ["Thunderstruck", "Billie Jean", "Smells Like Teen Spirit"]
```

### Ejemplos de uso

```python
# Ejemplo de requerimiento: Inserci√≥n
# Intentamos poner "One" en la posici√≥n 2 (el tercer espacio)
insertar_cancion(2, "One")
# La lista debe ajustarse autom√°ticamente: ["Thunderstruck", "Billie Jean", "One", "Smells Like Teen Spirit"]

# Ejemplo de requerimiento: Eliminaci√≥n
eliminar_cancion("Billie Jean")
# La lista debe reajustarse: ["Thunderstruck", "One", "Smells Like Teen Spirit"]
```

### Punto extra: Visualizaci√≥n del √çndice

Muestre al DJ la lista completa, indicando claramente la posici√≥n inicial de cada pista en la secuencia.

## Scanner Pro 3000

### Contexto

En un recital, cada entrada tiene un c√≥digo.
Al ingresar, el lector va guardando los c√≥digos en una lista en el orden en que se escanean.
La producci√≥n te pide detectar si hubo c√≥digos repetidos (fraude o doble escaneo).

Te entregan una lista escaneos con miles de c√≥digos (que son _strings_ de Python).

```python
escaneos = [
    "A1F3", "B9K2", "X7Z1", "A1F3", "L0P9", "M2Q5", "B9K2", ...
]
```

1. Escriba una funci√≥n que encuentre si hay alg√∫n c√≥digo repetido comparando cada elemento con todos los que le siguen (utilice un doble bucle `for`).
    * ¬øCu√°ntas comparaciones hace en el peor caso con N elementos?
    * ¬øQu√© pasa cuando N crece x10?
2. Implemente una versi√≥n lineal usando un `set` para registrar c√≥digos ya vistos.
    * ¬øPor qu√© ahora es $O(N)$?
    * ¬øQu√© operaci√≥n te permite "saltar" comparaciones?
3. Use esta funcion que crea codigos aleatorios para generar listas de codigos de tama√±os crecientes y mida el tiempo de ejecucion de cada funcion anterior:
    ```python
    import random, string, time

    def generar_codigos(n, dup_ratio=0.0, seed=0):
        rng = random.Random(seed)
        base = set()
        # crear c√≥digos √∫nicos
        while len(base) < int(n * (1 - dup_ratio)):
            base.add(''.join(rng.choices(string.ascii_uppercase + string.digits, k=6)))
        lista = list(base)
        # inyectar duplicados
        while len(lista) < n:
            lista.append(rng.choice(list(base)))
        rng.shuffle(lista)
        return lista
    ```

## El club secreto de los _hackers_

### Contexto

Un grupo de _hackers_ tiene un club secreto con reglas muy estrictas sobre qui√©n puede entrar y salir.
Los miembros se ordenan seg√∫n su entrada: desde el fundador hasta el √∫ltimo ingresante.
En caso de ser necesaria una reducci√≥n de miembros, los primeros en irse deben ser los que menos experiencia tienen (el √∫ltimo en entrar al club debe ser el primero en salir).

Si un hacker que no es el √∫ltimo en entrar sale del grupo fuera de orden, se considera una violaci√≥n de seguridad y se registra la acci√≥n en el sistema.

### Datos iniciales

```python
club = [
    {"nombre": "Anonymous"},
    {"nombre": "Mitnick"},
    {"nombre": "Soupnazi"},
    {"nombre": "D-Dante"}
]

```

Teniendo en cuenta el contexto implementa las siguientes funciones para regular la entrada y salida de los miembros del club:

1. `entrar(nombre)`
   - Agrega un hacker a la pila del club
   - Cada entrada debe registrarse como un diccionario: `{"nombre": "Neo"}`
   - Si hay m√°s de 10 hacker, imprimir: **"El Club esta lleno, capacidad m√°xima alcanzada"**
2. `salir()`
   - Saca al √∫ltimo hacker que entr√≥
   - Retorna el nombre del hacker que sali√≥
   - Si la pila est√° vac√≠a, imprimir: **"El club ha desaparecido en la oscuridad..."**
3. `ultimo_en_entrar()`
   - Muestra qui√©n est√° en la cima de la pila **sin sacarlo**
   - Retorna el nombre del √∫ltimo que entr√≥
   - Si la posiion aun no fue cubierta, retorna `None`
4. `mostrar_club()`
   - Muestra todos los hackers en el club, del m√°s reciente al m√°s antiguo
   - Indica cu√°ntos hay en total
   - Formato: `[Top] Neo -> Trinity -> Anonymous [Base]`
5. `esta_en_club(nombre)`
   - Verifica si un hacker espec√≠fico est√° dentro
   - Retorna `True` o `False`
   - **IMPORTANTE**: No destruir la pila al buscar

### Ejemplo de uso esperado

```python
entrar("Morpheus")
entrar("Trinity")
entrar("Neo")

mostrar_club()
# Salida:  Club (3 hackers): [Top] Neo -> Trinity -> Morpheus [Base]

print(ultimo_en_entrar())
# Salida: Neo

salir()
# Salida: Neo ha salido del club

print(esta_en_club("Trinity"))
# Salida: True

print(esta_en_club("Cypher"))
# Salida: False
```

### Ejemplo de uso esperado

```python
# Caso 1: Club vac√≠o
club.clear()
salir()  # Debe mostrar mensaje

# Caso 2: Verificar LIFO
entrar("A")
entrar("B")
entrar("C")
salir()  # Debe salir C (√∫ltimo en entrar)
salir()  # Debe salir B
ultimo_en_entrar()  # Debe ser A

# Caso 3: Club lleno
for i in range(12):
    entrar(f"Hacker{i}")  # En el 11vo debe avisar que est√° lleno

# Caso 4: Buscar sin destruir
entrar("Neo")
entrar("Trinity")
print(esta_en_club("Neo"))  # True
mostrar_club()  # Neo debe seguir en la pila
```

### Nivel 2: Desaf√≠o üöÄ

Nueva funcionalidad: Control de acceso con violaciones

Impelmente las siguentes funciones:

6. `salir_especifico(nombre)`
  -  Si nombre es el TOP: sacarlo sin registrar violaci√≥n, retornar `True`.
  -  Si no es el TOP pero est√° en la pila:
    -  Desapilar a un buffer hasta encontrar nombre.
    -  Remover nombre.
    -  Reapilar en orden original todo lo que sacaste.
  -  Registrar violaci√≥n en `_log_violaciones` con formato:
     `"{HH:MM} - Violaci√≥n: {nombre} sali√≥ fuera de orden"`
     (usar `datetime.now().strftime("%H:%M")`).
     Retornar `True`.
  -  Si no se encuentra: retornar `False`.
7. `historial_violaciones()`
   - Muestra todas las violaciones de seguridad registradas
   - Formato: `["17:30 - Violaci√≥n: Trinity sali√≥ fuera de orden"]`

### Ejemplo de uso

```python
entrar("Morpheus")
entrar("Trinity")
entrar("Neo")
entrar("Cypher")

# Neo y Cypher est√°n encima de Trinity
salir_especifico("Trinity")
# Salida: VIOLACI√ìN DE SEGURIDAD: Trinity sali√≥ fuera de orden

mostrar_club()
# Salida: [Top] Cypher -> Neo -> Morpheus [Base]
# Trinity ya no est√°
```

## Torre de control a√©reo

### Contexto

La Autoridad de Tr√°fico A√©reo necesita optimizar las operaciones de una torre de control.
Tu tarea es modelar el sistema que gestiona los permisos de movimiento de los aviones.

Existen dos tipos de solicitudes pendientes:

* **Aviones esperando despegue:** Estos aviones forman una fila de espera.
Se les debe dar permiso para despegar siguiendo un principio estricto:
el avi√≥n que lleva m√°s tiempo esperando en la fila es el primero en recibir permiso.
* **Aviones en aproximaci√≥n de emergencia:** Estos aviones requieren aterrizaje inmediato debido a una situaci√≥n cr√≠tica.
Estos permisos de aterrizaje se apilan, y la torre debe procesar la emergencia m√°s reciente antes que cualquier otra,
es decir: el √∫ltimo avi√≥n en reportar la emergencia es el primero en recibir la autorizaci√≥n de aterrizaje.

### Prioridad de la torre

La torre de control siempre otorga permisos siguiendo una estricta jerarqu√≠a:

* **Prioridad absoluta:** Si hay alguna emergencia pendiente, la torre siempre debe autorizar primero un aterrizaje de emergencia.
* **Prioridad secundaria:** Solo cuando no haya ninguna emergencia pendiente, la torre podr√° autorizar el despegue del avi√≥n que le corresponda.

### Datos iniciales

Comienza con la siguiente situaci√≥n en el aeropuerto:

```python
# Lista de aviones esperando para Despegar
solicitudes_despegue = ["Vuelo 101", "Vuelo 205"]
# Lista de aviones reportando Emergencia
solicitudes_emergencia = ["Vuelo 999"]
```

### Requisitos funcionales

Se debe crear un sistema con las siguientes acciones:

* Una funci√≥n para registrar la llegada de un nuevo avi√≥n a la lista de despegue.
* Una funci√≥n para registrar una nueva solicitud de aterrizaje de emergencia.
* Una funci√≥n principal, `procesar_evento()`, que simule la acci√≥n de la torre de control al otorgar un permiso seg√∫n las reglas de prioridad.

**Punto extra:** Si la torre intenta otorgar un permiso y ambas listas est√°n vac√≠as, debe notificarlo con el mensaje: `"Torre en silencio"`.

## Alerta de virus zombie

### Contexto

Sos un cient√≠fico/a de un laboratorio secreto que est√° procesando muestras de virus zombies.
Debes implementar un sistema de gesti√≥n usando colas para manejar el flujo de trabajo.

**Alerta importante**: Si hay m√°s de 5 muestras del mismo tipo de virus en la cola, se activa una alerta biol√≥gica (riesgo de propagaci√≥n masiva).

### Datos iniciales

```python
from collections import deque

muestras = deque(["virus_tank", "virus_witch", "virus_charger"])
```

### Tareas

Implementa las siguientes funciones:

1. `agregar_muestra(nombre)`
   - Agrega una muestra al final de la cola
   - Muestra mensaje confirmando la operaci√≥n
   - Verifica si hay m√°s de 5 muestras del mismo tipo
   - Si se cumple la condici√≥n, imprime: `"¬°Alerta biol√≥gica! Detectadas X muestras de [nombre_virus]"`
2. `procesar_muestra()`
   - Procesa (elimina) la primera muestra de la cola
   - Retorna el nombre de la muestra procesada
   - Si la cola est√° vac√≠a, muestra un mensaje de error
3. `mostrar_pendientes()`
   - Muestra la lista de muestras pendientes
   - Retorna la lista de muestras
   - Indica cu√°ntas muestras hay en espera
4. `contar_por_tipo()`
   - Retorna un diccionario con el conteo de cada tipo de virus
   - Ejemplo: `{"virus_tank": 3, "virus_witch": 2}`

### Ejemplo de uso esperado

```python
print(mostrar_pendientes())
# Salida: Muestras pendientes (3): ['virus_tank', 'virus_witch', 'virus_charger']

agregar_muestra("virus_tank")
agregar_muestra("virus_tank")
agregar_muestra("virus_tank")
agregar_muestra("virus_tank")
agregar_muestra("virus_tank")
# Salida en la 5ta: ¬°Alerta biol√≥gica! Detectadas X muestras de virus_tank ‚ò£Ô∏è

print(contar_por_tipo())
# Salida: {'virus_tank': 6, 'virus_witch': 1, 'virus_charger': 1}

procesar_muestra()
# Salida: Procesando 'virus_tank'
# Retorna: 'virus_tank'
```

### Casos a probar

```python
# Caso 1: Cola vac√≠a
muestras.clear()
procesar_muestra()  # Debe mostrar error

# Caso 2: Alerta biol√≥gica por acumulaci√≥n
for i in range(6):
    agregar_muestra("virus_hunter")  # Debe activar alerta en la 6ta

# Caso 3: Verificar que la alerta sea por tipo espec√≠fico
agregar_muestra("virus_tank")
agregar_muestra("virus_witch")
agregar_muestra("virus_tank")
# No debe haber alerta (solo 2 de cada tipo)

# Caso 4: Procesar reduce el conteo
for i in range(7):
    agregar_muestra("virus_smoker")  # Alerta: 7 smoker
procesar_muestra()  # Procesa 1 virus_tank (de los iniciales)
print(contar_por_tipo())  # Deber√≠a seguir mostrando 7 smoker
```

### Nivel 2: Desaf√≠o üöÄ

### Nueva funcionalidad: Muestras prioritarias

Algunas muestras son urgentes y deben procesarse antes que las normales.

### Datos iniciales

```python
from collections import deque

muestras_normales = deque(["virus_tank", "virus_witch"])
muestras_urgentes = deque()
```

### Tareas adicionales

5. `agregar_muestra(nombre, urgente=False)`
   - Si `urgente=True`, agrega a la cola de urgentes
   - Si `urgente=False`, agrega a la cola normal
   - **La alerta biol√≥gica debe contar en AMBAS colas** (misma cepa puede estar en las dos)
6. `procesar_muestra()` (modificada)
   - Primero procesa muestras urgentes
   - Si no hay urgentes, procesa normales
   - Si ambas colas est√°n vac√≠as, muestra error
7. `mostrar_todas()`
   - Muestra ambas colas por separado
   - Indica cu√°ntas muestras hay en cada una
   - Muestra el conteo total por tipo de virus
8. `contar_por_tipo()` (modificada)
   - Debe contar en ambas colas
   - Retorna el conteo global de cada tipo

### Ejemplo de uso

```python
# Agregar 4 tank normales y 3 tank urgentes
for i in range(4):
    agregar_muestra("virus_tank", urgente=False)

for i in range(3):
    agregar_muestra("virus_tank", urgente=True)
    # En la 3ra debe activarse la alerta (total: 4+3=7 tanks)

mostrar_todas()
# Salida:
# Urgentes (3): ['virus_tank', 'virus_tank', 'virus_tank']
# Normales (6): ['virus_tank', 'virus_witch', 'virus_tank', ...]
# Conteo por tipo: {'virus_tank': 7, 'virus_witch': 1}
```

## Batalla Pok√©mon

### Contexto

Un gimnasio Pok√©mon necesita un sistema para gestionar los batallas entre equipos.
Para lograrlo te contratan y te dan la siguiente infromaci√≥n:

- Los entrenadores Pok√©mon pueden capturar nuevos Pok√©mones y agregarlos a su equipo
- Los entrenadores necesitan poder buscar un Pok√©mon espec√≠fico por su nombre para usarlo en batalla
- Los entrenadores tienen que poder retirar del equipo a los Pok√©mon debilitados o que ya no quieren usar
- Los entrenadores deben poder revisar su equipo completo para decidir su estrategia

Tu trabajo sera implementar la clase `Equipo`, para eso puedes usar la siguente clase ya implementada:

```python
class Pokemon:
    """Representa un Pok√©mon individual"""
    def __init__(self, nombre, tipo, nivel, max_hp, ataque):
        self.nombre = nombre
        self.tipo = tipo
        self.nivel = nivel
        self.max_hp = max_hp
        self.hp = max_hp  # Empieza con vida completa
        self.ataque = ataque

    def recibir_da√±o(self, puntos):
        """Reduce HP, no puede ser negativo"""
        self.hp = max(0, self.hp - puntos)

    def curar(self, puntos):
        """Aumenta HP, no puede superar el m√°ximo"""
        self.hp = min(self.max_hp, self.hp + puntos)

    def esta_debilitado(self):
        """Retorna True si el Pok√©mon no puede combatir"""
        return self.hp == 0

    def subir_nivel(self):
        """Sube de nivel y aumenta stats"""
        self.nivel += 1
        self.max_hp += 5
        self.hp = self.max_hp  # Se cura completamente

    def __str__(self):
        return f"{self.nombre} ({self.tipo.capitalize()}) Nv.{self.nivel} [HP: {self.hp}/{self.max_hp}]"
```

### Ejemplo de uso

```python
pikachu = Pokemon("Pikachu", "el√©ctrico", nivel=25, max_hp=35, ataque=14)
print(pikachu)  # Pikachu (El√©ctrico) Nv.25 [HP: 35/35]

pikachu.recibir_da√±o(10)
print(pikachu)  # Pikachu (El√©ctrico) Nv.25 [HP: 25/35]
```

### Requerimientos para implementar la clase `Equipo`

Los maestros/as Pok√©mon necesitan gestionar su equipo de forma din√°mica.
Las operaciones que m√°s realizan son:

1. **Agregar** un Pok√©mon reci√©n capturado (siempre al final)
2. **Buscar** un Pok√©mon espec√≠fico por nombre
3. **Eliminar** un Pok√©mon espec√≠fico del equipo
4. **Listar** todos los Pok√©mon para revisarlos
5. **Eliminar todos los debilitados** despu√©s de una batalla
6. **Contar** cu√°ntos Pok√©mon tiene

**Importante**

- No se te permite usar listas normales de Python con acceso por √≠ndice** (`lista[0]`, `lista[2]`, etc.)
- La clase debe ser eficiente para agregar y eliminar elementos
- Podes crear clases auxiliares si lo necesitas (como Nodo).

### M√©todos necesarios

- `__init__(nombre_entrenador)`. Inicializa un equipo vac√≠o para el entrenador.
- `agregar_pokemon(pokemon)`. Agrega un Pok√©mon al final del equipo.
- `buscar(nombre)`. Busca un Pok√©mon por nombre. Retorna el objeto Pokemon si lo encuentra, `None` si no existe.
- `eliminar(nombre)`. Elimina un Pok√©mon espec√≠fico del equipo. Retorna `True` si lo elimin√≥, `False` si no exist√≠a.
**Importante:**  este metodo debe manejar correctamente los casos de elimnar un elemento que sea el primero, uno del medio o el ultimo.
- `eliminar_debilitados()`. Elimina todos los Pok√©mon con HP igual a 0. Retorna una lista con los nombres de los eliminados.
- `contar()`. Retorna cu√°ntos Pok√©mon hay en el equipo.
- `esta_vacio()`. Retorna `True` si no hay ning√∫n Pok√©mon en el equipo.
- `listar()`. Retorna una lista de cadenas de texto con todos los Pok√©mon en orden.
Formato: `["1. Pikachu (El√©ctrico) Nv.25 [HP: 35/35]", "2. Charmander...", ...]`
- `obtener_primero()`. Retorna el primer Pok√©mon del equipo sin eliminarlo. `None` si est√° vac√≠o.
- `obtener_mas_fuerte()`. Retorna el Pok√©mon con mayor ataque. `None` si est√° vac√≠o.
- `pokemon_por_tipo(tipo)`. Retorna una lista con todos los Pok√©mon de un tipo espec√≠fico.
Ejemplo: `pokemon_por_tipo("fuego")` ‚Üí lista con Charmander, Vulpix, etc.

### Ejemplo de uso completo

```python
# Crear Pok√©mon
pikachu = Pokemon("Pikachu", "el√©ctrico", nivel=25, max_hp=35, ataque=14)
charmander = Pokemon("Charmander", "fuego", nivel=20, max_hp=39, ataque=12)
squirtle = Pokemon("Squirtle", "agua", nivel=22, max_hp=44, ataque=9)
bulbasaur = Pokemon("Bulbasaur", "planta", nivel=21, max_hp=45, ataque=10)
eevee = Pokemon("Eevee", "normal", nivel=18, max_hp=55, ataque=8)

# Crear equipo
equipo_ash = Equipo("Ash")

# Agregar Pok√©mon
equipo_ash.agregar_pokemon(pikachu)
equipo_ash.agregar_pokemon(charmander)
equipo_ash.agregar_pokemon(squirtle)
equipo_ash.agregar_pokemon(bulbasaur)

print(f"Pok√©mon en el equipo: {equipo_ash.contar()}")  # 4

# Listar equipo
print("\n=== EQUIPO DE ASH ===")
for info in equipo_ash.listar():
    print(info)

# Buscar un Pok√©mon
encontrado = equipo_ash.buscar("Squirtle")
if encontrado:
    print(f"\n Encontrado: {encontrado}")

# Obtener el m√°s fuerte
fuerte = equipo_ash.obtener_mas_fuerte()
print(f"\n  M√°s fuerte: {fuerte}")

# Simular batalla
print("\n=== SIMULANDO BATALLA ===")
charmander.recibir_da√±o(39)  # Charmander se debilita
squirtle.recibir_da√±o(20)    # Squirtle pierde HP pero sobrevive

print(f"Charmander debilitado: {charmander.esta_debilitado()}")

# Eliminar debilitados
eliminados = equipo_ash.eliminar_debilitados()
print(f"Pok√©mon eliminados: {eliminados}")  # ['Charmander']

# Ver equipo actualizado
print(f"\nPok√©mon restantes: {equipo_ash.contar()}")  # 3
for info in equipo_ash.listar():
    print(info)

# Agregar nuevo Pok√©mon
equipo_ash.agregar_pokemon(eevee)
print(f"\n Eevee agregado. Total: {equipo_ash.contar()}")

# Buscar por tipo
fuego = equipo_ash.pokemon_por_tipo("fuego")
print(f"\nPok√©mon de fuego: {[str(p) for p in fuego]}")

# Eliminar un Pok√©mon espec√≠fico
equipo_ash.eliminar("Pikachu")
print(f"\n Pikachu liberado. Restantes: {equipo_ash.contar()}")
```

::: {.callout-tip collapse="true"}

#### Ayuda

**Preguntas para reflexionar ANTES de programar**

1. ¬øQu√© estructura me permite conectar elementos sin √≠ndices?
2. ¬øNecesito crear una clase auxiliar (como Nodo)?
3. Al eliminar un elemento, ¬øqu√© debo hacer con los enlaces?
   - Pista: Debes "saltar" al elemento eliminado reconectando los que estaban antes y despu√©s
4. ¬øC√≥mo recorro todos los elementos sin √≠ndices?
   - Pista: Empezas por el primero y seguis los enlaces hasta llegar al final
5. ¬øQu√© pasa si elimino el primer elemento? ¬øEs diferente a eliminar del medio?
   - Pista: El primer elemento es especial, no tiene un elemento anterior
:::

## Uno m√°s dos

Proponer e implementar dos algoritmos que calculen la suma de los primeros `N` n√∫meros naturales.

* Uno con complejidad $O(N)$ (lineal).
* Uno con complejidad $O(1)$ (constante).

## Uno m√°s tres

Proponer e implementar dos algoritmos que calculen la suma de los primeros `N` n√∫meros naturales **impares**.

* Uno con complejidad $O(N)$ (lineal).
* Uno con complejidad $O(1)$ (constante).

## M√°s y m√°s datos

a. Considere el siguiente c√≥digo que calcula un acumulado de promedios para una lista de tama√±o `N`.

```python
def promedios_acumulados(lista):
    """
    Ejemplo:  Entrada -> [1, 2, 3, 5]
              Salida  -> [1, 1.5, 2, 2.75]
    """
    N = len(lista)
    promedios = []
    for i in range(1, N+1):
        promedio = sum(lista[:i]) / i
        promedios.append(promedio)
    return promedios
```

Determine la complejidad de este algoritmo.

b. Siendo $\overline{X}_n$ el promedio de los primeros $n$ n√∫meros en la lista,
vale la siguiente identidad recursiva:
    $$
    \overline{X}_{n+1} = \frac{n \cdot \overline{X}_n + x_{n+1}}{n+1}
    $$

    donde $x_{n+1}$ es el elemento $(n+1)$-√©simo de la lista.

Utilice este resultado para implementar un algoritmo m√°s eficiente.

## El regreso de Fibonacci

En el [Ejercicio 4 de la Unidad 2](../02_programacion_funcional/ejercicios.qmd#sucesi√≥n-de-fibonacci)
se implement√≥ una funci√≥n recursiva para calcular el $n$-√©simo n√∫mero en la sucesi√≥n de Fibonacci.

Esta implementaci√≥n, sin embargo, es muy ineficiente.
De hecho, se puede demostrar que su complejidad es $O(2^n)$ (exponencial).

Utilice [memoizaci√≥n](https://es.stackoverflow.com/questions/398370/qu%C3%A9-es-memoizaci%C3%B3n-y-c%C3%B3mo-se-usa) para mejorar la eficiencia del algoritmo recursivo.
Este nuevo programa tendr√° eficiencia lineal: $O(n)$.

::: {.callout-tip collapse="true"}

### Ayuda

Al inicio de la funci√≥n se debe crear un diccionario vac√≠o: `valores = {}`.

Ante cada valor $f(n)$ de la sucesi√≥n que toque calcular, se deber√° chequear si $n$ est√° entre las claves existentes del diccionario.

* Si no lo est√°, se deber√° calcular recursivamente y luego almacenar su resultado: `valores[n] = f(n)`.
* Si lo est√°, se devolver√° el valor `f(n)` sin efectuar m√°s c√°lculos.

:::

## Vinieron los primos

Implementar un algoritmo para determinar si un n√∫mero natural `N` es primo, con complejidad $O(\sqrt{N})$.

::: {.callout-tip collapse="true"}

### Ayuda

N√≥tese que, dado un n√∫mero natural $N$,
para verificar su primalidad es suficiente con verificar si es divisible por alg√∫n entero entre $1$ y $\sqrt{N}$.

Si fuese un n√∫mero compuesto, jam√°s podr√≠a expresarse como el producto de dos n√∫meros mayores a $\sqrt{N}$.

$$
a > \sqrt{N}, \quad b > \sqrt{N} \implies a \cdot b > \sqrt{N} \cdot \sqrt{N} = N
$$

:::

## El bueno, el malo y el eficiente

Se tiene una lista con `N` n√∫meros enteros.
Se quiere saber si en la lista existe al menos un par de elementos tales que su suma sea impar.

Proponga e implemente dos algoritmos para esta tarea:

* Uno con complejidad $O(N^2)$ (cuadr√°tica).
* Uno con complejidad $O(N)$ (lineal).

## Seamos sinceros

Utilizando el m√≥dulo `time`, compare el tiempo que tardan estos dos m√©todos para determinar si una
lista incluye ceros:

* Un bucle `for` que eval√∫a cada elemento.
* `0 in mi_lista`

¬øCu√°l es m√°s r√°pido? ¬øQu√© complejidad parece tener cada uno?

::: {.callout-tip collapse="true"}

### Ayuda

Utilice la funci√≥n `random.randint` de NumPy para generar un arreglo grande con n√∫meros al azar.

```python
import numpy as np

N = 3

# Arreglo de n√∫meros enteros aleatorios
mi_lista = np.random.randint(0, 10**N, size=10**N)
```

Haga variar el valor de `N` entre 3 y 6 para ver c√≥mo cambia el tiempo de c√≥mputo en cada m√©todo.

(En el [Ejercicio 10 de la Unidad 2](../02_programacion_funcional/ejercicios.qmd#el-tiempo-vuela) se explica c√≥mo usar el m√≥dulo `time`.)
:::

## Seamos originales

Utilizando el m√≥dulo `time`, compare el tiempo que tardan estos dos m√©todos para remover duplicados de una lista:

* Conviertiendo la lista a `dict` y luego de nuevo a `list`.
* Conviertiendo la lista a `set` y luego de nuevo a `list`.

¬øCu√°l es m√°s r√°pido? ¬øQu√© complejidad parece tener cada uno?

::: {.callout-tip collapse="true"}

### Ayuda

El primer m√©todo implica crear un diccionario a partir de una lista.

Esto debe hacerse de forma tal que cada elemento en la lista pase a ser una clave, y a cada ella se le asigna un valor arbitrario (por ejemplo, `None`).
De este modo, Python se encargar√° de que no haya claves duplicadas.

Por √∫ltimo, se deber√° tomar el conjunto de claves y convertirlo a una lista.
Esto devolver√° una lista similar a la original, pero sin duplicados.
:::

## Altas dimensiones

Implemente un algoritmo para multiplicar dos matrices de dimensi√≥n `N x N`.

¬øQu√© complejidad tiene?

## Mediana complejidad

Se tiene una lista desordenada con `2N+1` n√∫meros distintos (es decir, la lista es de tama√±o impar).

Implemente un algoritmo _naive_ para hallar la mediana. ¬øQu√© complejidad tiene?

Luego, utilice un algoritmo de ordenamiento que permita resolver el problema de forma m√°s eficiente.

::: {.callout-tip collapse="true"}

### Ayuda

Para una lista de tama√±o `2N+1`, la mediana es el valor tal que `N` elementos son menores (o iguales) a √©l.
:::


## _Bubble sort_ eficiente

La implementaci√≥n de _bubble sort_ en el apunte de teor√≠a realiza m√°s comparaciones de las necesarias.
Recorre la lista de punta a punta en todas las pasadas, cuando podr√≠an obviarse
los elementos ya ubicados al final.

Implemente una versi√≥n de _bubble sort_ que recorra solo la parte desordenada de la lista,
sin considerar los valores ya ordenados.

## Piedra _sort_ 

El algoritmo _bubble sort_ recibe su nombre por la analog√≠a con las burbujas que suben a la superficie,
que en nuestro caso son los elementos de mayor valor que se ubican al final de la secuencia.

Implemente una versi√≥n "inversa" a _bubble sort_ que, en vez de "subir" los elementos
con mayor valor a la superficie, "hunda" los de menor valor hacia el fondo como una piedra.

## _Selection sort_ basado en m√°ximos

La versi√≥n de _selection sort_ que se discute en el apunte de teor√≠a se basa en buscar el
m√≠nimo en la parte desordenada de la lista y trasladarlo a su ubicaci√≥n final.

Implemente una versi√≥n que est√© basada en la b√∫squeda y traslado del m√°ximo.
