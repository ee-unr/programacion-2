---
title: "3 - Algoritmos de ordenamiento"
toc: true
filters:
  - carousel
---

## Introducción

Ordenar significa reorganizar un conjunto de elementos según algún criterio, por ejemplo,
de menor a mayor, alfabéticamente o por fecha.

Ordenar es una de las tareas más importantes y estudiadas en informática.
Almacenar un conjunto de datos de manera ordenada permite realizar búsquedas y
otras operaciones de forma más eficiente.
Muchos algoritmos avanzados dependen del ordenamiento como parte de su funcionamiento interno.

Python incluye funciones y métodos para ordenar que ya están muy optimizados y, salvo raras excepciones, siempre deberíamos utilizar estas implementaciones.
Pero sigue siendo fundamental comprender cómo funcionan los algoritmos detrás de esas operaciones.

Por ejemplo, en el trabajo práctico grupal se usaron dos funciones de ordenamiento,
con tiempos de ejecución notablemente distintos.
¿Qué podría explicar semejante diferencia en el desempeño de los algoritmos utilizados?
¿Cuál es la complejidad temporal de cada uno de ellos? ¿Siempre es mejor uno que el otro?

Como veremos en este apunte, existe una gran variedad de algoritmos de ordenamiento,
que realizan diferentes operaciones y se basan en distintas estrategias con un mismo objetivo:
obtener una secuencia de valores ordenados.


## _Bubble sort_

Supongamos que tenemos un arreglo de valores numéricos sin ningún orden particular.

<center>
![](imgs/03/bubble_sort-0.png)
</center>

A simple vista, podemos determinar que el arreglo ordenado sería `[2, 4, 5, 7]`.

Sin embargo, para que una computadora llegue al mismo resultado, necesitamos un algoritmo:
una secuencia de pasos que garantice que, al ejecutarse, la lista quede ordenada.

En una lista ordenada, cada elemento está seguido por uno mayor o igual.
De manera formal, si tenemos una secuencia $\boldsymbol{S} = [s_1, s_2, \dots, s_n]$, 
diremos que está ordenada si se cumple que $s_i \le s_{i + 1}$ para todo $i \in {1, 2, \dots, n}$.

Por ejemplo, la siguiente lista está ordenada:

```python
[10, 14, 99, 99, 1000]
```

mientras que esta no:

```python
[50, 60, 10, 214]
```

En el primer caso, cada elemento tiene a su derecha un valor mayor o igual;
en el segundo, el valor `60` tiene a su derecha un número menor (`10`), lo que rompe el orden.

Una forma sencilla de obtener un algoritmo de ordenamiento consiste en comparar cada valor con el siguiente.
Si el siguiente es menor, se intercambian; si no, se mantienen en su lugar.
El procedimiento continúa con el elemento siguiente, repitiéndose hasta llegar al final de la lista.

Veamos cómo funciona este procedimiento con la lista original `[7, 2, 4, 5]`:


:::: {style="margin: auto;"}
:::: {.carousel id="carousel-01"}

:::: {.item image="imgs/03/bubble_sort-0.png" caption="Inicialmente, la lista se encuentra desordenada."}
:::

:::: {.item image="imgs/03/bubble_sort-1.png" caption="Se comparan los valores en las posiciones 0 y 1."}
:::

:::: {.item image="imgs/03/bubble_sort-2.png" caption="Como el primero (7) es mayor que el segundo (2), se intercambian."}
:::

:::: {.item image="imgs/03/bubble_sort-3.png" caption="Se comparan los valores en las posiciones 1 y 2."}
:::

:::: {.item image="imgs/03/bubble_sort-4.png" caption="Como el primero (7) es mayor que el segundo (4), se intercambian."}
:::

:::: {.item image="imgs/03/bubble_sort-5.png" caption="Se comparan los valores en las posiciones 2 y 3."}
:::

:::: {.item image="imgs/03/bubble_sort-6.png" caption="Como el primero (7) es mayor que el segundo (5), se intercambian."}
:::

:::: {.item image="imgs/03/bubble_sort-7.png" caption="Finalmente, la lista se encuentra ordenada."}
:::

:::
:::


El proceso que acabamos de observar es la base del algoritmo _bubble sort_.
Más adelante volveremos sobre el origen del nombre.

Lo importante, ahora, es notar que obtuvimos la lista ordenada en tan pocos pasos de pura suerte.
Para ver por qué, apliquemos el mismo conjunto de pasos sobre una lista con la misma
cantidad de elementos, en un orden apenas diferente.

:::: {.carousel id="carousel-02"}

:::: {.item image="imgs/03/bubble_sort_2-0.png" caption="La lista contiene los mismos valores, en otro orden."}
:::

:::: {.item image="imgs/03/bubble_sort_2-1.png" caption="Se comparan los valores en las posiciones 0 y 1.<br>No hay intercambio: el primero (4) es menor que el segundo (7)."}
:::

:::: {.item image="imgs/03/bubble_sort_2-2.png" caption="Se comparan los valores en las posiciones 1 y 2."}
:::

:::: {.item image="imgs/03/bubble_sort_2-3.png" caption="Como el primero (7) es mayor que el segundo (2), se intercambian."}
:::

:::: {.item image="imgs/03/bubble_sort_2-4.png" caption="Se comparan los valores en las posiciones 2 y 3."}
:::

:::: {.item image="imgs/03/bubble_sort_2-5.png" caption="Como el primero (7) es mayor que el segundo (5), se intercambian."}
:::

:::: {.item image="imgs/03/bubble_sort_2-6.png" caption="Al final, sin embargo, la lista no se encuentra ordenada."}
:::

:::

La primera vez que usamos el algoritmo obtuvimos una lista ordenada.
En la segunda, la lista quedó más ordenada que al inicio, pero todavía no completamente.

Como mencionamos antes, el primer caso fue simplemente una coincidencia.
El algoritmo _bubble sort_ funciona realizando sucesivas pasadas sobre la lista,
comparando pares de valores consecutivos de principio a fin.

En cada comparación, si un valor es mayor que el siguiente, se intercambian sus posiciones.
Este proceso se repite hasta completar una pasada en la que no se realiza ningún intercambio;
solo entonces puede concluirse que la lista está completamente ordenada.

Continuando el ejemplo, tenemos:

:::: {.carousel id="carousel-02-b"}
:::: {.item image="imgs/03/bubble_sort_2-7.png" caption="Se vuelven a comparar los valores en las posiciones 0 y 1."}
:::

:::: {.item image="imgs/03/bubble_sort_2-8.png" caption="Como el primero (4) es mayor que el segundo (2), se intercambian."}
:::

:::: {.item image="imgs/03/bubble_sort_2-9.png" caption="Se comparan los valores en las posiciones 1 y 2.<br>No hay intercambio: el primero (4) es menor que el segundo (5)."}
:::

:::: {.item image="imgs/03/bubble_sort_2-10.png" caption="Se comparan los valores en las posiciones 2 y 3.<br>Tampoco se intercambia: el primero (5) es menor que el segundo (7)."}
:::

:::: {.item image="imgs/03/bubble_sort_2-11.png" caption="Comienza otra pasada, comparando los primeros dos valores,<br> que no se intercambian."}
:::

:::: {.item image="imgs/03/bubble_sort_2-12.png" caption="Se continúa comparando los de las posiciones 1 y 2,<br> que tampoco se intercambian."}
:::

:::: {.item image="imgs/03/bubble_sort_2-13.png" caption="Se comparan los últimos dos valores, quedan en su lugar,<br> y se finaliza una pasada sin intercambios."}
:::

:::: {.item image="imgs/03/bubble_sort_2-14.png" caption="Finalmente, la lista se encuentra ordenada."}
:::

:::

### Implementación

```python
def bubble_sort(arr):
    arr = arr[:] # Hacer copia
    n = len(arr)
    intercambiado = True

    while intercambiado:
        intercambiado = False
        for i in range(n - 1):
            if arr[i] > arr[i + 1]:
                # Se intercambian los valores
                arr[i], arr[i + 1] = arr[i + 1], arr[i]
                intercambiado = True

    return arr
```

```python
bubble_sort([12, 9, 3, 6, 11, 5])
[3, 5, 6, 9, 11, 12]
```

Esta versión repite pasadas completas hasta que no se produce ningún intercambio,
lo que indica que la lista está ordenada.

<!-- **TAREA**: Implementar una versión reduciendo la cantidad de elementos a comparar. -->

::: {.callout-note}

#### Por qué _bubble sort_

En cada pasada, el algoritmo ubica el mayor valor fuera de orden en su posición correcta, al final de la lista.
Este proceso hace que los valores más grandes “suban” gradualmente hacia la parte superior,
como burbujas que ascienden en el agua, lo que da origen al nombre bubble sort.

:::

::: {.callout-note}

#### Implementación eficiente

En cada pasada, el mayor valor fuera de orden se coloca en su posición definitiva.
Esto implica que en la primera pasada el valor máximo llega a la última posición,
en la segunda el segundo mayor queda en la penúltima, y así sucesivamente.

Por lo tanto, en cada nueva pasada puede omitirse la última comparación,
ya que los elementos finales ya están ordenados.

:::


::: {.callout-note}

#### Versión interactiva

Hacer [clic aquí](https://opendsa-server.cs.vt.edu/embed/bubblesortAV)

:::


### Análisis de la eficiencia

El algoritmo _bubble sort_ tiene dos tipos principales de pasos:

* Comparaciones: se comparan números de a pares para determinar cuál es mayor.
* Intercambios: se intercambian números para ordenarlos.

Supongamos que tenemos una lista de 5 números y usamos una implementación eficiente,
que omite las comparaciones innecesarias al final del arreglo.

En la primera pasada se realizan 4 comparaciones, en la segunda 3, en la tercera 2 y en la última 1.
En total, se efectúan 4 + 3 + 2 + 1 = 10 comparaciones.

De manera general, si el arreglo tiene $N$ elementos, pueden realizarse hasta
$(N - 1) + (N - 2) + \cdots + 1$ comparaciones.

Por otro lado, en el peor de los casos (cuando la lista está ordenada en forma descendente),
será necesario realizar tantos intercambios como comparaciones,
ya que en cada comparación habrá un valor mayor a su derecha.

El total de comparaciones e intercambios posibles es entonces
$2 \times [(N - 1) + (N - 2) + \cdots + 1]$.

La siguiente tabla resume la cantidad máxima de pasos para algunos valores de $N$:

| $N$   | Cantidad máxima de pasos |
| ----- | -----------------------: |
| 5     | 20                       |
| 10    | 90                       |
| 20    | 380                      |
| 30    | 870                      |
| 50    | 2450                     |
| 100   | 9900                     |

: {.striped .hover}

Se puede notar que la cantidad de pasos crece a un ritmo sustancialmente mayor que el de un crecimiento lineal.
Si agregamos una columna con el cuadrado de $N$, podemos ver que la complejidad temporal de este 
algoritmo es cuadrática.

| $N$   | Cantidad máxima de pasos | $N^2$ |
| ----- | -----------------------: | ----: |
| 5     | 20                       | 25    |
| 10    | 90                       | 100   |
| 20    | 380                      | 400   |
| 30    | 870                      | 900   |
| 50    | 2450                     | 2500  |
| 100   | 9900                     | 10000 |

: {.striped .hover}


## _Selection sort_

Otro algoritmo sencillo para ordenar una secuencia es _selection sort_.
Al igual que _bubble sort_, realiza múltiples pasadas a través de la lista.

Su particularidad es que en cada pasada **selecciona el menor valor** de la parte desordenada y 
lo coloca en la posición que le corresponde.

Luego, continúa con el resto de la lista, repitiendo el proceso hasta que todos los elementos quedan ordenados.


:::: {.carousel id="carousel-03"}

:::: {.item image="imgs/03/selection_sort-0.png" caption="Se cuenta con una lista desordenada."}
:::

:::: {.item image="imgs/03/selection_sort-1.png" caption="Se inspecciona el primer valor,<br> que es por ahora el mínimo."}
:::

:::: {.item image="imgs/03/selection_sort-2.png" caption="Se avanza a la segunda posición. Como 8 es mayor que 5, este último continúa siendo el mínimo."}
:::

:::: {.item image="imgs/03/selection_sort-3.png" caption="Se avanza a la tercera posición, donde se encuentra un nuevo mínimo (4)."}
:::

:::: {.item image="imgs/03/selection_sort-4.png" caption="Se avanza a la última posición, donde se encuentra un nuevo mínimo (3)."}
:::

:::: {.item image="imgs/03/selection_sort-5.png" caption="Se intercambia el mínimo con el valor de la primera posición."}
:::

:::: {.item image="imgs/03/selection_sort-6.png" caption="Ahora se procede a buscar el mínimo de la parte desordenada."}
:::

:::: {.item image="imgs/03/selection_sort-7.png" caption="Se inspecciona el primer valor,<br> que es por ahora el mínimo."}
:::

:::: {.item image="imgs/03/selection_sort-8.png" caption="Se avanza a la segunda posición, donde se encuentra un nuevo mínimo (4)."}
:::

:::: {.item image="imgs/03/selection_sort-9.png" caption="Se avanza a la última posición. Como 5 es mayor que 4, este último continúa siendo el mínimo."}
:::

:::: {.item image="imgs/03/selection_sort-10.png" caption="Se intercambia el mínimo con el valor de la segunda posición."}
:::

:::: {.item image="imgs/03/selection_sort-11.png" caption="Ahora se procede a buscar el mínimo de la parte desordenada."}
:::

:::: {.item image="imgs/03/selection_sort-12.png" caption="Se inspecciona el primer valor,<br> que es por ahora el mínimo."}
:::

:::: {.item image="imgs/03/selection_sort-13.png" caption="Se avanza a la última posición, donde se encuentra un nuevo mínimo (5)."}
:::

:::: {.item image="imgs/03/selection_sort-14.png" caption="Se intercambia el mínimo con el valor de la tercera posición."}
:::

:::: {.item image="imgs/03/selection_sort-15.png" caption="Como la parte desordenada de la lista contiene un solo elemento, debe ser mayor que todo el resto."}
:::

:::: {.item image="imgs/03/selection_sort-16.png" caption="Finalmente, se obtiene una lista ordenada."}
:::
:::

### Implementación

```python
def selection_sort(arr):
    arr = arr[:] # Crear copia de 'arr'

    for i in range(len(arr) - 1):
        indice_menor_numero = i

        for j in range(i + 1, len(arr)):
            if arr[j] < arr[indice_menor_numero]:
                indice_menor_numero = j

        if indice_menor_numero != i:
            arr[i], arr[indice_menor_numero] = arr[indice_menor_numero], arr[i]

    return arr
```

```python
selection_sort([95, 50, 20, 13, 17, 100])
# [13, 17, 20, 50, 95, 100]
```


### Análisis de eficiencia

Al igual que _bubble sort_, el algoritmo _selection sort_ también utiliza dos tipos de operaciones:
comparaciones e intercambios. En cada pasada, se compara cada valor de la parte desordenada con el mínimo actual,
y al finalizar se coloca dicho mínimo en su posición correcta (intercambiándolo con el valor que estaba allí).

La cantidad de comparaciones que realiza es idéntica a la del algoritmo _bubble sort_.
Para un arreglo de longitud $N$, se efectúan $(N - 1) + (N - 2) + \cdots + 1$ comparaciones.

Por otro lado, y a diferencia del algoritmo _bubble sort_, se realiza **a lo sumo** un intercambio
por pasada. Se puede ver que, entonces, la cantidad de intercambios es menor que con el _bubble sort_,
donde en el peor de los casos teníamos que hacer un intercambio por cada comparación.

Por otro lado, a diferencia de _bubble sort_, se realiza **a lo sumo un intercambio por pasada**.
Por lo tanto, la cantidad total de intercambios es mucho menor, ya que en el peor de los casos _bubble sort_
realiza un intercambio por cada comparación.

La siguiente tabla muestra una comparación lado a lado entre ambos algoritmos:

| N   | Pasos máximos en _bubble sort_ |           Pasos máximos en _selection sort_ |
| --- | -----------------------------: | ------------------------------------------: |
| 5   |                             20 |      14 (10 comparaciones + 4 intercambios) |
| 10  |                             90 |      54 (45 comparaciones + 9 intercambios) |
| 20  |                            380 |   209 (190 comparaciones + 19 intercambios) |
| 30  |                            870 |   464 (435 comparaciones + 29 intercambios) |
| 50  |                           2450 | 1274 (1225 comparaciones + 49 intercambios) |
| 100 |                           9900 | 5049 (4950 comparaciones + 99 intercambios) |


De esta comparación se observa que _selection sort_ requiere aproximadamente la mitad de los pasos
que _bubble sort_, lo que indica que, en promedio, resulta alrededor de dos veces más rápido.


::: {.callout-note}

#### ¿Complejidad $O(\frac{N^2}{2})$?

A pesar de que el algoritmo _selection sort_ realiza aproximadamente la mitad de pasos que _bubble sort_,
ambos se consideran algoritmos de complejidad cuadrática.

Al analizar la eficiencia mediante la notación _Big O_,
solo importa cómo crece el número de pasos con el tamaño del problema, no la constante que los multiplica.

Si un algoritmo realiza $N^2$ pasos y otro realiza $N^2 / 2$,
ambos crecen de manera proporcional a $N^2$ cuando $N$ aumenta.

Por lo tanto, tanto _bubble sort_ como _selection sort_ se describen como algoritmos de orden $O(N^2)$.
:::

::: {.callout-note}

#### Versión interactiva

Hacer [clic aquí](https://opendsa-server.cs.vt.edu/embed/selectionsortAV)

:::


## _Insertion sort_

Al analizar el desempeño de los algoritmos presentados, nos enfocamos en el peor caso:
cuando una lista está ordenada en sentido contrario al deseado.
En esa situación vimos que _selection sort_ resulta más eficiente que _bubble sort_.

Sin embargo, vale la pena considerar otros escenarios al evaluar un algoritmo ya que, en la práctica,
no suele ocurrir que las listas estén completamente ordenadas al inverso del orden que buscamos.

En esta sección estudiaremos otro algoritmo, llamado _insertion sort_.
Se trata de un método de ordenamiento simple que **inserta iterativamente** cada elemento de una
secuencia desordenada en su posición correcta dentro de la parte ya ordenada.

:::: {.carousel id="carousel-04"}

:::: {.item image="imgs/03/insertion_sort-0.png" caption="Todo comienza con una lista desordenada."}
:::

:::: {.item image="imgs/03/insertion_sort-1.png" caption="Se extrae el elemento en la segunda posición."}
:::

:::: {.item image="imgs/03/insertion_sort-2.png" caption="Se lo compara con los valores a su izquierda.<br>Si estos son mayores, se los traslada a la derecha dejando un hueco para el valor extraído."}
:::

:::: {.item image="imgs/03/insertion_sort-3.png" caption="Como 9 es mayor a 4, se lo traslada a la derecha."}
:::

:::: {.item image="imgs/03/insertion_sort-4.png" caption="Dado que no hay más números a comparar, se inserta el 4 en el hueco generado y se finaliza la primera iteración."}
:::

:::: {.item image="imgs/03/insertion_sort-5.png" caption="Con la lista en este estado, se repite el proceso."}
:::

:::: {.item image="imgs/03/insertion_sort-6.png" caption="Ahora se extrae el valor de la tercera posición."}
:::

:::: {.item image="imgs/03/insertion_sort-7.png" caption="Se lo compara con el primer valor a su izquierda, que es mayor y por lo tanto se traslada a la derecha."}
:::

:::: {.item image="imgs/03/insertion_sort-8.png" caption="Se lo compara con el segundo valor a su izquierda, que también es mayor y se los traslada a la derecha."}
:::

:::: {.item image="imgs/03/insertion_sort-9.png" caption="No habiendo valores por comparar, se inserta el valor extraído en el hueco generado."}
:::

:::: {.item image="imgs/03/insertion_sort-10.png" caption="Ahora se extrae el último valor en la secuencia."}
:::

:::: {.item image="imgs/03/insertion_sort-11.png" caption="Su primer valor a la izquierda es mayor, por lo tanto se traslada."}
:::

:::: {.item image="imgs/03/insertion_sort-12.png" caption="Su segundo valor a la izquierda también es mayor y se traslada a la derecha."}
:::

:::: {.item image="imgs/03/insertion_sort-13.png" caption="El último valor a comparar es menor, por lo tanto no se traslada."}
:::

:::: {.item image="imgs/03/insertion_sort-14.png" caption="Se coloca el valor extraído en el hueco generado."}
:::

:::: {.item image="imgs/03/insertion_sort-15.png" caption="Finalmente, se tiene la secuencia ordenada."}
:::

:::

Se puede observar que, en cada iteración, los valores a la izquierda del que se extrae se encuentran ordenados.

### Implementación

```python
def insertion_sort(arr):
    arr = arr[:]
    for i in range(1, len(arr)):
        valor_temporal = arr[i]
        puntero = i - 1

        while puntero >= 0:
            if arr[puntero] > valor_temporal:
                arr[puntero + 1] = arr[puntero]
                puntero = puntero - 1
            else:
                break
            arr[puntero + 1] = valor_temporal

    return arr
```

```python
insertion_sort([9, 7, 5, 999, 1, 10, 25])
# [1, 5, 7, 9, 10, 25, 999]
```

### Análisis de eficiencia

To Do...


::: {.callout-note}

#### Versión interactiva

Hacer [clic aquí](https://opendsa-server.cs.vt.edu/embed/insertionsortAV)

:::


## Divide y vencerás

Los tres algoritmos que vimos hasta ahora nos ayudaron a comprender las bases de los algoritmos de ordenamiento, y sobre todo, a reforzar que no hay una única forma de ordenar. Diferentes algoritmos proveen diferentes "prestaciones".

La complejidad temporal de todos los algoritmos es bastante pobre.
Una complejidad cuadrática implica que luego de un punto, que la secuencia contenga un elemento más
puede resultar en que el algoritmo tarde muchísimos pasos más.

Ningún lenguaje de programación lo suficientemente maduro los elije como algoritmo de ordenamiento por defecto.

En la práctica, suelen utilizar algoritmos de mayor complejidad, que resultan en una consirable mejora del desempeño computacional.

Dos de los algoritmos más populares son el _quick sort_ y el _merge sort_.

Ambos se apoyan en el paradigma de diseño algorítmico llamado divide y vencerás (DYV), del inglés _divide-and-conquer_.
Este método se basa en la solución recursiva de un problema, dividiéndolo en dos o más subproblemas de igual tipo o similar.

Se apoyan en el principio de que ordenar secuencias más pequeñas es sustancialmente más rápido que ordenar secuencias más grandes,
y que ordenar una secuencia parcialmente ordenada es más rápido que una secuencia totalmente desordenada.

De manera general, se puede dividir el método divide y vencerás en tres pasos, que en el contexto
del ordenamiento de una secuencia se pueden describir así:

1. Dividir: Si el tamaño de la secuencia $S$ es lo suficientemente pequeño (por ejemplo, contiene uno o dos elementos),
se resuelve el problema usando un método directo y se devuelve la solución obtenida.
Caso contrario, se divide la secuencia en dos (o más) sub-secuencias disjuntas.
2. Conquistar: Usando recursión, se ordena cada una de las sub-secuencias y se las devuelve.
3. Combinar: Se toman las sub-secuencias ordenadas y se las combina en una única secuencia ordenada,
que resuelve el problema original de ordenar la secuencia $S$.


## _Merge sort_

Explicación similar a quick sort...


1. Si la secuencia $S$ tiene 0 o 1 elementos, se devuelve porque ya está ordenada.
En otro caso, se reparten los elementos de $S$ en dos secuencias.
La primer mitad va a la secuencia $S_1$ y la segunda a la secuencia $S_2$
2. Ordenar las secuencias $S_1$ y $S_2$ recursivamente.
3. Unir las secuencias ordenadas $S_1$ y $S_2$ de manera tal que el resultado esté ordenado.


Podemos crear un árbol llamado _merge-sort tree_.


:::: {.carousel id="carousel-05"}

:::: {.item image="imgs/03/merge_sort_tree-0.png"}
:::

:::: {.item image="imgs/03/merge_sort_tree-1.png"}
:::

:::: {.item image="imgs/03/merge_sort_tree-2.png"}
:::

:::: {.item image="imgs/03/merge_sort_tree-3.png"}
:::

:::: {.item image="imgs/03/merge_sort_tree-4.png"}
:::

:::

:::: {.carousel id="carousel-05-b"}

:::: {.item image="imgs/03/merge_sort_tree_recursivo-0.png"}
:::

:::: {.item image="imgs/03/merge_sort_tree_recursivo-1.png"}
:::

:::: {.item image="imgs/03/merge_sort_tree_recursivo-2.png"}
:::

:::: {.item image="imgs/03/merge_sort_tree_recursivo-3.png"}
:::

:::: {.item image="imgs/03/merge_sort_tree_recursivo-4.png"}
:::

:::: {.item image="imgs/03/merge_sort_tree_recursivo-5.png"}
:::

:::: {.item image="imgs/03/merge_sort_tree_recursivo-6.png"}
:::

:::: {.item image="imgs/03/merge_sort_tree_recursivo-7.png"}
:::

:::: {.item image="imgs/03/merge_sort_tree_recursivo-8.png" }
:::

:::: {.item image="imgs/03/merge_sort_tree_recursivo-9.png"}
:::

:::: {.item image="imgs/03/merge_sort_tree_recursivo-10.png"}
:::

:::: {.item image="imgs/03/merge_sort_tree_recursivo-11.png"}
:::

:::: {.item image="imgs/03/merge_sort_tree_recursivo-12.png"}
:::

:::: {.item image="imgs/03/merge_sort_tree_recursivo-13.png"}
:::

:::: {.item image="imgs/03/merge_sort_tree_recursivo-14.png"}
:::

:::: {.item image="imgs/03/merge_sort_tree_recursivo-15.png"}
:::

:::

¿Cómo unir dos secuencias ordenadas en otra secuencia ordenada?

Mergesort ordena arreglos basándose en otro algoritmo más básico conocido como fusión de arreglos (*merging arrays*), o simplemente fusión (*merging*). En este contexto, fusionar arreglos significa tomar dos arreglos que ya están ordenados, copiar todos sus valores en un tercer arreglo y obtener como resultado un tercer arreglo completamente ordenado.

Supongamos que tenemos los arreglos `[3, 4, 7, 8]` y `[1, 2, 5, 6]`. Nótese que cada arreglo ya está ordenado. No se puede enfatizar lo suficiente: la fusión de arreglos solo funciona si los arreglos ya están ordenados.
El objetivo de la fusión es tomar todos los valores de ambos arreglos y copiarlos en un tercer arreglo, que contendrá todos los valores en orden ascendente.
El resultado de fusionar estos dos arreglos será: `[1, 2, 3, 4, 5, 6, 7, 8]`.


El algoritmo de fusión sigue estos pasos:

1. Se inicializa un puntero `left`, que apunta al primer índice del $S_1$ , y otro puntero `right` que apunta al primer índice de $S_2$.
2. Se crea un tercer arreglo vacío. Este será el arreglo con los datos fusionados, tendrá todos los valores de $S_1$ y $S_2$, en orden ascendente.
3. Se ejecuta un bucle hasta que el puntero izquierdo o el puntero derecho lleguen al final de su respectivas secuencias. Dentro del bucle, realiza lo siguiente:
   a. Comparar el valor apuntado por el puntero izquierdo con el valor apuntado por el puntero derecho y determina cuál es **menor**.
   b. Tomar el valor menor y añadirlo al arreglo `merged`.
   c. Incrementar el puntero que estaba apuntando al valor menor para que señale el siguiente índice de su arreglo.
   (Si en algún momento los dos valores que se comparan son iguales, se puede añadir arbitrariamente el valor del arreglo `left` y avanzar su puntero).
4. Una vez que el bucle termina, uno de los dos arreglos ($S_1$ o $S_2$) quedará "incompleto", es decir,
aún tendrá valores que no se copiaron al arreglo `merged`. Esto da inicio al último paso del algoritmo.
5. Se toman todos los valores restantes del arreglo "incompleto" y es añaden, en orden, al arreglo `merged`.


La versión del algoritmo merge sort que acabamos de ver se conoce como "top down", y usa recursión.

Esta no es la única versión del algoritmo merge sort.

Existe una versión llamada "bottom-up", que no utiliza recursión.
En la práctica es un poco mas eficiente que la versión que vimos nosotros porque no tiene que mantener un stack
de llamadas junto a la memoria que se necesita en cada una de ellas.


:::: {.carousel id="carousel-06"}


:::: {.item image="imgs/03/merge_sort_fusion-0.png"}
:::

:::: {.item image="imgs/03/merge_sort_fusion-1.png"}
:::

:::: {.item image="imgs/03/merge_sort_fusion-2.png"}
:::

:::: {.item image="imgs/03/merge_sort_fusion-3.png"}
:::

:::: {.item image="imgs/03/merge_sort_fusion-4.png"}
:::

:::: {.item image="imgs/03/merge_sort_fusion-5.png"}
:::

:::: {.item image="imgs/03/merge_sort_fusion-6.png"}
:::

:::: {.item image="imgs/03/merge_sort_fusion-7.png"}
:::

:::: {.item image="imgs/03/merge_sort_fusion-8.png"}
:::

:::: {.item image="imgs/03/merge_sort_fusion-9.png"}
:::

:::: {.item image="imgs/03/merge_sort_fusion-10.png"}
:::

:::: {.item image="imgs/03/merge_sort_fusion-11.png"}
:::

:::: {.item image="imgs/03/merge_sort_fusion-12.png"}
:::

:::: {.item image="imgs/03/merge_sort_fusion-13.png"}
:::

:::



[Versión interactiva](https://opendsa-server.cs.vt.edu/embed/mergesortAV)


## _Quick sort_

Este algoritmo se basa en el paradigma de dividir y conquistar.

Se divide la secuencia en sub-secuencias, se ordenan las subsecuencias de manera recursiva,
y luego se combinan las subsecuencias por simple concatenación.

El algoritmo consiste en los siguientes 3 pasos:

1. Dividir: Se selecciona un elemento $x$ de la secuencia, que se lo llama pivote.
En la práctica, se suele tomar el elemento de la última posición o de una posición aleatoria.
Luego, se extraen todos los elementos de la secuencia  y se los coloca en tres secuencias distintas:
    * $L$: que almacena los valores de $S$ menores a $x$.
    * $E$: que almacena los valores de $S$ iguales a $x$.
    * $G$: que almacena los valores de $S$ mayores a $x$.
2. Conquistar: Ordenar las secuencias $L$ y $G$ de manera recursiva, aplicando el mismo algoritmo.
3. Combinar: Colocar los elementos devuelta en $S$ en orden, primero insertando los elementos de $L$, luego los de $E$ y finalmente los de $G$.


- Mostrar diagrama, de esta implementación, que no es in place.
- Luego, hablar de la implementación in place.
    - Modifica la secuencia de entrada intercambiando elementos de lugar.
        - En esto se parece, por ejemplo, al bubble sort (solo que ese lo hace de manera muy tosca).
    - No se crean sub-secuencias.

La división no se raliza usando secuencias auxiliares.

En cambio, es usan dos variables "puntero", `left` y `right`.

Estos punteros comienzan en los extremos de la subsecuencia a la izquierda del pivote y avanzan hacia el centro.
`left` va de izquierda a derecha, y `right` va de derecha a izquierda.

El puntero `left` avanza hacia la derecha hasta que se encuentra un valor más grande o igual que el pivote.
El puntero `right` avanza hacia la izquierda hasta que se encuentra un valor más chico o igual que el pivote.
Cuando el puntero `right` se detiene. Si los punteros no se chocaron ni cruzaron, se intercambian sus valores y
se repite desde el inicio. Si se chocaron o cruzaron, se intercambia el pivote con el valor del puntero `left`.
En ese punto, se completa una "partición". Todos los valores a la izquierda del puntero son menores a el,
y todos los valores mayores se encuentran a su derecha.

Luego, se vuelve a aplicar este algoritmo en la secuencia a la izquierda y a la derecha del pivote.

- Quicksort es un algoritmo que es particularmente eficiente en casos promedio.
En el peor de los casos, cuando la secuencia está ordenada de forma inversa, su desempeño es similar
al de insertion sort y selection sort.


Eficiencia

* ¿Diagrama?
* Mejor y peor caso

- Este algoritmo tiene muy buen desempeño cuando la secuencia es grande, pero paga mucho _overhead_ cuando la secuencia es chica.
- Ordenar una secuencia de unos pocos valores nos lleva bastante "bookkeeping". Un algoritmo más sencillo sería más rápido.
- Comunmente, cuando usamos una función de ordenamiento, se usa un enfoque híbrido.
    - Cuando el tamaño de la secuencia es lo suficientemente pequeño, se usa un algoritmo directo, como insertion sort.
    - Cuando el tamaño es lo suficientement grande, se usa un algoritmo que aplica divide y vencerás.


```python
def naive_quicksort(arr):
    if len(arr) <= 1:
        return arr

    pivot = arr[-1]

    menores = []
    iguales = []
    mayores = []

    for x in arr:
        if x < pivot:
            menores.append(x)
        elif x == pivot:
            iguales.append(x)
        else:
            mayores.append(x)

    return naive_quicksort(menores) + iguales + naive_quicksort(mayores)

```


:::: {.carousel id="carousel-07"}

:::: {.item image="imgs/03/quick_sort-0.png"}
:::

:::: {.item image="imgs/03/quick_sort-1.png"}
:::

:::: {.item image="imgs/03/quick_sort-2.png"}
:::

:::: {.item image="imgs/03/quick_sort-3.png"}
:::

:::: {.item image="imgs/03/quick_sort-4.png"}
:::

:::: {.item image="imgs/03/quick_sort-5.png"}
:::

:::: {.item image="imgs/03/quick_sort-6.png"}
:::

:::: {.item image="imgs/03/quick_sort-7.png"}
:::

:::: {.item image="imgs/03/quick_sort-8.png"}
:::

:::


:::: {.carousel id="carousel-07-b"}

:::: {.item image="imgs/03/quick_sort_recursivo-0.png"}
:::

:::: {.item image="imgs/03/quick_sort_recursivo-1.png"}
:::

:::: {.item image="imgs/03/quick_sort_recursivo-2.png"}
:::

:::: {.item image="imgs/03/quick_sort_recursivo-3.png"}
:::

:::: {.item image="imgs/03/quick_sort_recursivo-4.png"}
:::

:::: {.item image="imgs/03/quick_sort_recursivo-5.png"}
:::

:::: {.item image="imgs/03/quick_sort_recursivo-6.png"}
:::

:::: {.item image="imgs/03/quick_sort_recursivo-7.png"}
:::

:::: {.item image="imgs/03/quick_sort_recursivo-8.png"}
:::

:::: {.item image="imgs/03/quick_sort_recursivo-9.png"}
:::

:::: {.item image="imgs/03/quick_sort_recursivo-10.png"}
:::

:::: {.item image="imgs/03/quick_sort_recursivo-11.png"}
:::

:::: {.item image="imgs/03/quick_sort_recursivo-12.png"}
:::

:::: {.item image="imgs/03/quick_sort_recursivo-13.png"}
:::
:::


:::: {.carousel id="carousel-08"}

:::: {.item image="imgs/03/quick_sort_in_place-0.png"}
:::

:::: {.item image="imgs/03/quick_sort_in_place-1.png"}
:::

:::: {.item image="imgs/03/quick_sort_in_place-2.png"}
:::

:::: {.item image="imgs/03/quick_sort_in_place-3.png"}
:::

:::: {.item image="imgs/03/quick_sort_in_place-4.png"}
:::

:::: {.item image="imgs/03/quick_sort_in_place-5.png"}
:::

:::: {.item image="imgs/03/quick_sort_in_place-6.png"}
:::

:::: {.item image="imgs/03/quick_sort_in_place-7.png"}
:::

:::: {.item image="imgs/03/quick_sort_in_place-8.png"}
:::

:::: {.item image="imgs/03/quick_sort_in_place-9.png"}
:::

:::: {.item image="imgs/03/quick_sort_in_place-10.png"}
:::

:::: {.item image="imgs/03/quick_sort_in_place-11.png"}
:::

:::: {.item image="imgs/03/quick_sort_in_place-12.png"}
:::


:::


Otra parte


:::: {.carousel id="carousel-09"}

:::: {.item image="imgs/03/quick_sort_in_place-13.png"}
:::

:::: {.item image="imgs/03/quick_sort_in_place-14.png"}
:::

:::: {.item image="imgs/03/quick_sort_in_place-15.png"}
:::

:::: {.item image="imgs/03/quick_sort_in_place-16.png"}
:::

:::: {.item image="imgs/03/quick_sort_in_place-17.png"}
:::

:::: {.item image="imgs/03/quick_sort_in_place-18.png"}
:::

:::: {.item image="imgs/03/quick_sort_in_place-19.png"}
:::

:::: {.item image="imgs/03/quick_sort_in_place-20.png"}
:::

:::: {.item image="imgs/03/quick_sort_in_place-21.png"}
:::

:::: {.item image="imgs/03/quick_sort_in_place-22.png"}
:::

:::: {.item image="imgs/03/quick_sort_in_place-23.png"}
:::

:::: {.item image="imgs/03/quick_sort_in_place-24.png"}
:::

:::: {.item image="imgs/03/quick_sort_in_place-25.png"}
:::

:::: {.item image="imgs/03/quick_sort_in_place-26.png"}
:::

:::

[Versión interactiva](https://opendsa-server.cs.vt.edu/embed/quicksortAV)


## Resumen

Tabla comparativa y luego algunas reflexiones.

* https://visualgo.net/en/sorting
* https://www.hackerearth.com/practice/algorithms/sorting/selection-sort/visualize/ 
* https://opendsa-server.cs.vt.edu/embed/mergesortAV
